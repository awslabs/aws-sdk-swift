// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DeleteLexiconInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLexiconInput(name: \(String(describing: name)))"}
}

extension DeleteLexiconInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteLexiconInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLexiconInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLexiconInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLexiconOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLexiconInput>
    public typealias MOutput = OperationOutput<DeleteLexiconOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLexiconOutputError>
}

public struct DeleteLexiconInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLexiconInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLexiconInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLexiconOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLexiconInput>
    public typealias MOutput = OperationOutput<DeleteLexiconOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLexiconOutputError>
}

public struct DeleteLexiconInput: Equatable {
    /// <p>The name of the lexicon to delete. Must be an existing lexicon in the region.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteLexiconInputBody: Equatable {
}

extension DeleteLexiconInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLexiconOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLexiconOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LexiconNotFoundException" : self = .lexiconNotFoundException(try LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLexiconOutputError: Equatable {
    case lexiconNotFoundException(LexiconNotFoundException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLexiconOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLexiconOutputResponse()"}
}

extension DeleteLexiconOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLexiconOutputResponse: Equatable {

    public init() {}
}

struct DeleteLexiconOutputResponseBody: Equatable {
}

extension DeleteLexiconOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeVoicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVoicesInput(engine: \(String(describing: engine)), includeAdditionalLanguageCodes: \(String(describing: includeAdditionalLanguageCodes)), languageCode: \(String(describing: languageCode)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeVoicesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeVoicesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVoicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVoicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVoicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVoicesInput>
    public typealias MOutput = OperationOutput<DescribeVoicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVoicesOutputError>
}

public struct DescribeVoicesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVoicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVoicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVoicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let languageCode = input.operationInput.languageCode {
            let languageCodeQueryItem = URLQueryItem(name: "LanguageCode".urlPercentEncoding(), value: String(languageCode.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(languageCodeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let engine = input.operationInput.engine {
            let engineQueryItem = URLQueryItem(name: "Engine".urlPercentEncoding(), value: String(engine.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(engineQueryItem)
        }
        let includeAdditionalLanguageCodesQueryItem = URLQueryItem(name: "IncludeAdditionalLanguageCodes".urlPercentEncoding(), value: String(input.operationInput.includeAdditionalLanguageCodes).urlPercentEncoding())
        input.builder.withQueryItem(includeAdditionalLanguageCodesQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVoicesInput>
    public typealias MOutput = OperationOutput<DescribeVoicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVoicesOutputError>
}

public struct DescribeVoicesInput: Equatable {
    /// <p>Specifies the engine (<code>standard</code> or <code>neural</code>) used by Amazon Polly
    ///       when processing input text for speech synthesis. </p>
    public let engine: Engine?
    /// <p>Boolean value indicating whether to return any bilingual voices that use the specified
    ///       language as an additional language. For instance, if you request all languages that use US
    ///       English (es-US), and there is an Italian voice that speaks both Italian (it-IT) and US
    ///       English, that voice will be included if you specify <code>yes</code> but not if you specify
    ///         <code>no</code>.</p>
    public let includeAdditionalLanguageCodes: Bool
    /// <p> The language identification tag (ISO 639 code for the language name-ISO 3166 country
    ///       code) for filtering the list of voices returned. If you don't specify this optional parameter,
    ///       all available voices are returned. </p>
    public let languageCode: LanguageCode?
    /// <p>An opaque pagination token returned from the previous <code>DescribeVoices</code>
    ///       operation. If present, this indicates where to continue the listing.</p>
    public let nextToken: String?

    public init (
        engine: Engine? = nil,
        includeAdditionalLanguageCodes: Bool = false,
        languageCode: LanguageCode? = nil,
        nextToken: String? = nil
    )
    {
        self.engine = engine
        self.includeAdditionalLanguageCodes = includeAdditionalLanguageCodes
        self.languageCode = languageCode
        self.nextToken = nextToken
    }
}

struct DescribeVoicesInputBody: Equatable {
}

extension DescribeVoicesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeVoicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVoicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVoicesOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVoicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVoicesOutputResponse(nextToken: \(String(describing: nextToken)), voices: \(String(describing: voices)))"}
}

extension DescribeVoicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeVoicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.voices = output.voices
        } else {
            self.nextToken = nil
            self.voices = nil
        }
    }
}

public struct DescribeVoicesOutputResponse: Equatable {
    /// <p>The pagination token to use in the next request to continue the listing of voices.
    ///         <code>NextToken</code> is returned only if the response is truncated.</p>
    public let nextToken: String?
    /// <p>A list of voices with their properties.</p>
    public let voices: [Voice]?

    public init (
        nextToken: String? = nil,
        voices: [Voice]? = nil
    )
    {
        self.nextToken = nextToken
        self.voices = voices
    }
}

struct DescribeVoicesOutputResponseBody: Equatable {
    public let voices: [Voice]?
    public let nextToken: String?
}

extension DescribeVoicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case voices = "Voices"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voicesContainer = try containerValues.decodeIfPresent([Voice?].self, forKey: .voices)
        var voicesDecoded0:[Voice]? = nil
        if let voicesContainer = voicesContainer {
            voicesDecoded0 = [Voice]()
            for structure0 in voicesContainer {
                if let structure0 = structure0 {
                    voicesDecoded0?.append(structure0)
                }
            }
        }
        voices = voicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum Engine {
    case neural
    case standard
    case sdkUnknown(String)
}

extension Engine : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Engine] {
        return [
            .neural,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .neural: return "neural"
        case .standard: return "standard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Engine(rawValue: rawValue) ?? Engine.sdkUnknown(rawValue)
    }
}

extension EngineNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EngineNotSupportedException(message: \(String(describing: message)))"}
}

extension EngineNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EngineNotSupportedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This engine is not compatible with the voice that you have designated. Choose a new voice
///       that is compatible with the engine or change the engine and restart the operation.</p>
public struct EngineNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EngineNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension EngineNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Gender {
    case female
    case male
    case sdkUnknown(String)
}

extension Gender : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Gender] {
        return [
            .female,
            .male,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .female: return "Female"
        case .male: return "Male"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Gender(rawValue: rawValue) ?? Gender.sdkUnknown(rawValue)
    }
}

extension GetLexiconInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLexiconInput(name: \(String(describing: name)))"}
}

extension GetLexiconInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLexiconInputHeadersMiddleware: Middleware {
    public let id: String = "GetLexiconInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLexiconInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLexiconOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLexiconInput>
    public typealias MOutput = OperationOutput<GetLexiconOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLexiconOutputError>
}

public struct GetLexiconInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLexiconInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLexiconInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLexiconOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLexiconInput>
    public typealias MOutput = OperationOutput<GetLexiconOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLexiconOutputError>
}

public struct GetLexiconInput: Equatable {
    /// <p>Name of the lexicon.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetLexiconInputBody: Equatable {
}

extension GetLexiconInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLexiconOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLexiconOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LexiconNotFoundException" : self = .lexiconNotFoundException(try LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLexiconOutputError: Equatable {
    case lexiconNotFoundException(LexiconNotFoundException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLexiconOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLexiconOutputResponse(lexicon: \(String(describing: lexicon)), lexiconAttributes: \(String(describing: lexiconAttributes)))"}
}

extension GetLexiconOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLexiconOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lexicon = output.lexicon
            self.lexiconAttributes = output.lexiconAttributes
        } else {
            self.lexicon = nil
            self.lexiconAttributes = nil
        }
    }
}

public struct GetLexiconOutputResponse: Equatable {
    /// <p>Lexicon object that provides name and the string content of the lexicon. </p>
    public let lexicon: Lexicon?
    /// <p>Metadata of the lexicon, including phonetic alphabetic used, language code, lexicon
    ///       ARN, number of lexemes defined in the lexicon, and size of lexicon in bytes.</p>
    public let lexiconAttributes: LexiconAttributes?

    public init (
        lexicon: Lexicon? = nil,
        lexiconAttributes: LexiconAttributes? = nil
    )
    {
        self.lexicon = lexicon
        self.lexiconAttributes = lexiconAttributes
    }
}

struct GetLexiconOutputResponseBody: Equatable {
    public let lexicon: Lexicon?
    public let lexiconAttributes: LexiconAttributes?
}

extension GetLexiconOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lexicon = "Lexicon"
        case lexiconAttributes = "LexiconAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexiconDecoded = try containerValues.decodeIfPresent(Lexicon.self, forKey: .lexicon)
        lexicon = lexiconDecoded
        let lexiconAttributesDecoded = try containerValues.decodeIfPresent(LexiconAttributes.self, forKey: .lexiconAttributes)
        lexiconAttributes = lexiconAttributesDecoded
    }
}

extension GetSpeechSynthesisTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSpeechSynthesisTaskInput(taskId: \(String(describing: taskId)))"}
}

extension GetSpeechSynthesisTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSpeechSynthesisTaskInputHeadersMiddleware: Middleware {
    public let id: String = "GetSpeechSynthesisTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSpeechSynthesisTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSpeechSynthesisTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSpeechSynthesisTaskInput>
    public typealias MOutput = OperationOutput<GetSpeechSynthesisTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSpeechSynthesisTaskOutputError>
}

public struct GetSpeechSynthesisTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSpeechSynthesisTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSpeechSynthesisTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSpeechSynthesisTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSpeechSynthesisTaskInput>
    public typealias MOutput = OperationOutput<GetSpeechSynthesisTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSpeechSynthesisTaskOutputError>
}

public struct GetSpeechSynthesisTaskInput: Equatable {
    /// <p>The Amazon Polly generated identifier for a speech synthesis task.</p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct GetSpeechSynthesisTaskInputBody: Equatable {
}

extension GetSpeechSynthesisTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSpeechSynthesisTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSpeechSynthesisTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTaskIdException" : self = .invalidTaskIdException(try InvalidTaskIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SynthesisTaskNotFoundException" : self = .synthesisTaskNotFoundException(try SynthesisTaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSpeechSynthesisTaskOutputError: Equatable {
    case invalidTaskIdException(InvalidTaskIdException)
    case serviceFailureException(ServiceFailureException)
    case synthesisTaskNotFoundException(SynthesisTaskNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSpeechSynthesisTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSpeechSynthesisTaskOutputResponse(synthesisTask: \(String(describing: synthesisTask)))"}
}

extension GetSpeechSynthesisTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSpeechSynthesisTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.synthesisTask = output.synthesisTask
        } else {
            self.synthesisTask = nil
        }
    }
}

public struct GetSpeechSynthesisTaskOutputResponse: Equatable {
    /// <p>SynthesisTask object that provides information from the requested task, including output
    ///       format, creation time, task status, and so on.</p>
    public let synthesisTask: SynthesisTask?

    public init (
        synthesisTask: SynthesisTask? = nil
    )
    {
        self.synthesisTask = synthesisTask
    }
}

struct GetSpeechSynthesisTaskOutputResponseBody: Equatable {
    public let synthesisTask: SynthesisTask?
}

extension GetSpeechSynthesisTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case synthesisTask = "SynthesisTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let synthesisTaskDecoded = try containerValues.decodeIfPresent(SynthesisTask.self, forKey: .synthesisTask)
        synthesisTask = synthesisTaskDecoded
    }
}

extension InvalidLexiconException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLexiconException(message: \(String(describing: message)))"}
}

extension InvalidLexiconException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLexiconExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Polly can't find the specified lexicon. Verify that the lexicon's name is
///       spelled correctly, and then try again.</p>
public struct InvalidLexiconException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLexiconExceptionBody: Equatable {
    public let message: String?
}

extension InvalidLexiconExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The NextToken is invalid. Verify that it's spelled correctly, and then try
///       again.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3BucketException(message: \(String(describing: message)))"}
}

extension InvalidS3BucketException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidS3BucketExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided Amazon S3 bucket name is invalid. Please check your input with S3 bucket
///       naming requirements and try again.</p>
public struct InvalidS3BucketException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3BucketExceptionBody: Equatable {
    public let message: String?
}

extension InvalidS3BucketExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3KeyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3KeyException(message: \(String(describing: message)))"}
}

extension InvalidS3KeyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidS3KeyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided Amazon S3 key prefix is invalid. Please provide a valid S3 object key
///       name.</p>
public struct InvalidS3KeyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3KeyExceptionBody: Equatable {
    public let message: String?
}

extension InvalidS3KeyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSampleRateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSampleRateException(message: \(String(describing: message)))"}
}

extension InvalidSampleRateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSampleRateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified sample rate is not valid.</p>
public struct InvalidSampleRateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSampleRateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSampleRateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnsTopicArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSnsTopicArnException(message: \(String(describing: message)))"}
}

extension InvalidSnsTopicArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSnsTopicArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided SNS topic ARN is invalid. Please provide a valid SNS topic ARN and try
///       again.</p>
public struct InvalidSnsTopicArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSnsTopicArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSnsTopicArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSsmlException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSsmlException(message: \(String(describing: message)))"}
}

extension InvalidSsmlException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSsmlExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The SSML you provided is invalid. Verify the SSML syntax, spelling of tags and values,
///       and then try again.</p>
public struct InvalidSsmlException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSsmlExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSsmlExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTaskIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTaskIdException(message: \(String(describing: message)))"}
}

extension InvalidTaskIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTaskIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided Task ID is not valid. Please provide a valid Task ID and try again.</p>
public struct InvalidTaskIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTaskIdExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTaskIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LanguageCode {
    case arb
    case cmnCn
    case cyGb
    case daDk
    case deDe
    case enAu
    case enGb
    case enGbWls
    case enIn
    case enUs
    case esEs
    case esMx
    case esUs
    case frCa
    case frFr
    case hiIn
    case isIs
    case itIt
    case jaJp
    case koKr
    case nbNo
    case nlNl
    case plPl
    case ptBr
    case ptPt
    case roRo
    case ruRu
    case svSe
    case trTr
    case sdkUnknown(String)
}

extension LanguageCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LanguageCode] {
        return [
            .arb,
            .cmnCn,
            .cyGb,
            .daDk,
            .deDe,
            .enAu,
            .enGb,
            .enGbWls,
            .enIn,
            .enUs,
            .esEs,
            .esMx,
            .esUs,
            .frCa,
            .frFr,
            .hiIn,
            .isIs,
            .itIt,
            .jaJp,
            .koKr,
            .nbNo,
            .nlNl,
            .plPl,
            .ptBr,
            .ptPt,
            .roRo,
            .ruRu,
            .svSe,
            .trTr,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .arb: return "arb"
        case .cmnCn: return "cmn-CN"
        case .cyGb: return "cy-GB"
        case .daDk: return "da-DK"
        case .deDe: return "de-DE"
        case .enAu: return "en-AU"
        case .enGb: return "en-GB"
        case .enGbWls: return "en-GB-WLS"
        case .enIn: return "en-IN"
        case .enUs: return "en-US"
        case .esEs: return "es-ES"
        case .esMx: return "es-MX"
        case .esUs: return "es-US"
        case .frCa: return "fr-CA"
        case .frFr: return "fr-FR"
        case .hiIn: return "hi-IN"
        case .isIs: return "is-IS"
        case .itIt: return "it-IT"
        case .jaJp: return "ja-JP"
        case .koKr: return "ko-KR"
        case .nbNo: return "nb-NO"
        case .nlNl: return "nl-NL"
        case .plPl: return "pl-PL"
        case .ptBr: return "pt-BR"
        case .ptPt: return "pt-PT"
        case .roRo: return "ro-RO"
        case .ruRu: return "ru-RU"
        case .svSe: return "sv-SE"
        case .trTr: return "tr-TR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
    }
}

extension LanguageNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LanguageNotSupportedException(message: \(String(describing: message)))"}
}

extension LanguageNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LanguageNotSupportedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The language specified is not currently supported by Amazon Polly in this capacity.</p>
public struct LanguageNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LanguageNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension LanguageNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Lexicon: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Lexicon: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Lexicon(content: \(String(describing: content)), name: \(String(describing: name)))"}
}

/// <p>Provides lexicon name and lexicon content in string format. For more information, see
///         <a href="https://www.w3.org/TR/pronunciation-lexicon/">Pronunciation Lexicon
///         Specification (PLS) Version 1.0</a>.</p>
public struct Lexicon: Equatable {
    /// <p>Lexicon content in string format. The content of a lexicon must be in PLS
    ///       format.</p>
    public let content: String?
    /// <p>Name of the lexicon.</p>
    public let name: String?

    public init (
        content: String? = nil,
        name: String? = nil
    )
    {
        self.content = content
        self.name = name
    }
}

extension LexiconAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alphabet = "Alphabet"
        case languageCode = "LanguageCode"
        case lastModified = "LastModified"
        case lexemesCount = "LexemesCount"
        case lexiconArn = "LexiconArn"
        case size = "Size"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alphabet = alphabet {
            try encodeContainer.encode(alphabet, forKey: .alphabet)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if lexemesCount != 0 {
            try encodeContainer.encode(lexemesCount, forKey: .lexemesCount)
        }
        if let lexiconArn = lexiconArn {
            try encodeContainer.encode(lexiconArn, forKey: .lexiconArn)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alphabetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alphabet)
        alphabet = alphabetDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lexiconArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lexiconArn)
        lexiconArn = lexiconArnDecoded
        let lexemesCountDecoded = try containerValues.decode(Int.self, forKey: .lexemesCount)
        lexemesCount = lexemesCountDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension LexiconAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LexiconAttributes(alphabet: \(String(describing: alphabet)), languageCode: \(String(describing: languageCode)), lastModified: \(String(describing: lastModified)), lexemesCount: \(String(describing: lexemesCount)), lexiconArn: \(String(describing: lexiconArn)), size: \(String(describing: size)))"}
}

/// <p>Contains metadata describing the lexicon such as the number of lexemes, language code,
///       and so on. For more information, see <a href="https://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html">Managing
///         Lexicons</a>.</p>
public struct LexiconAttributes: Equatable {
    /// <p>Phonetic alphabet used in the lexicon. Valid values are <code>ipa</code> and
    ///         <code>x-sampa</code>.</p>
    public let alphabet: String?
    /// <p>Language code that the lexicon applies to. A lexicon with a language code such as "en"
    ///       would be applied to all English languages (en-GB, en-US, en-AUS, en-WLS, and so on.</p>
    public let languageCode: LanguageCode?
    /// <p>Date lexicon was last modified (a timestamp value).</p>
    public let lastModified: Date?
    /// <p>Number of lexemes in the lexicon.</p>
    public let lexemesCount: Int
    /// <p>Amazon Resource Name (ARN) of the lexicon.</p>
    public let lexiconArn: String?
    /// <p>Total size of the lexicon, in characters.</p>
    public let size: Int

    public init (
        alphabet: String? = nil,
        languageCode: LanguageCode? = nil,
        lastModified: Date? = nil,
        lexemesCount: Int = 0,
        lexiconArn: String? = nil,
        size: Int = 0
    )
    {
        self.alphabet = alphabet
        self.languageCode = languageCode
        self.lastModified = lastModified
        self.lexemesCount = lexemesCount
        self.lexiconArn = lexiconArn
        self.size = size
    }
}

extension LexiconDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(LexiconAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension LexiconDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LexiconDescription(attributes: \(String(describing: attributes)), name: \(String(describing: name)))"}
}

/// <p>Describes the content of the lexicon.</p>
public struct LexiconDescription: Equatable {
    /// <p>Provides lexicon metadata.</p>
    public let attributes: LexiconAttributes?
    /// <p>Name of the lexicon.</p>
    public let name: String?

    public init (
        attributes: LexiconAttributes? = nil,
        name: String? = nil
    )
    {
        self.attributes = attributes
        self.name = name
    }
}

extension LexiconNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LexiconNotFoundException(message: \(String(describing: message)))"}
}

extension LexiconNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LexiconNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Polly can't find the specified lexicon. This could be caused by a lexicon that
///       is missing, its name is misspelled or specifying a lexicon that is in a different
///       region.</p>
///          <p>Verify that the lexicon exists, is in the region (see <a>ListLexicons</a>)
///       and that you spelled its name is spelled correctly. Then try again.</p>
public struct LexiconNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LexiconNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension LexiconNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexiconSizeExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LexiconSizeExceededException(message: \(String(describing: message)))"}
}

extension LexiconSizeExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LexiconSizeExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum size of the specified lexicon would be exceeded by this
///       operation.</p>
public struct LexiconSizeExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LexiconSizeExceededExceptionBody: Equatable {
    public let message: String?
}

extension LexiconSizeExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListLexiconsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLexiconsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListLexiconsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLexiconsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLexiconsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLexiconsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLexiconsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLexiconsInput>
    public typealias MOutput = OperationOutput<ListLexiconsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLexiconsOutputError>
}

public struct ListLexiconsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLexiconsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLexiconsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLexiconsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLexiconsInput>
    public typealias MOutput = OperationOutput<ListLexiconsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLexiconsOutputError>
}

public struct ListLexiconsInput: Equatable {
    /// <p>An opaque pagination token returned from previous <code>ListLexicons</code> operation.
    ///       If present, indicates where to continue the list of lexicons.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListLexiconsInputBody: Equatable {
}

extension ListLexiconsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLexiconsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLexiconsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLexiconsOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLexiconsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLexiconsOutputResponse(lexicons: \(String(describing: lexicons)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLexiconsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLexiconsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lexicons = output.lexicons
            self.nextToken = output.nextToken
        } else {
            self.lexicons = nil
            self.nextToken = nil
        }
    }
}

public struct ListLexiconsOutputResponse: Equatable {
    /// <p>A list of lexicon names and attributes.</p>
    public let lexicons: [LexiconDescription]?
    /// <p>The pagination token to use in the next request to continue the listing of lexicons.
    ///         <code>NextToken</code> is returned only if the response is truncated.</p>
    public let nextToken: String?

    public init (
        lexicons: [LexiconDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.lexicons = lexicons
        self.nextToken = nextToken
    }
}

struct ListLexiconsOutputResponseBody: Equatable {
    public let lexicons: [LexiconDescription]?
    public let nextToken: String?
}

extension ListLexiconsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lexicons = "Lexicons"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexiconsContainer = try containerValues.decodeIfPresent([LexiconDescription?].self, forKey: .lexicons)
        var lexiconsDecoded0:[LexiconDescription]? = nil
        if let lexiconsContainer = lexiconsContainer {
            lexiconsDecoded0 = [LexiconDescription]()
            for structure0 in lexiconsContainer {
                if let structure0 = structure0 {
                    lexiconsDecoded0?.append(structure0)
                }
            }
        }
        lexicons = lexiconsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeechSynthesisTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSpeechSynthesisTasksInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)))"}
}

extension ListSpeechSynthesisTasksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSpeechSynthesisTasksInputHeadersMiddleware: Middleware {
    public let id: String = "ListSpeechSynthesisTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSpeechSynthesisTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSpeechSynthesisTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSpeechSynthesisTasksInput>
    public typealias MOutput = OperationOutput<ListSpeechSynthesisTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSpeechSynthesisTasksOutputError>
}

public struct ListSpeechSynthesisTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSpeechSynthesisTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSpeechSynthesisTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSpeechSynthesisTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let status = input.operationInput.status {
            let statusQueryItem = URLQueryItem(name: "Status".urlPercentEncoding(), value: String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSpeechSynthesisTasksInput>
    public typealias MOutput = OperationOutput<ListSpeechSynthesisTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSpeechSynthesisTasksOutputError>
}

public struct ListSpeechSynthesisTasksInput: Equatable {
    /// <p>Maximum number of speech synthesis tasks returned in a List operation.</p>
    public let maxResults: Int?
    /// <p>The pagination token to use in the next request to continue the listing of speech
    ///       synthesis tasks. </p>
    public let nextToken: String?
    /// <p>Status of the speech synthesis tasks returned in a List operation</p>
    public let status: TaskStatus?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: TaskStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListSpeechSynthesisTasksInputBody: Equatable {
}

extension ListSpeechSynthesisTasksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSpeechSynthesisTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSpeechSynthesisTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSpeechSynthesisTasksOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case serviceFailureException(ServiceFailureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSpeechSynthesisTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSpeechSynthesisTasksOutputResponse(nextToken: \(String(describing: nextToken)), synthesisTasks: \(String(describing: synthesisTasks)))"}
}

extension ListSpeechSynthesisTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSpeechSynthesisTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.synthesisTasks = output.synthesisTasks
        } else {
            self.nextToken = nil
            self.synthesisTasks = nil
        }
    }
}

public struct ListSpeechSynthesisTasksOutputResponse: Equatable {
    /// <p>An opaque pagination token returned from the previous List operation in this request. If
    ///       present, this indicates where to continue the listing.</p>
    public let nextToken: String?
    /// <p>List of SynthesisTask objects that provides information from the specified task in the
    ///       list request, including output format, creation time, task status, and so on.</p>
    public let synthesisTasks: [SynthesisTask]?

    public init (
        nextToken: String? = nil,
        synthesisTasks: [SynthesisTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.synthesisTasks = synthesisTasks
    }
}

struct ListSpeechSynthesisTasksOutputResponseBody: Equatable {
    public let nextToken: String?
    public let synthesisTasks: [SynthesisTask]?
}

extension ListSpeechSynthesisTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case synthesisTasks = "SynthesisTasks"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let synthesisTasksContainer = try containerValues.decodeIfPresent([SynthesisTask?].self, forKey: .synthesisTasks)
        var synthesisTasksDecoded0:[SynthesisTask]? = nil
        if let synthesisTasksContainer = synthesisTasksContainer {
            synthesisTasksDecoded0 = [SynthesisTask]()
            for structure0 in synthesisTasksContainer {
                if let structure0 = structure0 {
                    synthesisTasksDecoded0?.append(structure0)
                }
            }
        }
        synthesisTasks = synthesisTasksDecoded0
    }
}

extension MarksNotSupportedForFormatException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MarksNotSupportedForFormatException(message: \(String(describing: message)))"}
}

extension MarksNotSupportedForFormatException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MarksNotSupportedForFormatExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Speech marks are not supported for the <code>OutputFormat</code> selected. Speech marks
///       are only available for content in <code>json</code> format.</p>
public struct MarksNotSupportedForFormatException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MarksNotSupportedForFormatExceptionBody: Equatable {
    public let message: String?
}

extension MarksNotSupportedForFormatExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxLexemeLengthExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxLexemeLengthExceededException(message: \(String(describing: message)))"}
}

extension MaxLexemeLengthExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxLexemeLengthExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum size of the lexeme would be exceeded by this operation.</p>
public struct MaxLexemeLengthExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxLexemeLengthExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaxLexemeLengthExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxLexiconsNumberExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxLexiconsNumberExceededException(message: \(String(describing: message)))"}
}

extension MaxLexiconsNumberExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxLexiconsNumberExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of lexicons would be exceeded by this operation.</p>
public struct MaxLexiconsNumberExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxLexiconsNumberExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaxLexiconsNumberExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum OutputFormat {
    case json
    case mp3
    case oggVorbis
    case pcm
    case sdkUnknown(String)
}

extension OutputFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OutputFormat] {
        return [
            .json,
            .mp3,
            .oggVorbis,
            .pcm,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "json"
        case .mp3: return "mp3"
        case .oggVorbis: return "ogg_vorbis"
        case .pcm: return "pcm"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OutputFormat(rawValue: rawValue) ?? OutputFormat.sdkUnknown(rawValue)
    }
}

public struct PutLexiconInputBodyMiddleware: Middleware {
    public let id: String = "PutLexiconInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLexiconInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLexiconOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLexiconInput>
    public typealias MOutput = OperationOutput<PutLexiconOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLexiconOutputError>
}

extension PutLexiconInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLexiconInput(content: \(String(describing: content)), name: \(String(describing: name)))"}
}

extension PutLexiconInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

public struct PutLexiconInputHeadersMiddleware: Middleware {
    public let id: String = "PutLexiconInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLexiconInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLexiconOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLexiconInput>
    public typealias MOutput = OperationOutput<PutLexiconOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLexiconOutputError>
}

public struct PutLexiconInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLexiconInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLexiconInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLexiconOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLexiconInput>
    public typealias MOutput = OperationOutput<PutLexiconOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLexiconOutputError>
}

public struct PutLexiconInput: Equatable {
    /// <p>Content of the PLS lexicon as string data.</p>
    public let content: String?
    /// <p>Name of the lexicon. The name must follow the regular express format [0-9A-Za-z]{1,20}.
    ///       That is, the name is a case-sensitive alphanumeric string up to 20 characters long. </p>
    public let name: String?

    public init (
        content: String? = nil,
        name: String? = nil
    )
    {
        self.content = content
        self.name = name
    }
}

struct PutLexiconInputBody: Equatable {
    public let content: String?
}

extension PutLexiconInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
    }
}

extension PutLexiconOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLexiconOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLexiconException" : self = .invalidLexiconException(try InvalidLexiconException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LexiconSizeExceededException" : self = .lexiconSizeExceededException(try LexiconSizeExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxLexemeLengthExceededException" : self = .maxLexemeLengthExceededException(try MaxLexemeLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxLexiconsNumberExceededException" : self = .maxLexiconsNumberExceededException(try MaxLexiconsNumberExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlsAlphabetException" : self = .unsupportedPlsAlphabetException(try UnsupportedPlsAlphabetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlsLanguageException" : self = .unsupportedPlsLanguageException(try UnsupportedPlsLanguageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLexiconOutputError: Equatable {
    case invalidLexiconException(InvalidLexiconException)
    case lexiconSizeExceededException(LexiconSizeExceededException)
    case maxLexemeLengthExceededException(MaxLexemeLengthExceededException)
    case maxLexiconsNumberExceededException(MaxLexiconsNumberExceededException)
    case serviceFailureException(ServiceFailureException)
    case unsupportedPlsAlphabetException(UnsupportedPlsAlphabetException)
    case unsupportedPlsLanguageException(UnsupportedPlsLanguageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLexiconOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLexiconOutputResponse()"}
}

extension PutLexiconOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutLexiconOutputResponse: Equatable {

    public init() {}
}

struct PutLexiconOutputResponseBody: Equatable {
}

extension PutLexiconOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ServiceFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceFailureException(message: \(String(describing: message)))"}
}

extension ServiceFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An unknown condition has caused a service failure.</p>
public struct ServiceFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Equatable {
    public let message: String?
}

extension ServiceFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SpeechMarkType {
    case sentence
    case ssml
    case viseme
    case word
    case sdkUnknown(String)
}

extension SpeechMarkType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SpeechMarkType] {
        return [
            .sentence,
            .ssml,
            .viseme,
            .word,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sentence: return "sentence"
        case .ssml: return "ssml"
        case .viseme: return "viseme"
        case .word: return "word"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SpeechMarkType(rawValue: rawValue) ?? SpeechMarkType.sdkUnknown(rawValue)
    }
}

extension SsmlMarksNotSupportedForTextTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SsmlMarksNotSupportedForTextTypeException(message: \(String(describing: message)))"}
}

extension SsmlMarksNotSupportedForTextTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SsmlMarksNotSupportedForTextTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>SSML speech marks are not supported for plain text-type input.</p>
public struct SsmlMarksNotSupportedForTextTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SsmlMarksNotSupportedForTextTypeExceptionBody: Equatable {
    public let message: String?
}

extension SsmlMarksNotSupportedForTextTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartSpeechSynthesisTaskInputBodyMiddleware: Middleware {
    public let id: String = "StartSpeechSynthesisTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSpeechSynthesisTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSpeechSynthesisTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSpeechSynthesisTaskInput>
    public typealias MOutput = OperationOutput<StartSpeechSynthesisTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSpeechSynthesisTaskOutputError>
}

extension StartSpeechSynthesisTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSpeechSynthesisTaskInput(engine: \(String(describing: engine)), languageCode: \(String(describing: languageCode)), lexiconNames: \(String(describing: lexiconNames)), outputFormat: \(String(describing: outputFormat)), outputS3BucketName: \(String(describing: outputS3BucketName)), outputS3KeyPrefix: \(String(describing: outputS3KeyPrefix)), sampleRate: \(String(describing: sampleRate)), snsTopicArn: \(String(describing: snsTopicArn)), speechMarkTypes: \(String(describing: speechMarkTypes)), text: \(String(describing: text)), textType: \(String(describing: textType)), voiceId: \(String(describing: voiceId)))"}
}

extension StartSpeechSynthesisTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engine = engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lexiconNames = lexiconNames {
            var lexiconNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lexiconNames)
            for lexiconnamelist0 in lexiconNames {
                try lexiconNamesContainer.encode(lexiconnamelist0)
            }
        }
        if let outputFormat = outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let sampleRate = sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let speechMarkTypes = speechMarkTypes {
            var speechMarkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .speechMarkTypes)
            for speechmarktypelist0 in speechMarkTypes {
                try speechMarkTypesContainer.encode(speechmarktypelist0.rawValue)
            }
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let textType = textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }
}

public struct StartSpeechSynthesisTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StartSpeechSynthesisTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSpeechSynthesisTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSpeechSynthesisTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSpeechSynthesisTaskInput>
    public typealias MOutput = OperationOutput<StartSpeechSynthesisTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSpeechSynthesisTaskOutputError>
}

public struct StartSpeechSynthesisTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSpeechSynthesisTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSpeechSynthesisTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSpeechSynthesisTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSpeechSynthesisTaskInput>
    public typealias MOutput = OperationOutput<StartSpeechSynthesisTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSpeechSynthesisTaskOutputError>
}

public struct StartSpeechSynthesisTaskInput: Equatable {
    /// <p>Specifies the engine (<code>standard</code> or <code>neural</code>) for Amazon Polly to
    ///       use when processing input text for speech synthesis. Using a voice that is not supported for
    ///       the engine selected will result in an error.</p>
    public let engine: Engine?
    /// <p>Optional language code for the Speech Synthesis request. This is only necessary if using a
    ///       bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi
    ///       (hi-IN). </p>
    ///          <p>If a bilingual voice is used and no language code is specified, Amazon Polly will use the
    ///       default language of the bilingual voice. The default language for any voice is the one
    ///       returned by the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html">DescribeVoices</a> operation for the <code>LanguageCode</code> parameter. For example,
    ///       if no language code is specified, Aditi will use Indian English rather than Hindi.</p>
    public let languageCode: LanguageCode?
    /// <p>List of one or more pronunciation lexicon names you want the service to apply during
    ///       synthesis. Lexicons are applied only if the language of the lexicon is the same as the
    ///       language of the voice. </p>
    public let lexiconNames: [String]?
    /// <p>The format in which the returned output will be encoded. For audio stream, this will be
    ///       mp3, ogg_vorbis, or pcm. For speech marks, this will be json. </p>
    public let outputFormat: OutputFormat?
    /// <p>Amazon S3 bucket name to which the output file will be saved.</p>
    public let outputS3BucketName: String?
    /// <p>The Amazon S3 key prefix for the output speech file.</p>
    public let outputS3KeyPrefix: String?
    /// <p>The audio frequency specified in Hz.</p>
    ///          <p>The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The
    ///       default value for standard voices is "22050". The default value for neural voices is
    ///       "24000".</p>
    ///          <p>Valid values for pcm are "8000" and "16000" The default value is "16000". </p>
    public let sampleRate: String?
    /// <p>ARN for the SNS topic optionally used for providing status notification for a speech
    ///       synthesis task.</p>
    public let snsTopicArn: String?
    /// <p>The type of speech marks returned for the input text.</p>
    public let speechMarkTypes: [SpeechMarkType]?
    /// <p>The input text to synthesize. If you specify ssml as the TextType, follow the SSML format
    ///       for the input text. </p>
    public let text: String?
    /// <p>Specifies whether the input text is plain text or SSML. The default value is plain text.
    ///     </p>
    public let textType: TextType?
    /// <p>Voice ID to use for the synthesis. </p>
    public let voiceId: VoiceId?

    public init (
        engine: Engine? = nil,
        languageCode: LanguageCode? = nil,
        lexiconNames: [String]? = nil,
        outputFormat: OutputFormat? = nil,
        outputS3BucketName: String? = nil,
        outputS3KeyPrefix: String? = nil,
        sampleRate: String? = nil,
        snsTopicArn: String? = nil,
        speechMarkTypes: [SpeechMarkType]? = nil,
        text: String? = nil,
        textType: TextType? = nil,
        voiceId: VoiceId? = nil
    )
    {
        self.engine = engine
        self.languageCode = languageCode
        self.lexiconNames = lexiconNames
        self.outputFormat = outputFormat
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.sampleRate = sampleRate
        self.snsTopicArn = snsTopicArn
        self.speechMarkTypes = speechMarkTypes
        self.text = text
        self.textType = textType
        self.voiceId = voiceId
    }
}

struct StartSpeechSynthesisTaskInputBody: Equatable {
    public let engine: Engine?
    public let languageCode: LanguageCode?
    public let lexiconNames: [String]?
    public let outputFormat: OutputFormat?
    public let outputS3BucketName: String?
    public let outputS3KeyPrefix: String?
    public let sampleRate: String?
    public let snsTopicArn: String?
    public let speechMarkTypes: [SpeechMarkType]?
    public let text: String?
    public let textType: TextType?
    public let voiceId: VoiceId?
}

extension StartSpeechSynthesisTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Engine.self, forKey: .engine)
        engine = engineDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [String]()
            for string0 in lexiconNamesContainer {
                if let string0 = string0 {
                    lexiconNamesDecoded0?.append(string0)
                }
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([SpeechMarkType?].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [SpeechMarkType]()
            for string0 in speechMarkTypesContainer {
                if let string0 = string0 {
                    speechMarkTypesDecoded0?.append(string0)
                }
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let textTypeDecoded = try containerValues.decodeIfPresent(TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension StartSpeechSynthesisTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSpeechSynthesisTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EngineNotSupportedException" : self = .engineNotSupportedException(try EngineNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketException" : self = .invalidS3BucketException(try InvalidS3BucketException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3KeyException" : self = .invalidS3KeyException(try InvalidS3KeyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSampleRateException" : self = .invalidSampleRateException(try InvalidSampleRateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSnsTopicArnException" : self = .invalidSnsTopicArnException(try InvalidSnsTopicArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSsmlException" : self = .invalidSsmlException(try InvalidSsmlException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LanguageNotSupportedException" : self = .languageNotSupportedException(try LanguageNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LexiconNotFoundException" : self = .lexiconNotFoundException(try LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MarksNotSupportedForFormatException" : self = .marksNotSupportedForFormatException(try MarksNotSupportedForFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SsmlMarksNotSupportedForTextTypeException" : self = .ssmlMarksNotSupportedForTextTypeException(try SsmlMarksNotSupportedForTextTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextLengthExceededException" : self = .textLengthExceededException(try TextLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSpeechSynthesisTaskOutputError: Equatable {
    case engineNotSupportedException(EngineNotSupportedException)
    case invalidS3BucketException(InvalidS3BucketException)
    case invalidS3KeyException(InvalidS3KeyException)
    case invalidSampleRateException(InvalidSampleRateException)
    case invalidSnsTopicArnException(InvalidSnsTopicArnException)
    case invalidSsmlException(InvalidSsmlException)
    case languageNotSupportedException(LanguageNotSupportedException)
    case lexiconNotFoundException(LexiconNotFoundException)
    case marksNotSupportedForFormatException(MarksNotSupportedForFormatException)
    case serviceFailureException(ServiceFailureException)
    case ssmlMarksNotSupportedForTextTypeException(SsmlMarksNotSupportedForTextTypeException)
    case textLengthExceededException(TextLengthExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSpeechSynthesisTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSpeechSynthesisTaskOutputResponse(synthesisTask: \(String(describing: synthesisTask)))"}
}

extension StartSpeechSynthesisTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartSpeechSynthesisTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.synthesisTask = output.synthesisTask
        } else {
            self.synthesisTask = nil
        }
    }
}

public struct StartSpeechSynthesisTaskOutputResponse: Equatable {
    /// <p>SynthesisTask object that provides information and attributes about a newly submitted
    ///       speech synthesis task.</p>
    public let synthesisTask: SynthesisTask?

    public init (
        synthesisTask: SynthesisTask? = nil
    )
    {
        self.synthesisTask = synthesisTask
    }
}

struct StartSpeechSynthesisTaskOutputResponseBody: Equatable {
    public let synthesisTask: SynthesisTask?
}

extension StartSpeechSynthesisTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case synthesisTask = "SynthesisTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let synthesisTaskDecoded = try containerValues.decodeIfPresent(SynthesisTask.self, forKey: .synthesisTask)
        synthesisTask = synthesisTaskDecoded
    }
}

extension SynthesisTask: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputUri = "OutputUri"
        case requestCharacters = "RequestCharacters"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case taskId = "TaskId"
        case taskStatus = "TaskStatus"
        case taskStatusReason = "TaskStatusReason"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let engine = engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lexiconNames = lexiconNames {
            var lexiconNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lexiconNames)
            for lexiconnamelist0 in lexiconNames {
                try lexiconNamesContainer.encode(lexiconnamelist0)
            }
        }
        if let outputFormat = outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let outputUri = outputUri {
            try encodeContainer.encode(outputUri, forKey: .outputUri)
        }
        if requestCharacters != 0 {
            try encodeContainer.encode(requestCharacters, forKey: .requestCharacters)
        }
        if let sampleRate = sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let speechMarkTypes = speechMarkTypes {
            var speechMarkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .speechMarkTypes)
            for speechmarktypelist0 in speechMarkTypes {
                try speechMarkTypesContainer.encode(speechmarktypelist0.rawValue)
            }
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
        if let taskStatusReason = taskStatusReason {
            try encodeContainer.encode(taskStatusReason, forKey: .taskStatusReason)
        }
        if let textType = textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Engine.self, forKey: .engine)
        engine = engineDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(TaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskStatusReason)
        taskStatusReason = taskStatusReasonDecoded
        let outputUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputUri)
        outputUri = outputUriDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let requestCharactersDecoded = try containerValues.decode(Int.self, forKey: .requestCharacters)
        requestCharacters = requestCharactersDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [String]()
            for string0 in lexiconNamesContainer {
                if let string0 = string0 {
                    lexiconNamesDecoded0?.append(string0)
                }
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([SpeechMarkType?].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [SpeechMarkType]()
            for string0 in speechMarkTypesContainer {
                if let string0 = string0 {
                    speechMarkTypesDecoded0?.append(string0)
                }
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textTypeDecoded = try containerValues.decodeIfPresent(TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension SynthesisTask: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SynthesisTask(creationTime: \(String(describing: creationTime)), engine: \(String(describing: engine)), languageCode: \(String(describing: languageCode)), lexiconNames: \(String(describing: lexiconNames)), outputFormat: \(String(describing: outputFormat)), outputUri: \(String(describing: outputUri)), requestCharacters: \(String(describing: requestCharacters)), sampleRate: \(String(describing: sampleRate)), snsTopicArn: \(String(describing: snsTopicArn)), speechMarkTypes: \(String(describing: speechMarkTypes)), taskId: \(String(describing: taskId)), taskStatus: \(String(describing: taskStatus)), taskStatusReason: \(String(describing: taskStatusReason)), textType: \(String(describing: textType)), voiceId: \(String(describing: voiceId)))"}
}

/// <p>SynthesisTask object that provides information about a speech synthesis task.</p>
public struct SynthesisTask: Equatable {
    /// <p>Timestamp for the time the synthesis task was started.</p>
    public let creationTime: Date?
    /// <p>Specifies the engine (<code>standard</code> or <code>neural</code>) for Amazon Polly to
    ///       use when processing input text for speech synthesis. Using a voice that is not supported for
    ///       the engine selected will result in an error.</p>
    public let engine: Engine?
    /// <p>Optional language code for a synthesis task. This is only necessary if using a bilingual
    ///       voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi (hi-IN). </p>
    ///          <p>If a bilingual voice is used and no language code is specified, Amazon Polly will use the
    ///       default language of the bilingual voice. The default language for any voice is the one
    ///       returned by the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html">DescribeVoices</a> operation for the <code>LanguageCode</code> parameter. For example,
    ///       if no language code is specified, Aditi will use Indian English rather than Hindi.</p>
    public let languageCode: LanguageCode?
    /// <p>List of one or more pronunciation lexicon names you want the service to apply during
    ///       synthesis. Lexicons are applied only if the language of the lexicon is the same as the
    ///       language of the voice. </p>
    public let lexiconNames: [String]?
    /// <p>The format in which the returned output will be encoded. For audio stream, this will be
    ///       mp3, ogg_vorbis, or pcm. For speech marks, this will be json. </p>
    public let outputFormat: OutputFormat?
    /// <p>Pathway for the output speech file.</p>
    public let outputUri: String?
    /// <p>Number of billable characters synthesized.</p>
    public let requestCharacters: Int
    /// <p>The audio frequency specified in Hz.</p>
    ///          <p>The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The
    ///       default value for standard voices is "22050". The default value for neural voices is
    ///       "24000".</p>
    ///          <p>Valid values for pcm are "8000" and "16000" The default value is "16000". </p>
    public let sampleRate: String?
    /// <p>ARN for the SNS topic optionally used for providing status notification for a speech
    ///       synthesis task.</p>
    public let snsTopicArn: String?
    /// <p>The type of speech marks returned for the input text.</p>
    public let speechMarkTypes: [SpeechMarkType]?
    /// <p>The Amazon Polly generated identifier for a speech synthesis task.</p>
    public let taskId: String?
    /// <p>Current status of the individual speech synthesis task.</p>
    public let taskStatus: TaskStatus?
    /// <p>Reason for the current status of a specific speech synthesis task, including errors if the
    ///       task has failed.</p>
    public let taskStatusReason: String?
    /// <p>Specifies whether the input text is plain text or SSML. The default value is plain text.
    ///     </p>
    public let textType: TextType?
    /// <p>Voice ID to use for the synthesis. </p>
    public let voiceId: VoiceId?

    public init (
        creationTime: Date? = nil,
        engine: Engine? = nil,
        languageCode: LanguageCode? = nil,
        lexiconNames: [String]? = nil,
        outputFormat: OutputFormat? = nil,
        outputUri: String? = nil,
        requestCharacters: Int = 0,
        sampleRate: String? = nil,
        snsTopicArn: String? = nil,
        speechMarkTypes: [SpeechMarkType]? = nil,
        taskId: String? = nil,
        taskStatus: TaskStatus? = nil,
        taskStatusReason: String? = nil,
        textType: TextType? = nil,
        voiceId: VoiceId? = nil
    )
    {
        self.creationTime = creationTime
        self.engine = engine
        self.languageCode = languageCode
        self.lexiconNames = lexiconNames
        self.outputFormat = outputFormat
        self.outputUri = outputUri
        self.requestCharacters = requestCharacters
        self.sampleRate = sampleRate
        self.snsTopicArn = snsTopicArn
        self.speechMarkTypes = speechMarkTypes
        self.taskId = taskId
        self.taskStatus = taskStatus
        self.taskStatusReason = taskStatusReason
        self.textType = textType
        self.voiceId = voiceId
    }
}

extension SynthesisTaskNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SynthesisTaskNotFoundException(message: \(String(describing: message)))"}
}

extension SynthesisTaskNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SynthesisTaskNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Speech Synthesis task with requested Task ID cannot be found.</p>
public struct SynthesisTaskNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SynthesisTaskNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension SynthesisTaskNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SynthesizeSpeechInputBodyMiddleware: Middleware {
    public let id: String = "SynthesizeSpeechInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SynthesizeSpeechInput>,
                  next: H) -> Swift.Result<OperationOutput<SynthesizeSpeechOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SynthesizeSpeechInput>
    public typealias MOutput = OperationOutput<SynthesizeSpeechOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SynthesizeSpeechOutputError>
}

extension SynthesizeSpeechInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SynthesizeSpeechInput(engine: \(String(describing: engine)), languageCode: \(String(describing: languageCode)), lexiconNames: \(String(describing: lexiconNames)), outputFormat: \(String(describing: outputFormat)), sampleRate: \(String(describing: sampleRate)), speechMarkTypes: \(String(describing: speechMarkTypes)), text: \(String(describing: text)), textType: \(String(describing: textType)), voiceId: \(String(describing: voiceId)))"}
}

extension SynthesizeSpeechInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case sampleRate = "SampleRate"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engine = engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lexiconNames = lexiconNames {
            var lexiconNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lexiconNames)
            for lexiconnamelist0 in lexiconNames {
                try lexiconNamesContainer.encode(lexiconnamelist0)
            }
        }
        if let outputFormat = outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let sampleRate = sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if let speechMarkTypes = speechMarkTypes {
            var speechMarkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .speechMarkTypes)
            for speechmarktypelist0 in speechMarkTypes {
                try speechMarkTypesContainer.encode(speechmarktypelist0.rawValue)
            }
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let textType = textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }
}

public struct SynthesizeSpeechInputHeadersMiddleware: Middleware {
    public let id: String = "SynthesizeSpeechInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SynthesizeSpeechInput>,
                  next: H) -> Swift.Result<OperationOutput<SynthesizeSpeechOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SynthesizeSpeechInput>
    public typealias MOutput = OperationOutput<SynthesizeSpeechOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SynthesizeSpeechOutputError>
}

public struct SynthesizeSpeechInputQueryItemMiddleware: Middleware {
    public let id: String = "SynthesizeSpeechInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SynthesizeSpeechInput>,
                  next: H) -> Swift.Result<OperationOutput<SynthesizeSpeechOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SynthesizeSpeechInput>
    public typealias MOutput = OperationOutput<SynthesizeSpeechOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SynthesizeSpeechOutputError>
}

public struct SynthesizeSpeechInput: Equatable {
    /// <p>Specifies the engine (<code>standard</code> or <code>neural</code>) for Amazon Polly to
    ///       use when processing input text for speech synthesis. For information on Amazon Polly voices and which voices are available in standard-only, NTTS-only, and
    ///       both standard and NTTS formats, see <a href="https://docs.aws.amazon.com/polly/latest/dg/voicelist.html">Available Voices</a>.</p>
    ///          <p>
    ///             <b>NTTS-only voices</b>
    ///          </p>
    ///          <p>When using NTTS-only voices such as Kevin (en-US), this parameter is required and must be
    ///       set to <code>neural</code>. If the engine is not specified, or is set to <code>standard</code>,
    ///       this will result in an error. </p>
    ///          <p>Type: String</p>
    ///          <p>Valid Values: <code>standard</code>  |  <code>neural</code>
    ///          </p>
    ///          <p>Required: Yes</p>
    ///
    ///          <p>
    ///             <b>Standard voices</b>
    ///          </p>
    ///          <p>For standard voices, this is not required; the engine parameter defaults to
    ///       <code>standard</code>. If the engine is not specified, or is set to <code>standard</code> and
    ///       an NTTS-only voice is selected, this will result in an error. </p>
    public let engine: Engine?
    /// <p>Optional language code for the Synthesize Speech request. This is only necessary if using
    ///       a bilingual voice, such as Aditi, which can be used for either Indian English (en-IN) or Hindi
    ///       (hi-IN). </p>
    ///          <p>If a bilingual voice is used and no language code is specified, Amazon Polly will use the
    ///       default language of the bilingual voice. The default language for any voice is the one
    ///       returned by the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html">DescribeVoices</a> operation for the <code>LanguageCode</code> parameter. For example,
    ///       if no language code is specified, Aditi will use Indian English rather than Hindi.</p>
    public let languageCode: LanguageCode?
    /// <p>List of one or more pronunciation lexicon names you want the service to apply during
    ///       synthesis. Lexicons are applied only if the language of the lexicon is the same as the
    ///       language of the voice. For information about storing lexicons, see <a href="https://docs.aws.amazon.com/polly/latest/dg/API_PutLexicon.html">PutLexicon</a>.</p>
    public let lexiconNames: [String]?
    /// <p> The format in which the returned output will be encoded. For audio stream, this will
    ///       be mp3, ogg_vorbis, or pcm. For speech marks, this will be json. </p>
    ///          <p>When pcm is used, the content returned is audio/pcm in a signed 16-bit, 1 channel
    ///       (mono), little-endian format. </p>
    public let outputFormat: OutputFormat?
    /// <p>The audio frequency specified in Hz.</p>
    ///          <p>The valid values for mp3 and ogg_vorbis are "8000", "16000", "22050", and "24000". The
    ///       default value for standard voices is "22050". The default value for neural voices is
    ///       "24000".</p>
    ///          <p>Valid values for pcm are "8000" and "16000" The default value is "16000". </p>
    public let sampleRate: String?
    /// <p>The type of speech marks returned for the input text.</p>
    public let speechMarkTypes: [SpeechMarkType]?
    /// <p> Input text to synthesize. If you specify <code>ssml</code> as the
    ///         <code>TextType</code>, follow the SSML format for the input text. </p>
    public let text: String?
    /// <p> Specifies whether the input text is plain text or SSML. The default value is plain
    ///       text. For more information, see <a href="https://docs.aws.amazon.com/polly/latest/dg/ssml.html">Using SSML</a>.</p>
    public let textType: TextType?
    /// <p> Voice ID to use for the synthesis. You can get a list of available voice IDs by
    ///       calling the <a href="https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html">DescribeVoices</a> operation. </p>
    public let voiceId: VoiceId?

    public init (
        engine: Engine? = nil,
        languageCode: LanguageCode? = nil,
        lexiconNames: [String]? = nil,
        outputFormat: OutputFormat? = nil,
        sampleRate: String? = nil,
        speechMarkTypes: [SpeechMarkType]? = nil,
        text: String? = nil,
        textType: TextType? = nil,
        voiceId: VoiceId? = nil
    )
    {
        self.engine = engine
        self.languageCode = languageCode
        self.lexiconNames = lexiconNames
        self.outputFormat = outputFormat
        self.sampleRate = sampleRate
        self.speechMarkTypes = speechMarkTypes
        self.text = text
        self.textType = textType
        self.voiceId = voiceId
    }
}

struct SynthesizeSpeechInputBody: Equatable {
    public let engine: Engine?
    public let languageCode: LanguageCode?
    public let lexiconNames: [String]?
    public let outputFormat: OutputFormat?
    public let sampleRate: String?
    public let speechMarkTypes: [SpeechMarkType]?
    public let text: String?
    public let textType: TextType?
    public let voiceId: VoiceId?
}

extension SynthesizeSpeechInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case sampleRate = "SampleRate"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Engine.self, forKey: .engine)
        engine = engineDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [String]()
            for string0 in lexiconNamesContainer {
                if let string0 = string0 {
                    lexiconNamesDecoded0?.append(string0)
                }
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([SpeechMarkType?].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [SpeechMarkType]()
            for string0 in speechMarkTypesContainer {
                if let string0 = string0 {
                    speechMarkTypesDecoded0?.append(string0)
                }
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let textTypeDecoded = try containerValues.decodeIfPresent(TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension SynthesizeSpeechOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SynthesizeSpeechOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EngineNotSupportedException" : self = .engineNotSupportedException(try EngineNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSampleRateException" : self = .invalidSampleRateException(try InvalidSampleRateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSsmlException" : self = .invalidSsmlException(try InvalidSsmlException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LanguageNotSupportedException" : self = .languageNotSupportedException(try LanguageNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LexiconNotFoundException" : self = .lexiconNotFoundException(try LexiconNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MarksNotSupportedForFormatException" : self = .marksNotSupportedForFormatException(try MarksNotSupportedForFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SsmlMarksNotSupportedForTextTypeException" : self = .ssmlMarksNotSupportedForTextTypeException(try SsmlMarksNotSupportedForTextTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextLengthExceededException" : self = .textLengthExceededException(try TextLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SynthesizeSpeechOutputError: Equatable {
    case engineNotSupportedException(EngineNotSupportedException)
    case invalidSampleRateException(InvalidSampleRateException)
    case invalidSsmlException(InvalidSsmlException)
    case languageNotSupportedException(LanguageNotSupportedException)
    case lexiconNotFoundException(LexiconNotFoundException)
    case marksNotSupportedForFormatException(MarksNotSupportedForFormatException)
    case serviceFailureException(ServiceFailureException)
    case ssmlMarksNotSupportedForTextTypeException(SsmlMarksNotSupportedForTextTypeException)
    case textLengthExceededException(TextLengthExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SynthesizeSpeechOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SynthesizeSpeechOutputResponse(audioStream: \(String(describing: audioStream)), contentType: \(String(describing: contentType)), requestCharacters: \(String(describing: requestCharacters)))"}
}

extension SynthesizeSpeechOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let requestCharactersHeaderValue = httpResponse.headers.value(for: "x-amzn-RequestCharacters") {
            self.requestCharacters = Int(requestCharactersHeaderValue) ?? 0
        } else {
            self.requestCharacters = 0
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.audioStream = unwrappedData
        } else {
            self.audioStream = nil
        }
    }
}

public struct SynthesizeSpeechOutputResponse: Equatable {
    /// <p> Stream containing the synthesized speech. </p>
    public let audioStream: Data?
    /// <p> Specifies the type audio stream. This should reflect the <code>OutputFormat</code>
    ///       parameter in your request. </p>
    ///          <ul>
    ///             <li>
    ///                <p> If you request <code>mp3</code> as the <code>OutputFormat</code>, the
    ///             <code>ContentType</code> returned is audio/mpeg. </p>
    ///             </li>
    ///             <li>
    ///                <p> If you request <code>ogg_vorbis</code> as the <code>OutputFormat</code>, the
    ///             <code>ContentType</code> returned is audio/ogg. </p>
    ///             </li>
    ///             <li>
    ///                <p> If you request <code>pcm</code> as the <code>OutputFormat</code>, the
    ///             <code>ContentType</code> returned is audio/pcm in a signed 16-bit, 1 channel (mono),
    ///           little-endian format. </p>
    ///             </li>
    ///             <li>
    ///                <p>If you request <code>json</code> as the <code>OutputFormat</code>, the
    ///             <code>ContentType</code> returned is audio/json.</p>
    ///             </li>
    ///          </ul>
    ///          <p> </p>
    public let contentType: String?
    /// <p>Number of characters synthesized.</p>
    public let requestCharacters: Int

    public init (
        audioStream: Data? = nil,
        contentType: String? = nil,
        requestCharacters: Int = 0
    )
    {
        self.audioStream = audioStream
        self.contentType = contentType
        self.requestCharacters = requestCharacters
    }
}

struct SynthesizeSpeechOutputResponseBody: Equatable {
    public let audioStream: Data?
}

extension SynthesizeSpeechOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case audioStream = "AudioStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

public enum TaskStatus {
    case completed
    case failed
    case inProgress
    case scheduled
    case sdkUnknown(String)
}

extension TaskStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskStatus] {
        return [
            .completed,
            .failed,
            .inProgress,
            .scheduled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "completed"
        case .failed: return "failed"
        case .inProgress: return "inProgress"
        case .scheduled: return "scheduled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
    }
}

extension TextLengthExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextLengthExceededException(message: \(String(describing: message)))"}
}

extension TextLengthExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TextLengthExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value of the "Text" parameter is longer than the accepted limits. For the
///         <code>SynthesizeSpeech</code> API, the limit for input text is a maximum of 6000 characters
///       total, of which no more than 3000 can be billed characters. For the
///         <code>StartSpeechSynthesisTask</code> API, the maximum is 200,000 characters, of which no
///       more than 100,000 can be billed characters. SSML tags are not counted as billed
///       characters.</p>
public struct TextLengthExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TextLengthExceededExceptionBody: Equatable {
    public let message: String?
}

extension TextLengthExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum TextType {
    case ssml
    case text
    case sdkUnknown(String)
}

extension TextType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TextType] {
        return [
            .ssml,
            .text,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ssml: return "ssml"
        case .text: return "text"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TextType(rawValue: rawValue) ?? TextType.sdkUnknown(rawValue)
    }
}

extension UnsupportedPlsAlphabetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedPlsAlphabetException(message: \(String(describing: message)))"}
}

extension UnsupportedPlsAlphabetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedPlsAlphabetExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The alphabet specified by the lexicon is not a supported alphabet. Valid values are
///         <code>x-sampa</code> and <code>ipa</code>.</p>
public struct UnsupportedPlsAlphabetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedPlsAlphabetExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedPlsAlphabetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedPlsLanguageException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedPlsLanguageException(message: \(String(describing: message)))"}
}

extension UnsupportedPlsLanguageException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedPlsLanguageExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The language specified in the lexicon is unsupported. For a list of supported
///       languages, see <a href="https://docs.aws.amazon.com/polly/latest/dg/API_LexiconAttributes.html">Lexicon
///         Attributes</a>.</p>
public struct UnsupportedPlsLanguageException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedPlsLanguageExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedPlsLanguageExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Voice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalLanguageCodes = "AdditionalLanguageCodes"
        case gender = "Gender"
        case id = "Id"
        case languageCode = "LanguageCode"
        case languageName = "LanguageName"
        case name = "Name"
        case supportedEngines = "SupportedEngines"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalLanguageCodes = additionalLanguageCodes {
            var additionalLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalLanguageCodes)
            for languagecodelist0 in additionalLanguageCodes {
                try additionalLanguageCodesContainer.encode(languagecodelist0.rawValue)
            }
        }
        if let gender = gender {
            try encodeContainer.encode(gender.rawValue, forKey: .gender)
        }
        if let id = id {
            try encodeContainer.encode(id.rawValue, forKey: .id)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageName = languageName {
            try encodeContainer.encode(languageName, forKey: .languageName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let supportedEngines = supportedEngines {
            var supportedEnginesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedEngines)
            for enginelist0 in supportedEngines {
                try supportedEnginesContainer.encode(enginelist0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let genderDecoded = try containerValues.decodeIfPresent(Gender.self, forKey: .gender)
        gender = genderDecoded
        let idDecoded = try containerValues.decodeIfPresent(VoiceId.self, forKey: .id)
        id = idDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let languageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .languageName)
        languageName = languageNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let additionalLanguageCodesContainer = try containerValues.decodeIfPresent([LanguageCode?].self, forKey: .additionalLanguageCodes)
        var additionalLanguageCodesDecoded0:[LanguageCode]? = nil
        if let additionalLanguageCodesContainer = additionalLanguageCodesContainer {
            additionalLanguageCodesDecoded0 = [LanguageCode]()
            for string0 in additionalLanguageCodesContainer {
                if let string0 = string0 {
                    additionalLanguageCodesDecoded0?.append(string0)
                }
            }
        }
        additionalLanguageCodes = additionalLanguageCodesDecoded0
        let supportedEnginesContainer = try containerValues.decodeIfPresent([Engine?].self, forKey: .supportedEngines)
        var supportedEnginesDecoded0:[Engine]? = nil
        if let supportedEnginesContainer = supportedEnginesContainer {
            supportedEnginesDecoded0 = [Engine]()
            for string0 in supportedEnginesContainer {
                if let string0 = string0 {
                    supportedEnginesDecoded0?.append(string0)
                }
            }
        }
        supportedEngines = supportedEnginesDecoded0
    }
}

extension Voice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Voice(additionalLanguageCodes: \(String(describing: additionalLanguageCodes)), gender: \(String(describing: gender)), id: \(String(describing: id)), languageCode: \(String(describing: languageCode)), languageName: \(String(describing: languageName)), name: \(String(describing: name)), supportedEngines: \(String(describing: supportedEngines)))"}
}

/// <p>Description of the voice.</p>
public struct Voice: Equatable {
    /// <p>Additional codes for languages available for the specified voice in addition to its
    ///       default language. </p>
    ///          <p>For example, the default language for Aditi is Indian English (en-IN) because it was first
    ///       used for that language. Since Aditi is bilingual and fluent in both Indian English and Hindi,
    ///       this parameter would show the code <code>hi-IN</code>.</p>
    public let additionalLanguageCodes: [LanguageCode]?
    /// <p>Gender of the voice.</p>
    public let gender: Gender?
    /// <p>Amazon Polly assigned voice ID. This is the ID that you specify when calling the
    ///         <code>SynthesizeSpeech</code> operation.</p>
    public let id: VoiceId?
    /// <p>Language code of the voice.</p>
    public let languageCode: LanguageCode?
    /// <p>Human readable name of the language in English.</p>
    public let languageName: String?
    /// <p>Name of the voice (for example, Salli, Kendra, etc.). This provides a human readable
    ///       voice name that you might display in your application.</p>
    public let name: String?
    /// <p>Specifies which engines (<code>standard</code> or <code>neural</code>) that are supported
    ///       by a given voice.</p>
    public let supportedEngines: [Engine]?

    public init (
        additionalLanguageCodes: [LanguageCode]? = nil,
        gender: Gender? = nil,
        id: VoiceId? = nil,
        languageCode: LanguageCode? = nil,
        languageName: String? = nil,
        name: String? = nil,
        supportedEngines: [Engine]? = nil
    )
    {
        self.additionalLanguageCodes = additionalLanguageCodes
        self.gender = gender
        self.id = id
        self.languageCode = languageCode
        self.languageName = languageName
        self.name = name
        self.supportedEngines = supportedEngines
    }
}

public enum VoiceId {
    case aditi
    case amy
    case astrid
    case bianca
    case brian
    case camila
    case carla
    case carmen
    case celine
    case chantal
    case conchita
    case cristiano
    case dora
    case emma
    case enrique
    case ewa
    case filiz
    case gabrielle
    case geraint
    case giorgio
    case gwyneth
    case hans
    case ines
    case ivy
    case jacek
    case jan
    case joanna
    case joey
    case justin
    case karl
    case kendra
    case kevin
    case kimberly
    case lea
    case liv
    case lotte
    case lucia
    case lupe
    case mads
    case maja
    case marlene
    case mathieu
    case matthew
    case maxim
    case mia
    case miguel
    case mizuki
    case naja
    case nicole
    case olivia
    case penelope
    case raveena
    case ricardo
    case ruben
    case russell
    case salli
    case seoyeon
    case takumi
    case tatyana
    case vicki
    case vitoria
    case zeina
    case zhiyu
    case sdkUnknown(String)
}

extension VoiceId : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VoiceId] {
        return [
            .aditi,
            .amy,
            .astrid,
            .bianca,
            .brian,
            .camila,
            .carla,
            .carmen,
            .celine,
            .chantal,
            .conchita,
            .cristiano,
            .dora,
            .emma,
            .enrique,
            .ewa,
            .filiz,
            .gabrielle,
            .geraint,
            .giorgio,
            .gwyneth,
            .hans,
            .ines,
            .ivy,
            .jacek,
            .jan,
            .joanna,
            .joey,
            .justin,
            .karl,
            .kendra,
            .kevin,
            .kimberly,
            .lea,
            .liv,
            .lotte,
            .lucia,
            .lupe,
            .mads,
            .maja,
            .marlene,
            .mathieu,
            .matthew,
            .maxim,
            .mia,
            .miguel,
            .mizuki,
            .naja,
            .nicole,
            .olivia,
            .penelope,
            .raveena,
            .ricardo,
            .ruben,
            .russell,
            .salli,
            .seoyeon,
            .takumi,
            .tatyana,
            .vicki,
            .vitoria,
            .zeina,
            .zhiyu,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aditi: return "Aditi"
        case .amy: return "Amy"
        case .astrid: return "Astrid"
        case .bianca: return "Bianca"
        case .brian: return "Brian"
        case .camila: return "Camila"
        case .carla: return "Carla"
        case .carmen: return "Carmen"
        case .celine: return "Celine"
        case .chantal: return "Chantal"
        case .conchita: return "Conchita"
        case .cristiano: return "Cristiano"
        case .dora: return "Dora"
        case .emma: return "Emma"
        case .enrique: return "Enrique"
        case .ewa: return "Ewa"
        case .filiz: return "Filiz"
        case .gabrielle: return "Gabrielle"
        case .geraint: return "Geraint"
        case .giorgio: return "Giorgio"
        case .gwyneth: return "Gwyneth"
        case .hans: return "Hans"
        case .ines: return "Ines"
        case .ivy: return "Ivy"
        case .jacek: return "Jacek"
        case .jan: return "Jan"
        case .joanna: return "Joanna"
        case .joey: return "Joey"
        case .justin: return "Justin"
        case .karl: return "Karl"
        case .kendra: return "Kendra"
        case .kevin: return "Kevin"
        case .kimberly: return "Kimberly"
        case .lea: return "Lea"
        case .liv: return "Liv"
        case .lotte: return "Lotte"
        case .lucia: return "Lucia"
        case .lupe: return "Lupe"
        case .mads: return "Mads"
        case .maja: return "Maja"
        case .marlene: return "Marlene"
        case .mathieu: return "Mathieu"
        case .matthew: return "Matthew"
        case .maxim: return "Maxim"
        case .mia: return "Mia"
        case .miguel: return "Miguel"
        case .mizuki: return "Mizuki"
        case .naja: return "Naja"
        case .nicole: return "Nicole"
        case .olivia: return "Olivia"
        case .penelope: return "Penelope"
        case .raveena: return "Raveena"
        case .ricardo: return "Ricardo"
        case .ruben: return "Ruben"
        case .russell: return "Russell"
        case .salli: return "Salli"
        case .seoyeon: return "Seoyeon"
        case .takumi: return "Takumi"
        case .tatyana: return "Tatyana"
        case .vicki: return "Vicki"
        case .vitoria: return "Vitoria"
        case .zeina: return "Zeina"
        case .zhiyu: return "Zhiyu"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VoiceId(rawValue: rawValue) ?? VoiceId.sdkUnknown(rawValue)
    }
}
