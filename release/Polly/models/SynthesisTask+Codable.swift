// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SynthesisTask: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputUri = "OutputUri"
        case requestCharacters = "RequestCharacters"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case taskId = "TaskId"
        case taskStatus = "TaskStatus"
        case taskStatusReason = "TaskStatusReason"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let engine = engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let lexiconNames = lexiconNames {
            var lexiconNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lexiconNames)
            for lexiconnamelist0 in lexiconNames {
                try lexiconNamesContainer.encode(lexiconnamelist0)
            }
        }
        if let outputFormat = outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let outputUri = outputUri {
            try encodeContainer.encode(outputUri, forKey: .outputUri)
        }
        if requestCharacters != 0 {
            try encodeContainer.encode(requestCharacters, forKey: .requestCharacters)
        }
        if let sampleRate = sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let speechMarkTypes = speechMarkTypes {
            var speechMarkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .speechMarkTypes)
            for speechmarktypelist0 in speechMarkTypes {
                try speechMarkTypesContainer.encode(speechmarktypelist0.rawValue)
            }
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
        if let taskStatusReason = taskStatusReason {
            try encodeContainer.encode(taskStatusReason, forKey: .taskStatusReason)
        }
        if let textType = textType {
            try encodeContainer.encode(textType.rawValue, forKey: .textType)
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Engine.self, forKey: .engine)
        engine = engineDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(TaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskStatusReason)
        taskStatusReason = taskStatusReasonDecoded
        let outputUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputUri)
        outputUri = outputUriDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let requestCharactersDecoded = try containerValues.decode(Int.self, forKey: .requestCharacters)
        requestCharacters = requestCharactersDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([String].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [String]()
            for string0 in lexiconNamesContainer {
                lexiconNamesDecoded0?.append(string0)
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([SpeechMarkType].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [SpeechMarkType]()
            for string0 in speechMarkTypesContainer {
                speechMarkTypesDecoded0?.append(string0)
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textTypeDecoded = try containerValues.decodeIfPresent(TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}
