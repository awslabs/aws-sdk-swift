// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct StartSpeechSynthesisTaskInputBody: Equatable {
    public let engine: Engine?
    public let languageCode: LanguageCode?
    public let lexiconNames: [String]?
    public let outputFormat: OutputFormat?
    public let outputS3BucketName: String?
    public let outputS3KeyPrefix: String?
    public let sampleRate: String?
    public let snsTopicArn: String?
    public let speechMarkTypes: [SpeechMarkType]?
    public let text: String?
    public let textType: TextType?
    public let voiceId: VoiceId?
}

extension StartSpeechSynthesisTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engine = "Engine"
        case languageCode = "LanguageCode"
        case lexiconNames = "LexiconNames"
        case outputFormat = "OutputFormat"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case sampleRate = "SampleRate"
        case snsTopicArn = "SnsTopicArn"
        case speechMarkTypes = "SpeechMarkTypes"
        case text = "Text"
        case textType = "TextType"
        case voiceId = "VoiceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Engine.self, forKey: .engine)
        engine = engineDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lexiconNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lexiconNames)
        var lexiconNamesDecoded0:[String]? = nil
        if let lexiconNamesContainer = lexiconNamesContainer {
            lexiconNamesDecoded0 = [String]()
            for string0 in lexiconNamesContainer {
                if let string0 = string0 {
                    lexiconNamesDecoded0?.append(string0)
                }
            }
        }
        lexiconNames = lexiconNamesDecoded0
        let outputFormatDecoded = try containerValues.decodeIfPresent(OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let speechMarkTypesContainer = try containerValues.decodeIfPresent([SpeechMarkType?].self, forKey: .speechMarkTypes)
        var speechMarkTypesDecoded0:[SpeechMarkType]? = nil
        if let speechMarkTypesContainer = speechMarkTypesContainer {
            speechMarkTypesDecoded0 = [SpeechMarkType]()
            for string0 in speechMarkTypesContainer {
                if let string0 = string0 {
                    speechMarkTypesDecoded0?.append(string0)
                }
            }
        }
        speechMarkTypes = speechMarkTypesDecoded0
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let textTypeDecoded = try containerValues.decodeIfPresent(TextType.self, forKey: .textType)
        textType = textTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}
