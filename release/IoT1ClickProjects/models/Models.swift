// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateDeviceWithPlacementInputBodyMiddleware: Middleware {
    public let id: String = "AssociateDeviceWithPlacementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDeviceWithPlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDeviceWithPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDeviceWithPlacementInput>
    public typealias MOutput = OperationOutput<AssociateDeviceWithPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDeviceWithPlacementOutputError>
}

extension AssociateDeviceWithPlacementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDeviceWithPlacementInput(deviceId: \(String(describing: deviceId)), deviceTemplateName: \(String(describing: deviceTemplateName)), placementName: \(String(describing: placementName)), projectName: \(String(describing: projectName)))"}
}

extension AssociateDeviceWithPlacementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
    }
}

public struct AssociateDeviceWithPlacementInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateDeviceWithPlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDeviceWithPlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDeviceWithPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDeviceWithPlacementInput>
    public typealias MOutput = OperationOutput<AssociateDeviceWithPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDeviceWithPlacementOutputError>
}

public struct AssociateDeviceWithPlacementInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateDeviceWithPlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDeviceWithPlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDeviceWithPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDeviceWithPlacementInput>
    public typealias MOutput = OperationOutput<AssociateDeviceWithPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDeviceWithPlacementOutputError>
}

public struct AssociateDeviceWithPlacementInput: Equatable {
    /// <p>The ID of the physical device to be associated with the given placement in the project.
    ///       Note that a mandatory 4 character prefix is required for all <code>deviceId</code>
    ///       values.</p>
    public let deviceId: String?
    /// <p>The device template name to associate with the device ID.</p>
    public let deviceTemplateName: String?
    /// <p>The name of the placement in which to associate the device.</p>
    public let placementName: String?
    /// <p>The name of the project containing the placement in which to associate the device.</p>
    public let projectName: String?

    public init (
        deviceId: String? = nil,
        deviceTemplateName: String? = nil,
        placementName: String? = nil,
        projectName: String? = nil
    )
    {
        self.deviceId = deviceId
        self.deviceTemplateName = deviceTemplateName
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct AssociateDeviceWithPlacementInputBody: Equatable {
    public let deviceId: String?
}

extension AssociateDeviceWithPlacementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension AssociateDeviceWithPlacementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDeviceWithPlacementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDeviceWithPlacementOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDeviceWithPlacementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDeviceWithPlacementOutputResponse()"}
}

extension AssociateDeviceWithPlacementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDeviceWithPlacementOutputResponse: Equatable {

    public init() {}
}

struct AssociateDeviceWithPlacementOutputResponseBody: Equatable {
}

extension AssociateDeviceWithPlacementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreatePlacementInputBodyMiddleware: Middleware {
    public let id: String = "CreatePlacementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlacementInput>
    public typealias MOutput = OperationOutput<CreatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlacementOutputError>
}

extension CreatePlacementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePlacementInput(attributes: \(String(describing: attributes)), placementName: \(String(describing: placementName)), projectName: \(String(describing: projectName)))"}
}

extension CreatePlacementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case placementName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, placementattributemap0) in attributes {
                try attributesContainer.encode(placementattributemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let placementName = placementName {
            try encodeContainer.encode(placementName, forKey: .placementName)
        }
    }
}

public struct CreatePlacementInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlacementInput>
    public typealias MOutput = OperationOutput<CreatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlacementOutputError>
}

public struct CreatePlacementInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePlacementInput>
    public typealias MOutput = OperationOutput<CreatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePlacementOutputError>
}

public struct CreatePlacementInput: Equatable {
    /// <p>Optional user-defined key/value pairs providing contextual data (such as location or
    ///       function) for the placement.</p>
    public let attributes: [String:String]?
    /// <p>The name of the placement to be created.</p>
    public let placementName: String?
    /// <p>The name of the project in which to create the placement.</p>
    public let projectName: String?

    public init (
        attributes: [String:String]? = nil,
        placementName: String? = nil,
        projectName: String? = nil
    )
    {
        self.attributes = attributes
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct CreatePlacementInputBody: Equatable {
    public let placementName: String?
    public let attributes: [String:String]?
}

extension CreatePlacementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes
        case placementName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .placementName)
        placementName = placementNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CreatePlacementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePlacementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePlacementOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlacementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePlacementOutputResponse()"}
}

extension CreatePlacementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreatePlacementOutputResponse: Equatable {

    public init() {}
}

struct CreatePlacementOutputResponseBody: Equatable {
}

extension CreatePlacementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateProjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectInput(description: \(String(describing: description)), placementTemplate: \(String(describing: placementTemplate)), projectName: \(String(describing: projectName)), tags: \(String(describing: tags)))"}
}

extension CreateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case placementTemplate
        case projectName
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let placementTemplate = placementTemplate {
            try encodeContainer.encode(placementTemplate, forKey: .placementTemplate)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInput: Equatable {
    /// <p>An optional description for the project.</p>
    public let description: String?
    /// <p>The schema defining the placement to be created. A placement template defines placement
    ///       default attributes and device templates. You cannot add or remove device templates after the
    ///       project has been created. However, you can update <code>callbackOverrides</code> for the
    ///       device templates using the <code>UpdateProject</code> API.</p>
    public let placementTemplate: PlacementTemplate?
    /// <p>The name of the project to create.</p>
    public let projectName: String?
    /// <p>Optional tags (metadata key/value pairs) to be associated with the project. For example,
    ///         <code>{ {"key1": "value1", "key2": "value2"} }</code>. For more information, see <a href="https://aws.amazon.com/answers/account-management/aws-tagging-strategies/">AWS Tagging
    ///         Strategies</a>.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        placementTemplate: PlacementTemplate? = nil,
        projectName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.placementTemplate = placementTemplate
        self.projectName = projectName
        self.tags = tags
    }
}

struct CreateProjectInputBody: Equatable {
    public let projectName: String?
    public let description: String?
    public let placementTemplate: PlacementTemplate?
    public let tags: [String:String]?
}

extension CreateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case placementTemplate
        case projectName
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let placementTemplateDecoded = try containerValues.decodeIfPresent(PlacementTemplate.self, forKey: .placementTemplate)
        placementTemplate = placementTemplateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectOutputResponse()"}
}

extension CreateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateProjectOutputResponse: Equatable {

    public init() {}
}

struct CreateProjectOutputResponseBody: Equatable {
}

extension CreateProjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePlacementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePlacementInput(placementName: \(String(describing: placementName)), projectName: \(String(describing: projectName)))"}
}

extension DeletePlacementInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePlacementInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlacementInput>
    public typealias MOutput = OperationOutput<DeletePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlacementOutputError>
}

public struct DeletePlacementInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlacementInput>
    public typealias MOutput = OperationOutput<DeletePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlacementOutputError>
}

public struct DeletePlacementInput: Equatable {
    /// <p>The name of the empty placement to delete.</p>
    public let placementName: String?
    /// <p>The project containing the empty placement to delete.</p>
    public let projectName: String?

    public init (
        placementName: String? = nil,
        projectName: String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct DeletePlacementInputBody: Equatable {
}

extension DeletePlacementInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePlacementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePlacementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlacementOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlacementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePlacementOutputResponse()"}
}

extension DeletePlacementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlacementOutputResponse: Equatable {

    public init() {}
}

struct DeletePlacementOutputResponseBody: Equatable {
}

extension DeletePlacementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectInput(projectName: \(String(describing: projectName)))"}
}

extension DeleteProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInput: Equatable {
    /// <p>The name of the empty project to delete.</p>
    public let projectName: String?

    public init (
        projectName: String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DeleteProjectInputBody: Equatable {
}

extension DeleteProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectOutputResponse()"}
}

extension DeleteProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProjectOutputResponse: Equatable {

    public init() {}
}

struct DeleteProjectOutputResponseBody: Equatable {
}

extension DeleteProjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribePlacementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePlacementInput(placementName: \(String(describing: placementName)), projectName: \(String(describing: projectName)))"}
}

extension DescribePlacementInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribePlacementInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePlacementInput>
    public typealias MOutput = OperationOutput<DescribePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePlacementOutputError>
}

public struct DescribePlacementInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePlacementInput>
    public typealias MOutput = OperationOutput<DescribePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePlacementOutputError>
}

public struct DescribePlacementInput: Equatable {
    /// <p>The name of the placement within a project.</p>
    public let placementName: String?
    /// <p>The project containing the placement to be described.</p>
    public let projectName: String?

    public init (
        placementName: String? = nil,
        projectName: String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct DescribePlacementInputBody: Equatable {
}

extension DescribePlacementInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribePlacementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePlacementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePlacementOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePlacementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePlacementOutputResponse(placement: \(String(describing: placement)))"}
}

extension DescribePlacementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePlacementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.placement = output.placement
        } else {
            self.placement = nil
        }
    }
}

public struct DescribePlacementOutputResponse: Equatable {
    /// <p>An object describing the placement.</p>
    public let placement: PlacementDescription?

    public init (
        placement: PlacementDescription? = nil
    )
    {
        self.placement = placement
    }
}

struct DescribePlacementOutputResponseBody: Equatable {
    public let placement: PlacementDescription?
}

extension DescribePlacementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case placement
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placementDecoded = try containerValues.decodeIfPresent(PlacementDescription.self, forKey: .placement)
        placement = placementDecoded
    }
}

extension DescribeProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectInput(projectName: \(String(describing: projectName)))"}
}

extension DescribeProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInput: Equatable {
    /// <p>The name of the project to be described.</p>
    public let projectName: String?

    public init (
        projectName: String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DescribeProjectInputBody: Equatable {
}

extension DescribeProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectOutputResponse(project: \(String(describing: project)))"}
}

extension DescribeProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Equatable {
    /// <p>An object describing the project.</p>
    public let project: ProjectDescription?

    public init (
        project: ProjectDescription? = nil
    )
    {
        self.project = project
    }
}

struct DescribeProjectOutputResponseBody: Equatable {
    public let project: ProjectDescription?
}

extension DescribeProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case project
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(ProjectDescription.self, forKey: .project)
        project = projectDecoded
    }
}

extension DeviceTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case callbackOverrides
        case deviceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callbackOverrides = callbackOverrides {
            var callbackOverridesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .callbackOverrides)
            for (dictKey0, devicecallbackoverridemap0) in callbackOverrides {
                try callbackOverridesContainer.encode(devicecallbackoverridemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let callbackOverridesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .callbackOverrides)
        var callbackOverridesDecoded0: [String:String]? = nil
        if let callbackOverridesContainer = callbackOverridesContainer {
            callbackOverridesDecoded0 = [String:String]()
            for (key0, devicecallbackvalue0) in callbackOverridesContainer {
                if let devicecallbackvalue0 = devicecallbackvalue0 {
                    callbackOverridesDecoded0?[key0] = devicecallbackvalue0
                }
            }
        }
        callbackOverrides = callbackOverridesDecoded0
    }
}

extension DeviceTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceTemplate(callbackOverrides: \(String(describing: callbackOverrides)), deviceType: \(String(describing: deviceType)))"}
}

/// <p>An object representing a device for a placement template (see <a>PlacementTemplate</a>).</p>
public struct DeviceTemplate: Equatable {
    /// <p>An optional Lambda function to invoke instead of the default Lambda function provided by
    ///       the placement template.</p>
    public let callbackOverrides: [String:String]?
    /// <p>The device type, which currently must be <code>"button"</code>.</p>
    public let deviceType: String?

    public init (
        callbackOverrides: [String:String]? = nil,
        deviceType: String? = nil
    )
    {
        self.callbackOverrides = callbackOverrides
        self.deviceType = deviceType
    }
}

extension DisassociateDeviceFromPlacementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDeviceFromPlacementInput(deviceTemplateName: \(String(describing: deviceTemplateName)), placementName: \(String(describing: placementName)), projectName: \(String(describing: projectName)))"}
}

extension DisassociateDeviceFromPlacementInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateDeviceFromPlacementInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateDeviceFromPlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDeviceFromPlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDeviceFromPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDeviceFromPlacementInput>
    public typealias MOutput = OperationOutput<DisassociateDeviceFromPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDeviceFromPlacementOutputError>
}

public struct DisassociateDeviceFromPlacementInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateDeviceFromPlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDeviceFromPlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDeviceFromPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDeviceFromPlacementInput>
    public typealias MOutput = OperationOutput<DisassociateDeviceFromPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDeviceFromPlacementOutputError>
}

public struct DisassociateDeviceFromPlacementInput: Equatable {
    /// <p>The device ID that should be removed from the placement.</p>
    public let deviceTemplateName: String?
    /// <p>The name of the placement that the device should be removed from.</p>
    public let placementName: String?
    /// <p>The name of the project that contains the placement.</p>
    public let projectName: String?

    public init (
        deviceTemplateName: String? = nil,
        placementName: String? = nil,
        projectName: String? = nil
    )
    {
        self.deviceTemplateName = deviceTemplateName
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct DisassociateDeviceFromPlacementInputBody: Equatable {
}

extension DisassociateDeviceFromPlacementInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateDeviceFromPlacementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDeviceFromPlacementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDeviceFromPlacementOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDeviceFromPlacementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDeviceFromPlacementOutputResponse()"}
}

extension DisassociateDeviceFromPlacementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDeviceFromPlacementOutputResponse: Equatable {

    public init() {}
}

struct DisassociateDeviceFromPlacementOutputResponseBody: Equatable {
}

extension DisassociateDeviceFromPlacementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDevicesInPlacementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevicesInPlacementInput(placementName: \(String(describing: placementName)), projectName: \(String(describing: projectName)))"}
}

extension GetDevicesInPlacementInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDevicesInPlacementInputHeadersMiddleware: Middleware {
    public let id: String = "GetDevicesInPlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevicesInPlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevicesInPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevicesInPlacementInput>
    public typealias MOutput = OperationOutput<GetDevicesInPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevicesInPlacementOutputError>
}

public struct GetDevicesInPlacementInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDevicesInPlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevicesInPlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevicesInPlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevicesInPlacementInput>
    public typealias MOutput = OperationOutput<GetDevicesInPlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevicesInPlacementOutputError>
}

public struct GetDevicesInPlacementInput: Equatable {
    /// <p>The name of the placement to get the devices from.</p>
    public let placementName: String?
    /// <p>The name of the project containing the placement.</p>
    public let projectName: String?

    public init (
        placementName: String? = nil,
        projectName: String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct GetDevicesInPlacementInputBody: Equatable {
}

extension GetDevicesInPlacementInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDevicesInPlacementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicesInPlacementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicesInPlacementOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicesInPlacementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevicesInPlacementOutputResponse(devices: \(String(describing: devices)))"}
}

extension GetDevicesInPlacementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDevicesInPlacementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devices = output.devices
        } else {
            self.devices = nil
        }
    }
}

public struct GetDevicesInPlacementOutputResponse: Equatable {
    /// <p>An object containing the devices (zero or more) within the placement.</p>
    public let devices: [String:String]?

    public init (
        devices: [String:String]? = nil
    )
    {
        self.devices = devices
    }
}

struct GetDevicesInPlacementOutputResponseBody: Equatable {
    public let devices: [String:String]?
}

extension GetDevicesInPlacementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devices
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .devices)
        var devicesDecoded0: [String:String]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [String:String]()
            for (key0, deviceid0) in devicesContainer {
                if let deviceid0 = deviceid0 {
                    devicesDecoded0?[key0] = deviceid0
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPlacementsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlacementsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), projectName: \(String(describing: projectName)))"}
}

extension ListPlacementsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPlacementsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPlacementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlacementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlacementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlacementsInput>
    public typealias MOutput = OperationOutput<ListPlacementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlacementsOutputError>
}

public struct ListPlacementsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPlacementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlacementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlacementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlacementsInput>
    public typealias MOutput = OperationOutput<ListPlacementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlacementsOutputError>
}

public struct ListPlacementsInput: Equatable {
    /// <p>The maximum number of results to return per request. If not set, a default value of 100 is
    ///       used.</p>
    public let maxResults: Int?
    /// <p>The token to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The project containing the placements to be listed.</p>
    public let projectName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        projectName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

struct ListPlacementsInputBody: Equatable {
}

extension ListPlacementsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPlacementsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPlacementsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlacementsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlacementsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlacementsOutputResponse(nextToken: \(String(describing: nextToken)), placements: \(String(describing: placements)))"}
}

extension ListPlacementsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPlacementsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.placements = output.placements
        } else {
            self.nextToken = nil
            self.placements = nil
        }
    }
}

public struct ListPlacementsOutputResponse: Equatable {
    /// <p>The token used to retrieve the next set of results - will be effectively empty if there
    ///       are no further results.</p>
    public let nextToken: String?
    /// <p>An object listing the requested placements.</p>
    public let placements: [PlacementSummary]?

    public init (
        nextToken: String? = nil,
        placements: [PlacementSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.placements = placements
    }
}

struct ListPlacementsOutputResponseBody: Equatable {
    public let placements: [PlacementSummary]?
    public let nextToken: String?
}

extension ListPlacementsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case placements
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placementsContainer = try containerValues.decodeIfPresent([PlacementSummary?].self, forKey: .placements)
        var placementsDecoded0:[PlacementSummary]? = nil
        if let placementsContainer = placementsContainer {
            placementsDecoded0 = [PlacementSummary]()
            for structure0 in placementsContainer {
                if let structure0 = structure0 {
                    placementsDecoded0?.append(structure0)
                }
            }
        }
        placements = placementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProjectsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInput: Equatable {
    /// <p>The maximum number of results to return per request. If not set, a default value of 100 is
    ///       used.</p>
    public let maxResults: Int?
    /// <p>The token to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Equatable {
}

extension ListProjectsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsOutputResponse(nextToken: \(String(describing: nextToken)), projects: \(String(describing: projects)))"}
}

extension ListProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Equatable {
    /// <p>The token used to retrieve the next set of results - will be effectively empty if there
    ///       are no further results.</p>
    public let nextToken: String?
    /// <p>An object containing the list of projects.</p>
    public let projects: [ProjectSummary]?

    public init (
        nextToken: String? = nil,
        projects: [ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Equatable {
    public let projects: [ProjectSummary]?
    public let nextToken: String?
}

extension ListProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the resource whose tags you want to list.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags (metadata key/value pairs) which you have assigned to the resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PlacementDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case createdDate
        case placementName
        case projectName
        case updatedDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, placementattributemap0) in attributes {
                try attributesContainer.encode(placementattributemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let placementName = placementName {
            try encodeContainer.encode(placementName, forKey: .placementName)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let updatedDate = updatedDate {
            try encodeContainer.encode(updatedDate.timeIntervalSince1970, forKey: .updatedDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let placementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .placementName)
        placementName = placementNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
    }
}

extension PlacementDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlacementDescription(attributes: \(String(describing: attributes)), createdDate: \(String(describing: createdDate)), placementName: \(String(describing: placementName)), projectName: \(String(describing: projectName)), updatedDate: \(String(describing: updatedDate)))"}
}

/// <p>An object describing a project's placement.</p>
public struct PlacementDescription: Equatable {
    /// <p>The user-defined attributes associated with the placement.</p>
    public let attributes: [String:String]?
    /// <p>The date when the placement was initially created, in UNIX epoch time format.</p>
    public let createdDate: Date?
    /// <p>The name of the placement.</p>
    public let placementName: String?
    /// <p>The name of the project containing the placement.</p>
    public let projectName: String?
    /// <p>The date when the placement was last updated, in UNIX epoch time format. If the placement
    ///       was not updated, then <code>createdDate</code> and <code>updatedDate</code> are the
    ///       same.</p>
    public let updatedDate: Date?

    public init (
        attributes: [String:String]? = nil,
        createdDate: Date? = nil,
        placementName: String? = nil,
        projectName: String? = nil,
        updatedDate: Date? = nil
    )
    {
        self.attributes = attributes
        self.createdDate = createdDate
        self.placementName = placementName
        self.projectName = projectName
        self.updatedDate = updatedDate
    }
}

extension PlacementSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate
        case placementName
        case projectName
        case updatedDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let placementName = placementName {
            try encodeContainer.encode(placementName, forKey: .placementName)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let updatedDate = updatedDate {
            try encodeContainer.encode(updatedDate.timeIntervalSince1970, forKey: .updatedDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let placementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .placementName)
        placementName = placementNameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
    }
}

extension PlacementSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlacementSummary(createdDate: \(String(describing: createdDate)), placementName: \(String(describing: placementName)), projectName: \(String(describing: projectName)), updatedDate: \(String(describing: updatedDate)))"}
}

/// <p>An object providing summary information for a particular placement.</p>
public struct PlacementSummary: Equatable {
    /// <p>The date when the placement was originally created, in UNIX epoch time format.</p>
    public let createdDate: Date?
    /// <p>The name of the placement being summarized.</p>
    public let placementName: String?
    /// <p>The name of the project containing the placement.</p>
    public let projectName: String?
    /// <p>The date when the placement was last updated, in UNIX epoch time format. If the placement
    ///       was not updated, then <code>createdDate</code> and <code>updatedDate</code> are the
    ///       same.</p>
    public let updatedDate: Date?

    public init (
        createdDate: Date? = nil,
        placementName: String? = nil,
        projectName: String? = nil,
        updatedDate: Date? = nil
    )
    {
        self.createdDate = createdDate
        self.placementName = placementName
        self.projectName = projectName
        self.updatedDate = updatedDate
    }
}

extension PlacementTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultAttributes
        case deviceTemplates
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAttributes = defaultAttributes {
            var defaultAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .defaultAttributes)
            for (dictKey0, defaultplacementattributemap0) in defaultAttributes {
                try defaultAttributesContainer.encode(defaultplacementattributemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let deviceTemplates = deviceTemplates {
            var deviceTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .deviceTemplates)
            for (dictKey0, devicetemplatemap0) in deviceTemplates {
                try deviceTemplatesContainer.encode(devicetemplatemap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .defaultAttributes)
        var defaultAttributesDecoded0: [String:String]? = nil
        if let defaultAttributesContainer = defaultAttributesContainer {
            defaultAttributesDecoded0 = [String:String]()
            for (key0, attributedefaultvalue0) in defaultAttributesContainer {
                if let attributedefaultvalue0 = attributedefaultvalue0 {
                    defaultAttributesDecoded0?[key0] = attributedefaultvalue0
                }
            }
        }
        defaultAttributes = defaultAttributesDecoded0
        let deviceTemplatesContainer = try containerValues.decodeIfPresent([String: DeviceTemplate?].self, forKey: .deviceTemplates)
        var deviceTemplatesDecoded0: [String:DeviceTemplate]? = nil
        if let deviceTemplatesContainer = deviceTemplatesContainer {
            deviceTemplatesDecoded0 = [String:DeviceTemplate]()
            for (key0, devicetemplate0) in deviceTemplatesContainer {
                if let devicetemplate0 = devicetemplate0 {
                    deviceTemplatesDecoded0?[key0] = devicetemplate0
                }
            }
        }
        deviceTemplates = deviceTemplatesDecoded0
    }
}

extension PlacementTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlacementTemplate(defaultAttributes: \(String(describing: defaultAttributes)), deviceTemplates: \(String(describing: deviceTemplates)))"}
}

/// <p>An object defining the template for a placement.</p>
public struct PlacementTemplate: Equatable {
    /// <p>The default attributes (key/value pairs) to be applied to all placements using this
    ///       template.</p>
    public let defaultAttributes: [String:String]?
    /// <p>An object specifying the <a>DeviceTemplate</a> for all placements using this
    ///         (<a>PlacementTemplate</a>) template.</p>
    public let deviceTemplates: [String:DeviceTemplate]?

    public init (
        defaultAttributes: [String:String]? = nil,
        deviceTemplates: [String:DeviceTemplate]? = nil
    )
    {
        self.defaultAttributes = defaultAttributes
        self.deviceTemplates = deviceTemplates
    }
}

extension ProjectDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdDate
        case description
        case placementTemplate
        case projectName
        case tags
        case updatedDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let placementTemplate = placementTemplate {
            try encodeContainer.encode(placementTemplate, forKey: .placementTemplate)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedDate = updatedDate {
            try encodeContainer.encode(updatedDate.timeIntervalSince1970, forKey: .updatedDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
        let placementTemplateDecoded = try containerValues.decodeIfPresent(PlacementTemplate.self, forKey: .placementTemplate)
        placementTemplate = placementTemplateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ProjectDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectDescription(arn: \(String(describing: arn)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), placementTemplate: \(String(describing: placementTemplate)), projectName: \(String(describing: projectName)), tags: \(String(describing: tags)), updatedDate: \(String(describing: updatedDate)))"}
}

/// <p>An object providing detailed information for a particular project associated with an AWS
///       account and region.</p>
public struct ProjectDescription: Equatable {
    /// <p>The ARN of the project.</p>
    public let arn: String?
    /// <p>The date when the project was originally created, in UNIX epoch time format.</p>
    public let createdDate: Date?
    /// <p>The description of the project.</p>
    public let description: String?
    /// <p>An object describing the project's placement specifications.</p>
    public let placementTemplate: PlacementTemplate?
    /// <p>The name of the project for which to obtain information from.</p>
    public let projectName: String?
    /// <p>The tags (metadata key/value pairs) associated with the project.</p>
    public let tags: [String:String]?
    /// <p>The date when the project was last updated, in UNIX epoch time format. If the project was
    ///       not updated, then <code>createdDate</code> and <code>updatedDate</code> are the same.</p>
    public let updatedDate: Date?

    public init (
        arn: String? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        placementTemplate: PlacementTemplate? = nil,
        projectName: String? = nil,
        tags: [String:String]? = nil,
        updatedDate: Date? = nil
    )
    {
        self.arn = arn
        self.createdDate = createdDate
        self.description = description
        self.placementTemplate = placementTemplate
        self.projectName = projectName
        self.tags = tags
        self.updatedDate = updatedDate
    }
}

extension ProjectSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdDate
        case projectName
        case tags
        case updatedDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedDate = updatedDate {
            try encodeContainer.encode(updatedDate.timeIntervalSince1970, forKey: .updatedDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ProjectSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectSummary(arn: \(String(describing: arn)), createdDate: \(String(describing: createdDate)), projectName: \(String(describing: projectName)), tags: \(String(describing: tags)), updatedDate: \(String(describing: updatedDate)))"}
}

/// <p>An object providing summary information for a particular project for an associated AWS
///       account and region.</p>
public struct ProjectSummary: Equatable {
    /// <p>The ARN of the project.</p>
    public let arn: String?
    /// <p>The date when the project was originally created, in UNIX epoch time format.</p>
    public let createdDate: Date?
    /// <p>The name of the project being summarized.</p>
    public let projectName: String?
    /// <p>The tags (metadata key/value pairs) associated with the project.</p>
    public let tags: [String:String]?
    /// <p>The date when the project was last updated, in UNIX epoch time format. If the project was
    ///       not updated, then <code>createdDate</code> and <code>updatedDate</code> are the same.</p>
    public let updatedDate: Date?

    public init (
        arn: String? = nil,
        createdDate: Date? = nil,
        projectName: String? = nil,
        tags: [String:String]? = nil,
        updatedDate: Date? = nil
    )
    {
        self.arn = arn
        self.createdDate = createdDate
        self.projectName = projectName
        self.tags = tags
        self.updatedDate = updatedDate
    }
}

extension ResourceConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceConflictException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ResourceConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension ResourceConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resouce for which tag(s) should be added or modified.</p>
    public let resourceArn: String?
    /// <p>The new or modifying tag(s) for the resource. See <a href="https://docs.aws.amazon.com/iot-1-click/latest/developerguide/1click-appendix.html#1click-limits">AWS IoT 1-Click Service Limits</a> for the maximum number of tags allowed per
    ///       resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource whose tag you want to remove.</p>
    public let resourceArn: String?
    /// <p>The keys of those tags which you want to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePlacementInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePlacementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePlacementInput>
    public typealias MOutput = OperationOutput<UpdatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePlacementOutputError>
}

extension UpdatePlacementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePlacementInput(attributes: \(String(describing: attributes)), placementName: \(String(describing: placementName)), projectName: \(String(describing: projectName)))"}
}

extension UpdatePlacementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, placementattributemap0) in attributes {
                try attributesContainer.encode(placementattributemap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdatePlacementInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePlacementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePlacementInput>
    public typealias MOutput = OperationOutput<UpdatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePlacementOutputError>
}

public struct UpdatePlacementInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePlacementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePlacementInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePlacementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePlacementInput>
    public typealias MOutput = OperationOutput<UpdatePlacementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePlacementOutputError>
}

public struct UpdatePlacementInput: Equatable {
    /// <p>The user-defined object of attributes used to update the placement. The maximum number of
    ///       key/value pairs is 50.</p>
    public let attributes: [String:String]?
    /// <p>The name of the placement to update.</p>
    public let placementName: String?
    /// <p>The name of the project containing the placement to be updated.</p>
    public let projectName: String?

    public init (
        attributes: [String:String]? = nil,
        placementName: String? = nil,
        projectName: String? = nil
    )
    {
        self.attributes = attributes
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct UpdatePlacementInputBody: Equatable {
    public let attributes: [String:String]?
}

extension UpdatePlacementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension UpdatePlacementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePlacementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePlacementOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePlacementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePlacementOutputResponse()"}
}

extension UpdatePlacementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePlacementOutputResponse: Equatable {

    public init() {}
}

struct UpdatePlacementOutputResponseBody: Equatable {
}

extension UpdatePlacementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateProjectInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectInput(description: \(String(describing: description)), placementTemplate: \(String(describing: placementTemplate)), projectName: \(String(describing: projectName)))"}
}

extension UpdateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case placementTemplate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let placementTemplate = placementTemplate {
            try encodeContainer.encode(placementTemplate, forKey: .placementTemplate)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInput: Equatable {
    /// <p>An optional user-defined description for the project.</p>
    public let description: String?
    /// <p>An object defining the project update. Once a project has been created, you cannot add
    ///       device template names to the project. However, for a given <code>placementTemplate</code>, you
    ///       can update the associated <code>callbackOverrides</code> for the device definition using this
    ///       API.</p>
    public let placementTemplate: PlacementTemplate?
    /// <p>The name of the project to be updated.</p>
    public let projectName: String?

    public init (
        description: String? = nil,
        placementTemplate: PlacementTemplate? = nil,
        projectName: String? = nil
    )
    {
        self.description = description
        self.placementTemplate = placementTemplate
        self.projectName = projectName
    }
}

struct UpdateProjectInputBody: Equatable {
    public let description: String?
    public let placementTemplate: PlacementTemplate?
}

extension UpdateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case placementTemplate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let placementTemplateDecoded = try containerValues.decodeIfPresent(PlacementTemplate.self, forKey: .placementTemplate)
        placementTemplate = placementTemplateDecoded
    }
}

extension UpdateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectOutputResponse()"}
}

extension UpdateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProjectOutputResponse: Equatable {

    public init() {}
}

struct UpdateProjectOutputResponseBody: Equatable {
}

extension UpdateProjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
