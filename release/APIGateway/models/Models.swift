// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessLogSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationArn
        case format
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

extension AccessLogSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessLogSettings(destinationArn: \(String(describing: destinationArn)), format: \(String(describing: format)))"}
}

/// <p>Access log settings, including the access log format and access log destination ARN.</p>
public struct AccessLogSettings: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with <code>amazon-apigateway-</code>.</p>
    public let destinationArn: String?
    /// <p>A single line format of the access logs of data, as specified by selected <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference">$context variables</a>. The format must include at least <code>$context.requestId</code>.</p>
    public let format: String?

    public init (
        destinationArn: String? = nil,
        format: String? = nil
    )
    {
        self.destinationArn = destinationArn
        self.format = format
    }
}

extension ApiKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let customerId = customerId {
            try encodeContainer.encode(customerId, forKey: .customerId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate.timeIntervalSince1970, forKey: .lastUpdatedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stageKeys = stageKeys {
            var stageKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stageKeys)
            for listofstring0 in stageKeys {
                try stageKeysContainer.encode(listofstring0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApiKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiKey(createdDate: \(String(describing: createdDate)), customerId: \(String(describing: customerId)), description: \(String(describing: description)), enabled: \(String(describing: enabled)), id: \(String(describing: id)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), name: \(String(describing: name)), stageKeys: \(String(describing: stageKeys)), tags: \(String(describing: tags)), value: \(String(describing: value)))"}
}

/// <p>A resource that can be distributed to callers for executing <a>Method</a> resources that require an API key. API keys can be mapped to any <a>Stage</a> on any <a>RestApi</a>, which indicates that the callers with the API key can make requests to that stage.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html">Use API Keys</a>
///       </div>
public struct ApiKey: Equatable {
    /// <p>The timestamp when the API Key was created.</p>
    public let createdDate: Date?
    /// <p>An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.</p>
    public let customerId: String?
    /// <p>The description of the API Key.</p>
    public let description: String?
    /// <p>Specifies whether the API Key can be used by callers.</p>
    public let enabled: Bool
    /// <p>The identifier of the API Key.</p>
    public let id: String?
    /// <p>The timestamp when the API Key was last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>The name of the API Key.</p>
    public let name: String?
    /// <p>A list of <a>Stage</a> resources that are associated with the <a>ApiKey</a> resource.</p>
    public let stageKeys: [String]?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The value of the API Key.</p>
    public let value: String?

    public init (
        createdDate: Date? = nil,
        customerId: String? = nil,
        description: String? = nil,
        enabled: Bool = false,
        id: String? = nil,
        lastUpdatedDate: Date? = nil,
        name: String? = nil,
        stageKeys: [String]? = nil,
        tags: [String:String]? = nil,
        value: String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

public enum ApiKeySourceType {
    case authorizer
    case header
    case sdkUnknown(String)
}

extension ApiKeySourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApiKeySourceType] {
        return [
            .authorizer,
            .header,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authorizer: return "AUTHORIZER"
        case .header: return "HEADER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApiKeySourceType(rawValue: rawValue) ?? ApiKeySourceType.sdkUnknown(rawValue)
    }
}

public enum ApiKeysFormat {
    case csv
    case sdkUnknown(String)
}

extension ApiKeysFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApiKeysFormat] {
        return [
            .csv,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "csv"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApiKeysFormat(rawValue: rawValue) ?? ApiKeysFormat.sdkUnknown(rawValue)
    }
}

extension ApiStage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiId
        case stage
        case throttle
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
        if let throttle = throttle {
            var throttleContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .throttle)
            for (dictKey0, mapofapistagethrottlesettings0) in throttle {
                try throttleContainer.encode(mapofapistagethrottlesettings0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
        let throttleContainer = try containerValues.decodeIfPresent([String: ThrottleSettings?].self, forKey: .throttle)
        var throttleDecoded0: [String:ThrottleSettings]? = nil
        if let throttleContainer = throttleContainer {
            throttleDecoded0 = [String:ThrottleSettings]()
            for (key0, throttlesettings0) in throttleContainer {
                if let throttlesettings0 = throttlesettings0 {
                    throttleDecoded0?[key0] = throttlesettings0
                }
            }
        }
        throttle = throttleDecoded0
    }
}

extension ApiStage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiStage(apiId: \(String(describing: apiId)), stage: \(String(describing: stage)), throttle: \(String(describing: throttle)))"}
}

/// <p>API stage name of the associated API stage in a usage plan.</p>
public struct ApiStage: Equatable {
    /// <p>API Id of the associated API stage in a usage plan.</p>
    public let apiId: String?
    /// <p>API stage name of the associated API stage in a usage plan.</p>
    public let stage: String?
    /// <p>Map containing method level throttling information for API stage in a usage plan.</p>
    public let throttle: [String:ThrottleSettings]?

    public init (
        apiId: String? = nil,
        stage: String? = nil,
        throttle: [String:ThrottleSettings]? = nil
    )
    {
        self.apiId = apiId
        self.stage = stage
        self.throttle = throttle
    }
}

extension Authorizer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = authType {
            try encodeContainer.encode(authType, forKey: .authType)
        }
        if let authorizerCredentials = authorizerCredentials {
            try encodeContainer.encode(authorizerCredentials, forKey: .authorizerCredentials)
        }
        if let authorizerResultTtlInSeconds = authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identitySource = identitySource {
            try encodeContainer.encode(identitySource, forKey: .identitySource)
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let providerARNs = providerARNs {
            var providerARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providerARNs)
            for listofarns0 in providerARNs {
                try providerARNsContainer.encode(listofarns0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

extension Authorizer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Authorizer(authType: \(String(describing: authType)), authorizerCredentials: \(String(describing: authorizerCredentials)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerUri: \(String(describing: authorizerUri)), id: \(String(describing: id)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), name: \(String(describing: name)), providerARNs: \(String(describing: providerARNs)), type: \(String(describing: type)))"}
}

/// <p>Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html">Use Lambda Function as Authorizer</a>
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html">Use Cognito User Pool as Authorizer</a>
///       </div>
public struct Authorizer: Equatable {
    /// <p>Optional customer-defined field, used in OpenAPI imports and exports without functional impact.</p>
    public let authType: String?
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.</p>
    public let authorizerCredentials: String?
    /// <p>The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.</p>
    public let authorizerResultTtlInSeconds: Int?
    /// <p>Specifies the authorizer's Uniform Resource Identifier (URI). For <code>TOKEN</code> or <code>REQUEST</code> authorizers, this must be a well-formed Lambda function URI, for example, <code>arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations</code>. In general, the URI has this form  <code>arn:aws:apigateway:{region}:lambda:path/{service_api}</code>, where <code>{region}</code> is the same as the region hosting the Lambda function, <code>path</code> indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial <code>/</code>. For Lambda functions, this is usually of the form <code>/2015-03-31/functions/[FunctionARN]/invocations</code>.</p>
    public let authorizerUri: String?
    /// <p>The identifier for the authorizer resource.</p>
    public let id: String?
    /// <p>The identity source for which authorization is requested. <ul><li>For a <code>TOKEN</code> or <code>COGNITO_USER_POOLS</code> authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is <code>Auth</code>, the header mapping expression is  <code>method.request.header.Auth</code>.</li><li>For the <code>REQUEST</code> authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an <code>Auth</code> header, a <code>Name</code> query string parameter are defined as identity sources, this value is <code>method.request.header.Auth, method.request.querystring.Name</code>.  These parameters will be used to derive the authorization caching key and to perform runtime validation of the <code>REQUEST</code> authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.</li></ul></p>
    public let identitySource: String?
    /// <p>A validation expression for the incoming identity token. For <code>TOKEN</code> authorizers, this value is a regular expression. For <code>COGNITO_USER_POOLS</code> authorizers, API Gateway will match the <code>aud</code> field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the <code>REQUEST</code> authorizer.</p>
    public let identityValidationExpression: String?
    /// <p>[Required] The name of the authorizer.</p>
    public let name: String?
    /// <p>A list of the Amazon Cognito user pool ARNs for the <code>COGNITO_USER_POOLS</code> authorizer. Each element is of this format: <code>arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}</code>. For a <code>TOKEN</code> or <code>REQUEST</code> authorizer, this is not defined.</p>
    public let providerARNs: [String]?
    /// <p>The authorizer type. Valid values are <code>TOKEN</code> for a Lambda function using a single authorization token submitted in a custom header, <code>REQUEST</code> for a Lambda function using incoming request parameters, and <code>COGNITO_USER_POOLS</code> for using an Amazon Cognito user pool.</p>
    public let type: AuthorizerType?

    public init (
        authType: String? = nil,
        authorizerCredentials: String? = nil,
        authorizerResultTtlInSeconds: Int? = nil,
        authorizerUri: String? = nil,
        id: String? = nil,
        identitySource: String? = nil,
        identityValidationExpression: String? = nil,
        name: String? = nil,
        providerARNs: [String]? = nil,
        type: AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

/// <p>The authorizer type. Valid values are <code>TOKEN</code> for a Lambda function using a single authorization token submitted in a custom header, <code>REQUEST</code> for a Lambda function using incoming request parameters, and <code>COGNITO_USER_POOLS</code> for using an Amazon Cognito user pool.</p>
public enum AuthorizerType {
    case cognitoUserPools
    case request
    case token
    case sdkUnknown(String)
}

extension AuthorizerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthorizerType] {
        return [
            .cognitoUserPools,
            .request,
            .token,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cognitoUserPools: return "COGNITO_USER_POOLS"
        case .request: return "REQUEST"
        case .token: return "TOKEN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthorizerType(rawValue: rawValue) ?? AuthorizerType.sdkUnknown(rawValue)
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The submitted request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BasePathMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePath = basePath {
            try encodeContainer.encode(basePath, forKey: .basePath)
        }
        if let restApiId = restApiId {
            try encodeContainer.encode(restApiId, forKey: .restApiId)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension BasePathMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BasePathMapping(basePath: \(String(describing: basePath)), restApiId: \(String(describing: restApiId)), stage: \(String(describing: stage)))"}
}

/// <p>Represents the base path that callers of the API must provide as part of the URL after the domain name.</p>
///         <div class="remarks">A custom domain name plus a <code>BasePathMapping</code> specification identifies a deployed <a>RestApi</a> in a given stage of the owner <a>Account</a>.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">Use Custom Domain Names</a>
///       </div>
public struct BasePathMapping: Equatable {
    /// <p>The base path name that callers of the API must provide as part of the URL after the domain name.</p>
    public let basePath: String?
    /// <p>The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>The name of the associated stage.</p>
    public let stage: String?

    public init (
        basePath: String? = nil,
        restApiId: String? = nil,
        stage: String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

/// <p>Returns the size of the <b>CacheCluster</b>.</p>
public enum CacheClusterSize {
    case size0Point5Gb
    case size118Gb
    case size13Point5Gb
    case size1Point6Gb
    case size237Gb
    case size28Point4Gb
    case size58Point2Gb
    case size6Point1Gb
    case sdkUnknown(String)
}

extension CacheClusterSize : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CacheClusterSize] {
        return [
            .size0Point5Gb,
            .size118Gb,
            .size13Point5Gb,
            .size1Point6Gb,
            .size237Gb,
            .size28Point4Gb,
            .size58Point2Gb,
            .size6Point1Gb,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .size0Point5Gb: return "0.5"
        case .size118Gb: return "118"
        case .size13Point5Gb: return "13.5"
        case .size1Point6Gb: return "1.6"
        case .size237Gb: return "237"
        case .size28Point4Gb: return "28.4"
        case .size58Point2Gb: return "58.2"
        case .size6Point1Gb: return "6.1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CacheClusterSize(rawValue: rawValue) ?? CacheClusterSize.sdkUnknown(rawValue)
    }
}

/// <p>Returns the status of the <b>CacheCluster</b>.</p>
public enum CacheClusterStatus {
    case available
    case createInProgress
    case deleteInProgress
    case flushInProgress
    case notAvailable
    case sdkUnknown(String)
}

extension CacheClusterStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CacheClusterStatus] {
        return [
            .available,
            .createInProgress,
            .deleteInProgress,
            .flushInProgress,
            .notAvailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .flushInProgress: return "FLUSH_IN_PROGRESS"
        case .notAvailable: return "NOT_AVAILABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CacheClusterStatus(rawValue: rawValue) ?? CacheClusterStatus.sdkUnknown(rawValue)
    }
}

extension CanarySettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deploymentId
        case percentTraffic
        case stageVariableOverrides
        case useStageCache
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if percentTraffic != 0.0 {
            try encodeContainer.encode(percentTraffic, forKey: .percentTraffic)
        }
        if let stageVariableOverrides = stageVariableOverrides {
            var stageVariableOverridesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stageVariableOverrides)
            for (dictKey0, mapofstringtostring0) in stageVariableOverrides {
                try stageVariableOverridesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if useStageCache != false {
            try encodeContainer.encode(useStageCache, forKey: .useStageCache)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentTrafficDecoded = try containerValues.decode(Double.self, forKey: .percentTraffic)
        percentTraffic = percentTrafficDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let stageVariableOverridesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariableOverrides)
        var stageVariableOverridesDecoded0: [String:String]? = nil
        if let stageVariableOverridesContainer = stageVariableOverridesContainer {
            stageVariableOverridesDecoded0 = [String:String]()
            for (key0, string0) in stageVariableOverridesContainer {
                if let string0 = string0 {
                    stageVariableOverridesDecoded0?[key0] = string0
                }
            }
        }
        stageVariableOverrides = stageVariableOverridesDecoded0
        let useStageCacheDecoded = try containerValues.decode(Bool.self, forKey: .useStageCache)
        useStageCache = useStageCacheDecoded
    }
}

extension CanarySettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanarySettings(deploymentId: \(String(describing: deploymentId)), percentTraffic: \(String(describing: percentTraffic)), stageVariableOverrides: \(String(describing: stageVariableOverrides)), useStageCache: \(String(describing: useStageCache)))"}
}

/// <p>Configuration settings of a canary deployment.</p>
public struct CanarySettings: Equatable {
    /// <p>The ID of the canary deployment.</p>
    public let deploymentId: String?
    /// <p>The percent (0-100) of traffic diverted to a canary deployment.</p>
    public let percentTraffic: Double
    /// <p>Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.</p>
    public let stageVariableOverrides: [String:String]?
    /// <p>A Boolean flag to indicate whether the canary deployment uses the stage cache or not.</p>
    public let useStageCache: Bool

    public init (
        deploymentId: String? = nil,
        percentTraffic: Double = 0.0,
        stageVariableOverrides: [String:String]? = nil,
        useStageCache: Bool = false
    )
    {
        self.deploymentId = deploymentId
        self.percentTraffic = percentTraffic
        self.stageVariableOverrides = stageVariableOverrides
        self.useStageCache = useStageCache
    }
}

extension ClientCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if let pemEncodedCertificate = pemEncodedCertificate {
            try encodeContainer.encode(pemEncodedCertificate, forKey: .pemEncodedCertificate)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ClientCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientCertificate(clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), expirationDate: \(String(describing: expirationDate)), pemEncodedCertificate: \(String(describing: pemEncodedCertificate)), tags: \(String(describing: tags)))"}
}

/// <p>Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.</p>
///         <div class="remarks">Client certificates are used to authenticate an API by the backend server. To authenticate an API client (or user), use IAM roles and policies, a custom <a>Authorizer</a> or an Amazon Cognito user pool.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html">Use Client-Side Certificate</a>
///       </div>
public struct ClientCertificate: Equatable {
    /// <p>The identifier of the client certificate.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the client certificate was created.</p>
    public let createdDate: Date?
    /// <p>The description of the client certificate.</p>
    public let description: String?
    /// <p>The timestamp when the client certificate will expire.</p>
    public let expirationDate: Date?
    /// <p>The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .</p>
    public let pemEncodedCertificate: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        expirationDate: Date? = nil,
        pemEncodedCertificate: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request configuration has conflicts. For details, see the accompanying error message.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ConnectionType {
    case internet
    case vpcLink
    case sdkUnknown(String)
}

extension ConnectionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionType] {
        return [
            .internet,
            .vpcLink,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internet: return "INTERNET"
        case .vpcLink: return "VPC_LINK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
    }
}

public enum ContentHandlingStrategy {
    case convertToBinary
    case convertToText
    case sdkUnknown(String)
}

extension ContentHandlingStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContentHandlingStrategy] {
        return [
            .convertToBinary,
            .convertToText,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .convertToBinary: return "CONVERT_TO_BINARY"
        case .convertToText: return "CONVERT_TO_TEXT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContentHandlingStrategy(rawValue: rawValue) ?? ContentHandlingStrategy.sdkUnknown(rawValue)
    }
}

public struct CreateApiKeyInputBodyMiddleware: Middleware {
    public let id: String = "CreateApiKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiKeyInput>
    public typealias MOutput = OperationOutput<CreateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiKeyOutputError>
}

extension CreateApiKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiKeyInput(customerId: \(String(describing: customerId)), description: \(String(describing: description)), enabled: \(String(describing: enabled)), generateDistinctId: \(String(describing: generateDistinctId)), name: \(String(describing: name)), stageKeys: \(String(describing: stageKeys)), tags: \(String(describing: tags)), value: \(String(describing: value)))"}
}

extension CreateApiKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerId
        case description
        case enabled
        case generateDistinctId
        case name
        case stageKeys
        case tags
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerId = customerId {
            try encodeContainer.encode(customerId, forKey: .customerId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if generateDistinctId != false {
            try encodeContainer.encode(generateDistinctId, forKey: .generateDistinctId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stageKeys = stageKeys {
            var stageKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stageKeys)
            for listofstagekeys0 in stageKeys {
                try stageKeysContainer.encode(listofstagekeys0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

public struct CreateApiKeyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApiKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiKeyInput>
    public typealias MOutput = OperationOutput<CreateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiKeyOutputError>
}

public struct CreateApiKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApiKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiKeyInput>
    public typealias MOutput = OperationOutput<CreateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiKeyOutputError>
}

/// <p>Request to create an <a>ApiKey</a> resource.</p>
public struct CreateApiKeyInput: Equatable {
    /// <p>An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.</p>
    public let customerId: String?
    /// <p>The description of the <a>ApiKey</a>.</p>
    public let description: String?
    /// <p>Specifies whether the <a>ApiKey</a> can be used by callers.</p>
    public let enabled: Bool
    /// <p>Specifies whether (<code>true</code>) or not (<code>false</code>) the key identifier is distinct from the created API key value. This parameter is deprecated and should not be used.</p>
    public let generateDistinctId: Bool
    /// <p>The name of the <a>ApiKey</a>.</p>
    public let name: String?
    /// <p>DEPRECATED FOR USAGE PLANS - Specifies stages associated with the API key.</p>
    public let stageKeys: [StageKey]?
    /// <p>The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.</p>
    public let tags: [String:String]?
    /// <p>Specifies a value of the API key.</p> <!-- Why is this declared as the input to create an API key? As a form of copying an existing key value into a new API key? -->
    public let value: String?

    public init (
        customerId: String? = nil,
        description: String? = nil,
        enabled: Bool = false,
        generateDistinctId: Bool = false,
        name: String? = nil,
        stageKeys: [StageKey]? = nil,
        tags: [String:String]? = nil,
        value: String? = nil
    )
    {
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.generateDistinctId = generateDistinctId
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct CreateApiKeyInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let enabled: Bool
    public let generateDistinctId: Bool
    public let value: String?
    public let stageKeys: [StageKey]?
    public let customerId: String?
    public let tags: [String:String]?
}

extension CreateApiKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customerId
        case description
        case enabled
        case generateDistinctId
        case name
        case stageKeys
        case tags
        case value
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let generateDistinctIdDecoded = try containerValues.decode(Bool.self, forKey: .generateDistinctId)
        generateDistinctId = generateDistinctIdDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([StageKey?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[StageKey]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [StageKey]()
            for structure0 in stageKeysContainer {
                if let structure0 = structure0 {
                    stageKeysDecoded0?.append(structure0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let customerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApiKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiKeyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiKeyOutputResponse(createdDate: \(String(describing: createdDate)), customerId: \(String(describing: customerId)), description: \(String(describing: description)), enabled: \(String(describing: enabled)), id: \(String(describing: id)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), name: \(String(describing: name)), stageKeys: \(String(describing: stageKeys)), tags: \(String(describing: tags)), value: \(String(describing: value)))"}
}

extension CreateApiKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdDate = output.createdDate
            self.customerId = output.customerId
            self.description = output.description
            self.enabled = output.enabled
            self.id = output.id
            self.lastUpdatedDate = output.lastUpdatedDate
            self.name = output.name
            self.stageKeys = output.stageKeys
            self.tags = output.tags
            self.value = output.value
        } else {
            self.createdDate = nil
            self.customerId = nil
            self.description = nil
            self.enabled = false
            self.id = nil
            self.lastUpdatedDate = nil
            self.name = nil
            self.stageKeys = nil
            self.tags = nil
            self.value = nil
        }
    }
}

/// <p>A resource that can be distributed to callers for executing <a>Method</a> resources that require an API key. API keys can be mapped to any <a>Stage</a> on any <a>RestApi</a>, which indicates that the callers with the API key can make requests to that stage.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html">Use API Keys</a>
///       </div>
public struct CreateApiKeyOutputResponse: Equatable {
    /// <p>The timestamp when the API Key was created.</p>
    public let createdDate: Date?
    /// <p>An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.</p>
    public let customerId: String?
    /// <p>The description of the API Key.</p>
    public let description: String?
    /// <p>Specifies whether the API Key can be used by callers.</p>
    public let enabled: Bool
    /// <p>The identifier of the API Key.</p>
    public let id: String?
    /// <p>The timestamp when the API Key was last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>The name of the API Key.</p>
    public let name: String?
    /// <p>A list of <a>Stage</a> resources that are associated with the <a>ApiKey</a> resource.</p>
    public let stageKeys: [String]?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The value of the API Key.</p>
    public let value: String?

    public init (
        createdDate: Date? = nil,
        customerId: String? = nil,
        description: String? = nil,
        enabled: Bool = false,
        id: String? = nil,
        lastUpdatedDate: Date? = nil,
        name: String? = nil,
        stageKeys: [String]? = nil,
        tags: [String:String]? = nil,
        value: String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct CreateApiKeyOutputResponseBody: Equatable {
    public let id: String?
    public let value: String?
    public let name: String?
    public let customerId: String?
    public let description: String?
    public let enabled: Bool
    public let createdDate: Date?
    public let lastUpdatedDate: Date?
    public let stageKeys: [String]?
    public let tags: [String:String]?
}

extension CreateApiKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateAuthorizerInputBodyMiddleware: Middleware {
    public let id: String = "CreateAuthorizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuthorizerInput>
    public typealias MOutput = OperationOutput<CreateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuthorizerOutputError>
}

extension CreateAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAuthorizerInput(authType: \(String(describing: authType)), authorizerCredentials: \(String(describing: authorizerCredentials)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerUri: \(String(describing: authorizerUri)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), name: \(String(describing: name)), providerARNs: \(String(describing: providerARNs)), restApiId: \(String(describing: restApiId)), type: \(String(describing: type)))"}
}

extension CreateAuthorizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = authType {
            try encodeContainer.encode(authType, forKey: .authType)
        }
        if let authorizerCredentials = authorizerCredentials {
            try encodeContainer.encode(authorizerCredentials, forKey: .authorizerCredentials)
        }
        if let authorizerResultTtlInSeconds = authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let identitySource = identitySource {
            try encodeContainer.encode(identitySource, forKey: .identitySource)
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let providerARNs = providerARNs {
            var providerARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providerARNs)
            for listofarns0 in providerARNs {
                try providerARNsContainer.encode(listofarns0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuthorizerInput>
    public typealias MOutput = OperationOutput<CreateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuthorizerOutputError>
}

public struct CreateAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuthorizerInput>
    public typealias MOutput = OperationOutput<CreateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuthorizerOutputError>
}

/// <p>Request to add a new <a>Authorizer</a> to an existing <a>RestApi</a> resource.</p>
public struct CreateAuthorizerInput: Equatable {
    /// <p>Optional customer-defined field, used in OpenAPI imports and exports without functional impact.</p>
    public let authType: String?
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.</p>
    public let authorizerCredentials: String?
    /// <p>The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.</p>
    public let authorizerResultTtlInSeconds: Int?
    /// <p>Specifies the authorizer's Uniform Resource Identifier (URI). For <code>TOKEN</code> or <code>REQUEST</code> authorizers, this must be a well-formed Lambda function URI, for example, <code>arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations</code>. In general, the URI has this form  <code>arn:aws:apigateway:{region}:lambda:path/{service_api}</code>, where <code>{region}</code> is the same as the region hosting the Lambda function, <code>path</code> indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial <code>/</code>. For Lambda functions, this is usually of the form <code>/2015-03-31/functions/[FunctionARN]/invocations</code>.</p>
    public let authorizerUri: String?
    /// <p>The identity source for which authorization is requested. <ul><li>For a <code>TOKEN</code> or <code>COGNITO_USER_POOLS</code> authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is <code>Auth</code>, the header mapping expression is  <code>method.request.header.Auth</code>.</li><li>For the <code>REQUEST</code> authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an <code>Auth</code> header, a <code>Name</code> query string parameter are defined as identity sources, this value is <code>method.request.header.Auth, method.request.querystring.Name</code>.  These parameters will be used to derive the authorization caching key and to perform runtime validation of the <code>REQUEST</code> authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.</li></ul></p>
    public let identitySource: String?
    /// <p>A validation expression for the incoming identity token. For <code>TOKEN</code> authorizers, this value is a regular expression. For <code>COGNITO_USER_POOLS</code> authorizers, API Gateway will match the <code>aud</code> field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the <code>REQUEST</code> authorizer.</p>
    public let identityValidationExpression: String?
    /// <p>[Required] The name of the authorizer.</p>
    public let name: String?
    /// <p>A list of the Amazon Cognito user pool ARNs for the <code>COGNITO_USER_POOLS</code> authorizer. Each element is of this format: <code>arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}</code>. For a <code>TOKEN</code> or <code>REQUEST</code> authorizer, this is not defined.</p>
    public let providerARNs: [String]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The authorizer type. Valid values are <code>TOKEN</code> for a Lambda function using a single authorization token submitted in a custom header, <code>REQUEST</code> for a Lambda function using incoming request parameters, and <code>COGNITO_USER_POOLS</code> for using an Amazon Cognito user pool.</p>
    public let type: AuthorizerType?

    public init (
        authType: String? = nil,
        authorizerCredentials: String? = nil,
        authorizerResultTtlInSeconds: Int? = nil,
        authorizerUri: String? = nil,
        identitySource: String? = nil,
        identityValidationExpression: String? = nil,
        name: String? = nil,
        providerARNs: [String]? = nil,
        restApiId: String? = nil,
        type: AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.restApiId = restApiId
        self.type = type
    }
}

struct CreateAuthorizerInputBody: Equatable {
    public let name: String?
    public let type: AuthorizerType?
    public let providerARNs: [String]?
    public let authType: String?
    public let authorizerUri: String?
    public let authorizerCredentials: String?
    public let identitySource: String?
    public let identityValidationExpression: String?
    public let authorizerResultTtlInSeconds: Int?
}

extension CreateAuthorizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

extension CreateAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAuthorizerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAuthorizerOutputResponse(authType: \(String(describing: authType)), authorizerCredentials: \(String(describing: authorizerCredentials)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerUri: \(String(describing: authorizerUri)), id: \(String(describing: id)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), name: \(String(describing: name)), providerARNs: \(String(describing: providerARNs)), type: \(String(describing: type)))"}
}

extension CreateAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authType = output.authType
            self.authorizerCredentials = output.authorizerCredentials
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerUri = output.authorizerUri
            self.id = output.id
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.name = output.name
            self.providerARNs = output.providerARNs
            self.type = output.type
        } else {
            self.authType = nil
            self.authorizerCredentials = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerUri = nil
            self.id = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.name = nil
            self.providerARNs = nil
            self.type = nil
        }
    }
}

/// <p>Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html">Use Lambda Function as Authorizer</a>
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html">Use Cognito User Pool as Authorizer</a>
///       </div>
public struct CreateAuthorizerOutputResponse: Equatable {
    /// <p>Optional customer-defined field, used in OpenAPI imports and exports without functional impact.</p>
    public let authType: String?
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.</p>
    public let authorizerCredentials: String?
    /// <p>The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.</p>
    public let authorizerResultTtlInSeconds: Int?
    /// <p>Specifies the authorizer's Uniform Resource Identifier (URI). For <code>TOKEN</code> or <code>REQUEST</code> authorizers, this must be a well-formed Lambda function URI, for example, <code>arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations</code>. In general, the URI has this form  <code>arn:aws:apigateway:{region}:lambda:path/{service_api}</code>, where <code>{region}</code> is the same as the region hosting the Lambda function, <code>path</code> indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial <code>/</code>. For Lambda functions, this is usually of the form <code>/2015-03-31/functions/[FunctionARN]/invocations</code>.</p>
    public let authorizerUri: String?
    /// <p>The identifier for the authorizer resource.</p>
    public let id: String?
    /// <p>The identity source for which authorization is requested. <ul><li>For a <code>TOKEN</code> or <code>COGNITO_USER_POOLS</code> authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is <code>Auth</code>, the header mapping expression is  <code>method.request.header.Auth</code>.</li><li>For the <code>REQUEST</code> authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an <code>Auth</code> header, a <code>Name</code> query string parameter are defined as identity sources, this value is <code>method.request.header.Auth, method.request.querystring.Name</code>.  These parameters will be used to derive the authorization caching key and to perform runtime validation of the <code>REQUEST</code> authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.</li></ul></p>
    public let identitySource: String?
    /// <p>A validation expression for the incoming identity token. For <code>TOKEN</code> authorizers, this value is a regular expression. For <code>COGNITO_USER_POOLS</code> authorizers, API Gateway will match the <code>aud</code> field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the <code>REQUEST</code> authorizer.</p>
    public let identityValidationExpression: String?
    /// <p>[Required] The name of the authorizer.</p>
    public let name: String?
    /// <p>A list of the Amazon Cognito user pool ARNs for the <code>COGNITO_USER_POOLS</code> authorizer. Each element is of this format: <code>arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}</code>. For a <code>TOKEN</code> or <code>REQUEST</code> authorizer, this is not defined.</p>
    public let providerARNs: [String]?
    /// <p>The authorizer type. Valid values are <code>TOKEN</code> for a Lambda function using a single authorization token submitted in a custom header, <code>REQUEST</code> for a Lambda function using incoming request parameters, and <code>COGNITO_USER_POOLS</code> for using an Amazon Cognito user pool.</p>
    public let type: AuthorizerType?

    public init (
        authType: String? = nil,
        authorizerCredentials: String? = nil,
        authorizerResultTtlInSeconds: Int? = nil,
        authorizerUri: String? = nil,
        id: String? = nil,
        identitySource: String? = nil,
        identityValidationExpression: String? = nil,
        name: String? = nil,
        providerARNs: [String]? = nil,
        type: AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

struct CreateAuthorizerOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let type: AuthorizerType?
    public let providerARNs: [String]?
    public let authType: String?
    public let authorizerUri: String?
    public let authorizerCredentials: String?
    public let identitySource: String?
    public let identityValidationExpression: String?
    public let authorizerResultTtlInSeconds: Int?
}

extension CreateAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

public struct CreateBasePathMappingInputBodyMiddleware: Middleware {
    public let id: String = "CreateBasePathMappingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBasePathMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBasePathMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBasePathMappingInput>
    public typealias MOutput = OperationOutput<CreateBasePathMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBasePathMappingOutputError>
}

extension CreateBasePathMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBasePathMappingInput(basePath: \(String(describing: basePath)), domainName: \(String(describing: domainName)), restApiId: \(String(describing: restApiId)), stage: \(String(describing: stage)))"}
}

extension CreateBasePathMappingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePath = basePath {
            try encodeContainer.encode(basePath, forKey: .basePath)
        }
        if let restApiId = restApiId {
            try encodeContainer.encode(restApiId, forKey: .restApiId)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }
}

public struct CreateBasePathMappingInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBasePathMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBasePathMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBasePathMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBasePathMappingInput>
    public typealias MOutput = OperationOutput<CreateBasePathMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBasePathMappingOutputError>
}

public struct CreateBasePathMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBasePathMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBasePathMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBasePathMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBasePathMappingInput>
    public typealias MOutput = OperationOutput<CreateBasePathMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBasePathMappingOutputError>
}

/// <p>Requests API Gateway to create a new <a>BasePathMapping</a> resource.</p>
public struct CreateBasePathMappingInput: Equatable {
    /// <p>The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify a base path name after the domain name.</p>
    public let basePath: String?
    /// <p>[Required] The domain name of the <a>BasePathMapping</a> resource to create.</p>
    public let domainName: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>The name of the API's stage that you want to use for this mapping. Specify '(none)' if you want callers to explicitly specify the stage name after any base path name.</p>
    public let stage: String?

    public init (
        basePath: String? = nil,
        domainName: String? = nil,
        restApiId: String? = nil,
        stage: String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct CreateBasePathMappingInputBody: Equatable {
    public let basePath: String?
    public let restApiId: String?
    public let stage: String?
}

extension CreateBasePathMappingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension CreateBasePathMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBasePathMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBasePathMappingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBasePathMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBasePathMappingOutputResponse(basePath: \(String(describing: basePath)), restApiId: \(String(describing: restApiId)), stage: \(String(describing: stage)))"}
}

extension CreateBasePathMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBasePathMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.basePath = output.basePath
            self.restApiId = output.restApiId
            self.stage = output.stage
        } else {
            self.basePath = nil
            self.restApiId = nil
            self.stage = nil
        }
    }
}

/// <p>Represents the base path that callers of the API must provide as part of the URL after the domain name.</p>
///         <div class="remarks">A custom domain name plus a <code>BasePathMapping</code> specification identifies a deployed <a>RestApi</a> in a given stage of the owner <a>Account</a>.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">Use Custom Domain Names</a>
///       </div>
public struct CreateBasePathMappingOutputResponse: Equatable {
    /// <p>The base path name that callers of the API must provide as part of the URL after the domain name.</p>
    public let basePath: String?
    /// <p>The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>The name of the associated stage.</p>
    public let stage: String?

    public init (
        basePath: String? = nil,
        restApiId: String? = nil,
        stage: String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct CreateBasePathMappingOutputResponseBody: Equatable {
    public let basePath: String?
    public let restApiId: String?
    public let stage: String?
}

extension CreateBasePathMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

public struct CreateDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

extension CreateDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentInput(cacheClusterEnabled: \(String(describing: cacheClusterEnabled)), cacheClusterSize: \(String(describing: cacheClusterSize)), canarySettings: \(String(describing: canarySettings)), description: \(String(describing: description)), restApiId: \(String(describing: restApiId)), stageDescription: \(String(describing: stageDescription)), stageName: \(String(describing: stageName)), tracingEnabled: \(String(describing: tracingEnabled)), variables: \(String(describing: variables)))"}
}

extension CreateDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case description
        case stageDescription
        case stageName
        case tracingEnabled
        case variables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheClusterEnabled = cacheClusterEnabled {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize.rawValue, forKey: .cacheClusterSize)
        }
        if let canarySettings = canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let stageDescription = stageDescription {
            try encodeContainer.encode(stageDescription, forKey: .stageDescription)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tracingEnabled = tracingEnabled {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .variables)
            for (dictKey0, mapofstringtostring0) in variables {
                try variablesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

/// <p>Requests API Gateway to create a <a>Deployment</a> resource.</p>
public struct CreateDeploymentInput: Equatable {
    /// <p>Enables a cache cluster for the <a>Stage</a> resource specified in the input.</p>
    public let cacheClusterEnabled: Bool?
    /// <p>Specifies the cache cluster size for the <a>Stage</a> resource specified in the input, if a cache cluster is enabled.</p>
    public let cacheClusterSize: CacheClusterSize?
    /// <p>The input configuration for the canary deployment when the deployment is a canary release deployment. </p>
    public let canarySettings: DeploymentCanarySettings?
    /// <p>The description for the <a>Deployment</a> resource to create.</p>
    public let description: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>The description of the <a>Stage</a> resource for the <a>Deployment</a> resource to create.</p>
    public let stageDescription: String?
    /// <p>The name of the <a>Stage</a> resource for the <a>Deployment</a> resource to create.</p>
    public let stageName: String?
    /// <p>Specifies whether active tracing with X-ray is enabled for the <a>Stage</a>.</p>
    public let tracingEnabled: Bool?
    /// <p>A map that defines the stage variables for the <a>Stage</a> resource that is associated
    ///           with the new deployment. Variable names can have alphanumeric and underscore characters, and the values
    ///           must match <code>[A-Za-z0-9-._~:/?#&=,]+</code>.</p>
    public let variables: [String:String]?

    public init (
        cacheClusterEnabled: Bool? = nil,
        cacheClusterSize: CacheClusterSize? = nil,
        canarySettings: DeploymentCanarySettings? = nil,
        description: String? = nil,
        restApiId: String? = nil,
        stageDescription: String? = nil,
        stageName: String? = nil,
        tracingEnabled: Bool? = nil,
        variables: [String:String]? = nil
    )
    {
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.canarySettings = canarySettings
        self.description = description
        self.restApiId = restApiId
        self.stageDescription = stageDescription
        self.stageName = stageName
        self.tracingEnabled = tracingEnabled
        self.variables = variables
    }
}

struct CreateDeploymentInputBody: Equatable {
    public let stageName: String?
    public let stageDescription: String?
    public let description: String?
    public let cacheClusterEnabled: Bool?
    public let cacheClusterSize: CacheClusterSize?
    public let variables: [String:String]?
    public let canarySettings: DeploymentCanarySettings?
    public let tracingEnabled: Bool?
}

extension CreateDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case description
        case stageDescription
        case stageName
        case tracingEnabled
        case variables
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageDescription)
        stageDescription = stageDescriptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let canarySettingsDecoded = try containerValues.decodeIfPresent(DeploymentCanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
    }
}

extension CreateDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentOutputResponse(apiSummary: \(String(describing: apiSummary)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), id: \(String(describing: id)))"}
}

extension CreateDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiSummary = output.apiSummary
            self.createdDate = output.createdDate
            self.description = output.description
            self.id = output.id
        } else {
            self.apiSummary = nil
            self.createdDate = nil
            self.description = nil
            self.id = nil
        }
    }
}

/// <p>An immutable representation of a <a>RestApi</a> resource that can be called by users using <a>Stages</a>. A deployment must be associated with a <a>Stage</a> for it to be callable over the Internet.</p>
///         <div class="remarks">To create a deployment, call <code>POST</code> on the <a>Deployments</a> resource of a <a>RestApi</a>.
///             To view, update, or delete a deployment, call <code>GET</code>, <code>PATCH</code>, or <code>DELETE</code> on the specified deployment resource (<code>/restapis/{restapi_id}/deployments/{deployment_id}</code>).</div>
///         <div class="seeAlso"><a>RestApi</a>, <a>Deployments</a>, <a>Stage</a>,
///             <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html">AWS CLI</a>,
///             <a href="https://aws.amazon.com/tools/">AWS SDKs</a>
///         </div>
public struct CreateDeploymentOutputResponse: Equatable {
    /// <p>A summary of the <a>RestApi</a> at the date and time that the deployment resource was created.</p>
    public let apiSummary: [String:[String:MethodSnapshot]]?
    /// <p>The date and time that the deployment resource was created.</p>
    public let createdDate: Date?
    /// <p>The description for the deployment resource.</p>
    public let description: String?
    /// <p>The identifier for the deployment resource.</p>
    public let id: String?

    public init (
        apiSummary: [String:[String:MethodSnapshot]]? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        id: String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

struct CreateDeploymentOutputResponseBody: Equatable {
    public let id: String?
    public let description: String?
    public let createdDate: Date?
    public let apiSummary: [String:[String:MethodSnapshot]]?
}

extension CreateDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([String: [String: MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [String:[String:MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [String:[String:MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [String: MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [String: MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

public struct CreateDocumentationPartInputBodyMiddleware: Middleware {
    public let id: String = "CreateDocumentationPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentationPartInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentationPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentationPartInput>
    public typealias MOutput = OperationOutput<CreateDocumentationPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentationPartOutputError>
}

extension CreateDocumentationPartInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDocumentationPartInput(location: \(String(describing: location)), properties: \(String(describing: properties)), restApiId: \(String(describing: restApiId)))"}
}

extension CreateDocumentationPartInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case location
        case properties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }
}

public struct CreateDocumentationPartInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDocumentationPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentationPartInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentationPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentationPartInput>
    public typealias MOutput = OperationOutput<CreateDocumentationPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentationPartOutputError>
}

public struct CreateDocumentationPartInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDocumentationPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentationPartInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentationPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentationPartInput>
    public typealias MOutput = OperationOutput<CreateDocumentationPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentationPartOutputError>
}

/// <p>Creates a new documentation part of a given API.</p>
public struct CreateDocumentationPartInput: Equatable {
    /// <p>[Required] The location of the targeted API entity of the to-be-created documentation part.</p>
    public let location: DocumentationPartLocation?
    /// <p>[Required] The new documentation content map of the targeted API entity. Enclosed key-value pairs are API-specific, but only OpenAPI-compliant key-value pairs can be exported and, hence, published.</p>
    public let properties: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        location: DocumentationPartLocation? = nil,
        properties: String? = nil,
        restApiId: String? = nil
    )
    {
        self.location = location
        self.properties = properties
        self.restApiId = restApiId
    }
}

struct CreateDocumentationPartInputBody: Equatable {
    public let location: DocumentationPartLocation?
    public let properties: String?
}

extension CreateDocumentationPartInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case location
        case properties
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension CreateDocumentationPartOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDocumentationPartOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDocumentationPartOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDocumentationPartOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDocumentationPartOutputResponse(id: \(String(describing: id)), location: \(String(describing: location)), properties: \(String(describing: properties)))"}
}

extension CreateDocumentationPartOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDocumentationPartOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.location = output.location
            self.properties = output.properties
        } else {
            self.id = nil
            self.location = nil
            self.properties = nil
        }
    }
}

/// <p>A documentation part for a targeted API entity.</p>
///     <div class="remarks">
///       <p>A documentation part consists of a content map (<code>properties</code>) and a target (<code>location</code>). The target specifies an API entity to which the documentation content applies. The supported API entity types are <code>API</code>, <code>AUTHORIZER</code>, <code>MODEL</code>, <code>RESOURCE</code>, <code>METHOD</code>, <code>PATH_PARAMETER</code>, <code>QUERY_PARAMETER</code>, <code>REQUEST_HEADER</code>, <code>REQUEST_BODY</code>, <code>RESPONSE</code>, <code>RESPONSE_HEADER</code>, and <code>RESPONSE_BODY</code>. Valid <code>location</code> fields depend on the API entity type. All valid fields are not required.</p>
///       <p>The content map is a JSON string of API-specific key-value pairs. Although an API can use any shape for the content map, only the OpenAPI-compliant documentation fields will be injected into the associated API entity definition in the exported OpenAPI definition file.</p></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a>DocumentationParts</a>
///     </div>
public struct CreateDocumentationPartOutputResponse: Equatable {
    /// <p>The <a>DocumentationPart</a> identifier, generated by API Gateway when the <code>DocumentationPart</code> is created.</p>
    public let id: String?
    /// <p>The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.</p>
    public let location: DocumentationPartLocation?
    /// <p>A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., <code>"{ \"description\": \"The API does ...\" }"</code>.  Only OpenAPI-compliant documentation-related fields from the <literal>properties</literal> map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of <code>x-amazon-apigateway-documentation</code>.</p>
    public let properties: String?

    public init (
        id: String? = nil,
        location: DocumentationPartLocation? = nil,
        properties: String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

struct CreateDocumentationPartOutputResponseBody: Equatable {
    public let id: String?
    public let location: DocumentationPartLocation?
    public let properties: String?
}

extension CreateDocumentationPartOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case location
        case properties
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

public struct CreateDocumentationVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateDocumentationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentationVersionInput>
    public typealias MOutput = OperationOutput<CreateDocumentationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentationVersionOutputError>
}

extension CreateDocumentationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDocumentationVersionInput(description: \(String(describing: description)), documentationVersion: \(String(describing: documentationVersion)), restApiId: \(String(describing: restApiId)), stageName: \(String(describing: stageName)))"}
}

extension CreateDocumentationVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case documentationVersion
        case stageName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }
}

public struct CreateDocumentationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDocumentationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentationVersionInput>
    public typealias MOutput = OperationOutput<CreateDocumentationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentationVersionOutputError>
}

public struct CreateDocumentationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDocumentationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentationVersionInput>
    public typealias MOutput = OperationOutput<CreateDocumentationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentationVersionOutputError>
}

/// <p>Creates a new documentation version of a given API.</p>
public struct CreateDocumentationVersionInput: Equatable {
    /// <p>A description about the new documentation snapshot.</p>
    public let description: String?
    /// <p>[Required] The version identifier of the new snapshot.</p>
    public let documentationVersion: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>The stage name to be associated with the new documentation snapshot.</p>
    public let stageName: String?

    public init (
        description: String? = nil,
        documentationVersion: String? = nil,
        restApiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.description = description
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct CreateDocumentationVersionInputBody: Equatable {
    public let documentationVersion: String?
    public let stageName: String?
    public let description: String?
}

extension CreateDocumentationVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case documentationVersion
        case stageName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateDocumentationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDocumentationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDocumentationVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDocumentationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDocumentationVersionOutputResponse(createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), version: \(String(describing: version)))"}
}

extension CreateDocumentationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDocumentationVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdDate = output.createdDate
            self.description = output.description
            self.version = output.version
        } else {
            self.createdDate = nil
            self.description = nil
            self.version = nil
        }
    }
}

/// <p>A snapshot of the documentation of an API.</p>
///     <div class="remarks"><p>Publishing API documentation involves creating a documentation version associated with an API stage and exporting the versioned documentation to an external (e.g., OpenAPI) file.</p></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a>DocumentationPart</a>, <a>DocumentationVersions</a>
///     </div>
public struct CreateDocumentationVersionOutputResponse: Equatable {
    /// <p>The date when the API documentation snapshot is created.</p>
    public let createdDate: Date?
    /// <p>The description of the API documentation snapshot.</p>
    public let description: String?
    /// <p>The version identifier of the API documentation snapshot.</p>
    public let version: String?

    public init (
        createdDate: Date? = nil,
        description: String? = nil,
        version: String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

struct CreateDocumentationVersionOutputResponseBody: Equatable {
    public let version: String?
    public let createdDate: Date?
    public let description: String?
}

extension CreateDocumentationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdDate
        case description
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct CreateDomainNameInputBodyMiddleware: Middleware {
    public let id: String = "CreateDomainNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainNameInput>
    public typealias MOutput = OperationOutput<CreateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainNameOutputError>
}

extension CreateDomainNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainNameInput(certificateArn: \(String(describing: certificateArn)), certificateBody: \(String(describing: certificateBody)), certificateChain: \(String(describing: certificateChain)), certificateName: \(String(describing: certificateName)), certificatePrivateKey: \(String(describing: certificatePrivateKey)), domainName: \(String(describing: domainName)), endpointConfiguration: \(String(describing: endpointConfiguration)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)), regionalCertificateArn: \(String(describing: regionalCertificateArn)), regionalCertificateName: \(String(describing: regionalCertificateName)), securityPolicy: \(String(describing: securityPolicy)), tags: \(String(describing: tags)))"}
}

extension CreateDomainNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateBody
        case certificateChain
        case certificateName
        case certificatePrivateKey
        case domainName
        case endpointConfiguration
        case mutualTlsAuthentication
        case regionalCertificateArn
        case regionalCertificateName
        case securityPolicy
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateBody = certificateBody {
            try encodeContainer.encode(certificateBody, forKey: .certificateBody)
        }
        if let certificateChain = certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let certificateName = certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let certificatePrivateKey = certificatePrivateKey {
            try encodeContainer.encode(certificatePrivateKey, forKey: .certificatePrivateKey)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let endpointConfiguration = endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let mutualTlsAuthentication = mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let regionalCertificateArn = regionalCertificateArn {
            try encodeContainer.encode(regionalCertificateArn, forKey: .regionalCertificateArn)
        }
        if let regionalCertificateName = regionalCertificateName {
            try encodeContainer.encode(regionalCertificateName, forKey: .regionalCertificateName)
        }
        if let securityPolicy = securityPolicy {
            try encodeContainer.encode(securityPolicy.rawValue, forKey: .securityPolicy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDomainNameInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDomainNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainNameInput>
    public typealias MOutput = OperationOutput<CreateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainNameOutputError>
}

public struct CreateDomainNameInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDomainNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainNameInput>
    public typealias MOutput = OperationOutput<CreateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainNameOutputError>
}

/// <p>A request to create a new domain name.</p>
public struct CreateDomainNameInput: Equatable {
    /// <p>The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.</p>
    public let certificateArn: String?
    /// <p>[Deprecated] The body of the server certificate that will be used by edge-optimized endpoint for this domain name provided by your certificate authority.</p>
    public let certificateBody: String?
    /// <p>[Deprecated] The intermediate certificates and optionally the root certificate, one after the other without any blank lines, used by an edge-optimized endpoint for this domain name. If you include the root certificate, your certificate chain must start with intermediate certificates and end with the root certificate. Use the intermediate certificates that were provided by your certificate authority. Do not include any intermediaries that are not in the chain of trust path.</p>
    public let certificateChain: String?
    /// <p>The user-friendly name of the certificate that will be used by edge-optimized endpoint for this domain name.</p>
    public let certificateName: String?
    /// <p>[Deprecated] Your edge-optimized endpoint's domain name certificate's private key.</p>
    public let certificatePrivateKey: String?
    /// <p>[Required] The name of the <a>DomainName</a> resource.</p>
    public let domainName: String?
    /// <p>The endpoint configuration of this <a>DomainName</a> showing the endpoint types of the domain name.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your custom domain name.</p>
    public let mutualTlsAuthentication: MutualTlsAuthenticationInput?
    /// <p>The reference to an AWS-managed certificate that will be used by regional endpoint for this domain name. AWS Certificate Manager is the only supported source.</p>
    public let regionalCertificateArn: String?
    /// <p>The user-friendly name of the certificate that will be used by regional endpoint for this domain name.</p>
    public let regionalCertificateName: String?
    /// <p>The Transport Layer Security (TLS) version + cipher suite for this <a>DomainName</a>. The valid values are <code>TLS_1_0</code> and <code>TLS_1_2</code>.</p>
    public let securityPolicy: SecurityPolicy?
    /// <p>The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.</p>
    public let tags: [String:String]?

    public init (
        certificateArn: String? = nil,
        certificateBody: String? = nil,
        certificateChain: String? = nil,
        certificateName: String? = nil,
        certificatePrivateKey: String? = nil,
        domainName: String? = nil,
        endpointConfiguration: EndpointConfiguration? = nil,
        mutualTlsAuthentication: MutualTlsAuthenticationInput? = nil,
        regionalCertificateArn: String? = nil,
        regionalCertificateName: String? = nil,
        securityPolicy: SecurityPolicy? = nil,
        tags: [String:String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateBody = certificateBody
        self.certificateChain = certificateChain
        self.certificateName = certificateName
        self.certificatePrivateKey = certificatePrivateKey
        self.domainName = domainName
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct CreateDomainNameInputBody: Equatable {
    public let domainName: String?
    public let certificateName: String?
    public let certificateBody: String?
    public let certificatePrivateKey: String?
    public let certificateChain: String?
    public let certificateArn: String?
    public let regionalCertificateName: String?
    public let regionalCertificateArn: String?
    public let endpointConfiguration: EndpointConfiguration?
    public let tags: [String:String]?
    public let securityPolicy: SecurityPolicy?
    public let mutualTlsAuthentication: MutualTlsAuthenticationInput?
}

extension CreateDomainNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateBody
        case certificateChain
        case certificateName
        case certificatePrivateKey
        case domainName
        case endpointConfiguration
        case mutualTlsAuthentication
        case regionalCertificateArn
        case regionalCertificateName
        case securityPolicy
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let certificatePrivateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePrivateKey)
        certificatePrivateKey = certificatePrivateKeyDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let securityPolicyDecoded = try containerValues.decodeIfPresent(SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthenticationInput.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
    }
}

extension CreateDomainNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainNameOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainNameOutputResponse(certificateArn: \(String(describing: certificateArn)), certificateName: \(String(describing: certificateName)), certificateUploadDate: \(String(describing: certificateUploadDate)), distributionDomainName: \(String(describing: distributionDomainName)), distributionHostedZoneId: \(String(describing: distributionHostedZoneId)), domainName: \(String(describing: domainName)), domainNameStatus: \(String(describing: domainNameStatus)), domainNameStatusMessage: \(String(describing: domainNameStatusMessage)), endpointConfiguration: \(String(describing: endpointConfiguration)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)), regionalCertificateArn: \(String(describing: regionalCertificateArn)), regionalCertificateName: \(String(describing: regionalCertificateName)), regionalDomainName: \(String(describing: regionalDomainName)), regionalHostedZoneId: \(String(describing: regionalHostedZoneId)), securityPolicy: \(String(describing: securityPolicy)), tags: \(String(describing: tags)))"}
}

extension CreateDomainNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateArn = output.certificateArn
            self.certificateName = output.certificateName
            self.certificateUploadDate = output.certificateUploadDate
            self.distributionDomainName = output.distributionDomainName
            self.distributionHostedZoneId = output.distributionHostedZoneId
            self.domainName = output.domainName
            self.domainNameStatus = output.domainNameStatus
            self.domainNameStatusMessage = output.domainNameStatusMessage
            self.endpointConfiguration = output.endpointConfiguration
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.regionalCertificateArn = output.regionalCertificateArn
            self.regionalCertificateName = output.regionalCertificateName
            self.regionalDomainName = output.regionalDomainName
            self.regionalHostedZoneId = output.regionalHostedZoneId
            self.securityPolicy = output.securityPolicy
            self.tags = output.tags
        } else {
            self.certificateArn = nil
            self.certificateName = nil
            self.certificateUploadDate = nil
            self.distributionDomainName = nil
            self.distributionHostedZoneId = nil
            self.domainName = nil
            self.domainNameStatus = nil
            self.domainNameStatusMessage = nil
            self.endpointConfiguration = nil
            self.mutualTlsAuthentication = nil
            self.regionalCertificateArn = nil
            self.regionalCertificateName = nil
            self.regionalDomainName = nil
            self.regionalHostedZoneId = nil
            self.securityPolicy = nil
            self.tags = nil
        }
    }
}

/// <p>Represents a custom domain name as a user-friendly host name of an API (<a>RestApi</a>).</p>
///         <div class="Remarks">
///             <p>When you deploy an API, API Gateway creates a default host name for the API. This default API host name is of the <code>{restapi-id}.execute-api.{region}.amazonaws.com</code> format. With the default host name, you can access the API's root resource with the URL of <code>https://{restapi-id}.execute-api.{region}.amazonaws.com/{stage}/</code>. When you set up a custom domain name of <code>apis.example.com</code> for this API, you can then access the same resource using the URL of the <code>https://apis.examples.com/myApi</code>, where <code>myApi</code> is the base path mapping (<a>BasePathMapping</a>) of your API under the custom domain name.
///             </p>
///         </div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">Set a Custom Host Name for an API</a>
///       </div>
public struct CreateDomainNameOutputResponse: Equatable {
    /// <p>The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.</p>
    public let certificateArn: String?
    /// <p>The name of the certificate that will be used by edge-optimized endpoint for this domain name.</p>
    public let certificateName: String?
    /// <p>The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.</p>
    public let certificateUploadDate: Date?
    /// <p>The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the <a target="_blank" href="https://aws.amazon.com/documentation/cloudfront/">Amazon CloudFront documentation</a>.</p>
    public let distributionDomainName: String?
    /// <p>The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is <code>Z2FDTNDATAQYW2</code> for all the regions. For more information, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html">Set up a Regional Custom Domain Name</a> and <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region">AWS Regions and Endpoints for API Gateway</a>. </p>
    public let distributionHostedZoneId: String?
    /// <p>The custom domain name as an API host name, for example, <code>my-api.example.com</code>.</p>
    public let domainName: String?
    /// <p>The status of the <a>DomainName</a> migration. The valid values are <code>AVAILABLE</code> and <code>UPDATING</code>. If the status is <code>UPDATING</code>, the domain cannot be modified further until the existing operation is complete. If it is <code>AVAILABLE</code>, the domain can be updated.</p>
    public let domainNameStatus: DomainNameStatus?
    /// <p>An optional text message containing detailed information about status of the <a>DomainName</a> migration.</p>
    public let domainNameStatusMessage: String?
    /// <p>The endpoint configuration of this <a>DomainName</a> showing the endpoint types of the domain name.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.</p>
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    /// <p>The reference to an AWS-managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.</p>
    public let regionalCertificateArn: String?
    /// <p>The name of the certificate that will be used for validating the regional domain name.</p>
    public let regionalCertificateName: String?
    /// <p>The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.</p>
    public let regionalDomainName: String?
    /// <p>The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html">Set up a Regional Custom Domain Name</a> and  <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region">AWS Regions and Endpoints for API Gateway</a>. </p>
    public let regionalHostedZoneId: String?
    /// <p>The Transport Layer Security (TLS) version + cipher suite for this <a>DomainName</a>. The valid values are <code>TLS_1_0</code> and <code>TLS_1_2</code>.</p>
    public let securityPolicy: SecurityPolicy?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        certificateArn: String? = nil,
        certificateName: String? = nil,
        certificateUploadDate: Date? = nil,
        distributionDomainName: String? = nil,
        distributionHostedZoneId: String? = nil,
        domainName: String? = nil,
        domainNameStatus: DomainNameStatus? = nil,
        domainNameStatusMessage: String? = nil,
        endpointConfiguration: EndpointConfiguration? = nil,
        mutualTlsAuthentication: MutualTlsAuthentication? = nil,
        regionalCertificateArn: String? = nil,
        regionalCertificateName: String? = nil,
        regionalDomainName: String? = nil,
        regionalHostedZoneId: String? = nil,
        securityPolicy: SecurityPolicy? = nil,
        tags: [String:String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct CreateDomainNameOutputResponseBody: Equatable {
    public let domainName: String?
    public let certificateName: String?
    public let certificateArn: String?
    public let certificateUploadDate: Date?
    public let regionalDomainName: String?
    public let regionalHostedZoneId: String?
    public let regionalCertificateName: String?
    public let regionalCertificateArn: String?
    public let distributionDomainName: String?
    public let distributionHostedZoneId: String?
    public let endpointConfiguration: EndpointConfiguration?
    public let domainNameStatus: DomainNameStatus?
    public let domainNameStatusMessage: String?
    public let securityPolicy: SecurityPolicy?
    public let tags: [String:String]?
    public let mutualTlsAuthentication: MutualTlsAuthentication?
}

extension CreateDomainNameOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
    }
}

public struct CreateModelInputBodyMiddleware: Middleware {
    public let id: String = "CreateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

extension CreateModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelInput(contentType: \(String(describing: contentType)), description: \(String(describing: description)), name: \(String(describing: name)), restApiId: \(String(describing: restApiId)), schema: \(String(describing: schema)))"}
}

extension CreateModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType
        case description
        case name
        case schema
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

public struct CreateModelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

public struct CreateModelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

/// <p>Request to add a new <a>Model</a> to an existing <a>RestApi</a> resource.</p>
public struct CreateModelInput: Equatable {
    /// <p>[Required] The content-type for the model.</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>[Required] The name of the model. Must be alphanumeric.</p>
    public let name: String?
    /// <p>[Required] The <a>RestApi</a> identifier under which the <a>Model</a> will be created.</p>
    public let restApiId: String?
    /// <p>The schema for the model. For <code>application/json</code> models, this should be <a target="_blank" href="https://tools.ietf.org/html/draft-zyp-json-schema-04">JSON schema draft 4</a> model.</p>
    public let schema: String?

    public init (
        contentType: String? = nil,
        description: String? = nil,
        name: String? = nil,
        restApiId: String? = nil,
        schema: String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.name = name
        self.restApiId = restApiId
        self.schema = schema
    }
}

struct CreateModelInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let schema: String?
    public let contentType: String?
}

extension CreateModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentType
        case description
        case name
        case schema
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CreateModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelOutputResponse(contentType: \(String(describing: contentType)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

extension CreateModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentType = output.contentType
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.schema = nil
        }
    }
}

/// <p>Represents the data structure of a method's request or response payload.</p>
///       <div class="remarks">
///         <p>A request model defines the data structure of the client-supplied request payload. A response model defines the data structure of the response payload returned by the back end. Although not required, models are useful for mapping payloads between the front end and back end.</p>
///         <p>A model is used for generating an API's SDK, validating the input request body, and creating a skeletal mapping template.</p>
///       </div>
///       <div class="seeAlso">
///         <a>Method</a>, <a>MethodResponse</a>, <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html">Models and Mappings</a>
///       </div>
public struct CreateModelOutputResponse: Equatable {
    /// <p>The content-type for the model.</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>The identifier for the model resource.</p>
    public let id: String?
    /// <p>The name of the model. Must be an alphanumeric string.</p>
    public let name: String?
    /// <p>The schema for the model. For <code>application/json</code> models, this should be <a target="_blank" href="https://tools.ietf.org/html/draft-zyp-json-schema-04">JSON schema draft 4</a> model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.</p>
    public let schema: String?

    public init (
        contentType: String? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

struct CreateModelOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let schema: String?
    public let contentType: String?
}

extension CreateModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

public struct CreateRequestValidatorInputBodyMiddleware: Middleware {
    public let id: String = "CreateRequestValidatorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRequestValidatorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRequestValidatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRequestValidatorInput>
    public typealias MOutput = OperationOutput<CreateRequestValidatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRequestValidatorOutputError>
}

extension CreateRequestValidatorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRequestValidatorInput(name: \(String(describing: name)), restApiId: \(String(describing: restApiId)), validateRequestBody: \(String(describing: validateRequestBody)), validateRequestParameters: \(String(describing: validateRequestParameters)))"}
}

extension CreateRequestValidatorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if validateRequestBody != false {
            try encodeContainer.encode(validateRequestBody, forKey: .validateRequestBody)
        }
        if validateRequestParameters != false {
            try encodeContainer.encode(validateRequestParameters, forKey: .validateRequestParameters)
        }
    }
}

public struct CreateRequestValidatorInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRequestValidatorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRequestValidatorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRequestValidatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRequestValidatorInput>
    public typealias MOutput = OperationOutput<CreateRequestValidatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRequestValidatorOutputError>
}

public struct CreateRequestValidatorInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRequestValidatorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRequestValidatorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRequestValidatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRequestValidatorInput>
    public typealias MOutput = OperationOutput<CreateRequestValidatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRequestValidatorOutputError>
}

/// <p>Creates a <a>RequestValidator</a> of a given <a>RestApi</a>.</p>
public struct CreateRequestValidatorInput: Equatable {
    /// <p>The name of the to-be-created <a>RequestValidator</a>.</p>
    public let name: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>A Boolean flag to indicate whether to validate request body according to the configured model schema for the method (<code>true</code>) or not (<code>false</code>).</p>
    public let validateRequestBody: Bool
    /// <p>A Boolean flag to indicate whether to validate request parameters, <code>true</code>, or not <code>false</code>.</p>
    public let validateRequestParameters: Bool

    public init (
        name: String? = nil,
        restApiId: String? = nil,
        validateRequestBody: Bool = false,
        validateRequestParameters: Bool = false
    )
    {
        self.name = name
        self.restApiId = restApiId
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct CreateRequestValidatorInputBody: Equatable {
    public let name: String?
    public let validateRequestBody: Bool
    public let validateRequestParameters: Bool
}

extension CreateRequestValidatorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decode(Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decode(Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

extension CreateRequestValidatorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRequestValidatorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRequestValidatorOutputError: Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRequestValidatorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRequestValidatorOutputResponse(id: \(String(describing: id)), name: \(String(describing: name)), validateRequestBody: \(String(describing: validateRequestBody)), validateRequestParameters: \(String(describing: validateRequestParameters)))"}
}

extension CreateRequestValidatorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRequestValidatorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.name = output.name
            self.validateRequestBody = output.validateRequestBody
            self.validateRequestParameters = output.validateRequestParameters
        } else {
            self.id = nil
            self.name = nil
            self.validateRequestBody = false
            self.validateRequestParameters = false
        }
    }
}

/// <p>A set of validation rules for incoming <a>Method</a> requests.</p>
///         <div class="remarks">
///           <p>In OpenAPI, a <a>RequestValidator</a> of an API is defined by the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.requestValidator.html">x-amazon-apigateway-request-validators.requestValidator</a> object. It the referenced using the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validator">x-amazon-apigateway-request-validator</a> property.</p>
///         </div>
///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html">Enable Basic Request Validation in API Gateway</a></div>
public struct CreateRequestValidatorOutputResponse: Equatable {
    /// <p>The identifier of this <a>RequestValidator</a>.</p>
    public let id: String?
    /// <p>The name of this <a>RequestValidator</a></p>
    public let name: String?
    /// <p>A Boolean flag to indicate whether to validate a request body according to the configured <a>Model</a> schema.</p>
    public let validateRequestBody: Bool
    /// <p>A Boolean flag to indicate whether to validate request parameters (<code>true</code>) or not (<code>false</code>).</p>
    public let validateRequestParameters: Bool

    public init (
        id: String? = nil,
        name: String? = nil,
        validateRequestBody: Bool = false,
        validateRequestParameters: Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct CreateRequestValidatorOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let validateRequestBody: Bool
    public let validateRequestParameters: Bool
}

extension CreateRequestValidatorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decode(Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decode(Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

public struct CreateResourceInputBodyMiddleware: Middleware {
    public let id: String = "CreateResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceInput>
    public typealias MOutput = OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceOutputError>
}

extension CreateResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceInput(parentId: \(String(describing: parentId)), pathPart: \(String(describing: pathPart)), restApiId: \(String(describing: restApiId)))"}
}

extension CreateResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pathPart
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pathPart = pathPart {
            try encodeContainer.encode(pathPart, forKey: .pathPart)
        }
    }
}

public struct CreateResourceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceInput>
    public typealias MOutput = OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceOutputError>
}

public struct CreateResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceInput>
    public typealias MOutput = OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceOutputError>
}

/// <p>Requests API Gateway to create a <a>Resource</a> resource.</p>
public struct CreateResourceInput: Equatable {
    /// <p>[Required] The parent resource's identifier.</p>
    public let parentId: String?
    /// <p>The last path segment for this resource.</p>
    public let pathPart: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        parentId: String? = nil,
        pathPart: String? = nil,
        restApiId: String? = nil
    )
    {
        self.parentId = parentId
        self.pathPart = pathPart
        self.restApiId = restApiId
    }
}

struct CreateResourceInputBody: Equatable {
    public let pathPart: String?
}

extension CreateResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pathPart
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
    }
}

extension CreateResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceOutputResponse(id: \(String(describing: id)), parentId: \(String(describing: parentId)), path: \(String(describing: path)), pathPart: \(String(describing: pathPart)), resourceMethods: \(String(describing: resourceMethods)))"}
}

extension CreateResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.parentId = output.parentId
            self.path = output.path
            self.pathPart = output.pathPart
            self.resourceMethods = output.resourceMethods
        } else {
            self.id = nil
            self.parentId = nil
            self.path = nil
            self.pathPart = nil
            self.resourceMethods = nil
        }
    }
}

/// <p>Represents an API resource.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct CreateResourceOutputResponse: Equatable {
    /// <p>The resource's identifier.</p>
    public let id: String?
    /// <p>The parent resource's identifier.</p>
    public let parentId: String?
    /// <p>The full path for this resource.</p>
    public let path: String?
    /// <p>The last path segment for this resource.</p>
    public let pathPart: String?
    /// <p>Gets an API resource's method of a given HTTP verb.</p>
    ///       <div class="remarks">
    ///         <p>The resource methods are a map of methods indexed by methods' HTTP verbs enabled on the resource. This method map is included in the <code>200 OK</code> response of the <code>GET /restapis/{restapi_id}/resources/{resource_id}</code> or <code>GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods</code> request.</p>
    ///         <h4>Example: Get the GET method of an API resource</h4>
    ///         <h5>Request</h5>
    ///         <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// X-Amz-Date: 20170223T031827Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20170223/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": [
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
    ///         "name": "integration",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///         "name": "integrationresponse",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html",
    ///         "name": "method",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
    ///         "name": "methodresponse",
    ///         "templated": true
    ///       }
    ///     ],
    ///     "self": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET",
    ///       "name": "GET",
    ///       "title": "GET"
    ///     },
    ///     "integration:put": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///     },
    ///     "method:delete": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
    ///     },
    ///     "method:integration": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///     },
    ///     "method:responses": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
    ///       "name": "200",
    ///       "title": "200"
    ///     },
    ///     "method:update": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
    ///     },
    ///     "methodresponse:put": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}",
    ///       "templated": true
    ///     }
    ///   },
    ///   "apiKeyRequired": false,
    ///   "authorizationType": "NONE",
    ///   "httpMethod": "GET",
    ///   "_embedded": {
    ///     "method:integration": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integration:delete": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integration:responses": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "integration:update": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integrationresponse:put": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}",
    ///           "templated": true
    ///         }
    ///       },
    ///       "cacheKeyParameters": [],
    ///       "cacheNamespace": "3kzxbg5sa2",
    ///       "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
    ///       "httpMethod": "POST",
    ///       "passthroughBehavior": "WHEN_NO_MATCH",
    ///       "requestParameters": {
    ///         "integration.request.header.Content-Type": "'application/x-amz-json-1.1'"
    ///       },
    ///       "requestTemplates": {
    ///         "application/json": "{\n}"
    ///       },
    ///       "type": "AWS",
    ///       "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams",
    ///       "_embedded": {
    ///         "integration:responses": {
    ///           "_links": {
    ///             "self": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///               "name": "200",
    ///               "title": "200"
    ///             },
    ///             "integrationresponse:delete": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///             },
    ///             "integrationresponse:update": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///             }
    ///           },
    ///           "responseParameters": {
    ///             "method.response.header.Content-Type": "'application/xml'"
    ///           },
    ///           "responseTemplates": {
    ///             "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n"
    ///           },
    ///           "statusCode": "200"
    ///         }
    ///       }
    ///     },
    ///     "method:responses": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "methodresponse:delete": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
    ///         },
    ///         "methodresponse:update": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
    ///         }
    ///       },
    ///       "responseModels": {
    ///         "application/json": "Empty"
    ///       },
    ///       "responseParameters": {
    ///         "method.response.header.Content-Type": false
    ///       },
    ///       "statusCode": "200"
    ///     }
    ///   }
    /// }</code></pre>
    ///         <p>If the <code>OPTIONS</code> is enabled on the resource, you can follow the example here to get that method. Just replace the <code>GET</code> of the last path segment in the request URL with <code>OPTIONS</code>.</p>
    ///       </div>
    ///       <div class="seeAlso">
    ///       </div>
    public let resourceMethods: [String:Method]?

    public init (
        id: String? = nil,
        parentId: String? = nil,
        path: String? = nil,
        pathPart: String? = nil,
        resourceMethods: [String:Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

struct CreateResourceOutputResponseBody: Equatable {
    public let id: String?
    public let parentId: String?
    public let pathPart: String?
    public let path: String?
    public let resourceMethods: [String:Method]?
}

extension CreateResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([String: Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [String:Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [String:Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

public struct CreateRestApiInputBodyMiddleware: Middleware {
    public let id: String = "CreateRestApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRestApiInput>
    public typealias MOutput = OperationOutput<CreateRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRestApiOutputError>
}

extension CreateRestApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRestApiInput(apiKeySource: \(String(describing: apiKeySource)), binaryMediaTypes: \(String(describing: binaryMediaTypes)), cloneFrom: \(String(describing: cloneFrom)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), endpointConfiguration: \(String(describing: endpointConfiguration)), minimumCompressionSize: \(String(describing: minimumCompressionSize)), name: \(String(describing: name)), policy: \(String(describing: policy)), tags: \(String(describing: tags)), version: \(String(describing: version)))"}
}

extension CreateRestApiInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case cloneFrom
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySource = apiKeySource {
            try encodeContainer.encode(apiKeySource.rawValue, forKey: .apiKeySource)
        }
        if let binaryMediaTypes = binaryMediaTypes {
            var binaryMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binaryMediaTypes)
            for listofstring0 in binaryMediaTypes {
                try binaryMediaTypesContainer.encode(listofstring0)
            }
        }
        if let cloneFrom = cloneFrom {
            try encodeContainer.encode(cloneFrom, forKey: .cloneFrom)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableExecuteApiEndpoint != false {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let endpointConfiguration = endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let minimumCompressionSize = minimumCompressionSize {
            try encodeContainer.encode(minimumCompressionSize, forKey: .minimumCompressionSize)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct CreateRestApiInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRestApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRestApiInput>
    public typealias MOutput = OperationOutput<CreateRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRestApiOutputError>
}

public struct CreateRestApiInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRestApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRestApiInput>
    public typealias MOutput = OperationOutput<CreateRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRestApiOutputError>
}

/// <p>The POST Request to add a new <a>RestApi</a> resource to your collection.</p>
public struct CreateRestApiInput: Equatable {
    /// <p>The source of the API key for metering requests according to a usage plan. Valid values are: <ul><li><code>HEADER</code> to read the API key from the <code>X-API-Key</code> header of a request. </li><li><code>AUTHORIZER</code> to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</li></ul></p>
    public let apiKeySource: ApiKeySourceType?
    /// <p>The list of binary media types supported by the <a>RestApi</a>. By default, the <a>RestApi</a> supports only UTF-8-encoded text payloads.</p>
    public let binaryMediaTypes: [String]?
    /// <p>The ID of the <a>RestApi</a> that you want to clone from.</p>
    public let cloneFrom: String?
    /// <p>The description of the <a>RestApi</a>.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default <code>execute-api</code> endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>The endpoint configuration of this <a>RestApi</a> showing the endpoint types of the API.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.</p>
    public let minimumCompressionSize: Int?
    /// <p>[Required] The name of the <a>RestApi</a>.</p>
    public let name: String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and <a>Method</a> configuration.
    public let policy: String?
    /// <p>The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?

    public init (
        apiKeySource: ApiKeySourceType? = nil,
        binaryMediaTypes: [String]? = nil,
        cloneFrom: String? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        endpointConfiguration: EndpointConfiguration? = nil,
        minimumCompressionSize: Int? = nil,
        name: String? = nil,
        policy: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.cloneFrom = cloneFrom
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
    }
}

struct CreateRestApiInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let version: String?
    public let cloneFrom: String?
    public let binaryMediaTypes: [String]?
    public let minimumCompressionSize: Int?
    public let apiKeySource: ApiKeySourceType?
    public let endpointConfiguration: EndpointConfiguration?
    public let policy: String?
    public let tags: [String:String]?
    public let disableExecuteApiEndpoint: Bool
}

extension CreateRestApiInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case cloneFrom
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let cloneFromDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloneFrom)
        cloneFrom = cloneFromDecoded
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension CreateRestApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRestApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRestApiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRestApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRestApiOutputResponse(apiKeySource: \(String(describing: apiKeySource)), binaryMediaTypes: \(String(describing: binaryMediaTypes)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), endpointConfiguration: \(String(describing: endpointConfiguration)), id: \(String(describing: id)), minimumCompressionSize: \(String(describing: minimumCompressionSize)), name: \(String(describing: name)), policy: \(String(describing: policy)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

extension CreateRestApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRestApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// <p>Represents a REST API.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct CreateRestApiOutputResponse: Equatable {
    /// <p>The source of the API key for metering requests according to a usage plan. Valid values are: <ul><li><code>HEADER</code> to read the API key from the <code>X-API-Key</code> header of a request. </li><li><code>AUTHORIZER</code> to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</li></ul></p>
    public let apiKeySource: ApiKeySourceType?
    /// <p>The list of binary media types supported by the <a>RestApi</a>. By default, the <a>RestApi</a> supports only UTF-8-encoded text payloads.</p>
    public let binaryMediaTypes: [String]?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The API's description.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default <code>execute-api</code> endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>The endpoint configuration of this <a>RestApi</a> showing the endpoint types of the API.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>The API's identifier. This identifier is unique across all of your APIs in API Gateway.</p>
    public let id: String?
    /// <p>A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.</p>
    public let minimumCompressionSize: Int?
    /// <p>The API's name.</p>
    public let name: String?
    /// <p>A stringified JSON policy document that applies to this RestApi regardless of the caller and <a>Method</a> configuration.</p>
    public let policy: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when <code>failonwarnings</code> is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiKeySource: ApiKeySourceType? = nil,
        binaryMediaTypes: [String]? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        endpointConfiguration: EndpointConfiguration? = nil,
        id: String? = nil,
        minimumCompressionSize: Int? = nil,
        name: String? = nil,
        policy: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct CreateRestApiOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let createdDate: Date?
    public let version: String?
    public let warnings: [String]?
    public let binaryMediaTypes: [String]?
    public let minimumCompressionSize: Int?
    public let apiKeySource: ApiKeySourceType?
    public let endpointConfiguration: EndpointConfiguration?
    public let policy: String?
    public let tags: [String:String]?
    public let disableExecuteApiEndpoint: Bool
}

extension CreateRestApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

public struct CreateStageInputBodyMiddleware: Middleware {
    public let id: String = "CreateStageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStageInput>
    public typealias MOutput = OperationOutput<CreateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStageOutputError>
}

extension CreateStageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStageInput(cacheClusterEnabled: \(String(describing: cacheClusterEnabled)), cacheClusterSize: \(String(describing: cacheClusterSize)), canarySettings: \(String(describing: canarySettings)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), documentationVersion: \(String(describing: documentationVersion)), restApiId: \(String(describing: restApiId)), stageName: \(String(describing: stageName)), tags: \(String(describing: tags)), tracingEnabled: \(String(describing: tracingEnabled)), variables: \(String(describing: variables)))"}
}

extension CreateStageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case deploymentId
        case description
        case documentationVersion
        case stageName
        case tags
        case tracingEnabled
        case variables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cacheClusterEnabled != false {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize.rawValue, forKey: .cacheClusterSize)
        }
        if let canarySettings = canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if tracingEnabled != false {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .variables)
            for (dictKey0, mapofstringtostring0) in variables {
                try variablesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateStageInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStageInput>
    public typealias MOutput = OperationOutput<CreateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStageOutputError>
}

public struct CreateStageInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStageInput>
    public typealias MOutput = OperationOutput<CreateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStageOutputError>
}

/// <p>Requests API Gateway to create a <a>Stage</a> resource.</p>
public struct CreateStageInput: Equatable {
    /// <p>Whether cache clustering is enabled for the stage.</p>
    public let cacheClusterEnabled: Bool
    /// <p>The stage's cache cluster size.</p>
    public let cacheClusterSize: CacheClusterSize?
    /// <p>The canary deployment settings of this stage.</p>
    public let canarySettings: CanarySettings?
    /// <p>[Required] The identifier of the <a>Deployment</a> resource for the <a>Stage</a> resource.</p>
    public let deploymentId: String?
    /// <p>The description of the <a>Stage</a> resource.</p>
    public let description: String?
    /// <p>The version of the associated API documentation.</p>
    public let documentationVersion: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The name for the <a>Stage</a> resource. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.</p>
    public let stageName: String?
    /// <p>The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.</p>
    public let tags: [String:String]?
    /// <p>Specifies whether active tracing with X-ray is enabled for the <a>Stage</a>.</p>
    public let tracingEnabled: Bool
    /// <p>A map that defines the stage variables for the new <a>Stage</a> resource. Variable names
    ///           can have alphanumeric and underscore characters, and the values must match
    ///           <code>[A-Za-z0-9-._~:/?#&=,]+</code>.</p>
    public let variables: [String:String]?

    public init (
        cacheClusterEnabled: Bool = false,
        cacheClusterSize: CacheClusterSize? = nil,
        canarySettings: CanarySettings? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        documentationVersion: String? = nil,
        restApiId: String? = nil,
        stageName: String? = nil,
        tags: [String:String]? = nil,
        tracingEnabled: Bool = false,
        variables: [String:String]? = nil
    )
    {
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.canarySettings = canarySettings
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
    }
}

struct CreateStageInputBody: Equatable {
    public let stageName: String?
    public let deploymentId: String?
    public let description: String?
    public let cacheClusterEnabled: Bool
    public let cacheClusterSize: CacheClusterSize?
    public let variables: [String:String]?
    public let documentationVersion: String?
    public let canarySettings: CanarySettings?
    public let tracingEnabled: Bool
    public let tags: [String:String]?
}

extension CreateStageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case deploymentId
        case description
        case documentationVersion
        case stageName
        case tags
        case tracingEnabled
        case variables
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStageOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStageOutputResponse(accessLogSettings: \(String(describing: accessLogSettings)), cacheClusterEnabled: \(String(describing: cacheClusterEnabled)), cacheClusterSize: \(String(describing: cacheClusterSize)), cacheClusterStatus: \(String(describing: cacheClusterStatus)), canarySettings: \(String(describing: canarySettings)), clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), documentationVersion: \(String(describing: documentationVersion)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), methodSettings: \(String(describing: methodSettings)), stageName: \(String(describing: stageName)), tags: \(String(describing: tags)), tracingEnabled: \(String(describing: tracingEnabled)), variables: \(String(describing: variables)), webAclArn: \(String(describing: webAclArn)))"}
}

extension CreateStageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessLogSettings = output.accessLogSettings
            self.cacheClusterEnabled = output.cacheClusterEnabled
            self.cacheClusterSize = output.cacheClusterSize
            self.cacheClusterStatus = output.cacheClusterStatus
            self.canarySettings = output.canarySettings
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.documentationVersion = output.documentationVersion
            self.lastUpdatedDate = output.lastUpdatedDate
            self.methodSettings = output.methodSettings
            self.stageName = output.stageName
            self.tags = output.tags
            self.tracingEnabled = output.tracingEnabled
            self.variables = output.variables
            self.webAclArn = output.webAclArn
        } else {
            self.accessLogSettings = nil
            self.cacheClusterEnabled = false
            self.cacheClusterSize = nil
            self.cacheClusterStatus = nil
            self.canarySettings = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.description = nil
            self.documentationVersion = nil
            self.lastUpdatedDate = nil
            self.methodSettings = nil
            self.stageName = nil
            self.tags = nil
            self.tracingEnabled = false
            self.variables = nil
            self.webAclArn = nil
        }
    }
}

/// <p>Represents a unique identifier for a version of a deployed <a>RestApi</a> that is callable by users.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html">Deploy an API</a>
///       </div>
public struct CreateStageOutputResponse: Equatable {
    /// <p>Settings for logging access in this stage.</p>
    public let accessLogSettings: AccessLogSettings?
    /// <p>Specifies whether a cache cluster is enabled for the stage.</p>
    public let cacheClusterEnabled: Bool
    /// <p>The size of the cache cluster for the stage, if enabled.</p>
    public let cacheClusterSize: CacheClusterSize?
    /// <p>The status of the cache cluster for the stage, if enabled.</p>
    public let cacheClusterStatus: CacheClusterStatus?
    /// <p>Settings for the canary deployment in this stage.</p>
    public let canarySettings: CanarySettings?
    /// <p>The identifier of a client certificate for an API stage.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the stage was created.</p>
    public let createdDate: Date?
    /// <p>The identifier of the <a>Deployment</a> that the stage points to.</p>
    public let deploymentId: String?
    /// <p>The stage's description.</p>
    public let description: String?
    /// <p>The version of the associated API documentation.</p>
    public let documentationVersion: String?
    /// <p>The timestamp when the stage last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>A map that defines the method settings for a <a>Stage</a> resource. Keys (designated as <code>/{method_setting_key</code> below) are method paths defined as <code>{resource_path}/{http_method}</code> for an individual method override, or <code>/\*/\*</code> for overriding all methods in the stage.  <!-- Any forward slash ("/") characters in the <code>resource_path</code> part must be encoded as "~1" as in, for example, <code>~1resource~1sub-resource/GET</code>.--></p>
    public let methodSettings: [String:MethodSetting]?
    /// <p>The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.</p>
    public let stageName: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>Specifies whether active tracing with X-ray is enabled for the <a>Stage</a>.</p>
    public let tracingEnabled: Bool
    /// <p>A map that defines the stage variables for a <a>Stage</a> resource. Variable names can
    ///           have alphanumeric and underscore characters, and the values must match <code>[A-Za-z0-9-._~:/?#&=,]+</code>.</p>
    public let variables: [String:String]?
    /// <p>The ARN of the WebAcl associated with the <a>Stage</a>.</p>
    public let webAclArn: String?

    public init (
        accessLogSettings: AccessLogSettings? = nil,
        cacheClusterEnabled: Bool = false,
        cacheClusterSize: CacheClusterSize? = nil,
        cacheClusterStatus: CacheClusterStatus? = nil,
        canarySettings: CanarySettings? = nil,
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        documentationVersion: String? = nil,
        lastUpdatedDate: Date? = nil,
        methodSettings: [String:MethodSetting]? = nil,
        stageName: String? = nil,
        tags: [String:String]? = nil,
        tracingEnabled: Bool = false,
        variables: [String:String]? = nil,
        webAclArn: String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

struct CreateStageOutputResponseBody: Equatable {
    public let deploymentId: String?
    public let clientCertificateId: String?
    public let stageName: String?
    public let description: String?
    public let cacheClusterEnabled: Bool
    public let cacheClusterSize: CacheClusterSize?
    public let cacheClusterStatus: CacheClusterStatus?
    public let methodSettings: [String:MethodSetting]?
    public let variables: [String:String]?
    public let documentationVersion: String?
    public let accessLogSettings: AccessLogSettings?
    public let canarySettings: CanarySettings?
    public let tracingEnabled: Bool
    public let webAclArn: String?
    public let tags: [String:String]?
    public let createdDate: Date?
    public let lastUpdatedDate: Date?
}

extension CreateStageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([String: MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [String:MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [String:MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

public struct CreateUsagePlanInputBodyMiddleware: Middleware {
    public let id: String = "CreateUsagePlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsagePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsagePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsagePlanInput>
    public typealias MOutput = OperationOutput<CreateUsagePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsagePlanOutputError>
}

extension CreateUsagePlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUsagePlanInput(apiStages: \(String(describing: apiStages)), description: \(String(describing: description)), name: \(String(describing: name)), quota: \(String(describing: quota)), tags: \(String(describing: tags)), throttle: \(String(describing: throttle)))"}
}

extension CreateUsagePlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiStages
        case description
        case name
        case quota
        case tags
        case throttle
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiStages = apiStages {
            var apiStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .apiStages)
            for listofapistage0 in apiStages {
                try apiStagesContainer.encode(listofapistage0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quota = quota {
            try encodeContainer.encode(quota, forKey: .quota)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let throttle = throttle {
            try encodeContainer.encode(throttle, forKey: .throttle)
        }
    }
}

public struct CreateUsagePlanInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUsagePlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsagePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsagePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsagePlanInput>
    public typealias MOutput = OperationOutput<CreateUsagePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsagePlanOutputError>
}

public struct CreateUsagePlanInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUsagePlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsagePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsagePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsagePlanInput>
    public typealias MOutput = OperationOutput<CreateUsagePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsagePlanOutputError>
}

/// <p>The POST request to create a usage plan with the name, description, throttle limits and quota limits, as well as the associated API stages, specified in the payload.</p>
public struct CreateUsagePlanInput: Equatable {
    /// <p>The associated API stages of the usage plan.</p>
    public let apiStages: [ApiStage]?
    /// <p>The description of the usage plan.</p>
    public let description: String?
    /// <p>[Required] The name of the usage plan.</p>
    public let name: String?
    /// <p>The quota of the usage plan.</p>
    public let quota: QuotaSettings?
    /// <p>The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.</p>
    public let tags: [String:String]?
    /// <p>The throttling limits of the usage plan.</p>
    public let throttle: ThrottleSettings?

    public init (
        apiStages: [ApiStage]? = nil,
        description: String? = nil,
        name: String? = nil,
        quota: QuotaSettings? = nil,
        tags: [String:String]? = nil,
        throttle: ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.name = name
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct CreateUsagePlanInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let apiStages: [ApiStage]?
    public let throttle: ThrottleSettings?
    public let quota: QuotaSettings?
    public let tags: [String:String]?
}

extension CreateUsagePlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiStages
        case description
        case name
        case quota
        case tags
        case throttle
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateUsagePlanKeyInputBodyMiddleware: Middleware {
    public let id: String = "CreateUsagePlanKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsagePlanKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsagePlanKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsagePlanKeyInput>
    public typealias MOutput = OperationOutput<CreateUsagePlanKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsagePlanKeyOutputError>
}

extension CreateUsagePlanKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUsagePlanKeyInput(keyId: \(String(describing: keyId)), keyType: \(String(describing: keyType)), usagePlanId: \(String(describing: usagePlanId)))"}
}

extension CreateUsagePlanKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId
        case keyType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType, forKey: .keyType)
        }
    }
}

public struct CreateUsagePlanKeyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUsagePlanKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsagePlanKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsagePlanKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsagePlanKeyInput>
    public typealias MOutput = OperationOutput<CreateUsagePlanKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsagePlanKeyOutputError>
}

public struct CreateUsagePlanKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUsagePlanKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsagePlanKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsagePlanKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsagePlanKeyInput>
    public typealias MOutput = OperationOutput<CreateUsagePlanKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsagePlanKeyOutputError>
}

/// <p>The POST request to create a usage plan key for adding an existing API key to a usage plan.</p>
public struct CreateUsagePlanKeyInput: Equatable {
    /// <p>[Required] The identifier of a <a>UsagePlanKey</a> resource for a plan customer.</p>
    public let keyId: String?
    /// <p>[Required] The type of a <a>UsagePlanKey</a> resource for a plan customer.</p>
    public let keyType: String?
    /// <p>[Required] The Id of the <a>UsagePlan</a> resource representing the usage plan containing the to-be-created <a>UsagePlanKey</a> resource representing a plan customer.</p>
    public let usagePlanId: String?

    public init (
        keyId: String? = nil,
        keyType: String? = nil,
        usagePlanId: String? = nil
    )
    {
        self.keyId = keyId
        self.keyType = keyType
        self.usagePlanId = usagePlanId
    }
}

struct CreateUsagePlanKeyInputBody: Equatable {
    public let keyId: String?
    public let keyType: String?
}

extension CreateUsagePlanKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId
        case keyType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension CreateUsagePlanKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUsagePlanKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUsagePlanKeyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUsagePlanKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUsagePlanKeyOutputResponse(id: \(String(describing: id)), name: \(String(describing: name)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

extension CreateUsagePlanKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUsagePlanKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.name = output.name
            self.type = output.type
            self.value = output.value
        } else {
            self.id = nil
            self.name = nil
            self.type = nil
            self.value = nil
        }
    }
}

/// <p>Represents a usage plan key to identify a plan customer.</p>
///     <div class="remarks">
///       <p>To associate an API stage with a selected API key in a usage plan, you must create a UsagePlanKey resource to represent the selected <a>ApiKey</a>.</p>
///     </div>"
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>
///     </div>
public struct CreateUsagePlanKeyOutputResponse: Equatable {
    /// <p>The Id of a usage plan key.</p>
    public let id: String?
    /// <p>The name of a usage plan key.</p>
    public let name: String?
    /// <p>The type of a usage plan key. Currently, the valid key type is <code>API_KEY</code>.</p>
    public let type: String?
    /// <p>The value of a usage plan key.</p>
    public let value: String?

    public init (
        id: String? = nil,
        name: String? = nil,
        type: String? = nil,
        value: String? = nil
    )
    {
        self.id = id
        self.name = name
        self.type = type
        self.value = value
    }
}

struct CreateUsagePlanKeyOutputResponseBody: Equatable {
    public let id: String?
    public let type: String?
    public let value: String?
    public let name: String?
}

extension CreateUsagePlanKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case type
        case value
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateUsagePlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUsagePlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUsagePlanOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUsagePlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUsagePlanOutputResponse(apiStages: \(String(describing: apiStages)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), productCode: \(String(describing: productCode)), quota: \(String(describing: quota)), tags: \(String(describing: tags)), throttle: \(String(describing: throttle)))"}
}

extension CreateUsagePlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUsagePlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiStages = output.apiStages
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.productCode = output.productCode
            self.quota = output.quota
            self.tags = output.tags
            self.throttle = output.throttle
        } else {
            self.apiStages = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.productCode = nil
            self.quota = nil
            self.tags = nil
            self.throttle = nil
        }
    }
}

/// <p>Represents a usage plan than can specify who can assess associated API stages with specified request limits and quotas.</p>
///       <div class="remarks">
///         <p>In a usage plan, you associate an API by specifying the API's Id and a stage name of the specified API. You add plan customers by adding API keys to the plan. </p>
///       </div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>
///       </div>
public struct CreateUsagePlanOutputResponse: Equatable {
    /// <p>The associated API stages of a usage plan.</p>
    public let apiStages: [ApiStage]?
    /// <p>The description of a usage plan.</p>
    public let description: String?
    /// <p>The identifier of a <a>UsagePlan</a> resource.</p>
    public let id: String?
    /// <p>The name of a usage plan.</p>
    public let name: String?
    /// <p>The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace.</p>
    public let productCode: String?
    /// <p>The maximum number of permitted requests per a given unit time interval.</p>
    public let quota: QuotaSettings?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The request throttle limits of a usage plan.</p>
    public let throttle: ThrottleSettings?

    public init (
        apiStages: [ApiStage]? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        productCode: String? = nil,
        quota: QuotaSettings? = nil,
        tags: [String:String]? = nil,
        throttle: ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct CreateUsagePlanOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let apiStages: [ApiStage]?
    public let throttle: ThrottleSettings?
    public let quota: QuotaSettings?
    public let productCode: String?
    public let tags: [String:String]?
}

extension CreateUsagePlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateVpcLinkInputBodyMiddleware: Middleware {
    public let id: String = "CreateVpcLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVpcLinkInput>
    public typealias MOutput = OperationOutput<CreateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVpcLinkOutputError>
}

extension CreateVpcLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVpcLinkInput(description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)), targetArns: \(String(describing: targetArns)))"}
}

extension CreateVpcLinkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case tags
        case targetArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targetArns = targetArns {
            var targetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetArns)
            for listofstring0 in targetArns {
                try targetArnsContainer.encode(listofstring0)
            }
        }
    }
}

public struct CreateVpcLinkInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVpcLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVpcLinkInput>
    public typealias MOutput = OperationOutput<CreateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVpcLinkOutputError>
}

public struct CreateVpcLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVpcLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVpcLinkInput>
    public typealias MOutput = OperationOutput<CreateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVpcLinkOutputError>
}

/// <p>Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services.</p>
public struct CreateVpcLinkInput: Equatable {
    /// <p>The description of the VPC link.</p>
    public let description: String?
    /// <p>[Required] The name used to label and identify the VPC link.</p>
    public let name: String?
    /// <p>The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.</p>
    public let tags: [String:String]?
    /// <p>[Required] The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.</p>
    public let targetArns: [String]?

    public init (
        description: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        targetArns: [String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct CreateVpcLinkInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let targetArns: [String]?
    public let tags: [String:String]?
}

extension CreateVpcLinkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case tags
        case targetArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVpcLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVpcLinkOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVpcLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVpcLinkOutputResponse(description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), tags: \(String(describing: tags)), targetArns: \(String(describing: targetArns)))"}
}

extension CreateVpcLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.targetArns = output.targetArns
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.targetArns = nil
        }
    }
}

/// <p>An API Gateway VPC link for a <a>RestApi</a> to access resources in an Amazon Virtual Private Cloud (VPC).</p>
///         <div class="remarks">
///           <p><p>To enable access to a resource in an Amazon Virtual Private Cloud through Amazon API Gateway, you, as an API developer, create a <a>VpcLink</a> resource targeted for one or more network load balancers of the VPC and then integrate an API method with a private integration that uses the <a>VpcLink</a>. The private integration has an integration type of <code>HTTP</code> or <code>HTTP_PROXY</code> and has a connection type of <code>VPC_LINK</code>. The integration uses the <code>connectionId</code> property to identify the <a>VpcLink</a> used.</p></p>
///         </div>
public struct CreateVpcLinkOutputResponse: Equatable {
    /// <p>The description of the VPC link.</p>
    public let description: String?
    /// <p>The identifier of the  <a>VpcLink</a>. It is used in an <a>Integration</a> to reference this <a>VpcLink</a>.</p>
    public let id: String?
    /// <p>The name used to label and identify the VPC link.</p>
    public let name: String?
    /// <p>The status of the VPC link. The valid values are <code>AVAILABLE</code>, <code>PENDING</code>, <code>DELETING</code>, or <code>FAILED</code>. Deploying an API will wait if the status is <code>PENDING</code> and will fail if the status is <code>DELETING</code>.</p>
    public let status: VpcLinkStatus?
    /// <p>A description about the VPC link status.</p>
    public let statusMessage: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.</p>
    public let targetArns: [String]?

    public init (
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        status: VpcLinkStatus? = nil,
        statusMessage: String? = nil,
        tags: [String:String]? = nil,
        targetArns: [String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct CreateVpcLinkOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let targetArns: [String]?
    public let status: VpcLinkStatus?
    public let statusMessage: String?
    public let tags: [String:String]?
}

extension CreateVpcLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeleteApiKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiKeyInput(apiKey: \(String(describing: apiKey)))"}
}

extension DeleteApiKeyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApiKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApiKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiKeyInput>
    public typealias MOutput = OperationOutput<DeleteApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiKeyOutputError>
}

public struct DeleteApiKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApiKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiKeyInput>
    public typealias MOutput = OperationOutput<DeleteApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiKeyOutputError>
}

/// <p>A request to delete the <a>ApiKey</a> resource.</p>
public struct DeleteApiKeyInput: Equatable {
    /// <p>[Required] The identifier of the <a>ApiKey</a> resource to be deleted.</p>
    public let apiKey: String?

    public init (
        apiKey: String? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct DeleteApiKeyInputBody: Equatable {
}

extension DeleteApiKeyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApiKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiKeyOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiKeyOutputResponse()"}
}

extension DeleteApiKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiKeyOutputResponse: Equatable {

    public init() {}
}

struct DeleteApiKeyOutputResponseBody: Equatable {
}

extension DeleteApiKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAuthorizerInput(authorizerId: \(String(describing: authorizerId)), restApiId: \(String(describing: restApiId)))"}
}

extension DeleteAuthorizerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAuthorizerInput>
    public typealias MOutput = OperationOutput<DeleteAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAuthorizerOutputError>
}

public struct DeleteAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAuthorizerInput>
    public typealias MOutput = OperationOutput<DeleteAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAuthorizerOutputError>
}

/// <p>Request to delete an existing <a>Authorizer</a> resource.</p>
public struct DeleteAuthorizerInput: Equatable {
    /// <p>[Required] The identifier of the <a>Authorizer</a> resource.</p>
    public let authorizerId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        authorizerId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.restApiId = restApiId
    }
}

struct DeleteAuthorizerInputBody: Equatable {
}

extension DeleteAuthorizerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAuthorizerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAuthorizerOutputResponse()"}
}

extension DeleteAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAuthorizerOutputResponse: Equatable {

    public init() {}
}

struct DeleteAuthorizerOutputResponseBody: Equatable {
}

extension DeleteAuthorizerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBasePathMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBasePathMappingInput(basePath: \(String(describing: basePath)), domainName: \(String(describing: domainName)))"}
}

extension DeleteBasePathMappingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBasePathMappingInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBasePathMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBasePathMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBasePathMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBasePathMappingInput>
    public typealias MOutput = OperationOutput<DeleteBasePathMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBasePathMappingOutputError>
}

public struct DeleteBasePathMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBasePathMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBasePathMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBasePathMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBasePathMappingInput>
    public typealias MOutput = OperationOutput<DeleteBasePathMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBasePathMappingOutputError>
}

/// <p>A request to delete the <a>BasePathMapping</a> resource.</p>
public struct DeleteBasePathMappingInput: Equatable {
    /// <p>[Required] The base path name of the <a>BasePathMapping</a> resource to delete.</p>
    ///         <p>To specify an empty base path, set this parameter to <code>'(none)'</code>.</p>
    public let basePath: String?
    /// <p>[Required] The domain name of the <a>BasePathMapping</a> resource to delete.</p>
    public let domainName: String?

    public init (
        basePath: String? = nil,
        domainName: String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
    }
}

struct DeleteBasePathMappingInputBody: Equatable {
}

extension DeleteBasePathMappingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBasePathMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBasePathMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBasePathMappingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBasePathMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBasePathMappingOutputResponse()"}
}

extension DeleteBasePathMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBasePathMappingOutputResponse: Equatable {

    public init() {}
}

struct DeleteBasePathMappingOutputResponseBody: Equatable {
}

extension DeleteBasePathMappingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteClientCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClientCertificateInput(clientCertificateId: \(String(describing: clientCertificateId)))"}
}

extension DeleteClientCertificateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteClientCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteClientCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClientCertificateInput>
    public typealias MOutput = OperationOutput<DeleteClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClientCertificateOutputError>
}

public struct DeleteClientCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteClientCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClientCertificateInput>
    public typealias MOutput = OperationOutput<DeleteClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClientCertificateOutputError>
}

/// <p>A request to delete the <a>ClientCertificate</a> resource.</p>
public struct DeleteClientCertificateInput: Equatable {
    /// <p>[Required] The identifier of the <a>ClientCertificate</a> resource to be deleted.</p>
    public let clientCertificateId: String?

    public init (
        clientCertificateId: String? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
    }
}

struct DeleteClientCertificateInputBody: Equatable {
}

extension DeleteClientCertificateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteClientCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClientCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClientCertificateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClientCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClientCertificateOutputResponse()"}
}

extension DeleteClientCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteClientCertificateOutputResponse: Equatable {

    public init() {}
}

struct DeleteClientCertificateOutputResponseBody: Equatable {
}

extension DeleteClientCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeploymentInput(deploymentId: \(String(describing: deploymentId)), restApiId: \(String(describing: restApiId)))"}
}

extension DeleteDeploymentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeploymentInput>
    public typealias MOutput = OperationOutput<DeleteDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeploymentOutputError>
}

public struct DeleteDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeploymentInput>
    public typealias MOutput = OperationOutput<DeleteDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeploymentOutputError>
}

/// <p>Requests API Gateway to delete a <a>Deployment</a> resource.</p>
public struct DeleteDeploymentInput: Equatable {
    /// <p>[Required] The identifier of the <a>Deployment</a> resource to delete.</p>
    public let deploymentId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        deploymentId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.restApiId = restApiId
    }
}

struct DeleteDeploymentInputBody: Equatable {
}

extension DeleteDeploymentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeploymentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeploymentOutputResponse()"}
}

extension DeleteDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeploymentOutputResponse: Equatable {

    public init() {}
}

struct DeleteDeploymentOutputResponseBody: Equatable {
}

extension DeleteDeploymentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDocumentationPartInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDocumentationPartInput(documentationPartId: \(String(describing: documentationPartId)), restApiId: \(String(describing: restApiId)))"}
}

extension DeleteDocumentationPartInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDocumentationPartInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDocumentationPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentationPartInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentationPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentationPartInput>
    public typealias MOutput = OperationOutput<DeleteDocumentationPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentationPartOutputError>
}

public struct DeleteDocumentationPartInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDocumentationPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentationPartInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentationPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentationPartInput>
    public typealias MOutput = OperationOutput<DeleteDocumentationPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentationPartOutputError>
}

/// <p>Deletes an existing documentation part of an API.</p>
public struct DeleteDocumentationPartInput: Equatable {
    /// <p>[Required] The identifier of the to-be-deleted documentation part.</p>
    public let documentationPartId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        documentationPartId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.restApiId = restApiId
    }
}

struct DeleteDocumentationPartInputBody: Equatable {
}

extension DeleteDocumentationPartInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDocumentationPartOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDocumentationPartOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDocumentationPartOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDocumentationPartOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDocumentationPartOutputResponse()"}
}

extension DeleteDocumentationPartOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDocumentationPartOutputResponse: Equatable {

    public init() {}
}

struct DeleteDocumentationPartOutputResponseBody: Equatable {
}

extension DeleteDocumentationPartOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDocumentationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDocumentationVersionInput(documentationVersion: \(String(describing: documentationVersion)), restApiId: \(String(describing: restApiId)))"}
}

extension DeleteDocumentationVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDocumentationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDocumentationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentationVersionInput>
    public typealias MOutput = OperationOutput<DeleteDocumentationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentationVersionOutputError>
}

public struct DeleteDocumentationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDocumentationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentationVersionInput>
    public typealias MOutput = OperationOutput<DeleteDocumentationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentationVersionOutputError>
}

/// <p>Deletes an existing documentation version of an API.</p>
public struct DeleteDocumentationVersionInput: Equatable {
    /// <p>[Required] The version identifier of a to-be-deleted documentation snapshot.</p>
    public let documentationVersion: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        documentationVersion: String? = nil,
        restApiId: String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
    }
}

struct DeleteDocumentationVersionInputBody: Equatable {
}

extension DeleteDocumentationVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDocumentationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDocumentationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDocumentationVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDocumentationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDocumentationVersionOutputResponse()"}
}

extension DeleteDocumentationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDocumentationVersionOutputResponse: Equatable {

    public init() {}
}

struct DeleteDocumentationVersionOutputResponseBody: Equatable {
}

extension DeleteDocumentationVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDomainNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainNameInput(domainName: \(String(describing: domainName)))"}
}

extension DeleteDomainNameInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDomainNameInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDomainNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainNameInput>
    public typealias MOutput = OperationOutput<DeleteDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainNameOutputError>
}

public struct DeleteDomainNameInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDomainNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainNameInput>
    public typealias MOutput = OperationOutput<DeleteDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainNameOutputError>
}

/// <p>A request to delete the <a>DomainName</a> resource.</p>
public struct DeleteDomainNameInput: Equatable {
    /// <p>[Required] The name of the <a>DomainName</a> resource to be deleted.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainNameInputBody: Equatable {
}

extension DeleteDomainNameInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDomainNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainNameOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainNameOutputResponse()"}
}

extension DeleteDomainNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDomainNameOutputResponse: Equatable {

    public init() {}
}

struct DeleteDomainNameOutputResponseBody: Equatable {
}

extension DeleteDomainNameOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGatewayResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGatewayResponseInput(responseType: \(String(describing: responseType)), restApiId: \(String(describing: restApiId)))"}
}

extension DeleteGatewayResponseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteGatewayResponseInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGatewayResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayResponseInput>
    public typealias MOutput = OperationOutput<DeleteGatewayResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayResponseOutputError>
}

public struct DeleteGatewayResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGatewayResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayResponseInput>
    public typealias MOutput = OperationOutput<DeleteGatewayResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayResponseOutputError>
}

/// <p>Clears any customization of a <a>GatewayResponse</a> of a specified response type on the given <a>RestApi</a> and resets it with the default settings.</p>
public struct DeleteGatewayResponseInput: Equatable {
    /// <p>[Required] <p>The response type of the associated <a>GatewayResponse</a>. Valid values are <ul><li>ACCESS_DENIED</li><li>API_CONFIGURATION_ERROR</li><li>AUTHORIZER_FAILURE</li><li> AUTHORIZER_CONFIGURATION_ERROR</li><li>BAD_REQUEST_PARAMETERS</li><li>BAD_REQUEST_BODY</li><li>DEFAULT_4XX</li><li>DEFAULT_5XX</li><li>EXPIRED_TOKEN</li><li>INVALID_SIGNATURE</li><li>INTEGRATION_FAILURE</li><li>INTEGRATION_TIMEOUT</li><li>INVALID_API_KEY</li><li>MISSING_AUTHENTICATION_TOKEN</li><li> QUOTA_EXCEEDED</li><li>REQUEST_TOO_LARGE</li><li>RESOURCE_NOT_FOUND</li><li>THROTTLED</li><li>UNAUTHORIZED</li><li>UNSUPPORTED_MEDIA_TYPE</li></ul> </p></p>
    public let responseType: GatewayResponseType?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        responseType: GatewayResponseType? = nil,
        restApiId: String? = nil
    )
    {
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

struct DeleteGatewayResponseInputBody: Equatable {
}

extension DeleteGatewayResponseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGatewayResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGatewayResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGatewayResponseOutputResponse()"}
}

extension DeleteGatewayResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGatewayResponseOutputResponse: Equatable {

    public init() {}
}

struct DeleteGatewayResponseOutputResponseBody: Equatable {
}

extension DeleteGatewayResponseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationInput(httpMethod: \(String(describing: httpMethod)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)))"}
}

extension DeleteIntegrationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationOutputError>
}

public struct DeleteIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationOutputError>
}

/// <p>Represents a delete integration request.</p>
public struct DeleteIntegrationInput: Equatable {
    /// <p>[Required] Specifies a delete integration request's HTTP method.</p>
    public let httpMethod: String?
    /// <p>[Required] Specifies a delete integration request's resource identifier.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        httpMethod: String? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct DeleteIntegrationInputBody: Equatable {
}

extension DeleteIntegrationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationOutputError: Equatable {
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationOutputResponse()"}
}

extension DeleteIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntegrationOutputResponse: Equatable {

    public init() {}
}

struct DeleteIntegrationOutputResponseBody: Equatable {
}

extension DeleteIntegrationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntegrationResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationResponseInput(httpMethod: \(String(describing: httpMethod)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)), statusCode: \(String(describing: statusCode)))"}
}

extension DeleteIntegrationResponseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteIntegrationResponseInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIntegrationResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationResponseInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationResponseOutputError>
}

public struct DeleteIntegrationResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIntegrationResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationResponseInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationResponseOutputError>
}

/// <p>Represents a delete integration response request.</p>
public struct DeleteIntegrationResponseInput: Equatable {
    /// <p>[Required] Specifies a delete integration response request's HTTP method.</p>
    public let httpMethod: String?
    /// <p>[Required] Specifies a delete integration response request's resource identifier.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] Specifies a delete integration response request's status code.</p>
    public let statusCode: String?

    public init (
        httpMethod: String? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil,
        statusCode: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct DeleteIntegrationResponseInputBody: Equatable {
}

extension DeleteIntegrationResponseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntegrationResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationResponseOutputResponse()"}
}

extension DeleteIntegrationResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntegrationResponseOutputResponse: Equatable {

    public init() {}
}

struct DeleteIntegrationResponseOutputResponseBody: Equatable {
}

extension DeleteIntegrationResponseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMethodInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMethodInput(httpMethod: \(String(describing: httpMethod)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)))"}
}

extension DeleteMethodInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteMethodInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMethodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMethodInput>
    public typealias MOutput = OperationOutput<DeleteMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMethodOutputError>
}

public struct DeleteMethodInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMethodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMethodInput>
    public typealias MOutput = OperationOutput<DeleteMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMethodOutputError>
}

/// <p>Request to delete an existing <a>Method</a> resource.</p>
public struct DeleteMethodInput: Equatable {
    /// <p>[Required] The HTTP verb of the <a>Method</a> resource.</p>
    public let httpMethod: String?
    /// <p>[Required] The <a>Resource</a> identifier for the <a>Method</a> resource.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        httpMethod: String? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct DeleteMethodInputBody: Equatable {
}

extension DeleteMethodInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMethodOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMethodOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMethodOutputError: Equatable {
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMethodOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMethodOutputResponse()"}
}

extension DeleteMethodOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMethodOutputResponse: Equatable {

    public init() {}
}

struct DeleteMethodOutputResponseBody: Equatable {
}

extension DeleteMethodOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMethodResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMethodResponseInput(httpMethod: \(String(describing: httpMethod)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)), statusCode: \(String(describing: statusCode)))"}
}

extension DeleteMethodResponseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteMethodResponseInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMethodResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMethodResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMethodResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMethodResponseInput>
    public typealias MOutput = OperationOutput<DeleteMethodResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMethodResponseOutputError>
}

public struct DeleteMethodResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMethodResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMethodResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMethodResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMethodResponseInput>
    public typealias MOutput = OperationOutput<DeleteMethodResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMethodResponseOutputError>
}

/// <p>A request to delete an existing <a>MethodResponse</a> resource.</p>
public struct DeleteMethodResponseInput: Equatable {
    /// <p>[Required] The HTTP verb of the <a>Method</a> resource.</p>
    public let httpMethod: String?
    /// <p>[Required] The <a>Resource</a> identifier for the <a>MethodResponse</a> resource.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The status code identifier for the <a>MethodResponse</a> resource.</p>
    public let statusCode: String?

    public init (
        httpMethod: String? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil,
        statusCode: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct DeleteMethodResponseInputBody: Equatable {
}

extension DeleteMethodResponseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMethodResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMethodResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMethodResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMethodResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMethodResponseOutputResponse()"}
}

extension DeleteMethodResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMethodResponseOutputResponse: Equatable {

    public init() {}
}

struct DeleteMethodResponseOutputResponseBody: Equatable {
}

extension DeleteMethodResponseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelInput(modelName: \(String(describing: modelName)), restApiId: \(String(describing: restApiId)))"}
}

extension DeleteModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteModelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

public struct DeleteModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

/// <p>Request to delete an existing model in an existing <a>RestApi</a> resource.</p>
public struct DeleteModelInput: Equatable {
    /// <p>[Required] The name of the model to delete.</p>
    public let modelName: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        modelName: String? = nil,
        restApiId: String? = nil
    )
    {
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

struct DeleteModelInputBody: Equatable {
}

extension DeleteModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelOutputResponse()"}
}

extension DeleteModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteModelOutputResponse: Equatable {

    public init() {}
}

struct DeleteModelOutputResponseBody: Equatable {
}

extension DeleteModelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRequestValidatorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRequestValidatorInput(requestValidatorId: \(String(describing: requestValidatorId)), restApiId: \(String(describing: restApiId)))"}
}

extension DeleteRequestValidatorInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRequestValidatorInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRequestValidatorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRequestValidatorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRequestValidatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRequestValidatorInput>
    public typealias MOutput = OperationOutput<DeleteRequestValidatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRequestValidatorOutputError>
}

public struct DeleteRequestValidatorInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRequestValidatorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRequestValidatorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRequestValidatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRequestValidatorInput>
    public typealias MOutput = OperationOutput<DeleteRequestValidatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRequestValidatorOutputError>
}

/// <p>Deletes a specified <a>RequestValidator</a> of a given <a>RestApi</a>.</p>
public struct DeleteRequestValidatorInput: Equatable {
    /// <p>[Required] The identifier of the <a>RequestValidator</a> to be deleted.</p>
    public let requestValidatorId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        requestValidatorId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

struct DeleteRequestValidatorInputBody: Equatable {
}

extension DeleteRequestValidatorInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRequestValidatorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRequestValidatorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRequestValidatorOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRequestValidatorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRequestValidatorOutputResponse()"}
}

extension DeleteRequestValidatorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRequestValidatorOutputResponse: Equatable {

    public init() {}
}

struct DeleteRequestValidatorOutputResponseBody: Equatable {
}

extension DeleteRequestValidatorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceInput(resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)))"}
}

extension DeleteResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceInput>
    public typealias MOutput = OperationOutput<DeleteResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceOutputError>
}

public struct DeleteResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceInput>
    public typealias MOutput = OperationOutput<DeleteResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceOutputError>
}

/// <p>Request to delete a <a>Resource</a>.</p>
public struct DeleteResourceInput: Equatable {
    /// <p>[Required] The identifier of the <a>Resource</a> resource.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        resourceId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct DeleteResourceInputBody: Equatable {
}

extension DeleteResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceOutputResponse()"}
}

extension DeleteResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourceOutputResponseBody: Equatable {
}

extension DeleteResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRestApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRestApiInput(restApiId: \(String(describing: restApiId)))"}
}

extension DeleteRestApiInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRestApiInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRestApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRestApiInput>
    public typealias MOutput = OperationOutput<DeleteRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRestApiOutputError>
}

public struct DeleteRestApiInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRestApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRestApiInput>
    public typealias MOutput = OperationOutput<DeleteRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRestApiOutputError>
}

/// <p>Request to delete the specified API from your collection.</p>
public struct DeleteRestApiInput: Equatable {
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        restApiId: String? = nil
    )
    {
        self.restApiId = restApiId
    }
}

struct DeleteRestApiInputBody: Equatable {
}

extension DeleteRestApiInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRestApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRestApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRestApiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRestApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRestApiOutputResponse()"}
}

extension DeleteRestApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRestApiOutputResponse: Equatable {

    public init() {}
}

struct DeleteRestApiOutputResponseBody: Equatable {
}

extension DeleteRestApiOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStageInput(restApiId: \(String(describing: restApiId)), stageName: \(String(describing: stageName)))"}
}

extension DeleteStageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStageInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStageInput>
    public typealias MOutput = OperationOutput<DeleteStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStageOutputError>
}

public struct DeleteStageInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStageInput>
    public typealias MOutput = OperationOutput<DeleteStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStageOutputError>
}

/// <p>Requests API Gateway to delete a <a>Stage</a> resource.</p>
public struct DeleteStageInput: Equatable {
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The name of the <a>Stage</a> resource to delete.</p>
    public let stageName: String?

    public init (
        restApiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct DeleteStageInputBody: Equatable {
}

extension DeleteStageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStageOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStageOutputResponse()"}
}

extension DeleteStageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStageOutputResponse: Equatable {

    public init() {}
}

struct DeleteStageOutputResponseBody: Equatable {
}

extension DeleteStageOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUsagePlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUsagePlanInput(usagePlanId: \(String(describing: usagePlanId)))"}
}

extension DeleteUsagePlanInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUsagePlanInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUsagePlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUsagePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUsagePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUsagePlanInput>
    public typealias MOutput = OperationOutput<DeleteUsagePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUsagePlanOutputError>
}

public struct DeleteUsagePlanInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUsagePlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUsagePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUsagePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUsagePlanInput>
    public typealias MOutput = OperationOutput<DeleteUsagePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUsagePlanOutputError>
}

/// <p>The DELETE request to delete a usage plan of a given plan Id.</p>
public struct DeleteUsagePlanInput: Equatable {
    /// <p>[Required] The Id of the to-be-deleted usage plan.</p>
    public let usagePlanId: String?

    public init (
        usagePlanId: String? = nil
    )
    {
        self.usagePlanId = usagePlanId
    }
}

struct DeleteUsagePlanInputBody: Equatable {
}

extension DeleteUsagePlanInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUsagePlanKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUsagePlanKeyInput(keyId: \(String(describing: keyId)), usagePlanId: \(String(describing: usagePlanId)))"}
}

extension DeleteUsagePlanKeyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUsagePlanKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUsagePlanKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUsagePlanKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUsagePlanKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUsagePlanKeyInput>
    public typealias MOutput = OperationOutput<DeleteUsagePlanKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUsagePlanKeyOutputError>
}

public struct DeleteUsagePlanKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUsagePlanKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUsagePlanKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUsagePlanKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUsagePlanKeyInput>
    public typealias MOutput = OperationOutput<DeleteUsagePlanKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUsagePlanKeyOutputError>
}

/// <p>The DELETE request to delete a usage plan key and remove the underlying API key from the associated usage plan.</p>
public struct DeleteUsagePlanKeyInput: Equatable {
    /// <p>[Required] The Id of the <a>UsagePlanKey</a> resource to be deleted.</p>
    public let keyId: String?
    /// <p>[Required] The Id of the <a>UsagePlan</a> resource representing the usage plan containing the to-be-deleted <a>UsagePlanKey</a> resource representing a plan customer.</p>
    public let usagePlanId: String?

    public init (
        keyId: String? = nil,
        usagePlanId: String? = nil
    )
    {
        self.keyId = keyId
        self.usagePlanId = usagePlanId
    }
}

struct DeleteUsagePlanKeyInputBody: Equatable {
}

extension DeleteUsagePlanKeyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUsagePlanKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUsagePlanKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUsagePlanKeyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUsagePlanKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUsagePlanKeyOutputResponse()"}
}

extension DeleteUsagePlanKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUsagePlanKeyOutputResponse: Equatable {

    public init() {}
}

struct DeleteUsagePlanKeyOutputResponseBody: Equatable {
}

extension DeleteUsagePlanKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUsagePlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUsagePlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUsagePlanOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUsagePlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUsagePlanOutputResponse()"}
}

extension DeleteUsagePlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUsagePlanOutputResponse: Equatable {

    public init() {}
}

struct DeleteUsagePlanOutputResponseBody: Equatable {
}

extension DeleteUsagePlanOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVpcLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVpcLinkInput(vpcLinkId: \(String(describing: vpcLinkId)))"}
}

extension DeleteVpcLinkInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVpcLinkInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVpcLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVpcLinkInput>
    public typealias MOutput = OperationOutput<DeleteVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVpcLinkOutputError>
}

public struct DeleteVpcLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVpcLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVpcLinkInput>
    public typealias MOutput = OperationOutput<DeleteVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVpcLinkOutputError>
}

/// <p>Deletes an existing <a>VpcLink</a> of a specified identifier.</p>
public struct DeleteVpcLinkInput: Equatable {
    /// <p>[Required] The identifier of the  <a>VpcLink</a>. It is used in an <a>Integration</a> to reference this <a>VpcLink</a>.</p>
    public let vpcLinkId: String?

    public init (
        vpcLinkId: String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct DeleteVpcLinkInputBody: Equatable {
}

extension DeleteVpcLinkInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVpcLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVpcLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVpcLinkOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVpcLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVpcLinkOutputResponse()"}
}

extension DeleteVpcLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVpcLinkOutputResponse: Equatable {

    public init() {}
}

struct DeleteVpcLinkOutputResponseBody: Equatable {
}

extension DeleteVpcLinkOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Deployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiSummary = apiSummary {
            var apiSummaryContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .apiSummary)
            for (dictKey0, pathtomapofmethodsnapshot0) in apiSummary {
                try apiSummaryContainer.encode(pathtomapofmethodsnapshot0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([String: [String: MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [String:[String:MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [String:[String:MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [String: MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [String: MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

extension Deployment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Deployment(apiSummary: \(String(describing: apiSummary)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), id: \(String(describing: id)))"}
}

/// <p>An immutable representation of a <a>RestApi</a> resource that can be called by users using <a>Stages</a>. A deployment must be associated with a <a>Stage</a> for it to be callable over the Internet.</p>
///         <div class="remarks">To create a deployment, call <code>POST</code> on the <a>Deployments</a> resource of a <a>RestApi</a>.
///             To view, update, or delete a deployment, call <code>GET</code>, <code>PATCH</code>, or <code>DELETE</code> on the specified deployment resource (<code>/restapis/{restapi_id}/deployments/{deployment_id}</code>).</div>
///         <div class="seeAlso"><a>RestApi</a>, <a>Deployments</a>, <a>Stage</a>,
///             <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html">AWS CLI</a>,
///             <a href="https://aws.amazon.com/tools/">AWS SDKs</a>
///         </div>
public struct Deployment: Equatable {
    /// <p>A summary of the <a>RestApi</a> at the date and time that the deployment resource was created.</p>
    public let apiSummary: [String:[String:MethodSnapshot]]?
    /// <p>The date and time that the deployment resource was created.</p>
    public let createdDate: Date?
    /// <p>The description for the deployment resource.</p>
    public let description: String?
    /// <p>The identifier for the deployment resource.</p>
    public let id: String?

    public init (
        apiSummary: [String:[String:MethodSnapshot]]? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        id: String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

extension DeploymentCanarySettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case percentTraffic
        case stageVariableOverrides
        case useStageCache
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if percentTraffic != 0.0 {
            try encodeContainer.encode(percentTraffic, forKey: .percentTraffic)
        }
        if let stageVariableOverrides = stageVariableOverrides {
            var stageVariableOverridesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stageVariableOverrides)
            for (dictKey0, mapofstringtostring0) in stageVariableOverrides {
                try stageVariableOverridesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if useStageCache != false {
            try encodeContainer.encode(useStageCache, forKey: .useStageCache)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentTrafficDecoded = try containerValues.decode(Double.self, forKey: .percentTraffic)
        percentTraffic = percentTrafficDecoded
        let stageVariableOverridesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariableOverrides)
        var stageVariableOverridesDecoded0: [String:String]? = nil
        if let stageVariableOverridesContainer = stageVariableOverridesContainer {
            stageVariableOverridesDecoded0 = [String:String]()
            for (key0, string0) in stageVariableOverridesContainer {
                if let string0 = string0 {
                    stageVariableOverridesDecoded0?[key0] = string0
                }
            }
        }
        stageVariableOverrides = stageVariableOverridesDecoded0
        let useStageCacheDecoded = try containerValues.decode(Bool.self, forKey: .useStageCache)
        useStageCache = useStageCacheDecoded
    }
}

extension DeploymentCanarySettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentCanarySettings(percentTraffic: \(String(describing: percentTraffic)), stageVariableOverrides: \(String(describing: stageVariableOverrides)), useStageCache: \(String(describing: useStageCache)))"}
}

/// <p>The input configuration for a canary deployment.</p>
public struct DeploymentCanarySettings: Equatable {
    /// <p>The percentage (0.0-100.0) of traffic routed to the canary deployment.</p>
    public let percentTraffic: Double
    /// <p>A stage variable overrides used for the canary release deployment. They can override existing stage variables or add new stage variables for the canary release deployment. These stage variables are represented as a string-to-string map between stage variable names and their values.</p>
    public let stageVariableOverrides: [String:String]?
    /// <p>A Boolean flag to indicate whether the canary release deployment uses the stage cache or not.</p>
    public let useStageCache: Bool

    public init (
        percentTraffic: Double = 0.0,
        stageVariableOverrides: [String:String]? = nil,
        useStageCache: Bool = false
    )
    {
        self.percentTraffic = percentTraffic
        self.stageVariableOverrides = stageVariableOverrides
        self.useStageCache = useStageCache
    }
}

extension DocumentationPart: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case location
        case properties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension DocumentationPart: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentationPart(id: \(String(describing: id)), location: \(String(describing: location)), properties: \(String(describing: properties)))"}
}

/// <p>A documentation part for a targeted API entity.</p>
///     <div class="remarks">
///       <p>A documentation part consists of a content map (<code>properties</code>) and a target (<code>location</code>). The target specifies an API entity to which the documentation content applies. The supported API entity types are <code>API</code>, <code>AUTHORIZER</code>, <code>MODEL</code>, <code>RESOURCE</code>, <code>METHOD</code>, <code>PATH_PARAMETER</code>, <code>QUERY_PARAMETER</code>, <code>REQUEST_HEADER</code>, <code>REQUEST_BODY</code>, <code>RESPONSE</code>, <code>RESPONSE_HEADER</code>, and <code>RESPONSE_BODY</code>. Valid <code>location</code> fields depend on the API entity type. All valid fields are not required.</p>
///       <p>The content map is a JSON string of API-specific key-value pairs. Although an API can use any shape for the content map, only the OpenAPI-compliant documentation fields will be injected into the associated API entity definition in the exported OpenAPI definition file.</p></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a>DocumentationParts</a>
///     </div>
public struct DocumentationPart: Equatable {
    /// <p>The <a>DocumentationPart</a> identifier, generated by API Gateway when the <code>DocumentationPart</code> is created.</p>
    public let id: String?
    /// <p>The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.</p>
    public let location: DocumentationPartLocation?
    /// <p>A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., <code>"{ \"description\": \"The API does ...\" }"</code>.  Only OpenAPI-compliant documentation-related fields from the <literal>properties</literal> map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of <code>x-amazon-apigateway-documentation</code>.</p>
    public let properties: String?

    public init (
        id: String? = nil,
        location: DocumentationPartLocation? = nil,
        properties: String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

extension DocumentationPartLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case method
        case name
        case path
        case statusCode
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let method = method {
            try encodeContainer.encode(method, forKey: .method)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DocumentationPartType.self, forKey: .type)
        type = typeDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let methodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .method)
        method = methodDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DocumentationPartLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentationPartLocation(method: \(String(describing: method)), name: \(String(describing: name)), path: \(String(describing: path)), statusCode: \(String(describing: statusCode)), type: \(String(describing: type)))"}
}

/// <p>Specifies the target API entity to which the documentation applies.</p>
public struct DocumentationPartLocation: Equatable {
    /// <p>The HTTP verb of a method. It is a valid field for the API entity types of  <code>METHOD</code>, <code>PATH_PARAMETER</code>, <code>QUERY_PARAMETER</code>, <code>REQUEST_HEADER</code>,  <code>REQUEST_BODY</code>, <code>RESPONSE</code>, <code>RESPONSE_HEADER</code>, and <code>RESPONSE_BODY</code>. The default value is <code>*</code> for any method.  When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other <code>location</code> attributes,  the child entity's <code>method</code> attribute must match that of the parent entity exactly.</p>
    public let method: String?
    /// <p>The name of the targeted API entity. It is a valid and required field for the API entity types of <code>AUTHORIZER</code>, <code>MODEL</code>, <code>PATH_PARAMETER</code>, <code>QUERY_PARAMETER</code>, <code>REQUEST_HEADER</code>, <code>REQUEST_BODY</code> and <code>RESPONSE_HEADER</code>. It is an invalid field for any other entity type.</p>
    public let name: String?
    /// <p>The URL path of the target. It is a valid field for the API entity types of <code>RESOURCE</code>, <code>METHOD</code>, <code>PATH_PARAMETER</code>, <code>QUERY_PARAMETER</code>, <code>REQUEST_HEADER</code>, <code>REQUEST_BODY</code>, <code>RESPONSE</code>, <code>RESPONSE_HEADER</code>, and <code>RESPONSE_BODY</code>. The default value is <code>/</code> for the root resource. When an applicable child entity inherits the content of another entity of the same type with more general specifications of the other <code>location</code> attributes,  the child entity's <code>path</code> attribute must match that of the parent entity as a prefix.</p>
    public let path: String?
    /// <p>The HTTP status code of a response. It is a valid field for the API entity types of <code>RESPONSE</code>, <code>RESPONSE_HEADER</code>, and <code>RESPONSE_BODY</code>. The default value is <code>*</code> for any status code. When an applicable child  entity inherits the content of an entity of the same type with more general specifications of the other <code>location</code> attributes, the child entity's <code>statusCode</code> attribute must match that of the parent entity exactly.</p>
    public let statusCode: String?
    /// <p>[Required] The type of API entity to which the documentation content applies. Valid values are <code>API</code>, <code>AUTHORIZER</code>, <code>MODEL</code>, <code>RESOURCE</code>, <code>METHOD</code>, <code>PATH_PARAMETER</code>, <code>QUERY_PARAMETER</code>, <code>REQUEST_HEADER</code>,  <code>REQUEST_BODY</code>, <code>RESPONSE</code>, <code>RESPONSE_HEADER</code>, and <code>RESPONSE_BODY</code>. Content inheritance does not apply to any entity of the <code>API</code>, <code>AUTHORIZER</code>, <code>METHOD</code>,  <code>MODEL</code>, <code>REQUEST_BODY</code>, or <code>RESOURCE</code> type.</p>
    public let type: DocumentationPartType?

    public init (
        method: String? = nil,
        name: String? = nil,
        path: String? = nil,
        statusCode: String? = nil,
        type: DocumentationPartType? = nil
    )
    {
        self.method = method
        self.name = name
        self.path = path
        self.statusCode = statusCode
        self.type = type
    }
}

public enum DocumentationPartType {
    case api
    case authorizer
    case method
    case model
    case pathParameter
    case queryParameter
    case requestBody
    case requestHeader
    case resource
    case response
    case responseBody
    case responseHeader
    case sdkUnknown(String)
}

extension DocumentationPartType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentationPartType] {
        return [
            .api,
            .authorizer,
            .method,
            .model,
            .pathParameter,
            .queryParameter,
            .requestBody,
            .requestHeader,
            .resource,
            .response,
            .responseBody,
            .responseHeader,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .api: return "API"
        case .authorizer: return "AUTHORIZER"
        case .method: return "METHOD"
        case .model: return "MODEL"
        case .pathParameter: return "PATH_PARAMETER"
        case .queryParameter: return "QUERY_PARAMETER"
        case .requestBody: return "REQUEST_BODY"
        case .requestHeader: return "REQUEST_HEADER"
        case .resource: return "RESOURCE"
        case .response: return "RESPONSE"
        case .responseBody: return "RESPONSE_BODY"
        case .responseHeader: return "RESPONSE_HEADER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentationPartType(rawValue: rawValue) ?? DocumentationPartType.sdkUnknown(rawValue)
    }
}

extension DocumentationVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate
        case description
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DocumentationVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentationVersion(createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), version: \(String(describing: version)))"}
}

/// <p>A snapshot of the documentation of an API.</p>
///     <div class="remarks"><p>Publishing API documentation involves creating a documentation version associated with an API stage and exporting the versioned documentation to an external (e.g., OpenAPI) file.</p></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a>DocumentationPart</a>, <a>DocumentationVersions</a>
///     </div>
public struct DocumentationVersion: Equatable {
    /// <p>The date when the API documentation snapshot is created.</p>
    public let createdDate: Date?
    /// <p>The description of the API documentation snapshot.</p>
    public let description: String?
    /// <p>The version identifier of the API documentation snapshot.</p>
    public let version: String?

    public init (
        createdDate: Date? = nil,
        description: String? = nil,
        version: String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

extension DomainName: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateName = certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let certificateUploadDate = certificateUploadDate {
            try encodeContainer.encode(certificateUploadDate.timeIntervalSince1970, forKey: .certificateUploadDate)
        }
        if let distributionDomainName = distributionDomainName {
            try encodeContainer.encode(distributionDomainName, forKey: .distributionDomainName)
        }
        if let distributionHostedZoneId = distributionHostedZoneId {
            try encodeContainer.encode(distributionHostedZoneId, forKey: .distributionHostedZoneId)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainNameStatus = domainNameStatus {
            try encodeContainer.encode(domainNameStatus.rawValue, forKey: .domainNameStatus)
        }
        if let domainNameStatusMessage = domainNameStatusMessage {
            try encodeContainer.encode(domainNameStatusMessage, forKey: .domainNameStatusMessage)
        }
        if let endpointConfiguration = endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let mutualTlsAuthentication = mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let regionalCertificateArn = regionalCertificateArn {
            try encodeContainer.encode(regionalCertificateArn, forKey: .regionalCertificateArn)
        }
        if let regionalCertificateName = regionalCertificateName {
            try encodeContainer.encode(regionalCertificateName, forKey: .regionalCertificateName)
        }
        if let regionalDomainName = regionalDomainName {
            try encodeContainer.encode(regionalDomainName, forKey: .regionalDomainName)
        }
        if let regionalHostedZoneId = regionalHostedZoneId {
            try encodeContainer.encode(regionalHostedZoneId, forKey: .regionalHostedZoneId)
        }
        if let securityPolicy = securityPolicy {
            try encodeContainer.encode(securityPolicy.rawValue, forKey: .securityPolicy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
    }
}

extension DomainName: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainName(certificateArn: \(String(describing: certificateArn)), certificateName: \(String(describing: certificateName)), certificateUploadDate: \(String(describing: certificateUploadDate)), distributionDomainName: \(String(describing: distributionDomainName)), distributionHostedZoneId: \(String(describing: distributionHostedZoneId)), domainName: \(String(describing: domainName)), domainNameStatus: \(String(describing: domainNameStatus)), domainNameStatusMessage: \(String(describing: domainNameStatusMessage)), endpointConfiguration: \(String(describing: endpointConfiguration)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)), regionalCertificateArn: \(String(describing: regionalCertificateArn)), regionalCertificateName: \(String(describing: regionalCertificateName)), regionalDomainName: \(String(describing: regionalDomainName)), regionalHostedZoneId: \(String(describing: regionalHostedZoneId)), securityPolicy: \(String(describing: securityPolicy)), tags: \(String(describing: tags)))"}
}

/// <p>Represents a custom domain name as a user-friendly host name of an API (<a>RestApi</a>).</p>
///         <div class="Remarks">
///             <p>When you deploy an API, API Gateway creates a default host name for the API. This default API host name is of the <code>{restapi-id}.execute-api.{region}.amazonaws.com</code> format. With the default host name, you can access the API's root resource with the URL of <code>https://{restapi-id}.execute-api.{region}.amazonaws.com/{stage}/</code>. When you set up a custom domain name of <code>apis.example.com</code> for this API, you can then access the same resource using the URL of the <code>https://apis.examples.com/myApi</code>, where <code>myApi</code> is the base path mapping (<a>BasePathMapping</a>) of your API under the custom domain name.
///             </p>
///         </div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">Set a Custom Host Name for an API</a>
///       </div>
public struct DomainName: Equatable {
    /// <p>The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.</p>
    public let certificateArn: String?
    /// <p>The name of the certificate that will be used by edge-optimized endpoint for this domain name.</p>
    public let certificateName: String?
    /// <p>The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.</p>
    public let certificateUploadDate: Date?
    /// <p>The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the <a target="_blank" href="https://aws.amazon.com/documentation/cloudfront/">Amazon CloudFront documentation</a>.</p>
    public let distributionDomainName: String?
    /// <p>The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is <code>Z2FDTNDATAQYW2</code> for all the regions. For more information, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html">Set up a Regional Custom Domain Name</a> and <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region">AWS Regions and Endpoints for API Gateway</a>. </p>
    public let distributionHostedZoneId: String?
    /// <p>The custom domain name as an API host name, for example, <code>my-api.example.com</code>.</p>
    public let domainName: String?
    /// <p>The status of the <a>DomainName</a> migration. The valid values are <code>AVAILABLE</code> and <code>UPDATING</code>. If the status is <code>UPDATING</code>, the domain cannot be modified further until the existing operation is complete. If it is <code>AVAILABLE</code>, the domain can be updated.</p>
    public let domainNameStatus: DomainNameStatus?
    /// <p>An optional text message containing detailed information about status of the <a>DomainName</a> migration.</p>
    public let domainNameStatusMessage: String?
    /// <p>The endpoint configuration of this <a>DomainName</a> showing the endpoint types of the domain name.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.</p>
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    /// <p>The reference to an AWS-managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.</p>
    public let regionalCertificateArn: String?
    /// <p>The name of the certificate that will be used for validating the regional domain name.</p>
    public let regionalCertificateName: String?
    /// <p>The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.</p>
    public let regionalDomainName: String?
    /// <p>The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html">Set up a Regional Custom Domain Name</a> and  <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region">AWS Regions and Endpoints for API Gateway</a>. </p>
    public let regionalHostedZoneId: String?
    /// <p>The Transport Layer Security (TLS) version + cipher suite for this <a>DomainName</a>. The valid values are <code>TLS_1_0</code> and <code>TLS_1_2</code>.</p>
    public let securityPolicy: SecurityPolicy?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        certificateArn: String? = nil,
        certificateName: String? = nil,
        certificateUploadDate: Date? = nil,
        distributionDomainName: String? = nil,
        distributionHostedZoneId: String? = nil,
        domainName: String? = nil,
        domainNameStatus: DomainNameStatus? = nil,
        domainNameStatusMessage: String? = nil,
        endpointConfiguration: EndpointConfiguration? = nil,
        mutualTlsAuthentication: MutualTlsAuthentication? = nil,
        regionalCertificateArn: String? = nil,
        regionalCertificateName: String? = nil,
        regionalDomainName: String? = nil,
        regionalHostedZoneId: String? = nil,
        securityPolicy: SecurityPolicy? = nil,
        tags: [String:String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

public enum DomainNameStatus {
    case available
    case pending
    case updating
    case sdkUnknown(String)
}

extension DomainNameStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DomainNameStatus] {
        return [
            .available,
            .pending,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .pending: return "PENDING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DomainNameStatus(rawValue: rawValue) ?? DomainNameStatus.sdkUnknown(rawValue)
    }
}

extension EndpointConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case types
        case vpcEndpointIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for listofendpointtype0 in types {
                try typesContainer.encode(listofendpointtype0.rawValue)
            }
        }
        if let vpcEndpointIds = vpcEndpointIds {
            var vpcEndpointIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcEndpointIds)
            for listofstring0 in vpcEndpointIds {
                try vpcEndpointIdsContainer.encode(listofstring0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesContainer = try containerValues.decodeIfPresent([EndpointType?].self, forKey: .types)
        var typesDecoded0:[EndpointType]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [EndpointType]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
        let vpcEndpointIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .vpcEndpointIds)
        var vpcEndpointIdsDecoded0:[String]? = nil
        if let vpcEndpointIdsContainer = vpcEndpointIdsContainer {
            vpcEndpointIdsDecoded0 = [String]()
            for string0 in vpcEndpointIdsContainer {
                if let string0 = string0 {
                    vpcEndpointIdsDecoded0?.append(string0)
                }
            }
        }
        vpcEndpointIds = vpcEndpointIdsDecoded0
    }
}

extension EndpointConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointConfiguration(types: \(String(describing: types)), vpcEndpointIds: \(String(describing: vpcEndpointIds)))"}
}

/// <p>The endpoint configuration to indicate the types of endpoints an API (<a>RestApi</a>) or its custom domain name (<a>DomainName</a>) has. </p>
public struct EndpointConfiguration: Equatable {
    /// <p>A list of endpoint types of an API (<a>RestApi</a>) or its custom domain name (<a>DomainName</a>). For an edge-optimized API and its custom domain name, the endpoint type is <code>"EDGE"</code>. For a regional API and its custom domain name, the endpoint type is <code>REGIONAL</code>. For a private API, the endpoint type is <code>PRIVATE</code>.</p>
    public let types: [EndpointType]?
    /// <p>A list of VpcEndpointIds of an API (<a>RestApi</a>) against which to create Route53 ALIASes. It is only supported for <code>PRIVATE</code> endpoint type.</p>
    public let vpcEndpointIds: [String]?

    public init (
        types: [EndpointType]? = nil,
        vpcEndpointIds: [String]? = nil
    )
    {
        self.types = types
        self.vpcEndpointIds = vpcEndpointIds
    }
}

/// <p>The endpoint type. The valid values are <code>EDGE</code> for edge-optimized API setup, most suitable for mobile applications; <code>REGIONAL</code> for regional API endpoint setup, most suitable for calling from AWS Region; and <code>PRIVATE</code> for private APIs.</p>
public enum EndpointType {
    case edge
    case `private`
    case regional
    case sdkUnknown(String)
}

extension EndpointType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EndpointType] {
        return [
            .edge,
            .private,
            .regional,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .edge: return "EDGE"
        case .private: return "PRIVATE"
        case .regional: return "REGIONAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
    }
}

extension FlushStageAuthorizersCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlushStageAuthorizersCacheInput(restApiId: \(String(describing: restApiId)), stageName: \(String(describing: stageName)))"}
}

extension FlushStageAuthorizersCacheInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct FlushStageAuthorizersCacheInputHeadersMiddleware: Middleware {
    public let id: String = "FlushStageAuthorizersCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FlushStageAuthorizersCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<FlushStageAuthorizersCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FlushStageAuthorizersCacheInput>
    public typealias MOutput = OperationOutput<FlushStageAuthorizersCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FlushStageAuthorizersCacheOutputError>
}

public struct FlushStageAuthorizersCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "FlushStageAuthorizersCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FlushStageAuthorizersCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<FlushStageAuthorizersCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FlushStageAuthorizersCacheInput>
    public typealias MOutput = OperationOutput<FlushStageAuthorizersCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FlushStageAuthorizersCacheOutputError>
}

/// <p>Request to flush authorizer cache entries on a specified stage.</p>
public struct FlushStageAuthorizersCacheInput: Equatable {
    /// <p>The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>The name of the stage to flush.</p>
    public let stageName: String?

    public init (
        restApiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct FlushStageAuthorizersCacheInputBody: Equatable {
}

extension FlushStageAuthorizersCacheInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension FlushStageAuthorizersCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FlushStageAuthorizersCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FlushStageAuthorizersCacheOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FlushStageAuthorizersCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlushStageAuthorizersCacheOutputResponse()"}
}

extension FlushStageAuthorizersCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct FlushStageAuthorizersCacheOutputResponse: Equatable {

    public init() {}
}

struct FlushStageAuthorizersCacheOutputResponseBody: Equatable {
}

extension FlushStageAuthorizersCacheOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension FlushStageCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlushStageCacheInput(restApiId: \(String(describing: restApiId)), stageName: \(String(describing: stageName)))"}
}

extension FlushStageCacheInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct FlushStageCacheInputHeadersMiddleware: Middleware {
    public let id: String = "FlushStageCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FlushStageCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<FlushStageCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FlushStageCacheInput>
    public typealias MOutput = OperationOutput<FlushStageCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FlushStageCacheOutputError>
}

public struct FlushStageCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "FlushStageCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FlushStageCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<FlushStageCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FlushStageCacheInput>
    public typealias MOutput = OperationOutput<FlushStageCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FlushStageCacheOutputError>
}

/// <p>Requests API Gateway to flush a stage's cache.</p>
public struct FlushStageCacheInput: Equatable {
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The name of the stage to flush its cache.</p>
    public let stageName: String?

    public init (
        restApiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct FlushStageCacheInputBody: Equatable {
}

extension FlushStageCacheInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension FlushStageCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FlushStageCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FlushStageCacheOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FlushStageCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlushStageCacheOutputResponse()"}
}

extension FlushStageCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct FlushStageCacheOutputResponse: Equatable {

    public init() {}
}

struct FlushStageCacheOutputResponseBody: Equatable {
}

extension FlushStageCacheOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GatewayResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultResponse != false {
            try encodeContainer.encode(defaultResponse, forKey: .defaultResponse)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtostring0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseTemplates)
            for (dictKey0, mapofstringtostring0) in responseTemplates {
                try responseTemplatesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseType = responseType {
            try encodeContainer.encode(responseType.rawValue, forKey: .responseType)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decode(Bool.self, forKey: .defaultResponse)
        defaultResponse = defaultResponseDecoded
    }
}

extension GatewayResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayResponse(defaultResponse: \(String(describing: defaultResponse)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), responseType: \(String(describing: responseType)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>A gateway response of a given response type and status code, with optional response parameters and mapping templates.</p>
///         <div class="remarks">
///             For more information about valid gateway response types, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html">Gateway Response Types Supported by API Gateway</a>
///             <div class="example">
///     <h4>Example: Get a Gateway Response of a given response type</h4>
///     <h5>Request</h5>
///     <p>This example shows how to get a gateway response of the <code>MISSING_AUTHENTICATION_TOKEN</code> type.</p>
///     <pre><code>GET /restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN HTTP/1.1
/// Host: beta-apigateway.us-east-1.amazonaws.com
/// Content-Type: application/json
/// X-Amz-Date: 20170503T202516Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=1b52460e3159c1a26cff29093855d50ea141c1c5b937528fecaf60f51129697a
/// Cache-Control: no-cache
/// Postman-Token: 3b2a1ce9-c848-2e26-2e2f-9c2caefbed45
/// </code></pre>
///     <p>The response type is specified as a URL path.</p>
///     <h5>Response</h5>
///     <p>The successful operation returns the <code>200 OK</code> status code and a payload similar to the following:</p>
///     <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html",
///       "name": "gatewayresponse",
///       "templated": true
///     },
///     "self": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     },
///     "gatewayresponse:delete": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     },
///     "gatewayresponse:put": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///       "templated": true
///     },
///     "gatewayresponse:update": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     }
///   },
///   "defaultResponse": false,
///   "responseParameters": {
///     "gatewayresponse.header.x-request-path": "method.request.path.petId",
///     "gatewayresponse.header.Access-Control-Allow-Origin": "'a.b.c'",
///     "gatewayresponse.header.x-request-query": "method.request.querystring.q",
///     "gatewayresponse.header.x-request-header": "method.request.header.Accept"
///   },
///   "responseTemplates": {
///     "application/json": "{\n     \"message\": $context.error.messageString,\n     \"type\":  \"$context.error.responseType\",\n     \"stage\":  \"$context.stage\",\n     \"resourcePath\":  \"$context.resourcePath\",\n     \"stageVariables.a\":  \"$stageVariables.a\",\n     \"statusCode\": \"'404'\"\n}"
///   },
///   "responseType": "MISSING_AUTHENTICATION_TOKEN",
///   "statusCode": "404"
/// }</code></pre>
///     <p></p>
///   </div>
///         </div>
///         <div class="seeAlso">
///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html">Customize Gateway Responses</a>
///         </div>
public struct GatewayResponse: Equatable {
    /// <p>A Boolean flag to indicate whether this <a>GatewayResponse</a> is the default gateway response (<code>true</code>) or not (<code>false</code>). A default gateway response is one generated by API Gateway without any customization by an API developer. </p>
    public let defaultResponse: Bool
    /// <p>Response parameters (paths, query strings and headers) of the <a>GatewayResponse</a> as a string-to-string map of key-value  pairs.</p>
    public let responseParameters: [String:String]?
    /// <p>Response templates of the <a>GatewayResponse</a> as a string-to-string map of key-value pairs.</p>
    public let responseTemplates: [String:String]?
    /// <p>The response type of the associated <a>GatewayResponse</a>. Valid values are <ul><li>ACCESS_DENIED</li><li>API_CONFIGURATION_ERROR</li><li>AUTHORIZER_FAILURE</li><li> AUTHORIZER_CONFIGURATION_ERROR</li><li>BAD_REQUEST_PARAMETERS</li><li>BAD_REQUEST_BODY</li><li>DEFAULT_4XX</li><li>DEFAULT_5XX</li><li>EXPIRED_TOKEN</li><li>INVALID_SIGNATURE</li><li>INTEGRATION_FAILURE</li><li>INTEGRATION_TIMEOUT</li><li>INVALID_API_KEY</li><li>MISSING_AUTHENTICATION_TOKEN</li><li> QUOTA_EXCEEDED</li><li>REQUEST_TOO_LARGE</li><li>RESOURCE_NOT_FOUND</li><li>THROTTLED</li><li>UNAUTHORIZED</li><li>UNSUPPORTED_MEDIA_TYPE</li></ul> </p>
    public let responseType: GatewayResponseType?
    /// <p>The HTTP status code for this <a>GatewayResponse</a>.</p>
    public let statusCode: String?

    public init (
        defaultResponse: Bool = false,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        responseType: GatewayResponseType? = nil,
        statusCode: String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

public enum GatewayResponseType {
    case accessDenied
    case apiConfigurationError
    case authorizerConfigurationError
    case authorizerFailure
    case badRequestBody
    case badRequestParameters
    case default4xx
    case default5xx
    case expiredToken
    case integrationFailure
    case integrationTimeout
    case invalidApiKey
    case invalidSignature
    case missingAuthenticationToken
    case quotaExceeded
    case requestTooLarge
    case resourceNotFound
    case throttled
    case unauthorized
    case unsupportedMediaType
    case sdkUnknown(String)
}

extension GatewayResponseType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GatewayResponseType] {
        return [
            .accessDenied,
            .apiConfigurationError,
            .authorizerConfigurationError,
            .authorizerFailure,
            .badRequestBody,
            .badRequestParameters,
            .default4xx,
            .default5xx,
            .expiredToken,
            .integrationFailure,
            .integrationTimeout,
            .invalidApiKey,
            .invalidSignature,
            .missingAuthenticationToken,
            .quotaExceeded,
            .requestTooLarge,
            .resourceNotFound,
            .throttled,
            .unauthorized,
            .unsupportedMediaType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "ACCESS_DENIED"
        case .apiConfigurationError: return "API_CONFIGURATION_ERROR"
        case .authorizerConfigurationError: return "AUTHORIZER_CONFIGURATION_ERROR"
        case .authorizerFailure: return "AUTHORIZER_FAILURE"
        case .badRequestBody: return "BAD_REQUEST_BODY"
        case .badRequestParameters: return "BAD_REQUEST_PARAMETERS"
        case .default4xx: return "DEFAULT_4XX"
        case .default5xx: return "DEFAULT_5XX"
        case .expiredToken: return "EXPIRED_TOKEN"
        case .integrationFailure: return "INTEGRATION_FAILURE"
        case .integrationTimeout: return "INTEGRATION_TIMEOUT"
        case .invalidApiKey: return "INVALID_API_KEY"
        case .invalidSignature: return "INVALID_SIGNATURE"
        case .missingAuthenticationToken: return "MISSING_AUTHENTICATION_TOKEN"
        case .quotaExceeded: return "QUOTA_EXCEEDED"
        case .requestTooLarge: return "REQUEST_TOO_LARGE"
        case .resourceNotFound: return "RESOURCE_NOT_FOUND"
        case .throttled: return "THROTTLED"
        case .unauthorized: return "UNAUTHORIZED"
        case .unsupportedMediaType: return "UNSUPPORTED_MEDIA_TYPE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GatewayResponseType(rawValue: rawValue) ?? GatewayResponseType.sdkUnknown(rawValue)
    }
}

public struct GenerateClientCertificateInputBodyMiddleware: Middleware {
    public let id: String = "GenerateClientCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateClientCertificateInput>
    public typealias MOutput = OperationOutput<GenerateClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateClientCertificateOutputError>
}

extension GenerateClientCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateClientCertificateInput(description: \(String(describing: description)), tags: \(String(describing: tags)))"}
}

extension GenerateClientCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct GenerateClientCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateClientCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateClientCertificateInput>
    public typealias MOutput = OperationOutput<GenerateClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateClientCertificateOutputError>
}

public struct GenerateClientCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateClientCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateClientCertificateInput>
    public typealias MOutput = OperationOutput<GenerateClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateClientCertificateOutputError>
}

/// <p>A request to generate a <a>ClientCertificate</a> resource.</p>
public struct GenerateClientCertificateInput: Equatable {
    /// <p>The description of the <a>ClientCertificate</a>.</p>
    public let description: String?
    /// <p>The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.tags = tags
    }
}

struct GenerateClientCertificateInputBody: Equatable {
    public let description: String?
    public let tags: [String:String]?
}

extension GenerateClientCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GenerateClientCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateClientCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateClientCertificateOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateClientCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateClientCertificateOutputResponse(clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), expirationDate: \(String(describing: expirationDate)), pemEncodedCertificate: \(String(describing: pemEncodedCertificate)), tags: \(String(describing: tags)))"}
}

extension GenerateClientCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateClientCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.pemEncodedCertificate = output.pemEncodedCertificate
            self.tags = output.tags
        } else {
            self.clientCertificateId = nil
            self.createdDate = nil
            self.description = nil
            self.expirationDate = nil
            self.pemEncodedCertificate = nil
            self.tags = nil
        }
    }
}

/// <p>Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.</p>
///         <div class="remarks">Client certificates are used to authenticate an API by the backend server. To authenticate an API client (or user), use IAM roles and policies, a custom <a>Authorizer</a> or an Amazon Cognito user pool.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html">Use Client-Side Certificate</a>
///       </div>
public struct GenerateClientCertificateOutputResponse: Equatable {
    /// <p>The identifier of the client certificate.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the client certificate was created.</p>
    public let createdDate: Date?
    /// <p>The description of the client certificate.</p>
    public let description: String?
    /// <p>The timestamp when the client certificate will expire.</p>
    public let expirationDate: Date?
    /// <p>The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .</p>
    public let pemEncodedCertificate: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        expirationDate: Date? = nil,
        pemEncodedCertificate: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

struct GenerateClientCertificateOutputResponseBody: Equatable {
    public let clientCertificateId: String?
    public let description: String?
    public let pemEncodedCertificate: String?
    public let createdDate: Date?
    public let expirationDate: Date?
    public let tags: [String:String]?
}

extension GenerateClientCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountInput()"}
}

extension GetAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountInput>
    public typealias MOutput = OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountOutputError>
}

public struct GetAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountInput>
    public typealias MOutput = OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountOutputError>
}

/// <p>Requests API Gateway to get information about the current <a>Account</a> resource.</p>
public struct GetAccountInput: Equatable {

    public init() {}
}

struct GetAccountInputBody: Equatable {
}

extension GetAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountOutputResponse(apiKeyVersion: \(String(describing: apiKeyVersion)), cloudwatchRoleArn: \(String(describing: cloudwatchRoleArn)), features: \(String(describing: features)), throttleSettings: \(String(describing: throttleSettings)))"}
}

extension GetAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeyVersion = output.apiKeyVersion
            self.cloudwatchRoleArn = output.cloudwatchRoleArn
            self.features = output.features
            self.throttleSettings = output.throttleSettings
        } else {
            self.apiKeyVersion = nil
            self.cloudwatchRoleArn = nil
            self.features = nil
            self.throttleSettings = nil
        }
    }
}

/// <p>Represents an AWS account that is associated with API Gateway.</p>
///         <div class="remarks">
///           <p>To view the account info, call <code>GET</code> on this resource.</p>
///           <h4>Error Codes</h4>
///           <p>The following exception may be thrown when the request fails.</p>
///           <ul>
///             <li>UnauthorizedException</li>
///             <li>NotFoundException</li>
///             <li>TooManyRequestsException</li>
///           </ul>
///           <p>For detailed error code information, including the corresponding HTTP Status Codes, see <a href="https://docs.aws.amazon.com/apigateway/api-reference/handling-errors/#api-error-codes">API Gateway Error Codes</a></p>
///             <h4>Example: Get the information about an account.</h4>
///             <h5>Request</h5>
///             <pre><code>GET /account HTTP/1.1
/// Content-Type: application/json
/// Host: apigateway.us-east-1.amazonaws.com
/// X-Amz-Date: 20160531T184618Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
///             </code></pre>
///             <h5>Response</h5>
///             <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
///             <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/account-apigateway-{rel}.html",
///       "name": "account",
///       "templated": true
///     },
///     "self": {
///       "href": "/account"
///     },
///     "account:update": {
///       "href": "/account"
///     }
///   },
///   "cloudwatchRoleArn": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
///   "throttleSettings": {
///     "rateLimit": 500,
///     "burstLimit": 1000
///   }
/// }
///             </code></pre>
///             <p>In addition to making the REST API call directly, you can use the AWS CLI and an AWS SDK to access this resource.</p>
///         </div>
///         <div class="seeAlso">
///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-limits.html">API Gateway Limits</a>
///             <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html">Developer Guide</a>,
///             <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-account.html">AWS CLI</a>
///         </div>
public struct GetAccountOutputResponse: Equatable {
    /// <p>The version of the API keys used for the account.</p>
    public let apiKeyVersion: String?
    /// <p>The ARN of an Amazon CloudWatch role for the current <a>Account</a>. </p>
    public let cloudwatchRoleArn: String?
    /// <p>A list of features supported for the account. When usage plans are enabled, the features list will include an entry of <code>"UsagePlans"</code>.</p>
    public let features: [String]?
    /// <p>Specifies the API request limits configured for the current <a>Account</a>.</p>
    public let throttleSettings: ThrottleSettings?

    public init (
        apiKeyVersion: String? = nil,
        cloudwatchRoleArn: String? = nil,
        features: [String]? = nil,
        throttleSettings: ThrottleSettings? = nil
    )
    {
        self.apiKeyVersion = apiKeyVersion
        self.cloudwatchRoleArn = cloudwatchRoleArn
        self.features = features
        self.throttleSettings = throttleSettings
    }
}

struct GetAccountOutputResponseBody: Equatable {
    public let cloudwatchRoleArn: String?
    public let throttleSettings: ThrottleSettings?
    public let features: [String]?
    public let apiKeyVersion: String?
}

extension GetAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeyVersion
        case cloudwatchRoleArn
        case features
        case throttleSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudwatchRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudwatchRoleArn)
        cloudwatchRoleArn = cloudwatchRoleArnDecoded
        let throttleSettingsDecoded = try containerValues.decodeIfPresent(ThrottleSettings.self, forKey: .throttleSettings)
        throttleSettings = throttleSettingsDecoded
        let featuresContainer = try containerValues.decodeIfPresent([String?].self, forKey: .features)
        var featuresDecoded0:[String]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [String]()
            for string0 in featuresContainer {
                if let string0 = string0 {
                    featuresDecoded0?.append(string0)
                }
            }
        }
        features = featuresDecoded0
        let apiKeyVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeyVersion)
        apiKeyVersion = apiKeyVersionDecoded
    }
}

extension GetApiKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiKeyInput(apiKey: \(String(describing: apiKey)), includeValue: \(String(describing: includeValue)))"}
}

extension GetApiKeyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApiKeyInputHeadersMiddleware: Middleware {
    public let id: String = "GetApiKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiKeyInput>
    public typealias MOutput = OperationOutput<GetApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiKeyOutputError>
}

public struct GetApiKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApiKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let includeValue = input.operationInput.includeValue {
            let includeValueQueryItem = URLQueryItem(name: "includeValue".urlPercentEncoding(), value: String(includeValue).urlPercentEncoding())
            input.builder.withQueryItem(includeValueQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiKeyInput>
    public typealias MOutput = OperationOutput<GetApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiKeyOutputError>
}

/// <p>A request to get information about the current <a>ApiKey</a> resource.</p>
public struct GetApiKeyInput: Equatable {
    /// <p>[Required] The identifier of the <a>ApiKey</a> resource.</p>
    public let apiKey: String?
    /// <p>A boolean flag to specify whether (<code>true</code>) or not (<code>false</code>) the result contains the key value.</p>
    public let includeValue: Bool?

    public init (
        apiKey: String? = nil,
        includeValue: Bool? = nil
    )
    {
        self.apiKey = apiKey
        self.includeValue = includeValue
    }
}

struct GetApiKeyInputBody: Equatable {
}

extension GetApiKeyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApiKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiKeyOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiKeyOutputResponse(createdDate: \(String(describing: createdDate)), customerId: \(String(describing: customerId)), description: \(String(describing: description)), enabled: \(String(describing: enabled)), id: \(String(describing: id)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), name: \(String(describing: name)), stageKeys: \(String(describing: stageKeys)), tags: \(String(describing: tags)), value: \(String(describing: value)))"}
}

extension GetApiKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdDate = output.createdDate
            self.customerId = output.customerId
            self.description = output.description
            self.enabled = output.enabled
            self.id = output.id
            self.lastUpdatedDate = output.lastUpdatedDate
            self.name = output.name
            self.stageKeys = output.stageKeys
            self.tags = output.tags
            self.value = output.value
        } else {
            self.createdDate = nil
            self.customerId = nil
            self.description = nil
            self.enabled = false
            self.id = nil
            self.lastUpdatedDate = nil
            self.name = nil
            self.stageKeys = nil
            self.tags = nil
            self.value = nil
        }
    }
}

/// <p>A resource that can be distributed to callers for executing <a>Method</a> resources that require an API key. API keys can be mapped to any <a>Stage</a> on any <a>RestApi</a>, which indicates that the callers with the API key can make requests to that stage.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html">Use API Keys</a>
///       </div>
public struct GetApiKeyOutputResponse: Equatable {
    /// <p>The timestamp when the API Key was created.</p>
    public let createdDate: Date?
    /// <p>An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.</p>
    public let customerId: String?
    /// <p>The description of the API Key.</p>
    public let description: String?
    /// <p>Specifies whether the API Key can be used by callers.</p>
    public let enabled: Bool
    /// <p>The identifier of the API Key.</p>
    public let id: String?
    /// <p>The timestamp when the API Key was last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>The name of the API Key.</p>
    public let name: String?
    /// <p>A list of <a>Stage</a> resources that are associated with the <a>ApiKey</a> resource.</p>
    public let stageKeys: [String]?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The value of the API Key.</p>
    public let value: String?

    public init (
        createdDate: Date? = nil,
        customerId: String? = nil,
        description: String? = nil,
        enabled: Bool = false,
        id: String? = nil,
        lastUpdatedDate: Date? = nil,
        name: String? = nil,
        stageKeys: [String]? = nil,
        tags: [String:String]? = nil,
        value: String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct GetApiKeyOutputResponseBody: Equatable {
    public let id: String?
    public let value: String?
    public let name: String?
    public let customerId: String?
    public let description: String?
    public let enabled: Bool
    public let createdDate: Date?
    public let lastUpdatedDate: Date?
    public let stageKeys: [String]?
    public let tags: [String:String]?
}

extension GetApiKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetApiKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiKeysInput(customerId: \(String(describing: customerId)), includeValues: \(String(describing: includeValues)), limit: \(String(describing: limit)), nameQuery: \(String(describing: nameQuery)), position: \(String(describing: position)))"}
}

extension GetApiKeysInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApiKeysInputHeadersMiddleware: Middleware {
    public let id: String = "GetApiKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiKeysInput>
    public typealias MOutput = OperationOutput<GetApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiKeysOutputError>
}

public struct GetApiKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApiKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let includeValues = input.operationInput.includeValues {
            let includeValuesQueryItem = URLQueryItem(name: "includeValues".urlPercentEncoding(), value: String(includeValues).urlPercentEncoding())
            input.builder.withQueryItem(includeValuesQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let customerId = input.operationInput.customerId {
            let customerIdQueryItem = URLQueryItem(name: "customerId".urlPercentEncoding(), value: String(customerId).urlPercentEncoding())
            input.builder.withQueryItem(customerIdQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        if let nameQuery = input.operationInput.nameQuery {
            let nameQueryQueryItem = URLQueryItem(name: "name".urlPercentEncoding(), value: String(nameQuery).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiKeysInput>
    public typealias MOutput = OperationOutput<GetApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiKeysOutputError>
}

/// <p>A request to get information about the current <a>ApiKeys</a> resource.</p>
public struct GetApiKeysInput: Equatable {
    /// <p>The identifier of a customer in AWS Marketplace or an external system, such as a developer portal.</p>
    public let customerId: String?
    /// <p>A boolean flag to specify whether (<code>true</code>) or not (<code>false</code>) the result contains key values.</p>
    public let includeValues: Bool?
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The name of queried API keys.</p>
    public let nameQuery: String?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        customerId: String? = nil,
        includeValues: Bool? = nil,
        limit: Int? = nil,
        nameQuery: String? = nil,
        position: String? = nil
    )
    {
        self.customerId = customerId
        self.includeValues = includeValues
        self.limit = limit
        self.nameQuery = nameQuery
        self.position = position
    }
}

struct GetApiKeysInputBody: Equatable {
}

extension GetApiKeysInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApiKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiKeysOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiKeysOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)), warnings: \(String(describing: warnings)))"}
}

extension GetApiKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApiKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.warnings = output.warnings
        } else {
            self.items = nil
            self.warnings = nil
        }
        self.position = nil
    }
}

/// <p>Represents a collection of API keys as represented by an <a>ApiKeys</a> resource.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html">Use API Keys</a>
///       </div>
public struct GetApiKeysOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [ApiKey]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>A list of warning messages logged during the import of API keys when the <code>failOnWarnings</code> option is set to true.</p>
    public let warnings: [String]?

    public init (
        items: [ApiKey]? = nil,
        position: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.items = items
        self.position = position
        self.warnings = warnings
    }
}

struct GetApiKeysOutputResponseBody: Equatable {
    public let warnings: [String]?
    public let items: [ApiKey]?
}

extension GetApiKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
        case warnings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let itemsContainer = try containerValues.decodeIfPresent([ApiKey?].self, forKey: .items)
        var itemsDecoded0:[ApiKey]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiKey]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizerInput(authorizerId: \(String(describing: authorizerId)), restApiId: \(String(describing: restApiId)))"}
}

extension GetAuthorizerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "GetAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizerInput>
    public typealias MOutput = OperationOutput<GetAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizerOutputError>
}

public struct GetAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizerInput>
    public typealias MOutput = OperationOutput<GetAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizerOutputError>
}

/// <p>Request to describe an existing <a>Authorizer</a> resource.</p>
public struct GetAuthorizerInput: Equatable {
    /// <p>[Required] The identifier of the <a>Authorizer</a> resource.</p>
    public let authorizerId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        authorizerId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.restApiId = restApiId
    }
}

struct GetAuthorizerInputBody: Equatable {
}

extension GetAuthorizerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizerOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizerOutputResponse(authType: \(String(describing: authType)), authorizerCredentials: \(String(describing: authorizerCredentials)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerUri: \(String(describing: authorizerUri)), id: \(String(describing: id)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), name: \(String(describing: name)), providerARNs: \(String(describing: providerARNs)), type: \(String(describing: type)))"}
}

extension GetAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authType = output.authType
            self.authorizerCredentials = output.authorizerCredentials
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerUri = output.authorizerUri
            self.id = output.id
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.name = output.name
            self.providerARNs = output.providerARNs
            self.type = output.type
        } else {
            self.authType = nil
            self.authorizerCredentials = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerUri = nil
            self.id = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.name = nil
            self.providerARNs = nil
            self.type = nil
        }
    }
}

/// <p>Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html">Use Lambda Function as Authorizer</a>
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html">Use Cognito User Pool as Authorizer</a>
///       </div>
public struct GetAuthorizerOutputResponse: Equatable {
    /// <p>Optional customer-defined field, used in OpenAPI imports and exports without functional impact.</p>
    public let authType: String?
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.</p>
    public let authorizerCredentials: String?
    /// <p>The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.</p>
    public let authorizerResultTtlInSeconds: Int?
    /// <p>Specifies the authorizer's Uniform Resource Identifier (URI). For <code>TOKEN</code> or <code>REQUEST</code> authorizers, this must be a well-formed Lambda function URI, for example, <code>arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations</code>. In general, the URI has this form  <code>arn:aws:apigateway:{region}:lambda:path/{service_api}</code>, where <code>{region}</code> is the same as the region hosting the Lambda function, <code>path</code> indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial <code>/</code>. For Lambda functions, this is usually of the form <code>/2015-03-31/functions/[FunctionARN]/invocations</code>.</p>
    public let authorizerUri: String?
    /// <p>The identifier for the authorizer resource.</p>
    public let id: String?
    /// <p>The identity source for which authorization is requested. <ul><li>For a <code>TOKEN</code> or <code>COGNITO_USER_POOLS</code> authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is <code>Auth</code>, the header mapping expression is  <code>method.request.header.Auth</code>.</li><li>For the <code>REQUEST</code> authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an <code>Auth</code> header, a <code>Name</code> query string parameter are defined as identity sources, this value is <code>method.request.header.Auth, method.request.querystring.Name</code>.  These parameters will be used to derive the authorization caching key and to perform runtime validation of the <code>REQUEST</code> authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.</li></ul></p>
    public let identitySource: String?
    /// <p>A validation expression for the incoming identity token. For <code>TOKEN</code> authorizers, this value is a regular expression. For <code>COGNITO_USER_POOLS</code> authorizers, API Gateway will match the <code>aud</code> field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the <code>REQUEST</code> authorizer.</p>
    public let identityValidationExpression: String?
    /// <p>[Required] The name of the authorizer.</p>
    public let name: String?
    /// <p>A list of the Amazon Cognito user pool ARNs for the <code>COGNITO_USER_POOLS</code> authorizer. Each element is of this format: <code>arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}</code>. For a <code>TOKEN</code> or <code>REQUEST</code> authorizer, this is not defined.</p>
    public let providerARNs: [String]?
    /// <p>The authorizer type. Valid values are <code>TOKEN</code> for a Lambda function using a single authorization token submitted in a custom header, <code>REQUEST</code> for a Lambda function using incoming request parameters, and <code>COGNITO_USER_POOLS</code> for using an Amazon Cognito user pool.</p>
    public let type: AuthorizerType?

    public init (
        authType: String? = nil,
        authorizerCredentials: String? = nil,
        authorizerResultTtlInSeconds: Int? = nil,
        authorizerUri: String? = nil,
        id: String? = nil,
        identitySource: String? = nil,
        identityValidationExpression: String? = nil,
        name: String? = nil,
        providerARNs: [String]? = nil,
        type: AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

struct GetAuthorizerOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let type: AuthorizerType?
    public let providerARNs: [String]?
    public let authType: String?
    public let authorizerUri: String?
    public let authorizerCredentials: String?
    public let identitySource: String?
    public let identityValidationExpression: String?
    public let authorizerResultTtlInSeconds: Int?
}

extension GetAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

extension GetAuthorizersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizersInput(limit: \(String(describing: limit)), position: \(String(describing: position)), restApiId: \(String(describing: restApiId)))"}
}

extension GetAuthorizersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAuthorizersInputHeadersMiddleware: Middleware {
    public let id: String = "GetAuthorizersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizersInput>
    public typealias MOutput = OperationOutput<GetAuthorizersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizersOutputError>
}

public struct GetAuthorizersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAuthorizersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizersInput>
    public typealias MOutput = OperationOutput<GetAuthorizersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizersOutputError>
}

/// <p>Request to describe an existing <a>Authorizers</a> resource.</p>
public struct GetAuthorizersInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        limit: Int? = nil,
        position: String? = nil,
        restApiId: String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetAuthorizersInputBody: Equatable {
}

extension GetAuthorizersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAuthorizersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizersOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizersOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetAuthorizersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAuthorizersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>Represents a collection of <a>Authorizer</a> resources.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html">Use Lambda Function as Authorizer</a>
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html">Use Cognito User Pool as Authorizer</a>
///       </div>
public struct GetAuthorizersOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [Authorizer]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [Authorizer]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetAuthorizersOutputResponseBody: Equatable {
    public let items: [Authorizer]?
}

extension GetAuthorizersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Authorizer?].self, forKey: .items)
        var itemsDecoded0:[Authorizer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Authorizer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetBasePathMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBasePathMappingInput(basePath: \(String(describing: basePath)), domainName: \(String(describing: domainName)))"}
}

extension GetBasePathMappingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBasePathMappingInputHeadersMiddleware: Middleware {
    public let id: String = "GetBasePathMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBasePathMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBasePathMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBasePathMappingInput>
    public typealias MOutput = OperationOutput<GetBasePathMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBasePathMappingOutputError>
}

public struct GetBasePathMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBasePathMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBasePathMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBasePathMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBasePathMappingInput>
    public typealias MOutput = OperationOutput<GetBasePathMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBasePathMappingOutputError>
}

/// <p>Request to describe a <a>BasePathMapping</a> resource.</p>
public struct GetBasePathMappingInput: Equatable {
    /// <p>[Required] The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify any base path name after the domain name.</p>
    public let basePath: String?
    /// <p>[Required] The domain name of the <a>BasePathMapping</a> resource to be described.</p>
    public let domainName: String?

    public init (
        basePath: String? = nil,
        domainName: String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
    }
}

struct GetBasePathMappingInputBody: Equatable {
}

extension GetBasePathMappingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBasePathMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBasePathMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBasePathMappingOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBasePathMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBasePathMappingOutputResponse(basePath: \(String(describing: basePath)), restApiId: \(String(describing: restApiId)), stage: \(String(describing: stage)))"}
}

extension GetBasePathMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBasePathMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.basePath = output.basePath
            self.restApiId = output.restApiId
            self.stage = output.stage
        } else {
            self.basePath = nil
            self.restApiId = nil
            self.stage = nil
        }
    }
}

/// <p>Represents the base path that callers of the API must provide as part of the URL after the domain name.</p>
///         <div class="remarks">A custom domain name plus a <code>BasePathMapping</code> specification identifies a deployed <a>RestApi</a> in a given stage of the owner <a>Account</a>.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">Use Custom Domain Names</a>
///       </div>
public struct GetBasePathMappingOutputResponse: Equatable {
    /// <p>The base path name that callers of the API must provide as part of the URL after the domain name.</p>
    public let basePath: String?
    /// <p>The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>The name of the associated stage.</p>
    public let stage: String?

    public init (
        basePath: String? = nil,
        restApiId: String? = nil,
        stage: String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct GetBasePathMappingOutputResponseBody: Equatable {
    public let basePath: String?
    public let restApiId: String?
    public let stage: String?
}

extension GetBasePathMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension GetBasePathMappingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBasePathMappingsInput(domainName: \(String(describing: domainName)), limit: \(String(describing: limit)), position: \(String(describing: position)))"}
}

extension GetBasePathMappingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBasePathMappingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetBasePathMappingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBasePathMappingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBasePathMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBasePathMappingsInput>
    public typealias MOutput = OperationOutput<GetBasePathMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBasePathMappingsOutputError>
}

public struct GetBasePathMappingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBasePathMappingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBasePathMappingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBasePathMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBasePathMappingsInput>
    public typealias MOutput = OperationOutput<GetBasePathMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBasePathMappingsOutputError>
}

/// <p>A request to get information about a collection of <a>BasePathMapping</a> resources.</p>
public struct GetBasePathMappingsInput: Equatable {
    /// <p>[Required] The domain name of a <a>BasePathMapping</a> resource.</p>
    public let domainName: String?
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        domainName: String? = nil,
        limit: Int? = nil,
        position: String? = nil
    )
    {
        self.domainName = domainName
        self.limit = limit
        self.position = position
    }
}

struct GetBasePathMappingsInputBody: Equatable {
}

extension GetBasePathMappingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBasePathMappingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBasePathMappingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBasePathMappingsOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBasePathMappingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBasePathMappingsOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetBasePathMappingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBasePathMappingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>Represents a collection of <a>BasePathMapping</a> resources.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">Use Custom Domain Names</a>
///       </div>
public struct GetBasePathMappingsOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [BasePathMapping]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [BasePathMapping]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetBasePathMappingsOutputResponseBody: Equatable {
    public let items: [BasePathMapping]?
}

extension GetBasePathMappingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([BasePathMapping?].self, forKey: .items)
        var itemsDecoded0:[BasePathMapping]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [BasePathMapping]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetClientCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClientCertificateInput(clientCertificateId: \(String(describing: clientCertificateId)))"}
}

extension GetClientCertificateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetClientCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "GetClientCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClientCertificateInput>
    public typealias MOutput = OperationOutput<GetClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClientCertificateOutputError>
}

public struct GetClientCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetClientCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClientCertificateInput>
    public typealias MOutput = OperationOutput<GetClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClientCertificateOutputError>
}

/// <p>A request to get information about the current <a>ClientCertificate</a> resource.</p>
public struct GetClientCertificateInput: Equatable {
    /// <p>[Required] The identifier of the <a>ClientCertificate</a> resource to be described.</p>
    public let clientCertificateId: String?

    public init (
        clientCertificateId: String? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
    }
}

struct GetClientCertificateInputBody: Equatable {
}

extension GetClientCertificateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetClientCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetClientCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetClientCertificateOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetClientCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClientCertificateOutputResponse(clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), expirationDate: \(String(describing: expirationDate)), pemEncodedCertificate: \(String(describing: pemEncodedCertificate)), tags: \(String(describing: tags)))"}
}

extension GetClientCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetClientCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.pemEncodedCertificate = output.pemEncodedCertificate
            self.tags = output.tags
        } else {
            self.clientCertificateId = nil
            self.createdDate = nil
            self.description = nil
            self.expirationDate = nil
            self.pemEncodedCertificate = nil
            self.tags = nil
        }
    }
}

/// <p>Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.</p>
///         <div class="remarks">Client certificates are used to authenticate an API by the backend server. To authenticate an API client (or user), use IAM roles and policies, a custom <a>Authorizer</a> or an Amazon Cognito user pool.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html">Use Client-Side Certificate</a>
///       </div>
public struct GetClientCertificateOutputResponse: Equatable {
    /// <p>The identifier of the client certificate.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the client certificate was created.</p>
    public let createdDate: Date?
    /// <p>The description of the client certificate.</p>
    public let description: String?
    /// <p>The timestamp when the client certificate will expire.</p>
    public let expirationDate: Date?
    /// <p>The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .</p>
    public let pemEncodedCertificate: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        expirationDate: Date? = nil,
        pemEncodedCertificate: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

struct GetClientCertificateOutputResponseBody: Equatable {
    public let clientCertificateId: String?
    public let description: String?
    public let pemEncodedCertificate: String?
    public let createdDate: Date?
    public let expirationDate: Date?
    public let tags: [String:String]?
}

extension GetClientCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetClientCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClientCertificatesInput(limit: \(String(describing: limit)), position: \(String(describing: position)))"}
}

extension GetClientCertificatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetClientCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "GetClientCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClientCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClientCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClientCertificatesInput>
    public typealias MOutput = OperationOutput<GetClientCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClientCertificatesOutputError>
}

public struct GetClientCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetClientCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClientCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClientCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClientCertificatesInput>
    public typealias MOutput = OperationOutput<GetClientCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClientCertificatesOutputError>
}

/// <p>A request to get information about a collection of <a>ClientCertificate</a> resources.</p>
public struct GetClientCertificatesInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        limit: Int? = nil,
        position: String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetClientCertificatesInputBody: Equatable {
}

extension GetClientCertificatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetClientCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetClientCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetClientCertificatesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetClientCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClientCertificatesOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetClientCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetClientCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>Represents a collection of <a>ClientCertificate</a> resources.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html">Use Client-Side Certificate</a>
///       </div>
public struct GetClientCertificatesOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [ClientCertificate]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [ClientCertificate]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetClientCertificatesOutputResponseBody: Equatable {
    public let items: [ClientCertificate]?
}

extension GetClientCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ClientCertificate?].self, forKey: .items)
        var itemsDecoded0:[ClientCertificate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ClientCertificate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentInput(deploymentId: \(String(describing: deploymentId)), embed: \(String(describing: embed)), restApiId: \(String(describing: restApiId)))"}
}

extension GetDeploymentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let embed = input.operationInput.embed {
            embed.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "embed".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentOutputError>
}

/// <p>Requests API Gateway to get information about a <a>Deployment</a> resource.</p>
public struct GetDeploymentInput: Equatable {
    /// <p>[Required] The identifier of the <a>Deployment</a> resource to get information about.</p>
    public let deploymentId: String?
    /// <p>A query parameter to retrieve the specified embedded resources of the returned <a>Deployment</a> resource in the response. In a REST API call, this <code>embed</code> parameter value is a list of comma-separated strings, as in  <code>GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=var1,var2</code>. The SDK and other platform-dependent libraries might use a different format for the list. Currently, this request supports only retrieval of the embedded API summary this way. Hence, the parameter value must be a single-valued list containing only the <code>"apisummary"</code> string.  For example, <code>GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=apisummary</code>.</p>
    public let embed: [String]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        deploymentId: String? = nil,
        embed: [String]? = nil,
        restApiId: String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.embed = embed
        self.restApiId = restApiId
    }
}

struct GetDeploymentInputBody: Equatable {
}

extension GetDeploymentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentOutputError: Equatable {
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentOutputResponse(apiSummary: \(String(describing: apiSummary)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), id: \(String(describing: id)))"}
}

extension GetDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiSummary = output.apiSummary
            self.createdDate = output.createdDate
            self.description = output.description
            self.id = output.id
        } else {
            self.apiSummary = nil
            self.createdDate = nil
            self.description = nil
            self.id = nil
        }
    }
}

/// <p>An immutable representation of a <a>RestApi</a> resource that can be called by users using <a>Stages</a>. A deployment must be associated with a <a>Stage</a> for it to be callable over the Internet.</p>
///         <div class="remarks">To create a deployment, call <code>POST</code> on the <a>Deployments</a> resource of a <a>RestApi</a>.
///             To view, update, or delete a deployment, call <code>GET</code>, <code>PATCH</code>, or <code>DELETE</code> on the specified deployment resource (<code>/restapis/{restapi_id}/deployments/{deployment_id}</code>).</div>
///         <div class="seeAlso"><a>RestApi</a>, <a>Deployments</a>, <a>Stage</a>,
///             <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html">AWS CLI</a>,
///             <a href="https://aws.amazon.com/tools/">AWS SDKs</a>
///         </div>
public struct GetDeploymentOutputResponse: Equatable {
    /// <p>A summary of the <a>RestApi</a> at the date and time that the deployment resource was created.</p>
    public let apiSummary: [String:[String:MethodSnapshot]]?
    /// <p>The date and time that the deployment resource was created.</p>
    public let createdDate: Date?
    /// <p>The description for the deployment resource.</p>
    public let description: String?
    /// <p>The identifier for the deployment resource.</p>
    public let id: String?

    public init (
        apiSummary: [String:[String:MethodSnapshot]]? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        id: String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

struct GetDeploymentOutputResponseBody: Equatable {
    public let id: String?
    public let description: String?
    public let createdDate: Date?
    public let apiSummary: [String:[String:MethodSnapshot]]?
}

extension GetDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([String: [String: MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [String:[String:MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [String:[String:MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [String: MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [String: MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

extension GetDeploymentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentsInput(limit: \(String(describing: limit)), position: \(String(describing: position)), restApiId: \(String(describing: restApiId)))"}
}

extension GetDeploymentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeploymentsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentsInput>
    public typealias MOutput = OperationOutput<GetDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentsOutputError>
}

public struct GetDeploymentsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentsInput>
    public typealias MOutput = OperationOutput<GetDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentsOutputError>
}

/// <p>Requests API Gateway to get information about a <a>Deployments</a> collection.</p>
public struct GetDeploymentsInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        limit: Int? = nil,
        position: String? = nil,
        restApiId: String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetDeploymentsInputBody: Equatable {
}

extension GetDeploymentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeploymentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentsOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetDeploymentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>Represents a collection resource that contains zero or more references to your existing deployments, and links that guide you on how to interact with your collection. The collection offers a paginated view of the contained deployments.</p>
///         <div class="remarks">To create a new deployment of a <a>RestApi</a>, make a <code>POST</code> request against this resource. To view, update, or delete an existing
///         deployment, make a <code>GET</code>, <code>PATCH</code>, or <code>DELETE</code> request, respectively, on a specified <a>Deployment</a> resource.</div>
///         <div class="seeAlso">
///             <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html">Deploying an API</a>,
///             <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html">AWS CLI</a>,
///             <a href="https://aws.amazon.com/tools/">AWS SDKs</a>
///         </div>
public struct GetDeploymentsOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [Deployment]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [Deployment]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDeploymentsOutputResponseBody: Equatable {
    public let items: [Deployment]?
}

extension GetDeploymentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Deployment?].self, forKey: .items)
        var itemsDecoded0:[Deployment]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Deployment]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetDocumentationPartInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentationPartInput(documentationPartId: \(String(describing: documentationPartId)), restApiId: \(String(describing: restApiId)))"}
}

extension GetDocumentationPartInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDocumentationPartInputHeadersMiddleware: Middleware {
    public let id: String = "GetDocumentationPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentationPartInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentationPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentationPartInput>
    public typealias MOutput = OperationOutput<GetDocumentationPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentationPartOutputError>
}

public struct GetDocumentationPartInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDocumentationPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentationPartInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentationPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentationPartInput>
    public typealias MOutput = OperationOutput<GetDocumentationPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentationPartOutputError>
}

/// <p>Gets a specified documentation part of a given API.</p>
public struct GetDocumentationPartInput: Equatable {
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let documentationPartId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        documentationPartId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.restApiId = restApiId
    }
}

struct GetDocumentationPartInputBody: Equatable {
}

extension GetDocumentationPartInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDocumentationPartOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentationPartOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentationPartOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentationPartOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentationPartOutputResponse(id: \(String(describing: id)), location: \(String(describing: location)), properties: \(String(describing: properties)))"}
}

extension GetDocumentationPartOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDocumentationPartOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.location = output.location
            self.properties = output.properties
        } else {
            self.id = nil
            self.location = nil
            self.properties = nil
        }
    }
}

/// <p>A documentation part for a targeted API entity.</p>
///     <div class="remarks">
///       <p>A documentation part consists of a content map (<code>properties</code>) and a target (<code>location</code>). The target specifies an API entity to which the documentation content applies. The supported API entity types are <code>API</code>, <code>AUTHORIZER</code>, <code>MODEL</code>, <code>RESOURCE</code>, <code>METHOD</code>, <code>PATH_PARAMETER</code>, <code>QUERY_PARAMETER</code>, <code>REQUEST_HEADER</code>, <code>REQUEST_BODY</code>, <code>RESPONSE</code>, <code>RESPONSE_HEADER</code>, and <code>RESPONSE_BODY</code>. Valid <code>location</code> fields depend on the API entity type. All valid fields are not required.</p>
///       <p>The content map is a JSON string of API-specific key-value pairs. Although an API can use any shape for the content map, only the OpenAPI-compliant documentation fields will be injected into the associated API entity definition in the exported OpenAPI definition file.</p></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a>DocumentationParts</a>
///     </div>
public struct GetDocumentationPartOutputResponse: Equatable {
    /// <p>The <a>DocumentationPart</a> identifier, generated by API Gateway when the <code>DocumentationPart</code> is created.</p>
    public let id: String?
    /// <p>The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.</p>
    public let location: DocumentationPartLocation?
    /// <p>A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., <code>"{ \"description\": \"The API does ...\" }"</code>.  Only OpenAPI-compliant documentation-related fields from the <literal>properties</literal> map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of <code>x-amazon-apigateway-documentation</code>.</p>
    public let properties: String?

    public init (
        id: String? = nil,
        location: DocumentationPartLocation? = nil,
        properties: String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

struct GetDocumentationPartOutputResponseBody: Equatable {
    public let id: String?
    public let location: DocumentationPartLocation?
    public let properties: String?
}

extension GetDocumentationPartOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case location
        case properties
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension GetDocumentationPartsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentationPartsInput(limit: \(String(describing: limit)), locationStatus: \(String(describing: locationStatus)), nameQuery: \(String(describing: nameQuery)), path: \(String(describing: path)), position: \(String(describing: position)), restApiId: \(String(describing: restApiId)), type: \(String(describing: type)))"}
}

extension GetDocumentationPartsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDocumentationPartsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDocumentationPartsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentationPartsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentationPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentationPartsInput>
    public typealias MOutput = OperationOutput<GetDocumentationPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentationPartsOutputError>
}

public struct GetDocumentationPartsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDocumentationPartsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentationPartsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentationPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let locationStatus = input.operationInput.locationStatus {
            let locationStatusQueryItem = URLQueryItem(name: "locationStatus".urlPercentEncoding(), value: String(locationStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(locationStatusQueryItem)
        }
        if let path = input.operationInput.path {
            let pathQueryItem = URLQueryItem(name: "path".urlPercentEncoding(), value: String(path).urlPercentEncoding())
            input.builder.withQueryItem(pathQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let nameQuery = input.operationInput.nameQuery {
            let nameQueryQueryItem = URLQueryItem(name: "name".urlPercentEncoding(), value: String(nameQuery).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        if let type = input.operationInput.type {
            let typeQueryItem = URLQueryItem(name: "type".urlPercentEncoding(), value: String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentationPartsInput>
    public typealias MOutput = OperationOutput<GetDocumentationPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentationPartsOutputError>
}

/// <p>Gets the documentation parts of an API. The result may be filtered by the type, name, or path of API entities (targets).</p>
public struct GetDocumentationPartsInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The status of the API documentation parts to retrieve. Valid values are <code>DOCUMENTED</code> for retrieving <a>DocumentationPart</a> resources with content and <code>UNDOCUMENTED</code> for <a>DocumentationPart</a> resources without content.</p>
    public let locationStatus: LocationStatusType?
    /// <p>The name of API entities of the to-be-retrieved documentation parts.</p>
    public let nameQuery: String?
    /// <p>The path of API entities of the to-be-retrieved documentation parts.</p>
    public let path: String?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>The type of API entities of the to-be-retrieved documentation parts. </p>
    public let type: DocumentationPartType?

    public init (
        limit: Int? = nil,
        locationStatus: LocationStatusType? = nil,
        nameQuery: String? = nil,
        path: String? = nil,
        position: String? = nil,
        restApiId: String? = nil,
        type: DocumentationPartType? = nil
    )
    {
        self.limit = limit
        self.locationStatus = locationStatus
        self.nameQuery = nameQuery
        self.path = path
        self.position = position
        self.restApiId = restApiId
        self.type = type
    }
}

struct GetDocumentationPartsInputBody: Equatable {
}

extension GetDocumentationPartsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDocumentationPartsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentationPartsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentationPartsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentationPartsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentationPartsOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetDocumentationPartsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDocumentationPartsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>The collection of documentation parts of an API.</p>
///     <div class="remarks"></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a>DocumentationPart</a>
///     </div>
public struct GetDocumentationPartsOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [DocumentationPart]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [DocumentationPart]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDocumentationPartsOutputResponseBody: Equatable {
    public let items: [DocumentationPart]?
}

extension GetDocumentationPartsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DocumentationPart?].self, forKey: .items)
        var itemsDecoded0:[DocumentationPart]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DocumentationPart]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetDocumentationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentationVersionInput(documentationVersion: \(String(describing: documentationVersion)), restApiId: \(String(describing: restApiId)))"}
}

extension GetDocumentationVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDocumentationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetDocumentationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentationVersionInput>
    public typealias MOutput = OperationOutput<GetDocumentationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentationVersionOutputError>
}

public struct GetDocumentationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDocumentationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentationVersionInput>
    public typealias MOutput = OperationOutput<GetDocumentationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentationVersionOutputError>
}

/// <p>Gets a documentation snapshot of an API.</p>
public struct GetDocumentationVersionInput: Equatable {
    /// <p>[Required] The version identifier of the to-be-retrieved documentation snapshot.</p>
    public let documentationVersion: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        documentationVersion: String? = nil,
        restApiId: String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
    }
}

struct GetDocumentationVersionInputBody: Equatable {
}

extension GetDocumentationVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDocumentationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentationVersionOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentationVersionOutputResponse(createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), version: \(String(describing: version)))"}
}

extension GetDocumentationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDocumentationVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdDate = output.createdDate
            self.description = output.description
            self.version = output.version
        } else {
            self.createdDate = nil
            self.description = nil
            self.version = nil
        }
    }
}

/// <p>A snapshot of the documentation of an API.</p>
///     <div class="remarks"><p>Publishing API documentation involves creating a documentation version associated with an API stage and exporting the versioned documentation to an external (e.g., OpenAPI) file.</p></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a>DocumentationPart</a>, <a>DocumentationVersions</a>
///     </div>
public struct GetDocumentationVersionOutputResponse: Equatable {
    /// <p>The date when the API documentation snapshot is created.</p>
    public let createdDate: Date?
    /// <p>The description of the API documentation snapshot.</p>
    public let description: String?
    /// <p>The version identifier of the API documentation snapshot.</p>
    public let version: String?

    public init (
        createdDate: Date? = nil,
        description: String? = nil,
        version: String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

struct GetDocumentationVersionOutputResponseBody: Equatable {
    public let version: String?
    public let createdDate: Date?
    public let description: String?
}

extension GetDocumentationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdDate
        case description
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetDocumentationVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentationVersionsInput(limit: \(String(describing: limit)), position: \(String(describing: position)), restApiId: \(String(describing: restApiId)))"}
}

extension GetDocumentationVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDocumentationVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDocumentationVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentationVersionsInput>
    public typealias MOutput = OperationOutput<GetDocumentationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentationVersionsOutputError>
}

public struct GetDocumentationVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDocumentationVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentationVersionsInput>
    public typealias MOutput = OperationOutput<GetDocumentationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentationVersionsOutputError>
}

/// <p>Gets the documentation versions of an API.</p>
public struct GetDocumentationVersionsInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        limit: Int? = nil,
        position: String? = nil,
        restApiId: String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetDocumentationVersionsInputBody: Equatable {
}

extension GetDocumentationVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDocumentationVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentationVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentationVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentationVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentationVersionsOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetDocumentationVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDocumentationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>The collection of documentation snapshots of an API. </p>
///     <div class="remarks"><p>Use the <a>DocumentationVersions</a> to manage documentation snapshots associated with various API stages.</p></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a>DocumentationPart</a>, <a>DocumentationVersion</a>
///     </div>
public struct GetDocumentationVersionsOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [DocumentationVersion]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [DocumentationVersion]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDocumentationVersionsOutputResponseBody: Equatable {
    public let items: [DocumentationVersion]?
}

extension GetDocumentationVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DocumentationVersion?].self, forKey: .items)
        var itemsDecoded0:[DocumentationVersion]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DocumentationVersion]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetDomainNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainNameInput(domainName: \(String(describing: domainName)))"}
}

extension GetDomainNameInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainNameInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainNameInput>
    public typealias MOutput = OperationOutput<GetDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainNameOutputError>
}

public struct GetDomainNameInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainNameInput>
    public typealias MOutput = OperationOutput<GetDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainNameOutputError>
}

/// <p>Request to get the name of a <a>DomainName</a> resource.</p>
public struct GetDomainNameInput: Equatable {
    /// <p>[Required] The name of the <a>DomainName</a> resource.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainNameInputBody: Equatable {
}

extension GetDomainNameInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainNameOutputError: Equatable {
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainNameOutputResponse(certificateArn: \(String(describing: certificateArn)), certificateName: \(String(describing: certificateName)), certificateUploadDate: \(String(describing: certificateUploadDate)), distributionDomainName: \(String(describing: distributionDomainName)), distributionHostedZoneId: \(String(describing: distributionHostedZoneId)), domainName: \(String(describing: domainName)), domainNameStatus: \(String(describing: domainNameStatus)), domainNameStatusMessage: \(String(describing: domainNameStatusMessage)), endpointConfiguration: \(String(describing: endpointConfiguration)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)), regionalCertificateArn: \(String(describing: regionalCertificateArn)), regionalCertificateName: \(String(describing: regionalCertificateName)), regionalDomainName: \(String(describing: regionalDomainName)), regionalHostedZoneId: \(String(describing: regionalHostedZoneId)), securityPolicy: \(String(describing: securityPolicy)), tags: \(String(describing: tags)))"}
}

extension GetDomainNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateArn = output.certificateArn
            self.certificateName = output.certificateName
            self.certificateUploadDate = output.certificateUploadDate
            self.distributionDomainName = output.distributionDomainName
            self.distributionHostedZoneId = output.distributionHostedZoneId
            self.domainName = output.domainName
            self.domainNameStatus = output.domainNameStatus
            self.domainNameStatusMessage = output.domainNameStatusMessage
            self.endpointConfiguration = output.endpointConfiguration
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.regionalCertificateArn = output.regionalCertificateArn
            self.regionalCertificateName = output.regionalCertificateName
            self.regionalDomainName = output.regionalDomainName
            self.regionalHostedZoneId = output.regionalHostedZoneId
            self.securityPolicy = output.securityPolicy
            self.tags = output.tags
        } else {
            self.certificateArn = nil
            self.certificateName = nil
            self.certificateUploadDate = nil
            self.distributionDomainName = nil
            self.distributionHostedZoneId = nil
            self.domainName = nil
            self.domainNameStatus = nil
            self.domainNameStatusMessage = nil
            self.endpointConfiguration = nil
            self.mutualTlsAuthentication = nil
            self.regionalCertificateArn = nil
            self.regionalCertificateName = nil
            self.regionalDomainName = nil
            self.regionalHostedZoneId = nil
            self.securityPolicy = nil
            self.tags = nil
        }
    }
}

/// <p>Represents a custom domain name as a user-friendly host name of an API (<a>RestApi</a>).</p>
///         <div class="Remarks">
///             <p>When you deploy an API, API Gateway creates a default host name for the API. This default API host name is of the <code>{restapi-id}.execute-api.{region}.amazonaws.com</code> format. With the default host name, you can access the API's root resource with the URL of <code>https://{restapi-id}.execute-api.{region}.amazonaws.com/{stage}/</code>. When you set up a custom domain name of <code>apis.example.com</code> for this API, you can then access the same resource using the URL of the <code>https://apis.examples.com/myApi</code>, where <code>myApi</code> is the base path mapping (<a>BasePathMapping</a>) of your API under the custom domain name.
///             </p>
///         </div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">Set a Custom Host Name for an API</a>
///       </div>
public struct GetDomainNameOutputResponse: Equatable {
    /// <p>The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.</p>
    public let certificateArn: String?
    /// <p>The name of the certificate that will be used by edge-optimized endpoint for this domain name.</p>
    public let certificateName: String?
    /// <p>The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.</p>
    public let certificateUploadDate: Date?
    /// <p>The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the <a target="_blank" href="https://aws.amazon.com/documentation/cloudfront/">Amazon CloudFront documentation</a>.</p>
    public let distributionDomainName: String?
    /// <p>The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is <code>Z2FDTNDATAQYW2</code> for all the regions. For more information, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html">Set up a Regional Custom Domain Name</a> and <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region">AWS Regions and Endpoints for API Gateway</a>. </p>
    public let distributionHostedZoneId: String?
    /// <p>The custom domain name as an API host name, for example, <code>my-api.example.com</code>.</p>
    public let domainName: String?
    /// <p>The status of the <a>DomainName</a> migration. The valid values are <code>AVAILABLE</code> and <code>UPDATING</code>. If the status is <code>UPDATING</code>, the domain cannot be modified further until the existing operation is complete. If it is <code>AVAILABLE</code>, the domain can be updated.</p>
    public let domainNameStatus: DomainNameStatus?
    /// <p>An optional text message containing detailed information about status of the <a>DomainName</a> migration.</p>
    public let domainNameStatusMessage: String?
    /// <p>The endpoint configuration of this <a>DomainName</a> showing the endpoint types of the domain name.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.</p>
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    /// <p>The reference to an AWS-managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.</p>
    public let regionalCertificateArn: String?
    /// <p>The name of the certificate that will be used for validating the regional domain name.</p>
    public let regionalCertificateName: String?
    /// <p>The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.</p>
    public let regionalDomainName: String?
    /// <p>The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html">Set up a Regional Custom Domain Name</a> and  <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region">AWS Regions and Endpoints for API Gateway</a>. </p>
    public let regionalHostedZoneId: String?
    /// <p>The Transport Layer Security (TLS) version + cipher suite for this <a>DomainName</a>. The valid values are <code>TLS_1_0</code> and <code>TLS_1_2</code>.</p>
    public let securityPolicy: SecurityPolicy?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        certificateArn: String? = nil,
        certificateName: String? = nil,
        certificateUploadDate: Date? = nil,
        distributionDomainName: String? = nil,
        distributionHostedZoneId: String? = nil,
        domainName: String? = nil,
        domainNameStatus: DomainNameStatus? = nil,
        domainNameStatusMessage: String? = nil,
        endpointConfiguration: EndpointConfiguration? = nil,
        mutualTlsAuthentication: MutualTlsAuthentication? = nil,
        regionalCertificateArn: String? = nil,
        regionalCertificateName: String? = nil,
        regionalDomainName: String? = nil,
        regionalHostedZoneId: String? = nil,
        securityPolicy: SecurityPolicy? = nil,
        tags: [String:String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct GetDomainNameOutputResponseBody: Equatable {
    public let domainName: String?
    public let certificateName: String?
    public let certificateArn: String?
    public let certificateUploadDate: Date?
    public let regionalDomainName: String?
    public let regionalHostedZoneId: String?
    public let regionalCertificateName: String?
    public let regionalCertificateArn: String?
    public let distributionDomainName: String?
    public let distributionHostedZoneId: String?
    public let endpointConfiguration: EndpointConfiguration?
    public let domainNameStatus: DomainNameStatus?
    public let domainNameStatusMessage: String?
    public let securityPolicy: SecurityPolicy?
    public let tags: [String:String]?
    public let mutualTlsAuthentication: MutualTlsAuthentication?
}

extension GetDomainNameOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
    }
}

extension GetDomainNamesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainNamesInput(limit: \(String(describing: limit)), position: \(String(describing: position)))"}
}

extension GetDomainNamesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainNamesInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainNamesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainNamesInput>
    public typealias MOutput = OperationOutput<GetDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainNamesOutputError>
}

public struct GetDomainNamesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainNamesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainNamesInput>
    public typealias MOutput = OperationOutput<GetDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainNamesOutputError>
}

/// <p>Request to describe a collection of <a>DomainName</a> resources.</p>
public struct GetDomainNamesInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        limit: Int? = nil,
        position: String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetDomainNamesInputBody: Equatable {
}

extension GetDomainNamesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainNamesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainNamesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainNamesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainNamesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainNamesOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetDomainNamesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainNamesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>Represents a collection of <a>DomainName</a> resources.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">Use Client-Side Certificate</a>
///       </div>
public struct GetDomainNamesOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [DomainName]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [DomainName]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDomainNamesOutputResponseBody: Equatable {
    public let items: [DomainName]?
}

extension GetDomainNamesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DomainName?].self, forKey: .items)
        var itemsDecoded0:[DomainName]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DomainName]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetExportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExportInput(accepts: \(String(describing: accepts)), exportType: \(String(describing: exportType)), parameters: \(String(describing: parameters)), restApiId: \(String(describing: restApiId)), stageName: \(String(describing: stageName)))"}
}

extension GetExportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetExportInputHeadersMiddleware: Middleware {
    public let id: String = "GetExportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accepts = input.operationInput.accepts {
            input.builder.withHeader(name: "Accept", value: String(accepts))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExportInput>
    public typealias MOutput = OperationOutput<GetExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExportOutputError>
}

public struct GetExportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetExportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let parameters = input.operationInput.parameters {
            let currentQueryItemNames = input.builder.currentQueryItems.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    input.builder.withQueryItem(queryItem)
                }
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExportInput>
    public typealias MOutput = OperationOutput<GetExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExportOutputError>
}

/// <p>Request a new export of a <a>RestApi</a> for a particular <a>Stage</a>.</p>
public struct GetExportInput: Equatable {
    /// <p>The content-type of the export, for example <code>application/json</code>. Currently <code>application/json</code> and <code>application/yaml</code> are supported for <code>exportType</code> of<code>oas30</code> and <code>swagger</code>. This should be specified in the <code>Accept</code> header for direct API requests.</p>
    public let accepts: String?
    /// <p>[Required] The type of export. Acceptable values are 'oas30' for OpenAPI 3.0.x and 'swagger' for Swagger/OpenAPI 2.0.</p>
    public let exportType: String?
    /// <p>A key-value map of query string parameters that specify properties of the export, depending on the requested <code>exportType</code>. For <code>exportType</code> <code>oas30</code> and <code>swagger</code>, any combination of the following parameters are supported: <code>extensions='integrations'</code> or <code>extensions='apigateway'</code> will export the API with x-amazon-apigateway-integration extensions. <code>extensions='authorizers'</code> will export the API with  x-amazon-apigateway-authorizer extensions. <code>postman</code> will export the API with Postman extensions, allowing for import to the Postman tool</p>
    public let parameters: [String:String]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The name of the <a>Stage</a> that will be exported.</p>
    public let stageName: String?

    public init (
        accepts: String? = nil,
        exportType: String? = nil,
        parameters: [String:String]? = nil,
        restApiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.accepts = accepts
        self.exportType = exportType
        self.parameters = parameters
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct GetExportInputBody: Equatable {
}

extension GetExportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetExportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExportOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExportOutputResponse(body: \(String(describing: body)), contentDisposition: \(String(describing: contentDisposition)), contentType: \(String(describing: contentType)))"}
}

extension GetExportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.body = unwrappedData
        } else {
            self.body = nil
        }
    }
}

/// <p>The binary blob response to <a>GetExport</a>, which contains the generated SDK.</p>
public struct GetExportOutputResponse: Equatable {
    /// <p>The binary blob response to <a>GetExport</a>, which contains the export.</p>
    public let body: Data?
    /// <p>The content-disposition header value in the HTTP response.</p>
    public let contentDisposition: String?
    /// <p>The content-type header value in the HTTP response. This will correspond to a valid 'accept' type in the request.</p>
    public let contentType: String?

    public init (
        body: Data? = nil,
        contentDisposition: String? = nil,
        contentType: String? = nil
    )
    {
        self.body = body
        self.contentDisposition = contentDisposition
        self.contentType = contentType
    }
}

struct GetExportOutputResponseBody: Equatable {
    public let body: Data?
}

extension GetExportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension GetGatewayResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGatewayResponseInput(responseType: \(String(describing: responseType)), restApiId: \(String(describing: restApiId)))"}
}

extension GetGatewayResponseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetGatewayResponseInputHeadersMiddleware: Middleware {
    public let id: String = "GetGatewayResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGatewayResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGatewayResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGatewayResponseInput>
    public typealias MOutput = OperationOutput<GetGatewayResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGatewayResponseOutputError>
}

public struct GetGatewayResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGatewayResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGatewayResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGatewayResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGatewayResponseInput>
    public typealias MOutput = OperationOutput<GetGatewayResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGatewayResponseOutputError>
}

/// <p>Gets a <a>GatewayResponse</a> of a specified response type on the given <a>RestApi</a>.</p>
public struct GetGatewayResponseInput: Equatable {
    /// <p>[Required] <p>The response type of the associated <a>GatewayResponse</a>. Valid values are <ul><li>ACCESS_DENIED</li><li>API_CONFIGURATION_ERROR</li><li>AUTHORIZER_FAILURE</li><li> AUTHORIZER_CONFIGURATION_ERROR</li><li>BAD_REQUEST_PARAMETERS</li><li>BAD_REQUEST_BODY</li><li>DEFAULT_4XX</li><li>DEFAULT_5XX</li><li>EXPIRED_TOKEN</li><li>INVALID_SIGNATURE</li><li>INTEGRATION_FAILURE</li><li>INTEGRATION_TIMEOUT</li><li>INVALID_API_KEY</li><li>MISSING_AUTHENTICATION_TOKEN</li><li> QUOTA_EXCEEDED</li><li>REQUEST_TOO_LARGE</li><li>RESOURCE_NOT_FOUND</li><li>THROTTLED</li><li>UNAUTHORIZED</li><li>UNSUPPORTED_MEDIA_TYPE</li></ul> </p></p>
    public let responseType: GatewayResponseType?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        responseType: GatewayResponseType? = nil,
        restApiId: String? = nil
    )
    {
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

struct GetGatewayResponseInputBody: Equatable {
}

extension GetGatewayResponseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetGatewayResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGatewayResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGatewayResponseOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGatewayResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGatewayResponseOutputResponse(defaultResponse: \(String(describing: defaultResponse)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), responseType: \(String(describing: responseType)), statusCode: \(String(describing: statusCode)))"}
}

extension GetGatewayResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGatewayResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.defaultResponse = output.defaultResponse
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.responseType = output.responseType
            self.statusCode = output.statusCode
        } else {
            self.defaultResponse = false
            self.responseParameters = nil
            self.responseTemplates = nil
            self.responseType = nil
            self.statusCode = nil
        }
    }
}

/// <p>A gateway response of a given response type and status code, with optional response parameters and mapping templates.</p>
///         <div class="remarks">
///             For more information about valid gateway response types, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html">Gateway Response Types Supported by API Gateway</a>
///             <div class="example">
///     <h4>Example: Get a Gateway Response of a given response type</h4>
///     <h5>Request</h5>
///     <p>This example shows how to get a gateway response of the <code>MISSING_AUTHENTICATION_TOKEN</code> type.</p>
///     <pre><code>GET /restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN HTTP/1.1
/// Host: beta-apigateway.us-east-1.amazonaws.com
/// Content-Type: application/json
/// X-Amz-Date: 20170503T202516Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=1b52460e3159c1a26cff29093855d50ea141c1c5b937528fecaf60f51129697a
/// Cache-Control: no-cache
/// Postman-Token: 3b2a1ce9-c848-2e26-2e2f-9c2caefbed45
/// </code></pre>
///     <p>The response type is specified as a URL path.</p>
///     <h5>Response</h5>
///     <p>The successful operation returns the <code>200 OK</code> status code and a payload similar to the following:</p>
///     <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html",
///       "name": "gatewayresponse",
///       "templated": true
///     },
///     "self": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     },
///     "gatewayresponse:delete": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     },
///     "gatewayresponse:put": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///       "templated": true
///     },
///     "gatewayresponse:update": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     }
///   },
///   "defaultResponse": false,
///   "responseParameters": {
///     "gatewayresponse.header.x-request-path": "method.request.path.petId",
///     "gatewayresponse.header.Access-Control-Allow-Origin": "'a.b.c'",
///     "gatewayresponse.header.x-request-query": "method.request.querystring.q",
///     "gatewayresponse.header.x-request-header": "method.request.header.Accept"
///   },
///   "responseTemplates": {
///     "application/json": "{\n     \"message\": $context.error.messageString,\n     \"type\":  \"$context.error.responseType\",\n     \"stage\":  \"$context.stage\",\n     \"resourcePath\":  \"$context.resourcePath\",\n     \"stageVariables.a\":  \"$stageVariables.a\",\n     \"statusCode\": \"'404'\"\n}"
///   },
///   "responseType": "MISSING_AUTHENTICATION_TOKEN",
///   "statusCode": "404"
/// }</code></pre>
///     <p></p>
///   </div>
///         </div>
///         <div class="seeAlso">
///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html">Customize Gateway Responses</a>
///         </div>
public struct GetGatewayResponseOutputResponse: Equatable {
    /// <p>A Boolean flag to indicate whether this <a>GatewayResponse</a> is the default gateway response (<code>true</code>) or not (<code>false</code>). A default gateway response is one generated by API Gateway without any customization by an API developer. </p>
    public let defaultResponse: Bool
    /// <p>Response parameters (paths, query strings and headers) of the <a>GatewayResponse</a> as a string-to-string map of key-value  pairs.</p>
    public let responseParameters: [String:String]?
    /// <p>Response templates of the <a>GatewayResponse</a> as a string-to-string map of key-value pairs.</p>
    public let responseTemplates: [String:String]?
    /// <p>The response type of the associated <a>GatewayResponse</a>. Valid values are <ul><li>ACCESS_DENIED</li><li>API_CONFIGURATION_ERROR</li><li>AUTHORIZER_FAILURE</li><li> AUTHORIZER_CONFIGURATION_ERROR</li><li>BAD_REQUEST_PARAMETERS</li><li>BAD_REQUEST_BODY</li><li>DEFAULT_4XX</li><li>DEFAULT_5XX</li><li>EXPIRED_TOKEN</li><li>INVALID_SIGNATURE</li><li>INTEGRATION_FAILURE</li><li>INTEGRATION_TIMEOUT</li><li>INVALID_API_KEY</li><li>MISSING_AUTHENTICATION_TOKEN</li><li> QUOTA_EXCEEDED</li><li>REQUEST_TOO_LARGE</li><li>RESOURCE_NOT_FOUND</li><li>THROTTLED</li><li>UNAUTHORIZED</li><li>UNSUPPORTED_MEDIA_TYPE</li></ul> </p>
    public let responseType: GatewayResponseType?
    /// <p>The HTTP status code for this <a>GatewayResponse</a>.</p>
    public let statusCode: String?

    public init (
        defaultResponse: Bool = false,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        responseType: GatewayResponseType? = nil,
        statusCode: String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

struct GetGatewayResponseOutputResponseBody: Equatable {
    public let responseType: GatewayResponseType?
    public let statusCode: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let defaultResponse: Bool
}

extension GetGatewayResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decode(Bool.self, forKey: .defaultResponse)
        defaultResponse = defaultResponseDecoded
    }
}

extension GetGatewayResponsesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGatewayResponsesInput(limit: \(String(describing: limit)), position: \(String(describing: position)), restApiId: \(String(describing: restApiId)))"}
}

extension GetGatewayResponsesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetGatewayResponsesInputHeadersMiddleware: Middleware {
    public let id: String = "GetGatewayResponsesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGatewayResponsesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGatewayResponsesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGatewayResponsesInput>
    public typealias MOutput = OperationOutput<GetGatewayResponsesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGatewayResponsesOutputError>
}

public struct GetGatewayResponsesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGatewayResponsesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGatewayResponsesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGatewayResponsesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGatewayResponsesInput>
    public typealias MOutput = OperationOutput<GetGatewayResponsesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGatewayResponsesOutputError>
}

/// <p>Gets the <a>GatewayResponses</a> collection on the given <a>RestApi</a>. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default <a>GatewayResponses</a> collection for the supported response types.</p>
public struct GetGatewayResponsesInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500. The <a>GatewayResponses</a> collection does not support pagination and the limit does not apply here.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set. The <a>GatewayResponse</a> collection does not support pagination and the position does not apply here.</p>
    public let position: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        limit: Int? = nil,
        position: String? = nil,
        restApiId: String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetGatewayResponsesInputBody: Equatable {
}

extension GetGatewayResponsesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetGatewayResponsesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGatewayResponsesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGatewayResponsesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGatewayResponsesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGatewayResponsesOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetGatewayResponsesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGatewayResponsesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>The collection of the <a>GatewayResponse</a> instances of a <a>RestApi</a> as a <code>responseType</code>-to-<a>GatewayResponse</a> object map of key-value pairs. As such, pagination is not supported for querying this collection.</p>
///         <div class="remarks">
///             For more information about valid gateway response types, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html">Gateway Response Types Supported by API Gateway</a>
///             <div class="example">
///     <h4>Example: Get the collection of gateway responses of an API</h4>
///     <h5>Request</h5>
///     <p>This example request shows how to retrieve the <a>GatewayResponses</a> collection from an API.</p>
///     <pre><code>GET /restapis/o81lxisefl/gatewayresponses HTTP/1.1
/// Host: beta-apigateway.us-east-1.amazonaws.com
/// Content-Type: application/json
/// X-Amz-Date: 20170503T220604Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=59b42fe54a76a5de8adf2c67baa6d39206f8e9ad49a1d77ccc6a5da3103a398a
/// Cache-Control: no-cache
/// Postman-Token: 5637af27-dc29-fc5c-9dfe-0645d52cb515
/// </code></pre>
///     <p></p>
///     <h5>Response</h5>
///     <p>The successful operation returns the <code>200 OK</code> status code and a payload similar to the following:</p>
///     <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html",
///       "name": "gatewayresponse",
///       "templated": true
///     },
///     "self": {
///       "href": "/restapis/o81lxisefl/gatewayresponses"
///     },
///     "first": {
///       "href": "/restapis/o81lxisefl/gatewayresponses"
///     },
///     "gatewayresponse:by-type": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///       "templated": true
///     },
///     "item": [
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_FAILURE"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/RESOURCE_NOT_FOUND"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/REQUEST_TOO_LARGE"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/THROTTLED"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/UNSUPPORTED_MEDIA_TYPE"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_CONFIGURATION_ERROR"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_5XX"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_4XX"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_PARAMETERS"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_BODY"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/EXPIRED_TOKEN"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/ACCESS_DENIED"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_API_KEY"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/UNAUTHORIZED"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/API_CONFIGURATION_ERROR"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/QUOTA_EXCEEDED"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_TIMEOUT"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_SIGNATURE"
///       },
///       {
///         "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_FAILURE"
///       }
///     ]
///   },
///   "_embedded": {
///     "item": [
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_FAILURE"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_FAILURE"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "INTEGRATION_FAILURE",
///         "statusCode": "504"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/RESOURCE_NOT_FOUND"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/RESOURCE_NOT_FOUND"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "RESOURCE_NOT_FOUND",
///         "statusCode": "404"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/REQUEST_TOO_LARGE"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/REQUEST_TOO_LARGE"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "REQUEST_TOO_LARGE",
///         "statusCode": "413"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/THROTTLED"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/THROTTLED"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "THROTTLED",
///         "statusCode": "429"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/UNSUPPORTED_MEDIA_TYPE"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/UNSUPPORTED_MEDIA_TYPE"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "UNSUPPORTED_MEDIA_TYPE",
///         "statusCode": "415"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_CONFIGURATION_ERROR"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_CONFIGURATION_ERROR"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "AUTHORIZER_CONFIGURATION_ERROR",
///         "statusCode": "500"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_5XX"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_5XX"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "DEFAULT_5XX"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_4XX"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_4XX"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "DEFAULT_4XX"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_PARAMETERS"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_PARAMETERS"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "BAD_REQUEST_PARAMETERS",
///         "statusCode": "400"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_BODY"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_BODY"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "BAD_REQUEST_BODY",
///         "statusCode": "400"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/EXPIRED_TOKEN"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/EXPIRED_TOKEN"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "EXPIRED_TOKEN",
///         "statusCode": "403"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/ACCESS_DENIED"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/ACCESS_DENIED"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "ACCESS_DENIED",
///         "statusCode": "403"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_API_KEY"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_API_KEY"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "INVALID_API_KEY",
///         "statusCode": "403"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/UNAUTHORIZED"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/UNAUTHORIZED"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "UNAUTHORIZED",
///         "statusCode": "401"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/API_CONFIGURATION_ERROR"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/API_CONFIGURATION_ERROR"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "API_CONFIGURATION_ERROR",
///         "statusCode": "500"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/QUOTA_EXCEEDED"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/QUOTA_EXCEEDED"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "QUOTA_EXCEEDED",
///         "statusCode": "429"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_TIMEOUT"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_TIMEOUT"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "INTEGRATION_TIMEOUT",
///         "statusCode": "504"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "MISSING_AUTHENTICATION_TOKEN",
///         "statusCode": "403"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_SIGNATURE"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_SIGNATURE"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "INVALID_SIGNATURE",
///         "statusCode": "403"
///       },
///       {
///         "_links": {
///           "self": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_FAILURE"
///           },
///           "gatewayresponse:put": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///             "templated": true
///           },
///           "gatewayresponse:update": {
///             "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_FAILURE"
///           }
///         },
///         "defaultResponse": true,
///         "responseParameters": {},
///         "responseTemplates": {
///           "application/json": "{\"message\":$context.error.messageString}"
///         },
///         "responseType": "AUTHORIZER_FAILURE",
///         "statusCode": "500"
///       }
///     ]
///   }
/// }</code></pre>
///     <p></p>
///   </div>
///         </div>
///         <div class="seeAlso">
///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html">Customize Gateway Responses</a>
///         </div>
public struct GetGatewayResponsesOutputResponse: Equatable {
    /// <p>Returns the entire collection, because of no pagination support.</p>
    public let items: [GatewayResponse]?
    /// <p>The current pagination position in the paged result set. The <a>GatewayResponse</a> collection does not support pagination and the position does not apply here.</p>
    public let position: String?

    public init (
        items: [GatewayResponse]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetGatewayResponsesOutputResponseBody: Equatable {
    public let items: [GatewayResponse]?
}

extension GetGatewayResponsesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([GatewayResponse?].self, forKey: .items)
        var itemsDecoded0:[GatewayResponse]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [GatewayResponse]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationInput(httpMethod: \(String(describing: httpMethod)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)))"}
}

extension GetIntegrationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "GetIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationInput>
    public typealias MOutput = OperationOutput<GetIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationOutputError>
}

public struct GetIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationInput>
    public typealias MOutput = OperationOutput<GetIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationOutputError>
}

/// <p>Represents a request to get the integration configuration.</p>
public struct GetIntegrationInput: Equatable {
    /// <p>[Required] Specifies a get integration request's HTTP method.</p>
    public let httpMethod: String?
    /// <p>[Required] Specifies a get integration request's resource identifier</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        httpMethod: String? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct GetIntegrationInputBody: Equatable {
}

extension GetIntegrationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationOutputResponse(cacheKeyParameters: \(String(describing: cacheKeyParameters)), cacheNamespace: \(String(describing: cacheNamespace)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandling: \(String(describing: contentHandling)), credentials: \(String(describing: credentials)), httpMethod: \(String(describing: httpMethod)), integrationResponses: \(String(describing: integrationResponses)), passthroughBehavior: \(String(describing: passthroughBehavior)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)), type: \(String(describing: type)), uri: \(String(describing: uri)))"}
}

extension GetIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cacheKeyParameters = output.cacheKeyParameters
            self.cacheNamespace = output.cacheNamespace
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandling = output.contentHandling
            self.credentials = output.credentials
            self.httpMethod = output.httpMethod
            self.integrationResponses = output.integrationResponses
            self.passthroughBehavior = output.passthroughBehavior
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
            self.type = output.type
            self.uri = output.uri
        } else {
            self.cacheKeyParameters = nil
            self.cacheNamespace = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandling = nil
            self.credentials = nil
            self.httpMethod = nil
            self.integrationResponses = nil
            self.passthroughBehavior = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
            self.type = nil
            self.uri = nil
        }
    }
}

/// <p>Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.</p>
///         <div class="remarks">In the API Gateway console, the built-in Lambda integration is an AWS integration.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct GetIntegrationOutputResponse: Equatable {
    /// <p>A list of request parameters whose values API Gateway caches. To be valid values for <code>cacheKeyParameters</code>, these parameters must also be specified for <a>Method</a> <code>requestParameters</code>.</p>
    public let cacheKeyParameters: [String]?
    /// <p>Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the <code>cacheNamespace</code>. You can specify the same <code>cacheNamespace</code> across resources to return the same cached data for requests to different resources.</p>
    public let cacheNamespace: String?
    /// <p>The (<a href="https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id"><code>id</code></a>) of the <a>VpcLink</a> used for the integration when <code>connectionType=VPC_LINK</code> and undefined, otherwise.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. The valid value is <code>INTERNET</code> for connections through the public routable internet or <code>VPC_LINK</code> for private connections between API Gateway and a network load balancer in a VPC. The default value is <code>INTERNET</code>.</p>
    public let connectionType: ConnectionType?
    /// <p>Specifies how to handle request payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p>
    ///       <ul>
    ///         <li><p><code>CONVERT_TO_BINARY</code>: Converts a request payload from a Base64-encoded string to the corresponding binary blob.</p></li>
    ///         <li><p><code>CONVERT_TO_TEXT</code>: Converts a request payload from a binary blob to a Base64-encoded string.</p></li>
    ///       </ul>
    ///       <p>If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the <code>passthroughBehavior</code> is configured to support payload pass-through.</p>
    public let contentHandling: ContentHandlingStrategy?
    /// <p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string <code>arn:aws:iam::\*:user/\*</code>. To use resource-based permissions on supported AWS services, specify null.</p>
    public let credentials: String?
    /// <p>Specifies the integration's HTTP method type.</p>
    public let httpMethod: String?
    /// <p>Specifies the integration's responses.</p>
    ///         <div class="remarks">
    ///     <p></p>
    ///     <h4>Example: Get integration responses of a method</h4>
    ///     <h5>Request</h5>
    ///     <p></p>
    ///     <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200 HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// X-Amz-Date: 20160607T191449Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160607/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    /// </code></pre>
    ///     <h5>Response</h5>
    ///     <p>The successful response returns <code>200 OK</code> status and a payload as follows:</p>
    ///     <pre><code>{
    ///   "_links": {
    ///     "curies": {
    ///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///       "name": "integrationresponse",
    ///       "templated": true
    ///     },
    ///     "self": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///       "title": "200"
    ///     },
    ///     "integrationresponse:delete": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///     },
    ///     "integrationresponse:update": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///     }
    ///   },
    ///   "responseParameters": {
    ///     "method.response.header.Content-Type": "'application/xml'"
    ///   },
    ///   "responseTemplates": {
    ///     "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n"
    ///   },
    ///   "statusCode": "200"
    /// }</code></pre>
    ///     <p></p>
    ///         </div>
    ///         <div class="seeAlso">
    ///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
    ///         </div>
    public let integrationResponses: [String:IntegrationResponse]?
    /// <div>
    ///         <p>
    ///             Specifies how the method request body of an unmapped content type will be passed through the integration request
    ///             to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration
    ///             or the content type does not match any of the mapped content types, as specified in <code>requestTemplates</code>.
    ///             The valid value is one of the following:
    ///         </p>
    ///         <ul>
    ///           <li>
    ///             <code>WHEN_NO_MATCH</code>: passes the method request body through the integration request to the back end without transformation
    ///             when the method request content type does not match any content type associated with the mapping templates defined in the integration request.
    ///           </li>
    ///           <li>
    ///             <code>WHEN_NO_TEMPLATES</code>: passes the method request body through the integration request to the back end without transformation
    ///             when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request
    ///             of an unmapped content-type will be rejected with an HTTP <code>415 Unsupported Media Type</code> response.
    ///           </li>
    ///           <li>
    ///             <code>NEVER</code>: rejects the method request with an HTTP <code>415 Unsupported Media Type</code> response when either the method
    ///             request content type does not match any content type associated with the mapping templates defined in the integration request or
    ///             no mapping template is defined in the integration request.
    ///           </li>
    ///         </ul>
    ///       </div>
    public let passthroughBehavior: String?
    /// <p>A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of  <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> must be a valid and unique method request parameter name.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.</p>
    public let requestTemplates: [String:String]?
    /// <p>Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.</p>
    public let timeoutInMillis: Int
    /// <p>Specifies the TLS configuration for an integration.</p>
    public let tlsConfig: TlsConfig?
    /// <p>Specifies an API method integration type. The valid value is one of the following:</p>
    ///         <ul>
    ///             <li><code>AWS</code>: for integrating the API method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration.</li>
    ///             <li><code>AWS_PROXY</code>: for integrating the API method request with the Lambda function-invoking action with the client request passed through as-is. This integration is also referred to as the Lambda proxy integration.</li>
    ///             <li><code>HTTP</code>: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC. This integration is also referred to as the HTTP custom integration.</li>
    ///             <li><code>HTTP_PROXY</code>: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC, with the client request passed through as-is. This is also referred to as the HTTP proxy integration.</li>
    ///             <li><code>MOCK</code>: for integrating the API method request with API Gateway as a "loop-back" endpoint without invoking any backend.</li>
    ///         </ul>
    ///         <p>For the HTTP and HTTP proxy integrations, each integration can specify a protocol (<code>http/https</code>), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a <code>connectionType</code> of <code>VPC_LINK</code> is referred to as a private integration and uses a <a>VpcLink</a> to connect API Gateway to a network load balancer of a VPC.</p>
    public let type: IntegrationType?
    /// <p>Specifies Uniform Resource Identifier (URI) of the integration endpoint.</p>
    /// <ul>
    /// <li><p> For <code>HTTP</code> or <code>HTTP_PROXY</code> integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the <a target="_blank" href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">RFC-3986 specification</a>, for either standard integration, where <code>connectionType</code> is not <code>VPC_LINK</code>, or private integration, where <code>connectionType</code> is <code>VPC_LINK</code>. For a private HTTP integration, the URI is not used for routing. </p>
    /// </li>
    /// <li><p> For <code>AWS</code> or <code>AWS_PROXY</code> integrations, the URI is of the form <code>arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}</code>. Here, <code>{Region}</code> is the API Gateway region (e.g., <code>us-east-1</code>); <code>{service}</code> is the name of the integrated AWS service (e.g., <code>s3</code>); and <code>{subdomain}</code> is a designated subdomain supported by certain AWS service for fast host-name lookup. <code>action</code> can be used for an AWS service action-based API, using an <code>Action={name}&{p1}={v1}&p2={v2}...</code> query string. The ensuing <code>{service_api}</code> refers to a supported action <code>{name}</code> plus any required input parameters. Alternatively, <code>path</code> can be used for an AWS service path-based API. The ensuing  <code>service_api</code> refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of <code><a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html">GetObject</a></code>, the <code>uri</code> can be either <code>arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key}</code> or  <code>arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}</code></p>
    /// </li></ul>
    public let uri: String?

    public init (
        cacheKeyParameters: [String]? = nil,
        cacheNamespace: String? = nil,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandling: ContentHandlingStrategy? = nil,
        credentials: String? = nil,
        httpMethod: String? = nil,
        integrationResponses: [String:IntegrationResponse]? = nil,
        passthroughBehavior: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        timeoutInMillis: Int = 0,
        tlsConfig: TlsConfig? = nil,
        type: IntegrationType? = nil,
        uri: String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct GetIntegrationOutputResponseBody: Equatable {
    public let type: IntegrationType?
    public let httpMethod: String?
    public let uri: String?
    public let connectionType: ConnectionType?
    public let connectionId: String?
    public let credentials: String?
    public let requestParameters: [String:String]?
    public let requestTemplates: [String:String]?
    public let passthroughBehavior: String?
    public let contentHandling: ContentHandlingStrategy?
    public let timeoutInMillis: Int
    public let cacheNamespace: String?
    public let cacheKeyParameters: [String]?
    public let integrationResponses: [String:IntegrationResponse]?
    public let tlsConfig: TlsConfig?
}

extension GetIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([String: IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [String:IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [String:IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension GetIntegrationResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationResponseInput(httpMethod: \(String(describing: httpMethod)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)), statusCode: \(String(describing: statusCode)))"}
}

extension GetIntegrationResponseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIntegrationResponseInputHeadersMiddleware: Middleware {
    public let id: String = "GetIntegrationResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationResponseInput>
    public typealias MOutput = OperationOutput<GetIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationResponseOutputError>
}

public struct GetIntegrationResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIntegrationResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationResponseInput>
    public typealias MOutput = OperationOutput<GetIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationResponseOutputError>
}

/// <p>Represents a get integration response request.</p>
public struct GetIntegrationResponseInput: Equatable {
    /// <p>[Required] Specifies a get integration response request's HTTP method.</p>
    public let httpMethod: String?
    /// <p>[Required] Specifies a get integration response request's resource identifier.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] Specifies a get integration response request's status code.</p>
    public let statusCode: String?

    public init (
        httpMethod: String? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil,
        statusCode: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct GetIntegrationResponseInputBody: Equatable {
}

extension GetIntegrationResponseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIntegrationResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationResponseOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationResponseOutputResponse(contentHandling: \(String(describing: contentHandling)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), selectionPattern: \(String(describing: selectionPattern)), statusCode: \(String(describing: statusCode)))"}
}

extension GetIntegrationResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentHandling = output.contentHandling
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.selectionPattern = output.selectionPattern
            self.statusCode = output.statusCode
        } else {
            self.contentHandling = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.selectionPattern = nil
            self.statusCode = nil
        }
    }
}

/// <p>Represents an integration response. The status code must map to an existing <a>MethodResponse</a>, and parameters and templates can be used to transform the back-end response.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct GetIntegrationResponseOutputResponse: Equatable {
    /// <p>Specifies how to handle response payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p>
    ///     <ul>
    ///       <li><p><code>CONVERT_TO_BINARY</code>: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p></li>
    ///       <li><p><code>CONVERT_TO_TEXT</code>: Converts a response payload from a binary blob to a Base64-encoded string.</p></li>
    ///     </ul>
    ///     <p>If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.</p>
    public let contentHandling: ContentHandlingStrategy?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the back end.
    ///             The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. The mapped non-static value must match the pattern of <code>integration.response.header.{name}</code> or <code>integration.response.body.{JSON-expression}</code>, where <code>name</code> is a valid and unique response header name and <code>JSON-expression</code> is a valid JSON expression without the <code>$</code> prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>
    public let responseTemplates: [String:String]?
    /// <p>Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the <code>.+</code> regex to match error response. However, make sure that the error response does not contain any newline (<code>\n</code>) character in such cases. If the back end is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.</p>
    public let selectionPattern: String?
    /// <p>Specifies the status code that is used to map the integration response to an existing <a>MethodResponse</a>.</p>
    public let statusCode: String?

    public init (
        contentHandling: ContentHandlingStrategy? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        selectionPattern: String? = nil,
        statusCode: String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct GetIntegrationResponseOutputResponseBody: Equatable {
    public let statusCode: String?
    public let selectionPattern: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let contentHandling: ContentHandlingStrategy?
}

extension GetIntegrationResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

extension GetMethodInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMethodInput(httpMethod: \(String(describing: httpMethod)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)))"}
}

extension GetMethodInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMethodInputHeadersMiddleware: Middleware {
    public let id: String = "GetMethodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMethodInput>
    public typealias MOutput = OperationOutput<GetMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMethodOutputError>
}

public struct GetMethodInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMethodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMethodInput>
    public typealias MOutput = OperationOutput<GetMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMethodOutputError>
}

/// <p>Request to describe an existing <a>Method</a> resource.</p>
public struct GetMethodInput: Equatable {
    /// <p>[Required] Specifies the method request's HTTP method type.</p>
    public let httpMethod: String?
    /// <p>[Required] The <a>Resource</a> identifier for the <a>Method</a> resource.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        httpMethod: String? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct GetMethodInputBody: Equatable {
}

extension GetMethodInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMethodOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMethodOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMethodOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMethodOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMethodOutputResponse(apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), httpMethod: \(String(describing: httpMethod)), methodIntegration: \(String(describing: methodIntegration)), methodResponses: \(String(describing: methodResponses)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), requestValidatorId: \(String(describing: requestValidatorId)))"}
}

extension GetMethodOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMethodOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.httpMethod = output.httpMethod
            self.methodIntegration = output.methodIntegration
            self.methodResponses = output.methodResponses
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.requestValidatorId = output.requestValidatorId
        } else {
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.httpMethod = nil
            self.methodIntegration = nil
            self.methodResponses = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.requestValidatorId = nil
        }
    }
}

/// <p>
///             Represents a client-facing interface by which the client calls the API to access back-end resources. A <b>Method</b> resource is
///             integrated with an <a>Integration</a> resource. Both consist of a request and one or more responses. The method request takes
///             the client input that is passed to the back end through the integration request. A method response returns the output from
///             the back end to the client through an integration response. A method request is embodied in a <b>Method</b> resource, whereas
///             an integration request is embodied in an <a>Integration</a> resource.  On the other hand, a method response is represented
///             by a <a>MethodResponse</a> resource, whereas an integration response is represented by an <a>IntegrationResponse</a> resource.
///         </p>
///         <div class="remarks">
///           <p></p>
///           <h4>Example: Retrive the GET method on a specified resource</h4>
///           <h5>Request</h5>
///           <p>The following example request retrieves the information about the GET method on an API resource (<code>3kzxbg5sa2</code>) of an API (<code>fugvjdxtri</code>). </p>
///           <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1
/// Content-Type: application/json
/// Host: apigateway.us-east-1.amazonaws.com
/// X-Amz-Date: 20160603T210259Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
///           <h5>Response</h5>
///           <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
///           <pre><code>{
///   "_links": {
///     "curies": [
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
///         "name": "integration",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
///         "name": "integrationresponse",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html",
///         "name": "method",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
///         "name": "methodresponse",
///         "templated": true
///       }
///     ],
///     "self": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET",
///       "name": "GET",
///       "title": "GET"
///     },
///     "integration:put": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///     },
///     "method:delete": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
///     },
///     "method:integration": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///     },
///     "method:responses": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///       "name": "200",
///       "title": "200"
///     },
///     "method:update": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
///     },
///     "methodresponse:put": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}",
///       "templated": true
///     }
///   },
///   "apiKeyRequired": true,
///   "authorizationType": "NONE",
///   "httpMethod": "GET",
///   "_embedded": {
///     "method:integration": {
///       "_links": {
///         "self": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integration:delete": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integration:responses": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
///           "name": "200",
///           "title": "200"
///         },
///         "integration:update": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integrationresponse:put": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}",
///           "templated": true
///         }
///       },
///       "cacheKeyParameters": [],
///       "cacheNamespace": "3kzxbg5sa2",
///       "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
///       "httpMethod": "POST",
///       "passthroughBehavior": "WHEN_NO_MATCH",
///       "requestParameters": {
///         "integration.request.header.Content-Type": "'application/x-amz-json-1.1'"
///       },
///       "requestTemplates": {
///         "application/json": "{\n}"
///       },
///       "type": "AWS",
///       "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams",
///       "_embedded": {
///         "integration:responses": {
///           "_links": {
///             "self": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
///               "name": "200",
///               "title": "200"
///             },
///             "integrationresponse:delete": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
///             },
///             "integrationresponse:update": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
///             }
///           },
///           "responseParameters": {
///             "method.response.header.Content-Type": "'application/xml'"
///           },
///           "responseTemplates": {
///             "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E\")"
///           },
///           "statusCode": "200"
///         }
///       }
///     },
///     "method:responses": {
///       "_links": {
///         "self": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///           "name": "200",
///           "title": "200"
///         },
///         "methodresponse:delete": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///         },
///         "methodresponse:update": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///         }
///       },
///       "responseModels": {
///         "application/json": "Empty"
///       },
///       "responseParameters": {
///         "method.response.header.Content-Type": false
///       },
///       "statusCode": "200"
///     }
///   }
/// }</code></pre>
///           <p>In the example above, the response template for the <code>200 OK</code> response maps the JSON output from the <code>ListStreams</code> action in the back end to an XML output. The mapping template is URL-encoded as <code>%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E</code> and the output is decoded using the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#util-templat-reference">$util.urlDecode()</a> helper function.</p>
///       </div>
///       <div class="seeAlso">
///         <a>MethodResponse</a>, <a>Integration</a>, <a>IntegrationResponse</a>, <a>Resource</a>,
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings.html">Set up an API's method</a>
///       </div>
public struct GetMethodOutputResponse: Equatable {
    /// <p>A boolean flag specifying whether a valid <a>ApiKey</a> is required to invoke this method.</p>
    public let apiKeyRequired: Bool?
    /// <p>A list of authorization scopes configured on the method. The scopes are used with a <code>COGNITO_USER_POOLS</code> authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    public let authorizationScopes: [String]?
    /// <p>The method's authorization type. Valid values are <code>NONE</code> for open access, <code>AWS_IAM</code> for using AWS IAM permissions, <code>CUSTOM</code> for using a custom authorizer, or <code>COGNITO_USER_POOLS</code> for using a Cognito user pool.</p>
    public let authorizationType: String?
    /// <p>The identifier of an <a>Authorizer</a> to use on this method. The <code>authorizationType</code> must be <code>CUSTOM</code>.</p>
    public let authorizerId: String?
    /// <p>The method's HTTP verb.</p>
    public let httpMethod: String?
    /// <p>Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.</p>
    ///       <div class="remarks">
    ///         <p></p>
    ///         <h4>Example: </h4>
    ///         <h5>Request</h5>
    ///         <p></p>
    ///         <pre><code>GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// Content-Length: 117
    /// X-Amz-Date: 20160613T213210Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": [
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
    ///         "name": "integration",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///         "name": "integrationresponse",
    ///         "templated": true
    ///       }
    ///     ],
    ///     "self": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integration:delete": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integration:responses": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200",
    ///       "name": "200",
    ///       "title": "200"
    ///     },
    ///     "integration:update": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integrationresponse:put": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/{status_code}",
    ///       "templated": true
    ///     }
    ///   },
    ///   "cacheKeyParameters": [],
    ///   "cacheNamespace": "0cjtch",
    ///   "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
    ///   "httpMethod": "POST",
    ///   "passthroughBehavior": "WHEN_NO_MATCH",
    ///   "requestTemplates": {
    ///     "application/json": "{\n    \"a\":  \"$input.params('operand1')\",\n    \"b\":  \"$input.params('operand2')\", \n    \"op\": \"$input.params('operator')\"   \n}"
    ///   },
    ///   "type": "AWS",
    ///   "uri": "arn:aws:apigateway:us-west-2:lambda:path//2015-03-31/functions/arn:aws:lambda:us-west-2:123456789012:function:Calc/invocations",
    ///   "_embedded": {
    ///     "integration:responses": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "integrationresponse:delete": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200"
    ///         },
    ///         "integrationresponse:update": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200"
    ///         }
    ///       },
    ///       "responseParameters": {
    ///         "method.response.header.operator": "integration.response.body.op",
    ///         "method.response.header.operand_2": "integration.response.body.b",
    ///         "method.response.header.operand_1": "integration.response.body.a"
    ///       },
    ///       "responseTemplates": {
    ///         "application/json": "#set($res = $input.path('$'))\n{\n    \"result\": \"$res.a, $res.b, $res.op => $res.c\",\n  \"a\" : \"$res.a\",\n  \"b\" : \"$res.b\",\n  \"op\" : \"$res.op\",\n  \"c\" : \"$res.c\"\n}"
    ///       },
    ///       "selectionPattern": "",
    ///       "statusCode": "200"
    ///     }
    ///   }
    /// }</code></pre>
    ///         <p></p>
    ///       </div>
    ///       <div class="seeAlso">
    ///         <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-integration.html">AWS CLI</a>
    ///       </div>
    public let methodIntegration: Integration?
    /// <p>Gets a method response associated with a given HTTP status code. </p>
    ///       <div class="remarks">
    ///         <p>The collection of method responses are encapsulated in a key-value map, where the key is a response's HTTP status code and the value is a <a>MethodResponse</a> resource that specifies the response returned to the caller from the back end through the integration response.</p>
    ///         <h4>Example: Get a 200 OK response of a GET method</h4>
    ///         <h5>Request</h5>
    ///         <p></p>
    ///         <pre><code>GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200 HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// Content-Length: 117
    /// X-Amz-Date: 20160613T215008Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": {
    ///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
    ///       "name": "methodresponse",
    ///       "templated": true
    ///     },
    ///     "self": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200",
    ///       "title": "200"
    ///     },
    ///     "methodresponse:delete": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200"
    ///     },
    ///     "methodresponse:update": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200"
    ///     }
    ///   },
    ///   "responseModels": {
    ///     "application/json": "Empty"
    ///   },
    ///   "responseParameters": {
    ///     "method.response.header.operator": false,
    ///     "method.response.header.operand_2": false,
    ///     "method.response.header.operand_1": false
    ///   },
    ///   "statusCode": "200"
    /// }</code></pre>
    ///         <p></p>
    ///       </div>
    ///       <div class="seeAlso">
    ///         <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-method-response.html">AWS CLI</a>
    ///       </div>
    public let methodResponses: [String:MethodResponse]?
    /// <p>A human-friendly operation identifier for the method. For example, you can assign the <code>operationName</code> of <code>ListPets</code> for the <code>GET /pets</code> method in the <code>PetStore</code> example.</p>
    public let operationName: String?
    /// <p>A key-value map specifying data schemas, represented by <a>Model</a> resources, (as the mapped value) of the request payloads of given content types (as the mapping key).</p>
    public let requestModels: [String:String]?
    /// <p>A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of  <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (<code>true</code>) or optional (<code>false</code>).  The method request parameter names defined here are available in <a>Integration</a> to be mapped to integration request parameters or templates.</p>
    public let requestParameters: [String:Bool]?
    /// <p>The identifier of a <a>RequestValidator</a> for request validation.</p>
    public let requestValidatorId: String?

    public init (
        apiKeyRequired: Bool? = nil,
        authorizationScopes: [String]? = nil,
        authorizationType: String? = nil,
        authorizerId: String? = nil,
        httpMethod: String? = nil,
        methodIntegration: Integration? = nil,
        methodResponses: [String:MethodResponse]? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:Bool]? = nil,
        requestValidatorId: String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

struct GetMethodOutputResponseBody: Equatable {
    public let httpMethod: String?
    public let authorizationType: String?
    public let authorizerId: String?
    public let apiKeyRequired: Bool?
    public let requestValidatorId: String?
    public let operationName: String?
    public let requestParameters: [String:Bool]?
    public let requestModels: [String:String]?
    public let methodResponses: [String:MethodResponse]?
    public let methodIntegration: Integration?
    public let authorizationScopes: [String]?
}

extension GetMethodOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([String: MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [String:MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [String:MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

extension GetMethodResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMethodResponseInput(httpMethod: \(String(describing: httpMethod)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)), statusCode: \(String(describing: statusCode)))"}
}

extension GetMethodResponseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMethodResponseInputHeadersMiddleware: Middleware {
    public let id: String = "GetMethodResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMethodResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMethodResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMethodResponseInput>
    public typealias MOutput = OperationOutput<GetMethodResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMethodResponseOutputError>
}

public struct GetMethodResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMethodResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMethodResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMethodResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMethodResponseInput>
    public typealias MOutput = OperationOutput<GetMethodResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMethodResponseOutputError>
}

/// <p>Request to describe a <a>MethodResponse</a> resource.</p>
public struct GetMethodResponseInput: Equatable {
    /// <p>[Required] The HTTP verb of the <a>Method</a> resource.</p>
    public let httpMethod: String?
    /// <p>[Required] The <a>Resource</a> identifier for the <a>MethodResponse</a> resource.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The status code for the <a>MethodResponse</a> resource.</p>
    public let statusCode: String?

    public init (
        httpMethod: String? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil,
        statusCode: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct GetMethodResponseInputBody: Equatable {
}

extension GetMethodResponseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMethodResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMethodResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMethodResponseOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMethodResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMethodResponseOutputResponse(responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), statusCode: \(String(describing: statusCode)))"}
}

extension GetMethodResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMethodResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.statusCode = output.statusCode
        } else {
            self.responseModels = nil
            self.responseParameters = nil
            self.statusCode = nil
        }
    }
}

/// <p>Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template. <!-- API Gateway sends back the status code to the caller as the HTTP status code. Parameters and models can be used to transform the response from the method's integration.--></p>
///         <div class="remarks">
///           <p></p>
///           <h4>Example: A <b>MethodResponse</b> instance of an API</h4>
///           <h5>Request</h5>
///           <p>The example request retrieves a <b>MethodResponse</b> of the 200 status code.</p>
///           <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200 HTTP/1.1
/// Content-Type: application/json
/// Host: apigateway.us-east-1.amazonaws.com
/// X-Amz-Date: 20160603T222952Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
///           <h5>Response</h5>
///           <p>The successful response returns <code>200 OK</code> status and a payload as follows:</p>
///           <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
///       "name": "methodresponse",
///       "templated": true
///     },
///     "self": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///       "title": "200"
///     },
///     "methodresponse:delete": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///     },
///     "methodresponse:update": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///     }
///   },
///   "responseModels": {
///     "application/json": "Empty"
///   },
///   "responseParameters": {
///     "method.response.header.Content-Type": false
///   },
///   "statusCode": "200"
/// }</code></pre>
///           <p></p>
///       </div>
///       <div class="seeAlso">
///         <a>Method</a>, <a>IntegrationResponse</a>, <a>Integration</a>
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct GetMethodResponseOutputResponse: Equatable {
    /// <p>Specifies the <a>Model</a> resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a <a>Model</a> name as the value.</p>
    public let responseModels: [String:String]?
    /// <p>A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's <a>IntegrationResponse</a>. The integration response data that can be mapped include an integration response header expressed in <code>integration.response.header.{name}</code>, a static value enclosed within a pair of single quotes (e.g., <code>'application/json'</code>), or a JSON expression from the back-end response payload in the form of <code>integration.response.body.{JSON-expression}</code>, where <code>JSON-expression</code> is a valid JSON expression without the <code>$</code> prefix.)</p>
    public let responseParameters: [String:Bool]?
    /// <p>The method response's status code.</p>
    public let statusCode: String?

    public init (
        responseModels: [String:String]? = nil,
        responseParameters: [String:Bool]? = nil,
        statusCode: String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

struct GetMethodResponseOutputResponseBody: Equatable {
    public let statusCode: String?
    public let responseParameters: [String:Bool]?
    public let responseModels: [String:String]?
}

extension GetMethodResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

extension GetModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelInput(flatten: \(String(describing: flatten)), modelName: \(String(describing: modelName)), restApiId: \(String(describing: restApiId)))"}
}

extension GetModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetModelInputHeadersMiddleware: Middleware {
    public let id: String = "GetModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelInput>
    public typealias MOutput = OperationOutput<GetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelOutputError>
}

public struct GetModelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let flattenQueryItem = URLQueryItem(name: "flatten".urlPercentEncoding(), value: String(input.operationInput.flatten).urlPercentEncoding())
        input.builder.withQueryItem(flattenQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelInput>
    public typealias MOutput = OperationOutput<GetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelOutputError>
}

/// <p>Request to list information about a model in an existing <a>RestApi</a> resource.</p>
public struct GetModelInput: Equatable {
    /// <p>A query parameter of a Boolean value to resolve (<code>true</code>) all external model references and returns a flattened model schema or not (<code>false</code>) The default is <code>false</code>.</p>
    public let flatten: Bool
    /// <p>[Required] The name of the model as an identifier.</p>
    public let modelName: String?
    /// <p>[Required] The <a>RestApi</a> identifier under which the <a>Model</a> exists.</p>
    public let restApiId: String?

    public init (
        flatten: Bool = false,
        modelName: String? = nil,
        restApiId: String? = nil
    )
    {
        self.flatten = flatten
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

struct GetModelInputBody: Equatable {
}

extension GetModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelOutputResponse(contentType: \(String(describing: contentType)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

extension GetModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentType = output.contentType
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.schema = nil
        }
    }
}

/// <p>Represents the data structure of a method's request or response payload.</p>
///       <div class="remarks">
///         <p>A request model defines the data structure of the client-supplied request payload. A response model defines the data structure of the response payload returned by the back end. Although not required, models are useful for mapping payloads between the front end and back end.</p>
///         <p>A model is used for generating an API's SDK, validating the input request body, and creating a skeletal mapping template.</p>
///       </div>
///       <div class="seeAlso">
///         <a>Method</a>, <a>MethodResponse</a>, <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html">Models and Mappings</a>
///       </div>
public struct GetModelOutputResponse: Equatable {
    /// <p>The content-type for the model.</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>The identifier for the model resource.</p>
    public let id: String?
    /// <p>The name of the model. Must be an alphanumeric string.</p>
    public let name: String?
    /// <p>The schema for the model. For <code>application/json</code> models, this should be <a target="_blank" href="https://tools.ietf.org/html/draft-zyp-json-schema-04">JSON schema draft 4</a> model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.</p>
    public let schema: String?

    public init (
        contentType: String? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

struct GetModelOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let schema: String?
    public let contentType: String?
}

extension GetModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension GetModelTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelTemplateInput(modelName: \(String(describing: modelName)), restApiId: \(String(describing: restApiId)))"}
}

extension GetModelTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetModelTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetModelTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelTemplateInput>
    public typealias MOutput = OperationOutput<GetModelTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelTemplateOutputError>
}

public struct GetModelTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetModelTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelTemplateInput>
    public typealias MOutput = OperationOutput<GetModelTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelTemplateOutputError>
}

/// <p>Request to generate a sample mapping template used to transform the payload.</p>
public struct GetModelTemplateInput: Equatable {
    /// <p>[Required] The name of the model for which to generate a template.</p>
    public let modelName: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        modelName: String? = nil,
        restApiId: String? = nil
    )
    {
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

struct GetModelTemplateInputBody: Equatable {
}

extension GetModelTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetModelTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelTemplateOutputResponse(value: \(String(describing: value)))"}
}

extension GetModelTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetModelTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.value = output.value
        } else {
            self.value = nil
        }
    }
}

/// <p>Represents a mapping template used to transform a payload.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html#models-mappings-mappings">Mapping Templates</a>
///       </div>
public struct GetModelTemplateOutputResponse: Equatable {
    /// <p>The Apache <a target="_blank" href="https://velocity.apache.org/engine/devel/vtl-reference.html">Velocity Template Language (VTL)</a> template content used for the template resource.</p>
    public let value: String?

    public init (
        value: String? = nil
    )
    {
        self.value = value
    }
}

struct GetModelTemplateOutputResponseBody: Equatable {
    public let value: String?
}

extension GetModelTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case value
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GetModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelsInput(limit: \(String(describing: limit)), position: \(String(describing: position)), restApiId: \(String(describing: restApiId)))"}
}

extension GetModelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetModelsInputHeadersMiddleware: Middleware {
    public let id: String = "GetModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelsInput>
    public typealias MOutput = OperationOutput<GetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelsOutputError>
}

public struct GetModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelsInput>
    public typealias MOutput = OperationOutput<GetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelsOutputError>
}

/// <p>Request to list existing <a>Models</a> defined for a <a>RestApi</a> resource.</p>
public struct GetModelsInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        limit: Int? = nil,
        position: String? = nil,
        restApiId: String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetModelsInputBody: Equatable {
}

extension GetModelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelsOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>Represents a collection of <a>Model</a> resources.</p>
///       <div class="seeAlso">
///         <a>Method</a>, <a>MethodResponse</a>, <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html">Models and Mappings</a>
///       </div>
public struct GetModelsOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [Model]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [Model]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetModelsOutputResponseBody: Equatable {
    public let items: [Model]?
}

extension GetModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Model?].self, forKey: .items)
        var itemsDecoded0:[Model]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Model]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetRequestValidatorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRequestValidatorInput(requestValidatorId: \(String(describing: requestValidatorId)), restApiId: \(String(describing: restApiId)))"}
}

extension GetRequestValidatorInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRequestValidatorInputHeadersMiddleware: Middleware {
    public let id: String = "GetRequestValidatorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRequestValidatorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRequestValidatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRequestValidatorInput>
    public typealias MOutput = OperationOutput<GetRequestValidatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRequestValidatorOutputError>
}

public struct GetRequestValidatorInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRequestValidatorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRequestValidatorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRequestValidatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRequestValidatorInput>
    public typealias MOutput = OperationOutput<GetRequestValidatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRequestValidatorOutputError>
}

/// <p>Gets a <a>RequestValidator</a> of a given <a>RestApi</a>.</p>
public struct GetRequestValidatorInput: Equatable {
    /// <p>[Required] The identifier of the <a>RequestValidator</a> to be retrieved.</p>
    public let requestValidatorId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        requestValidatorId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

struct GetRequestValidatorInputBody: Equatable {
}

extension GetRequestValidatorInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRequestValidatorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRequestValidatorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRequestValidatorOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRequestValidatorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRequestValidatorOutputResponse(id: \(String(describing: id)), name: \(String(describing: name)), validateRequestBody: \(String(describing: validateRequestBody)), validateRequestParameters: \(String(describing: validateRequestParameters)))"}
}

extension GetRequestValidatorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRequestValidatorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.name = output.name
            self.validateRequestBody = output.validateRequestBody
            self.validateRequestParameters = output.validateRequestParameters
        } else {
            self.id = nil
            self.name = nil
            self.validateRequestBody = false
            self.validateRequestParameters = false
        }
    }
}

/// <p>A set of validation rules for incoming <a>Method</a> requests.</p>
///         <div class="remarks">
///           <p>In OpenAPI, a <a>RequestValidator</a> of an API is defined by the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.requestValidator.html">x-amazon-apigateway-request-validators.requestValidator</a> object. It the referenced using the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validator">x-amazon-apigateway-request-validator</a> property.</p>
///         </div>
///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html">Enable Basic Request Validation in API Gateway</a></div>
public struct GetRequestValidatorOutputResponse: Equatable {
    /// <p>The identifier of this <a>RequestValidator</a>.</p>
    public let id: String?
    /// <p>The name of this <a>RequestValidator</a></p>
    public let name: String?
    /// <p>A Boolean flag to indicate whether to validate a request body according to the configured <a>Model</a> schema.</p>
    public let validateRequestBody: Bool
    /// <p>A Boolean flag to indicate whether to validate request parameters (<code>true</code>) or not (<code>false</code>).</p>
    public let validateRequestParameters: Bool

    public init (
        id: String? = nil,
        name: String? = nil,
        validateRequestBody: Bool = false,
        validateRequestParameters: Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct GetRequestValidatorOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let validateRequestBody: Bool
    public let validateRequestParameters: Bool
}

extension GetRequestValidatorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decode(Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decode(Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

extension GetRequestValidatorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRequestValidatorsInput(limit: \(String(describing: limit)), position: \(String(describing: position)), restApiId: \(String(describing: restApiId)))"}
}

extension GetRequestValidatorsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRequestValidatorsInputHeadersMiddleware: Middleware {
    public let id: String = "GetRequestValidatorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRequestValidatorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRequestValidatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRequestValidatorsInput>
    public typealias MOutput = OperationOutput<GetRequestValidatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRequestValidatorsOutputError>
}

public struct GetRequestValidatorsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRequestValidatorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRequestValidatorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRequestValidatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRequestValidatorsInput>
    public typealias MOutput = OperationOutput<GetRequestValidatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRequestValidatorsOutputError>
}

/// <p>Gets the <a>RequestValidators</a> collection of a given <a>RestApi</a>.</p>
public struct GetRequestValidatorsInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        limit: Int? = nil,
        position: String? = nil,
        restApiId: String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetRequestValidatorsInputBody: Equatable {
}

extension GetRequestValidatorsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRequestValidatorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRequestValidatorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRequestValidatorsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRequestValidatorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRequestValidatorsOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetRequestValidatorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRequestValidatorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>A collection of <a>RequestValidator</a> resources of a given <a>RestApi</a>.</p>
///         <div class="remarks">
///           <p>In OpenAPI, the <a>RequestValidators</a> of an API is defined by the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.html">x-amazon-apigateway-request-validators</a> extension.</p>
///         </div>
///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html">Enable Basic Request Validation in API Gateway</a></div>
public struct GetRequestValidatorsOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [RequestValidator]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [RequestValidator]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetRequestValidatorsOutputResponseBody: Equatable {
    public let items: [RequestValidator]?
}

extension GetRequestValidatorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([RequestValidator?].self, forKey: .items)
        var itemsDecoded0:[RequestValidator]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [RequestValidator]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceInput(embed: \(String(describing: embed)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)))"}
}

extension GetResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetResourceInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceInput>
    public typealias MOutput = OperationOutput<GetResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceOutputError>
}

public struct GetResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let embed = input.operationInput.embed {
            embed.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "embed".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceInput>
    public typealias MOutput = OperationOutput<GetResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceOutputError>
}

/// <p>Request to list information about a resource.</p>
public struct GetResourceInput: Equatable {
    /// <p>A query parameter to retrieve the specified resources embedded in the returned <a>Resource</a> representation in the response. This <code>embed</code> parameter value is a list of comma-separated strings. Currently, the request supports only retrieval of the embedded <a>Method</a> resources this way. The query parameter value must be a single-valued list and contain the <code>"methods"</code> string. For example, <code>GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods</code>.</p>
    public let embed: [String]?
    /// <p>[Required] The identifier for the <a>Resource</a> resource.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        embed: [String]? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.embed = embed
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct GetResourceInputBody: Equatable {
}

extension GetResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceOutputResponse(id: \(String(describing: id)), parentId: \(String(describing: parentId)), path: \(String(describing: path)), pathPart: \(String(describing: pathPart)), resourceMethods: \(String(describing: resourceMethods)))"}
}

extension GetResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.parentId = output.parentId
            self.path = output.path
            self.pathPart = output.pathPart
            self.resourceMethods = output.resourceMethods
        } else {
            self.id = nil
            self.parentId = nil
            self.path = nil
            self.pathPart = nil
            self.resourceMethods = nil
        }
    }
}

/// <p>Represents an API resource.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct GetResourceOutputResponse: Equatable {
    /// <p>The resource's identifier.</p>
    public let id: String?
    /// <p>The parent resource's identifier.</p>
    public let parentId: String?
    /// <p>The full path for this resource.</p>
    public let path: String?
    /// <p>The last path segment for this resource.</p>
    public let pathPart: String?
    /// <p>Gets an API resource's method of a given HTTP verb.</p>
    ///       <div class="remarks">
    ///         <p>The resource methods are a map of methods indexed by methods' HTTP verbs enabled on the resource. This method map is included in the <code>200 OK</code> response of the <code>GET /restapis/{restapi_id}/resources/{resource_id}</code> or <code>GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods</code> request.</p>
    ///         <h4>Example: Get the GET method of an API resource</h4>
    ///         <h5>Request</h5>
    ///         <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// X-Amz-Date: 20170223T031827Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20170223/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": [
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
    ///         "name": "integration",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///         "name": "integrationresponse",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html",
    ///         "name": "method",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
    ///         "name": "methodresponse",
    ///         "templated": true
    ///       }
    ///     ],
    ///     "self": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET",
    ///       "name": "GET",
    ///       "title": "GET"
    ///     },
    ///     "integration:put": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///     },
    ///     "method:delete": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
    ///     },
    ///     "method:integration": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///     },
    ///     "method:responses": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
    ///       "name": "200",
    ///       "title": "200"
    ///     },
    ///     "method:update": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
    ///     },
    ///     "methodresponse:put": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}",
    ///       "templated": true
    ///     }
    ///   },
    ///   "apiKeyRequired": false,
    ///   "authorizationType": "NONE",
    ///   "httpMethod": "GET",
    ///   "_embedded": {
    ///     "method:integration": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integration:delete": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integration:responses": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "integration:update": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integrationresponse:put": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}",
    ///           "templated": true
    ///         }
    ///       },
    ///       "cacheKeyParameters": [],
    ///       "cacheNamespace": "3kzxbg5sa2",
    ///       "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
    ///       "httpMethod": "POST",
    ///       "passthroughBehavior": "WHEN_NO_MATCH",
    ///       "requestParameters": {
    ///         "integration.request.header.Content-Type": "'application/x-amz-json-1.1'"
    ///       },
    ///       "requestTemplates": {
    ///         "application/json": "{\n}"
    ///       },
    ///       "type": "AWS",
    ///       "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams",
    ///       "_embedded": {
    ///         "integration:responses": {
    ///           "_links": {
    ///             "self": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///               "name": "200",
    ///               "title": "200"
    ///             },
    ///             "integrationresponse:delete": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///             },
    ///             "integrationresponse:update": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///             }
    ///           },
    ///           "responseParameters": {
    ///             "method.response.header.Content-Type": "'application/xml'"
    ///           },
    ///           "responseTemplates": {
    ///             "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n"
    ///           },
    ///           "statusCode": "200"
    ///         }
    ///       }
    ///     },
    ///     "method:responses": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "methodresponse:delete": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
    ///         },
    ///         "methodresponse:update": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
    ///         }
    ///       },
    ///       "responseModels": {
    ///         "application/json": "Empty"
    ///       },
    ///       "responseParameters": {
    ///         "method.response.header.Content-Type": false
    ///       },
    ///       "statusCode": "200"
    ///     }
    ///   }
    /// }</code></pre>
    ///         <p>If the <code>OPTIONS</code> is enabled on the resource, you can follow the example here to get that method. Just replace the <code>GET</code> of the last path segment in the request URL with <code>OPTIONS</code>.</p>
    ///       </div>
    ///       <div class="seeAlso">
    ///       </div>
    public let resourceMethods: [String:Method]?

    public init (
        id: String? = nil,
        parentId: String? = nil,
        path: String? = nil,
        pathPart: String? = nil,
        resourceMethods: [String:Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

struct GetResourceOutputResponseBody: Equatable {
    public let id: String?
    public let parentId: String?
    public let pathPart: String?
    public let path: String?
    public let resourceMethods: [String:Method]?
}

extension GetResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([String: Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [String:Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [String:Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

extension GetResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcesInput(embed: \(String(describing: embed)), limit: \(String(describing: limit)), position: \(String(describing: position)), restApiId: \(String(describing: restApiId)))"}
}

extension GetResourcesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcesInput>
    public typealias MOutput = OperationOutput<GetResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcesOutputError>
}

public struct GetResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        if let embed = input.operationInput.embed {
            embed.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "embed".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcesInput>
    public typealias MOutput = OperationOutput<GetResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcesOutputError>
}

/// <p>Request to list information about a collection of resources.</p>
public struct GetResourcesInput: Equatable {
    /// <p>A query parameter used to retrieve the specified resources embedded in the returned <a>Resources</a> resource in the response.  This <code>embed</code> parameter value is a list of comma-separated strings. Currently, the request supports only retrieval of the embedded <a>Method</a> resources this way. The query parameter value must be a single-valued list and contain the <code>"methods"</code> string. For example, <code>GET /restapis/{restapi_id}/resources?embed=methods</code>.</p>
    public let embed: [String]?
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        embed: [String]? = nil,
        limit: Int? = nil,
        position: String? = nil,
        restApiId: String? = nil
    )
    {
        self.embed = embed
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetResourcesInputBody: Equatable {
}

extension GetResourcesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcesOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>Represents a collection of <a>Resource</a> resources.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct GetResourcesOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [Resource]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [Resource]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetResourcesOutputResponseBody: Equatable {
    public let items: [Resource]?
}

extension GetResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .items)
        var itemsDecoded0:[Resource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Resource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetRestApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRestApiInput(restApiId: \(String(describing: restApiId)))"}
}

extension GetRestApiInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRestApiInputHeadersMiddleware: Middleware {
    public let id: String = "GetRestApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRestApiInput>
    public typealias MOutput = OperationOutput<GetRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRestApiOutputError>
}

public struct GetRestApiInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRestApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRestApiInput>
    public typealias MOutput = OperationOutput<GetRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRestApiOutputError>
}

/// <p>The GET request to list an existing <a>RestApi</a> defined for your collection. </p>
public struct GetRestApiInput: Equatable {
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        restApiId: String? = nil
    )
    {
        self.restApiId = restApiId
    }
}

struct GetRestApiInputBody: Equatable {
}

extension GetRestApiInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRestApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRestApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRestApiOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRestApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRestApiOutputResponse(apiKeySource: \(String(describing: apiKeySource)), binaryMediaTypes: \(String(describing: binaryMediaTypes)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), endpointConfiguration: \(String(describing: endpointConfiguration)), id: \(String(describing: id)), minimumCompressionSize: \(String(describing: minimumCompressionSize)), name: \(String(describing: name)), policy: \(String(describing: policy)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

extension GetRestApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRestApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// <p>Represents a REST API.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct GetRestApiOutputResponse: Equatable {
    /// <p>The source of the API key for metering requests according to a usage plan. Valid values are: <ul><li><code>HEADER</code> to read the API key from the <code>X-API-Key</code> header of a request. </li><li><code>AUTHORIZER</code> to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</li></ul></p>
    public let apiKeySource: ApiKeySourceType?
    /// <p>The list of binary media types supported by the <a>RestApi</a>. By default, the <a>RestApi</a> supports only UTF-8-encoded text payloads.</p>
    public let binaryMediaTypes: [String]?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The API's description.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default <code>execute-api</code> endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>The endpoint configuration of this <a>RestApi</a> showing the endpoint types of the API.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>The API's identifier. This identifier is unique across all of your APIs in API Gateway.</p>
    public let id: String?
    /// <p>A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.</p>
    public let minimumCompressionSize: Int?
    /// <p>The API's name.</p>
    public let name: String?
    /// <p>A stringified JSON policy document that applies to this RestApi regardless of the caller and <a>Method</a> configuration.</p>
    public let policy: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when <code>failonwarnings</code> is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiKeySource: ApiKeySourceType? = nil,
        binaryMediaTypes: [String]? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        endpointConfiguration: EndpointConfiguration? = nil,
        id: String? = nil,
        minimumCompressionSize: Int? = nil,
        name: String? = nil,
        policy: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct GetRestApiOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let createdDate: Date?
    public let version: String?
    public let warnings: [String]?
    public let binaryMediaTypes: [String]?
    public let minimumCompressionSize: Int?
    public let apiKeySource: ApiKeySourceType?
    public let endpointConfiguration: EndpointConfiguration?
    public let policy: String?
    public let tags: [String:String]?
    public let disableExecuteApiEndpoint: Bool
}

extension GetRestApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension GetRestApisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRestApisInput(limit: \(String(describing: limit)), position: \(String(describing: position)))"}
}

extension GetRestApisInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRestApisInputHeadersMiddleware: Middleware {
    public let id: String = "GetRestApisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRestApisInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRestApisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRestApisInput>
    public typealias MOutput = OperationOutput<GetRestApisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRestApisOutputError>
}

public struct GetRestApisInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRestApisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRestApisInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRestApisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRestApisInput>
    public typealias MOutput = OperationOutput<GetRestApisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRestApisOutputError>
}

/// <p>The GET request to list existing <a>RestApis</a> defined for your collection.</p>
public struct GetRestApisInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        limit: Int? = nil,
        position: String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetRestApisInputBody: Equatable {
}

extension GetRestApisInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRestApisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRestApisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRestApisOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRestApisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRestApisOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetRestApisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRestApisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>Contains references to your APIs and links that guide you in how to interact with your collection. A collection offers a paginated view of your APIs.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct GetRestApisOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [RestApi]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [RestApi]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetRestApisOutputResponseBody: Equatable {
    public let items: [RestApi]?
}

extension GetRestApisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([RestApi?].self, forKey: .items)
        var itemsDecoded0:[RestApi]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [RestApi]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetSdkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSdkInput(parameters: \(String(describing: parameters)), restApiId: \(String(describing: restApiId)), sdkType: \(String(describing: sdkType)), stageName: \(String(describing: stageName)))"}
}

extension GetSdkInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSdkInputHeadersMiddleware: Middleware {
    public let id: String = "GetSdkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSdkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSdkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSdkInput>
    public typealias MOutput = OperationOutput<GetSdkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSdkOutputError>
}

public struct GetSdkInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSdkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSdkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSdkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let parameters = input.operationInput.parameters {
            let currentQueryItemNames = input.builder.currentQueryItems.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    input.builder.withQueryItem(queryItem)
                }
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSdkInput>
    public typealias MOutput = OperationOutput<GetSdkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSdkOutputError>
}

/// <p>Request a new generated client SDK for a <a>RestApi</a> and <a>Stage</a>.</p>
public struct GetSdkInput: Equatable {
    /// <p>A string-to-string key-value map of query parameters <code>sdkType</code>-dependent properties of the SDK. For <code>sdkType</code> of <code>objectivec</code> or <code>swift</code>,  a parameter named <code>classPrefix</code> is required. For <code>sdkType</code> of <code>android</code>, parameters named <code>groupId</code>, <code>artifactId</code>, <code>artifactVersion</code>, and <code>invokerPackage</code> are required. For <code>sdkType</code> of <code>java</code>, parameters named <code>serviceName</code> and <code>javaPackageName</code> are required. </p>
    public let parameters: [String:String]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The language for the generated SDK. Currently <code>java</code>, <code>javascript</code>, <code>android</code>, <code>objectivec</code> (for iOS), <code>swift</code> (for iOS), and <code>ruby</code>  are supported.</p>
    public let sdkType: String?
    /// <p>[Required] The name of the <a>Stage</a> that the SDK will use.</p>
    public let stageName: String?

    public init (
        parameters: [String:String]? = nil,
        restApiId: String? = nil,
        sdkType: String? = nil,
        stageName: String? = nil
    )
    {
        self.parameters = parameters
        self.restApiId = restApiId
        self.sdkType = sdkType
        self.stageName = stageName
    }
}

struct GetSdkInputBody: Equatable {
}

extension GetSdkInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSdkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSdkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSdkOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSdkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSdkOutputResponse(body: \(String(describing: body)), contentDisposition: \(String(describing: contentDisposition)), contentType: \(String(describing: contentType)))"}
}

extension GetSdkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.body = unwrappedData
        } else {
            self.body = nil
        }
    }
}

/// <p>The binary blob response to <a>GetSdk</a>, which contains the generated SDK.</p>
public struct GetSdkOutputResponse: Equatable {
    /// <p>The binary blob response to <a>GetSdk</a>, which contains the generated SDK.</p>
    public let body: Data?
    /// <p>The content-disposition header value in the HTTP response.</p>
    public let contentDisposition: String?
    /// <p>The content-type header value in the HTTP response.</p>
    public let contentType: String?

    public init (
        body: Data? = nil,
        contentDisposition: String? = nil,
        contentType: String? = nil
    )
    {
        self.body = body
        self.contentDisposition = contentDisposition
        self.contentType = contentType
    }
}

struct GetSdkOutputResponseBody: Equatable {
    public let body: Data?
}

extension GetSdkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension GetSdkTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSdkTypeInput(id: \(String(describing: id)))"}
}

extension GetSdkTypeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSdkTypeInputHeadersMiddleware: Middleware {
    public let id: String = "GetSdkTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSdkTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSdkTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSdkTypeInput>
    public typealias MOutput = OperationOutput<GetSdkTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSdkTypeOutputError>
}

public struct GetSdkTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSdkTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSdkTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSdkTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSdkTypeInput>
    public typealias MOutput = OperationOutput<GetSdkTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSdkTypeOutputError>
}

/// <p>Get an <a>SdkType</a> instance.</p>
public struct GetSdkTypeInput: Equatable {
    /// <p>[Required] The identifier of the queried <a>SdkType</a> instance.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetSdkTypeInputBody: Equatable {
}

extension GetSdkTypeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSdkTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSdkTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSdkTypeOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSdkTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSdkTypeOutputResponse(configurationProperties: \(String(describing: configurationProperties)), description: \(String(describing: description)), friendlyName: \(String(describing: friendlyName)), id: \(String(describing: id)))"}
}

extension GetSdkTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSdkTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationProperties = output.configurationProperties
            self.description = output.description
            self.friendlyName = output.friendlyName
            self.id = output.id
        } else {
            self.configurationProperties = nil
            self.description = nil
            self.friendlyName = nil
            self.id = nil
        }
    }
}

/// <p>A type of SDK that API Gateway can generate.</p>
public struct GetSdkTypeOutputResponse: Equatable {
    /// <p>A list of configuration properties of an <a>SdkType</a>.</p>
    public let configurationProperties: [SdkConfigurationProperty]?
    /// <p>The description of an <a>SdkType</a>.</p>
    public let description: String?
    /// <p>The user-friendly name of an <a>SdkType</a> instance.</p>
    public let friendlyName: String?
    /// <p>The identifier of an <a>SdkType</a> instance.</p>
    public let id: String?

    public init (
        configurationProperties: [SdkConfigurationProperty]? = nil,
        description: String? = nil,
        friendlyName: String? = nil,
        id: String? = nil
    )
    {
        self.configurationProperties = configurationProperties
        self.description = description
        self.friendlyName = friendlyName
        self.id = id
    }
}

struct GetSdkTypeOutputResponseBody: Equatable {
    public let id: String?
    public let friendlyName: String?
    public let description: String?
    public let configurationProperties: [SdkConfigurationProperty]?
}

extension GetSdkTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationProperties
        case description
        case friendlyName
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let friendlyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let configurationPropertiesContainer = try containerValues.decodeIfPresent([SdkConfigurationProperty?].self, forKey: .configurationProperties)
        var configurationPropertiesDecoded0:[SdkConfigurationProperty]? = nil
        if let configurationPropertiesContainer = configurationPropertiesContainer {
            configurationPropertiesDecoded0 = [SdkConfigurationProperty]()
            for structure0 in configurationPropertiesContainer {
                if let structure0 = structure0 {
                    configurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        configurationProperties = configurationPropertiesDecoded0
    }
}

extension GetSdkTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSdkTypesInput(limit: \(String(describing: limit)), position: \(String(describing: position)))"}
}

extension GetSdkTypesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSdkTypesInputHeadersMiddleware: Middleware {
    public let id: String = "GetSdkTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSdkTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSdkTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSdkTypesInput>
    public typealias MOutput = OperationOutput<GetSdkTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSdkTypesOutputError>
}

public struct GetSdkTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSdkTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSdkTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSdkTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSdkTypesInput>
    public typealias MOutput = OperationOutput<GetSdkTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSdkTypesOutputError>
}

/// <p>Get the <a>SdkTypes</a> collection.</p>
public struct GetSdkTypesInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        limit: Int? = nil,
        position: String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetSdkTypesInputBody: Equatable {
}

extension GetSdkTypesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSdkTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSdkTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSdkTypesOutputError: Equatable {
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSdkTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSdkTypesOutputResponse(items: \(String(describing: items)))"}
}

extension GetSdkTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSdkTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
    }
}

/// <p>The collection of <a>SdkType</a> instances.</p>
public struct GetSdkTypesOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [SdkType]?

    public init (
        items: [SdkType]? = nil
    )
    {
        self.items = items
    }
}

struct GetSdkTypesOutputResponseBody: Equatable {
    public let items: [SdkType]?
}

extension GetSdkTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([SdkType?].self, forKey: .items)
        var itemsDecoded0:[SdkType]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SdkType]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetStageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStageInput(restApiId: \(String(describing: restApiId)), stageName: \(String(describing: stageName)))"}
}

extension GetStageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStageInputHeadersMiddleware: Middleware {
    public let id: String = "GetStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStageInput>
    public typealias MOutput = OperationOutput<GetStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStageOutputError>
}

public struct GetStageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStageInput>
    public typealias MOutput = OperationOutput<GetStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStageOutputError>
}

/// <p>Requests API Gateway to get information about a <a>Stage</a> resource.</p>
public struct GetStageInput: Equatable {
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The name of the <a>Stage</a> resource to get information about.</p>
    public let stageName: String?

    public init (
        restApiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct GetStageInputBody: Equatable {
}

extension GetStageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStageOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStageOutputResponse(accessLogSettings: \(String(describing: accessLogSettings)), cacheClusterEnabled: \(String(describing: cacheClusterEnabled)), cacheClusterSize: \(String(describing: cacheClusterSize)), cacheClusterStatus: \(String(describing: cacheClusterStatus)), canarySettings: \(String(describing: canarySettings)), clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), documentationVersion: \(String(describing: documentationVersion)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), methodSettings: \(String(describing: methodSettings)), stageName: \(String(describing: stageName)), tags: \(String(describing: tags)), tracingEnabled: \(String(describing: tracingEnabled)), variables: \(String(describing: variables)), webAclArn: \(String(describing: webAclArn)))"}
}

extension GetStageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessLogSettings = output.accessLogSettings
            self.cacheClusterEnabled = output.cacheClusterEnabled
            self.cacheClusterSize = output.cacheClusterSize
            self.cacheClusterStatus = output.cacheClusterStatus
            self.canarySettings = output.canarySettings
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.documentationVersion = output.documentationVersion
            self.lastUpdatedDate = output.lastUpdatedDate
            self.methodSettings = output.methodSettings
            self.stageName = output.stageName
            self.tags = output.tags
            self.tracingEnabled = output.tracingEnabled
            self.variables = output.variables
            self.webAclArn = output.webAclArn
        } else {
            self.accessLogSettings = nil
            self.cacheClusterEnabled = false
            self.cacheClusterSize = nil
            self.cacheClusterStatus = nil
            self.canarySettings = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.description = nil
            self.documentationVersion = nil
            self.lastUpdatedDate = nil
            self.methodSettings = nil
            self.stageName = nil
            self.tags = nil
            self.tracingEnabled = false
            self.variables = nil
            self.webAclArn = nil
        }
    }
}

/// <p>Represents a unique identifier for a version of a deployed <a>RestApi</a> that is callable by users.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html">Deploy an API</a>
///       </div>
public struct GetStageOutputResponse: Equatable {
    /// <p>Settings for logging access in this stage.</p>
    public let accessLogSettings: AccessLogSettings?
    /// <p>Specifies whether a cache cluster is enabled for the stage.</p>
    public let cacheClusterEnabled: Bool
    /// <p>The size of the cache cluster for the stage, if enabled.</p>
    public let cacheClusterSize: CacheClusterSize?
    /// <p>The status of the cache cluster for the stage, if enabled.</p>
    public let cacheClusterStatus: CacheClusterStatus?
    /// <p>Settings for the canary deployment in this stage.</p>
    public let canarySettings: CanarySettings?
    /// <p>The identifier of a client certificate for an API stage.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the stage was created.</p>
    public let createdDate: Date?
    /// <p>The identifier of the <a>Deployment</a> that the stage points to.</p>
    public let deploymentId: String?
    /// <p>The stage's description.</p>
    public let description: String?
    /// <p>The version of the associated API documentation.</p>
    public let documentationVersion: String?
    /// <p>The timestamp when the stage last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>A map that defines the method settings for a <a>Stage</a> resource. Keys (designated as <code>/{method_setting_key</code> below) are method paths defined as <code>{resource_path}/{http_method}</code> for an individual method override, or <code>/\*/\*</code> for overriding all methods in the stage.  <!-- Any forward slash ("/") characters in the <code>resource_path</code> part must be encoded as "~1" as in, for example, <code>~1resource~1sub-resource/GET</code>.--></p>
    public let methodSettings: [String:MethodSetting]?
    /// <p>The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.</p>
    public let stageName: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>Specifies whether active tracing with X-ray is enabled for the <a>Stage</a>.</p>
    public let tracingEnabled: Bool
    /// <p>A map that defines the stage variables for a <a>Stage</a> resource. Variable names can
    ///           have alphanumeric and underscore characters, and the values must match <code>[A-Za-z0-9-._~:/?#&=,]+</code>.</p>
    public let variables: [String:String]?
    /// <p>The ARN of the WebAcl associated with the <a>Stage</a>.</p>
    public let webAclArn: String?

    public init (
        accessLogSettings: AccessLogSettings? = nil,
        cacheClusterEnabled: Bool = false,
        cacheClusterSize: CacheClusterSize? = nil,
        cacheClusterStatus: CacheClusterStatus? = nil,
        canarySettings: CanarySettings? = nil,
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        documentationVersion: String? = nil,
        lastUpdatedDate: Date? = nil,
        methodSettings: [String:MethodSetting]? = nil,
        stageName: String? = nil,
        tags: [String:String]? = nil,
        tracingEnabled: Bool = false,
        variables: [String:String]? = nil,
        webAclArn: String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

struct GetStageOutputResponseBody: Equatable {
    public let deploymentId: String?
    public let clientCertificateId: String?
    public let stageName: String?
    public let description: String?
    public let cacheClusterEnabled: Bool
    public let cacheClusterSize: CacheClusterSize?
    public let cacheClusterStatus: CacheClusterStatus?
    public let methodSettings: [String:MethodSetting]?
    public let variables: [String:String]?
    public let documentationVersion: String?
    public let accessLogSettings: AccessLogSettings?
    public let canarySettings: CanarySettings?
    public let tracingEnabled: Bool
    public let webAclArn: String?
    public let tags: [String:String]?
    public let createdDate: Date?
    public let lastUpdatedDate: Date?
}

extension GetStageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([String: MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [String:MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [String:MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension GetStagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStagesInput(deploymentId: \(String(describing: deploymentId)), restApiId: \(String(describing: restApiId)))"}
}

extension GetStagesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStagesInputHeadersMiddleware: Middleware {
    public let id: String = "GetStagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStagesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStagesInput>
    public typealias MOutput = OperationOutput<GetStagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStagesOutputError>
}

public struct GetStagesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStagesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let deploymentId = input.operationInput.deploymentId {
            let deploymentIdQueryItem = URLQueryItem(name: "deploymentId".urlPercentEncoding(), value: String(deploymentId).urlPercentEncoding())
            input.builder.withQueryItem(deploymentIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStagesInput>
    public typealias MOutput = OperationOutput<GetStagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStagesOutputError>
}

/// <p>Requests API Gateway to get information about one or more <a>Stage</a> resources.</p>
public struct GetStagesInput: Equatable {
    /// <p>The stages' deployment identifiers.</p>
    public let deploymentId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        deploymentId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.restApiId = restApiId
    }
}

struct GetStagesInputBody: Equatable {
}

extension GetStagesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStagesOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStagesOutputResponse(item: \(String(describing: item)))"}
}

extension GetStagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.item = output.item
        } else {
            self.item = nil
        }
    }
}

/// <p>A list of <a>Stage</a> resources that are associated with the <a>ApiKey</a> resource.</p>
///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/stages.html">Deploying API in Stages</a></div>
public struct GetStagesOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let item: [Stage]?

    public init (
        item: [Stage]? = nil
    )
    {
        self.item = item
    }
}

struct GetStagesOutputResponseBody: Equatable {
    public let item: [Stage]?
}

extension GetStagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case item
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([Stage?].self, forKey: .item)
        var itemDecoded0:[Stage]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [Stage]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
    }
}

extension GetTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagsInput(limit: \(String(describing: limit)), position: \(String(describing: position)), resourceArn: \(String(describing: resourceArn)))"}
}

extension GetTagsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetTagsInputHeadersMiddleware: Middleware {
    public let id: String = "GetTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

public struct GetTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

/// <p>Gets the <a>Tags</a> collection for a given resource.</p>
public struct GetTagsInput: Equatable {
    /// <p>(Not currently supported) The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>(Not currently supported) The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>[Required] The ARN of a resource that can be tagged.</p>
    public let resourceArn: String?

    public init (
        limit: Int? = nil,
        position: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.resourceArn = resourceArn
    }
}

struct GetTagsInputBody: Equatable {
}

extension GetTagsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTagsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagsOutputResponse(tags: \(String(describing: tags)))"}
}

extension GetTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// <p>The collection of tags. Each tag element is associated with a given resource.</p>
public struct GetTagsOutputResponse: Equatable {
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetTagsOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension GetTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsageInput(endDate: \(String(describing: endDate)), keyId: \(String(describing: keyId)), limit: \(String(describing: limit)), position: \(String(describing: position)), startDate: \(String(describing: startDate)), usagePlanId: \(String(describing: usagePlanId)))"}
}

extension GetUsageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetUsageInputHeadersMiddleware: Middleware {
    public let id: String = "GetUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageInput>
    public typealias MOutput = OperationOutput<GetUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageOutputError>
}

public struct GetUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = URLQueryItem(name: "endDate".urlPercentEncoding(), value: String(endDate).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let keyId = input.operationInput.keyId {
            let keyIdQueryItem = URLQueryItem(name: "keyId".urlPercentEncoding(), value: String(keyId).urlPercentEncoding())
            input.builder.withQueryItem(keyIdQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = URLQueryItem(name: "startDate".urlPercentEncoding(), value: String(startDate).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageInput>
    public typealias MOutput = OperationOutput<GetUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageOutputError>
}

/// <p>The GET request to get the usage data of a usage plan in a specified time interval.</p>
public struct GetUsageInput: Equatable {
    /// <p>[Required] The ending date (e.g., 2016-12-31) of the usage data.</p>
    public let endDate: String?
    /// <p>The Id of the API key associated with the resultant usage data.</p>
    public let keyId: String?
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>[Required] The starting date (e.g., 2016-01-01) of the usage data.</p>
    public let startDate: String?
    /// <p>[Required] The Id of the usage plan associated with the usage data.</p>
    public let usagePlanId: String?

    public init (
        endDate: String? = nil,
        keyId: String? = nil,
        limit: Int? = nil,
        position: String? = nil,
        startDate: String? = nil,
        usagePlanId: String? = nil
    )
    {
        self.endDate = endDate
        self.keyId = keyId
        self.limit = limit
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

struct GetUsageInputBody: Equatable {
}

extension GetUsageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsageOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsageOutputResponse(endDate: \(String(describing: endDate)), items: \(String(describing: items)), position: \(String(describing: position)), startDate: \(String(describing: startDate)), usagePlanId: \(String(describing: usagePlanId)))"}
}

extension GetUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endDate = output.endDate
            self.items = output.items
            self.startDate = output.startDate
            self.usagePlanId = output.usagePlanId
        } else {
            self.endDate = nil
            self.items = nil
            self.startDate = nil
            self.usagePlanId = nil
        }
        self.position = nil
    }
}

/// <p>Represents the usage data of a usage plan.</p>
///     <div class="remarks"></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>,
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-usage-plans-with-console.html#api-gateway-usage-plan-manage-usage">Manage Usage in a Usage Plan</a>
///     </div>
public struct GetUsageOutputResponse: Equatable {
    /// <p>The ending date of the usage data.</p>
    public let endDate: String?
    /// <p>The usage data, as daily logs of used and remaining quotas, over the specified time interval indexed over the API keys in a usage plan. For example, <code>{..., "values" : { "{api_key}" : [ [0, 100], [10, 90], [100, 10]]}</code>, where <code>{api_key}</code> stands for an API key value and the daily log entry is of the format <code>[used quota, remaining quota]</code>.</p>
    public let items: [String:[[Int]]]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>The starting date of the usage data.</p>
    public let startDate: String?
    /// <p>The plan Id associated with this usage data.</p>
    public let usagePlanId: String?

    public init (
        endDate: String? = nil,
        items: [String:[[Int]]]? = nil,
        position: String? = nil,
        startDate: String? = nil,
        usagePlanId: String? = nil
    )
    {
        self.endDate = endDate
        self.items = items
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

struct GetUsageOutputResponseBody: Equatable {
    public let usagePlanId: String?
    public let startDate: String?
    public let endDate: String?
    public let items: [String:[[Int]]]?
}

extension GetUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endDate
        case items = "values"
        case startDate
        case usagePlanId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usagePlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usagePlanId)
        usagePlanId = usagePlanIdDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
        let itemsContainer = try containerValues.decodeIfPresent([String: [[Int?]?]?].self, forKey: .items)
        var itemsDecoded0: [String:[[Int]]]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [String:[[Int]]]()
            for (key0, listofusage0) in itemsContainer {
                var listofusage0Decoded0: [[Int]]? = nil
                if let listofusage0 = listofusage0 {
                    listofusage0Decoded0 = [[Int]]()
                    for list1 in listofusage0 {
                        var list1Decoded1: [Int]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Int]()
                            for long2 in list1 {
                                if let long2 = long2 {
                                    list1Decoded1?.append(long2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            listofusage0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                itemsDecoded0?[key0] = listofusage0Decoded0
            }
        }
        items = itemsDecoded0
    }
}

extension GetUsagePlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsagePlanInput(usagePlanId: \(String(describing: usagePlanId)))"}
}

extension GetUsagePlanInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetUsagePlanInputHeadersMiddleware: Middleware {
    public let id: String = "GetUsagePlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsagePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsagePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsagePlanInput>
    public typealias MOutput = OperationOutput<GetUsagePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsagePlanOutputError>
}

public struct GetUsagePlanInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUsagePlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsagePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsagePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsagePlanInput>
    public typealias MOutput = OperationOutput<GetUsagePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsagePlanOutputError>
}

/// <p>The GET request to get a usage plan of a given plan identifier.</p>
public struct GetUsagePlanInput: Equatable {
    /// <p>[Required] The identifier of the <a>UsagePlan</a> resource to be retrieved.</p>
    public let usagePlanId: String?

    public init (
        usagePlanId: String? = nil
    )
    {
        self.usagePlanId = usagePlanId
    }
}

struct GetUsagePlanInputBody: Equatable {
}

extension GetUsagePlanInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetUsagePlanKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsagePlanKeyInput(keyId: \(String(describing: keyId)), usagePlanId: \(String(describing: usagePlanId)))"}
}

extension GetUsagePlanKeyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetUsagePlanKeyInputHeadersMiddleware: Middleware {
    public let id: String = "GetUsagePlanKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsagePlanKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsagePlanKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsagePlanKeyInput>
    public typealias MOutput = OperationOutput<GetUsagePlanKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsagePlanKeyOutputError>
}

public struct GetUsagePlanKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUsagePlanKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsagePlanKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsagePlanKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsagePlanKeyInput>
    public typealias MOutput = OperationOutput<GetUsagePlanKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsagePlanKeyOutputError>
}

/// <p>The GET request to get a usage plan key of a given key identifier.</p>
public struct GetUsagePlanKeyInput: Equatable {
    /// <p>[Required] The key Id of the to-be-retrieved <a>UsagePlanKey</a> resource representing a plan customer.</p>
    public let keyId: String?
    /// <p>[Required] The Id of the <a>UsagePlan</a> resource representing the usage plan containing the to-be-retrieved <a>UsagePlanKey</a> resource representing a plan customer.</p>
    public let usagePlanId: String?

    public init (
        keyId: String? = nil,
        usagePlanId: String? = nil
    )
    {
        self.keyId = keyId
        self.usagePlanId = usagePlanId
    }
}

struct GetUsagePlanKeyInputBody: Equatable {
}

extension GetUsagePlanKeyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetUsagePlanKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsagePlanKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsagePlanKeyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsagePlanKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsagePlanKeyOutputResponse(id: \(String(describing: id)), name: \(String(describing: name)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

extension GetUsagePlanKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUsagePlanKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.name = output.name
            self.type = output.type
            self.value = output.value
        } else {
            self.id = nil
            self.name = nil
            self.type = nil
            self.value = nil
        }
    }
}

/// <p>Represents a usage plan key to identify a plan customer.</p>
///     <div class="remarks">
///       <p>To associate an API stage with a selected API key in a usage plan, you must create a UsagePlanKey resource to represent the selected <a>ApiKey</a>.</p>
///     </div>"
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>
///     </div>
public struct GetUsagePlanKeyOutputResponse: Equatable {
    /// <p>The Id of a usage plan key.</p>
    public let id: String?
    /// <p>The name of a usage plan key.</p>
    public let name: String?
    /// <p>The type of a usage plan key. Currently, the valid key type is <code>API_KEY</code>.</p>
    public let type: String?
    /// <p>The value of a usage plan key.</p>
    public let value: String?

    public init (
        id: String? = nil,
        name: String? = nil,
        type: String? = nil,
        value: String? = nil
    )
    {
        self.id = id
        self.name = name
        self.type = type
        self.value = value
    }
}

struct GetUsagePlanKeyOutputResponseBody: Equatable {
    public let id: String?
    public let type: String?
    public let value: String?
    public let name: String?
}

extension GetUsagePlanKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case type
        case value
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetUsagePlanKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsagePlanKeysInput(limit: \(String(describing: limit)), nameQuery: \(String(describing: nameQuery)), position: \(String(describing: position)), usagePlanId: \(String(describing: usagePlanId)))"}
}

extension GetUsagePlanKeysInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetUsagePlanKeysInputHeadersMiddleware: Middleware {
    public let id: String = "GetUsagePlanKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsagePlanKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsagePlanKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsagePlanKeysInput>
    public typealias MOutput = OperationOutput<GetUsagePlanKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsagePlanKeysOutputError>
}

public struct GetUsagePlanKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUsagePlanKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsagePlanKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsagePlanKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        if let nameQuery = input.operationInput.nameQuery {
            let nameQueryQueryItem = URLQueryItem(name: "name".urlPercentEncoding(), value: String(nameQuery).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsagePlanKeysInput>
    public typealias MOutput = OperationOutput<GetUsagePlanKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsagePlanKeysOutputError>
}

/// <p>The GET request to get all the usage plan keys representing the API keys added to a specified usage plan.</p>
public struct GetUsagePlanKeysInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>A query parameter specifying the name of the to-be-returned usage plan keys.</p>
    public let nameQuery: String?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>[Required] The Id of the <a>UsagePlan</a> resource representing the usage plan containing the to-be-retrieved <a>UsagePlanKey</a> resource representing a plan customer.</p>
    public let usagePlanId: String?

    public init (
        limit: Int? = nil,
        nameQuery: String? = nil,
        position: String? = nil,
        usagePlanId: String? = nil
    )
    {
        self.limit = limit
        self.nameQuery = nameQuery
        self.position = position
        self.usagePlanId = usagePlanId
    }
}

struct GetUsagePlanKeysInputBody: Equatable {
}

extension GetUsagePlanKeysInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetUsagePlanKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsagePlanKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsagePlanKeysOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsagePlanKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsagePlanKeysOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetUsagePlanKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUsagePlanKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>Represents the collection of usage plan keys added to usage plans for the associated API keys and, possibly, other types of keys.</p>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>
///     </div>
public struct GetUsagePlanKeysOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [UsagePlanKey]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [UsagePlanKey]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetUsagePlanKeysOutputResponseBody: Equatable {
    public let items: [UsagePlanKey]?
}

extension GetUsagePlanKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([UsagePlanKey?].self, forKey: .items)
        var itemsDecoded0:[UsagePlanKey]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [UsagePlanKey]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetUsagePlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsagePlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsagePlanOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsagePlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsagePlanOutputResponse(apiStages: \(String(describing: apiStages)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), productCode: \(String(describing: productCode)), quota: \(String(describing: quota)), tags: \(String(describing: tags)), throttle: \(String(describing: throttle)))"}
}

extension GetUsagePlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUsagePlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiStages = output.apiStages
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.productCode = output.productCode
            self.quota = output.quota
            self.tags = output.tags
            self.throttle = output.throttle
        } else {
            self.apiStages = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.productCode = nil
            self.quota = nil
            self.tags = nil
            self.throttle = nil
        }
    }
}

/// <p>Represents a usage plan than can specify who can assess associated API stages with specified request limits and quotas.</p>
///       <div class="remarks">
///         <p>In a usage plan, you associate an API by specifying the API's Id and a stage name of the specified API. You add plan customers by adding API keys to the plan. </p>
///       </div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>
///       </div>
public struct GetUsagePlanOutputResponse: Equatable {
    /// <p>The associated API stages of a usage plan.</p>
    public let apiStages: [ApiStage]?
    /// <p>The description of a usage plan.</p>
    public let description: String?
    /// <p>The identifier of a <a>UsagePlan</a> resource.</p>
    public let id: String?
    /// <p>The name of a usage plan.</p>
    public let name: String?
    /// <p>The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace.</p>
    public let productCode: String?
    /// <p>The maximum number of permitted requests per a given unit time interval.</p>
    public let quota: QuotaSettings?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The request throttle limits of a usage plan.</p>
    public let throttle: ThrottleSettings?

    public init (
        apiStages: [ApiStage]? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        productCode: String? = nil,
        quota: QuotaSettings? = nil,
        tags: [String:String]? = nil,
        throttle: ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct GetUsagePlanOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let apiStages: [ApiStage]?
    public let throttle: ThrottleSettings?
    public let quota: QuotaSettings?
    public let productCode: String?
    public let tags: [String:String]?
}

extension GetUsagePlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetUsagePlansInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsagePlansInput(keyId: \(String(describing: keyId)), limit: \(String(describing: limit)), position: \(String(describing: position)))"}
}

extension GetUsagePlansInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetUsagePlansInputHeadersMiddleware: Middleware {
    public let id: String = "GetUsagePlansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsagePlansInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsagePlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsagePlansInput>
    public typealias MOutput = OperationOutput<GetUsagePlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsagePlansOutputError>
}

public struct GetUsagePlansInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUsagePlansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsagePlansInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsagePlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let keyId = input.operationInput.keyId {
            let keyIdQueryItem = URLQueryItem(name: "keyId".urlPercentEncoding(), value: String(keyId).urlPercentEncoding())
            input.builder.withQueryItem(keyIdQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsagePlansInput>
    public typealias MOutput = OperationOutput<GetUsagePlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsagePlansOutputError>
}

/// <p>The GET request to get all the usage plans of the caller's account.</p>
public struct GetUsagePlansInput: Equatable {
    /// <p>The identifier of the API key associated with the usage plans.</p>
    public let keyId: String?
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        keyId: String? = nil,
        limit: Int? = nil,
        position: String? = nil
    )
    {
        self.keyId = keyId
        self.limit = limit
        self.position = position
    }
}

struct GetUsagePlansInputBody: Equatable {
}

extension GetUsagePlansInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetUsagePlansOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsagePlansOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsagePlansOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsagePlansOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsagePlansOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetUsagePlansOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUsagePlansOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>Represents a collection of usage plans for an AWS account.</p>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>
///     </div>
public struct GetUsagePlansOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [UsagePlan]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [UsagePlan]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetUsagePlansOutputResponseBody: Equatable {
    public let items: [UsagePlan]?
}

extension GetUsagePlansOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([UsagePlan?].self, forKey: .items)
        var itemsDecoded0:[UsagePlan]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [UsagePlan]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetVpcLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVpcLinkInput(vpcLinkId: \(String(describing: vpcLinkId)))"}
}

extension GetVpcLinkInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetVpcLinkInputHeadersMiddleware: Middleware {
    public let id: String = "GetVpcLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVpcLinkInput>
    public typealias MOutput = OperationOutput<GetVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVpcLinkOutputError>
}

public struct GetVpcLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVpcLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVpcLinkInput>
    public typealias MOutput = OperationOutput<GetVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVpcLinkOutputError>
}

/// <p>Gets a specified VPC link under the caller's account in a region.</p>
public struct GetVpcLinkInput: Equatable {
    /// <p>[Required] The identifier of the  <a>VpcLink</a>. It is used in an <a>Integration</a> to reference this <a>VpcLink</a>.</p>
    public let vpcLinkId: String?

    public init (
        vpcLinkId: String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct GetVpcLinkInputBody: Equatable {
}

extension GetVpcLinkInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetVpcLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVpcLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVpcLinkOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVpcLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVpcLinkOutputResponse(description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), tags: \(String(describing: tags)), targetArns: \(String(describing: targetArns)))"}
}

extension GetVpcLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.targetArns = output.targetArns
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.targetArns = nil
        }
    }
}

/// <p>An API Gateway VPC link for a <a>RestApi</a> to access resources in an Amazon Virtual Private Cloud (VPC).</p>
///         <div class="remarks">
///           <p><p>To enable access to a resource in an Amazon Virtual Private Cloud through Amazon API Gateway, you, as an API developer, create a <a>VpcLink</a> resource targeted for one or more network load balancers of the VPC and then integrate an API method with a private integration that uses the <a>VpcLink</a>. The private integration has an integration type of <code>HTTP</code> or <code>HTTP_PROXY</code> and has a connection type of <code>VPC_LINK</code>. The integration uses the <code>connectionId</code> property to identify the <a>VpcLink</a> used.</p></p>
///         </div>
public struct GetVpcLinkOutputResponse: Equatable {
    /// <p>The description of the VPC link.</p>
    public let description: String?
    /// <p>The identifier of the  <a>VpcLink</a>. It is used in an <a>Integration</a> to reference this <a>VpcLink</a>.</p>
    public let id: String?
    /// <p>The name used to label and identify the VPC link.</p>
    public let name: String?
    /// <p>The status of the VPC link. The valid values are <code>AVAILABLE</code>, <code>PENDING</code>, <code>DELETING</code>, or <code>FAILED</code>. Deploying an API will wait if the status is <code>PENDING</code> and will fail if the status is <code>DELETING</code>.</p>
    public let status: VpcLinkStatus?
    /// <p>A description about the VPC link status.</p>
    public let statusMessage: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.</p>
    public let targetArns: [String]?

    public init (
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        status: VpcLinkStatus? = nil,
        statusMessage: String? = nil,
        tags: [String:String]? = nil,
        targetArns: [String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct GetVpcLinkOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let targetArns: [String]?
    public let status: VpcLinkStatus?
    public let statusMessage: String?
    public let tags: [String:String]?
}

extension GetVpcLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetVpcLinksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVpcLinksInput(limit: \(String(describing: limit)), position: \(String(describing: position)))"}
}

extension GetVpcLinksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetVpcLinksInputHeadersMiddleware: Middleware {
    public let id: String = "GetVpcLinksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVpcLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVpcLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVpcLinksInput>
    public typealias MOutput = OperationOutput<GetVpcLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVpcLinksOutputError>
}

public struct GetVpcLinksInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVpcLinksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVpcLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVpcLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let position = input.operationInput.position {
            let positionQueryItem = URLQueryItem(name: "position".urlPercentEncoding(), value: String(position).urlPercentEncoding())
            input.builder.withQueryItem(positionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVpcLinksInput>
    public typealias MOutput = OperationOutput<GetVpcLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVpcLinksOutputError>
}

/// <p>Gets the <a>VpcLinks</a> collection under the caller's account in a selected region.</p>
public struct GetVpcLinksInput: Equatable {
    /// <p>The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</p>
    public let limit: Int?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        limit: Int? = nil,
        position: String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetVpcLinksInputBody: Equatable {
}

extension GetVpcLinksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetVpcLinksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVpcLinksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVpcLinksOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVpcLinksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVpcLinksOutputResponse(items: \(String(describing: items)), position: \(String(describing: position)))"}
}

extension GetVpcLinksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetVpcLinksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// <p>The collection of VPC links under the caller's account in a region.</p>
///         <div class="seeAlso">
///             <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-with-private-integration.html">Getting Started with Private Integrations</a>,
/// <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-private-integration.html">Set up Private Integrations</a>
///         </div>
public struct GetVpcLinksOutputResponse: Equatable {
    /// <p>The current page of elements from this collection.</p>
    public let items: [VpcLink]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?

    public init (
        items: [VpcLink]? = nil,
        position: String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetVpcLinksOutputResponseBody: Equatable {
    public let items: [VpcLink]?
}

extension GetVpcLinksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "item"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VpcLink?].self, forKey: .items)
        var itemsDecoded0:[VpcLink]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VpcLink]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

public struct ImportApiKeysInputBodyMiddleware: Middleware {
    public let id: String = "ImportApiKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportApiKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportApiKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportApiKeysInput>
    public typealias MOutput = OperationOutput<ImportApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportApiKeysOutputError>
}

extension ImportApiKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportApiKeysInput(body: \(String(describing: body)), failOnWarnings: \(String(describing: failOnWarnings)), format: \(String(describing: format)))"}
}

extension ImportApiKeysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

public struct ImportApiKeysInputHeadersMiddleware: Middleware {
    public let id: String = "ImportApiKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportApiKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportApiKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportApiKeysInput>
    public typealias MOutput = OperationOutput<ImportApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportApiKeysOutputError>
}

public struct ImportApiKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportApiKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportApiKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportApiKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "mode", value: "import"))
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        let failOnWarningsQueryItem = URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: String(input.operationInput.failOnWarnings).urlPercentEncoding())
        input.builder.withQueryItem(failOnWarningsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportApiKeysInput>
    public typealias MOutput = OperationOutput<ImportApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportApiKeysOutputError>
}

/// <p>The POST request to import API keys from an external source, such as a CSV-formatted file.</p>
public struct ImportApiKeysInput: Equatable {
    /// <p>The payload of the POST request to import API keys. For the payload format, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-key-file-format.html">API Key File Format</a>.</p>
    public let body: Data?
    /// <p>A query parameter to indicate whether to rollback <a>ApiKey</a> importation (<code>true</code>) or not (<code>false</code>) when error is encountered.</p>
    public let failOnWarnings: Bool
    /// <p>A query parameter to specify the input format to imported API keys. Currently, only the <code>csv</code> format is supported.</p>
    public let format: ApiKeysFormat?

    public init (
        body: Data? = nil,
        failOnWarnings: Bool = false,
        format: ApiKeysFormat? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.format = format
    }
}

struct ImportApiKeysInputBody: Equatable {
    public let body: Data?
}

extension ImportApiKeysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportApiKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportApiKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportApiKeysOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportApiKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportApiKeysOutputResponse(ids: \(String(describing: ids)), warnings: \(String(describing: warnings)))"}
}

extension ImportApiKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportApiKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ids = output.ids
            self.warnings = output.warnings
        } else {
            self.ids = nil
            self.warnings = nil
        }
    }
}

/// <p>The identifier of an <a>ApiKey</a> used in a <a>UsagePlan</a>.</p>
public struct ImportApiKeysOutputResponse: Equatable {
    /// <p>A list of all the <a>ApiKey</a> identifiers.</p>
    public let ids: [String]?
    /// <p>A list of warning messages.</p>
    public let warnings: [String]?

    public init (
        ids: [String]? = nil,
        warnings: [String]? = nil
    )
    {
        self.ids = ids
        self.warnings = warnings
    }
}

struct ImportApiKeysOutputResponseBody: Equatable {
    public let ids: [String]?
    public let warnings: [String]?
}

extension ImportApiKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids
        case warnings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct ImportDocumentationPartsInputBodyMiddleware: Middleware {
    public let id: String = "ImportDocumentationPartsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportDocumentationPartsInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportDocumentationPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportDocumentationPartsInput>
    public typealias MOutput = OperationOutput<ImportDocumentationPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportDocumentationPartsOutputError>
}

extension ImportDocumentationPartsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportDocumentationPartsInput(body: \(String(describing: body)), failOnWarnings: \(String(describing: failOnWarnings)), mode: \(String(describing: mode)), restApiId: \(String(describing: restApiId)))"}
}

extension ImportDocumentationPartsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

public struct ImportDocumentationPartsInputHeadersMiddleware: Middleware {
    public let id: String = "ImportDocumentationPartsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportDocumentationPartsInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportDocumentationPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportDocumentationPartsInput>
    public typealias MOutput = OperationOutput<ImportDocumentationPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportDocumentationPartsOutputError>
}

public struct ImportDocumentationPartsInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportDocumentationPartsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportDocumentationPartsInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportDocumentationPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let mode = input.operationInput.mode {
            let modeQueryItem = URLQueryItem(name: "mode".urlPercentEncoding(), value: String(mode.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(modeQueryItem)
        }
        let failOnWarningsQueryItem = URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: String(input.operationInput.failOnWarnings).urlPercentEncoding())
        input.builder.withQueryItem(failOnWarningsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportDocumentationPartsInput>
    public typealias MOutput = OperationOutput<ImportDocumentationPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportDocumentationPartsOutputError>
}

/// <p>Import documentation parts from an external (e.g., OpenAPI) definition file. </p>
public struct ImportDocumentationPartsInput: Equatable {
    /// <p>[Required] Raw byte array representing the to-be-imported documentation parts. To import from an OpenAPI file, this is a JSON object.</p>
    public let body: Data?
    /// <p>A query parameter to specify whether to rollback the documentation importation (<code>true</code>) or not (<code>false</code>) when a warning is encountered. The default value is <code>false</code>.</p>
    public let failOnWarnings: Bool
    /// <p>A query parameter to indicate whether to overwrite (<code>OVERWRITE</code>) any existing <a>DocumentationParts</a> definition or to merge (<code>MERGE</code>) the new definition into the existing one. The default value is <code>MERGE</code>.</p>
    public let mode: PutMode?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        body: Data? = nil,
        failOnWarnings: Bool = false,
        mode: PutMode? = nil,
        restApiId: String? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.mode = mode
        self.restApiId = restApiId
    }
}

struct ImportDocumentationPartsInputBody: Equatable {
    public let body: Data?
}

extension ImportDocumentationPartsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportDocumentationPartsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportDocumentationPartsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportDocumentationPartsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportDocumentationPartsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportDocumentationPartsOutputResponse(ids: \(String(describing: ids)), warnings: \(String(describing: warnings)))"}
}

extension ImportDocumentationPartsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportDocumentationPartsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ids = output.ids
            self.warnings = output.warnings
        } else {
            self.ids = nil
            self.warnings = nil
        }
    }
}

/// <p>A collection of the imported  <a>DocumentationPart</a> identifiers.</p>
///     <div class="remarks">This is used to return the result when documentation parts in an external (e.g., OpenAPI) file are imported into API Gateway</div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a href="https://docs.aws.amazon.com/apigateway/api-reference/link-relation/documentationpart-import/">documentationpart:import</a>, <a>DocumentationPart</a>
///     </div>
public struct ImportDocumentationPartsOutputResponse: Equatable {
    /// <p>A list of the returned documentation part identifiers.</p>
    public let ids: [String]?
    /// <p>A list of warning messages reported during import of documentation parts.</p>
    public let warnings: [String]?

    public init (
        ids: [String]? = nil,
        warnings: [String]? = nil
    )
    {
        self.ids = ids
        self.warnings = warnings
    }
}

struct ImportDocumentationPartsOutputResponseBody: Equatable {
    public let ids: [String]?
    public let warnings: [String]?
}

extension ImportDocumentationPartsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids
        case warnings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct ImportRestApiInputBodyMiddleware: Middleware {
    public let id: String = "ImportRestApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportRestApiInput>
    public typealias MOutput = OperationOutput<ImportRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportRestApiOutputError>
}

extension ImportRestApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportRestApiInput(body: \(String(describing: body)), failOnWarnings: \(String(describing: failOnWarnings)), parameters: \(String(describing: parameters)))"}
}

extension ImportRestApiInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

public struct ImportRestApiInputHeadersMiddleware: Middleware {
    public let id: String = "ImportRestApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportRestApiInput>
    public typealias MOutput = OperationOutput<ImportRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportRestApiOutputError>
}

public struct ImportRestApiInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportRestApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "mode", value: "import"))
        let failOnWarningsQueryItem = URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: String(input.operationInput.failOnWarnings).urlPercentEncoding())
        input.builder.withQueryItem(failOnWarningsQueryItem)
        if let parameters = input.operationInput.parameters {
            let currentQueryItemNames = input.builder.currentQueryItems.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    input.builder.withQueryItem(queryItem)
                }
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportRestApiInput>
    public typealias MOutput = OperationOutput<ImportRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportRestApiOutputError>
}

/// <p>A POST request to import an API to API Gateway using an input of an API definition file.</p>
public struct ImportRestApiInput: Equatable {
    /// <p>[Required] The POST request body containing external API definitions. Currently, only OpenAPI definition JSON/YAML files are supported. The maximum size of the API definition file is 6MB.</p>
    public let body: Data?
    /// <p>A query parameter to indicate whether to rollback the API creation (<code>true</code>) or not (<code>false</code>)
    ///             when a warning is encountered. The default value is <code>false</code>.</p>
    public let failOnWarnings: Bool
    /// <p>A key-value map of context-specific query string parameters specifying the behavior of different API importing operations. The following shows operation-specific parameters and their supported values.</p>
    ///         <p> To exclude <a>DocumentationParts</a> from the import, set <code>parameters</code> as <code>ignore=documentation</code>.</p>
    ///       <p> To configure the endpoint type, set <code>parameters</code> as <code>endpointConfigurationTypes=EDGE</code>, <code>endpointConfigurationTypes=REGIONAL</code>, or <code>endpointConfigurationTypes=PRIVATE</code>. The default endpoint type is <code>EDGE</code>.</p>
    ///         <p> To handle imported <code>basepath</code>, set <code>parameters</code> as <code>basepath=ignore</code>, <code>basepath=prepend</code> or <code>basepath=split</code>.</p>
    ///         <p>For example, the AWS CLI command to exclude documentation from the imported API is:</p>
    ///         <pre><code>aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'</code></pre>
    ///         <p>The AWS CLI command to set the regional endpoint on the imported API is:</p>
    ///         <pre><code>aws apigateway import-rest-api --parameters endpointConfigurationTypes=REGIONAL --body 'file:///path/to/imported-api-body.json'</code></pre>
    public let parameters: [String:String]?

    public init (
        body: Data? = nil,
        failOnWarnings: Bool = false,
        parameters: [String:String]? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.parameters = parameters
    }
}

struct ImportRestApiInputBody: Equatable {
    public let body: Data?
}

extension ImportRestApiInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportRestApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportRestApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportRestApiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportRestApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportRestApiOutputResponse(apiKeySource: \(String(describing: apiKeySource)), binaryMediaTypes: \(String(describing: binaryMediaTypes)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), endpointConfiguration: \(String(describing: endpointConfiguration)), id: \(String(describing: id)), minimumCompressionSize: \(String(describing: minimumCompressionSize)), name: \(String(describing: name)), policy: \(String(describing: policy)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

extension ImportRestApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportRestApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// <p>Represents a REST API.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct ImportRestApiOutputResponse: Equatable {
    /// <p>The source of the API key for metering requests according to a usage plan. Valid values are: <ul><li><code>HEADER</code> to read the API key from the <code>X-API-Key</code> header of a request. </li><li><code>AUTHORIZER</code> to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</li></ul></p>
    public let apiKeySource: ApiKeySourceType?
    /// <p>The list of binary media types supported by the <a>RestApi</a>. By default, the <a>RestApi</a> supports only UTF-8-encoded text payloads.</p>
    public let binaryMediaTypes: [String]?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The API's description.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default <code>execute-api</code> endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>The endpoint configuration of this <a>RestApi</a> showing the endpoint types of the API.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>The API's identifier. This identifier is unique across all of your APIs in API Gateway.</p>
    public let id: String?
    /// <p>A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.</p>
    public let minimumCompressionSize: Int?
    /// <p>The API's name.</p>
    public let name: String?
    /// <p>A stringified JSON policy document that applies to this RestApi regardless of the caller and <a>Method</a> configuration.</p>
    public let policy: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when <code>failonwarnings</code> is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiKeySource: ApiKeySourceType? = nil,
        binaryMediaTypes: [String]? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        endpointConfiguration: EndpointConfiguration? = nil,
        id: String? = nil,
        minimumCompressionSize: Int? = nil,
        name: String? = nil,
        policy: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct ImportRestApiOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let createdDate: Date?
    public let version: String?
    public let warnings: [String]?
    public let binaryMediaTypes: [String]?
    public let minimumCompressionSize: Int?
    public let apiKeySource: ApiKeySourceType?
    public let endpointConfiguration: EndpointConfiguration?
    public let policy: String?
    public let tags: [String:String]?
    public let disableExecuteApiEndpoint: Bool
}

extension ImportRestApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension Integration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheKeyParameters = cacheKeyParameters {
            var cacheKeyParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cacheKeyParameters)
            for listofstring0 in cacheKeyParameters {
                try cacheKeyParametersContainer.encode(listofstring0)
            }
        }
        if let cacheNamespace = cacheNamespace {
            try encodeContainer.encode(cacheNamespace, forKey: .cacheNamespace)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandling = contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let credentials = credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let integrationResponses = integrationResponses {
            var integrationResponsesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .integrationResponses)
            for (dictKey0, mapofintegrationresponse0) in integrationResponses {
                try integrationResponsesContainer.encode(mapofintegrationresponse0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let passthroughBehavior = passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior, forKey: .passthroughBehavior)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestParameters)
            for (dictKey0, mapofstringtostring0) in requestParameters {
                try requestParametersContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestTemplates)
            for (dictKey0, mapofstringtostring0) in requestTemplates {
                try requestTemplatesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if timeoutInMillis != 0 {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([String: IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [String:IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [String:IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension Integration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Integration(cacheKeyParameters: \(String(describing: cacheKeyParameters)), cacheNamespace: \(String(describing: cacheNamespace)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandling: \(String(describing: contentHandling)), credentials: \(String(describing: credentials)), httpMethod: \(String(describing: httpMethod)), integrationResponses: \(String(describing: integrationResponses)), passthroughBehavior: \(String(describing: passthroughBehavior)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)), type: \(String(describing: type)), uri: \(String(describing: uri)))"}
}

/// <p>Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.</p>
///         <div class="remarks">In the API Gateway console, the built-in Lambda integration is an AWS integration.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct Integration: Equatable {
    /// <p>A list of request parameters whose values API Gateway caches. To be valid values for <code>cacheKeyParameters</code>, these parameters must also be specified for <a>Method</a> <code>requestParameters</code>.</p>
    public let cacheKeyParameters: [String]?
    /// <p>Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the <code>cacheNamespace</code>. You can specify the same <code>cacheNamespace</code> across resources to return the same cached data for requests to different resources.</p>
    public let cacheNamespace: String?
    /// <p>The (<a href="https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id"><code>id</code></a>) of the <a>VpcLink</a> used for the integration when <code>connectionType=VPC_LINK</code> and undefined, otherwise.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. The valid value is <code>INTERNET</code> for connections through the public routable internet or <code>VPC_LINK</code> for private connections between API Gateway and a network load balancer in a VPC. The default value is <code>INTERNET</code>.</p>
    public let connectionType: ConnectionType?
    /// <p>Specifies how to handle request payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p>
    ///       <ul>
    ///         <li><p><code>CONVERT_TO_BINARY</code>: Converts a request payload from a Base64-encoded string to the corresponding binary blob.</p></li>
    ///         <li><p><code>CONVERT_TO_TEXT</code>: Converts a request payload from a binary blob to a Base64-encoded string.</p></li>
    ///       </ul>
    ///       <p>If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the <code>passthroughBehavior</code> is configured to support payload pass-through.</p>
    public let contentHandling: ContentHandlingStrategy?
    /// <p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string <code>arn:aws:iam::\*:user/\*</code>. To use resource-based permissions on supported AWS services, specify null.</p>
    public let credentials: String?
    /// <p>Specifies the integration's HTTP method type.</p>
    public let httpMethod: String?
    /// <p>Specifies the integration's responses.</p>
    ///         <div class="remarks">
    ///     <p></p>
    ///     <h4>Example: Get integration responses of a method</h4>
    ///     <h5>Request</h5>
    ///     <p></p>
    ///     <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200 HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// X-Amz-Date: 20160607T191449Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160607/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    /// </code></pre>
    ///     <h5>Response</h5>
    ///     <p>The successful response returns <code>200 OK</code> status and a payload as follows:</p>
    ///     <pre><code>{
    ///   "_links": {
    ///     "curies": {
    ///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///       "name": "integrationresponse",
    ///       "templated": true
    ///     },
    ///     "self": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///       "title": "200"
    ///     },
    ///     "integrationresponse:delete": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///     },
    ///     "integrationresponse:update": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///     }
    ///   },
    ///   "responseParameters": {
    ///     "method.response.header.Content-Type": "'application/xml'"
    ///   },
    ///   "responseTemplates": {
    ///     "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n"
    ///   },
    ///   "statusCode": "200"
    /// }</code></pre>
    ///     <p></p>
    ///         </div>
    ///         <div class="seeAlso">
    ///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
    ///         </div>
    public let integrationResponses: [String:IntegrationResponse]?
    /// <div>
    ///         <p>
    ///             Specifies how the method request body of an unmapped content type will be passed through the integration request
    ///             to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration
    ///             or the content type does not match any of the mapped content types, as specified in <code>requestTemplates</code>.
    ///             The valid value is one of the following:
    ///         </p>
    ///         <ul>
    ///           <li>
    ///             <code>WHEN_NO_MATCH</code>: passes the method request body through the integration request to the back end without transformation
    ///             when the method request content type does not match any content type associated with the mapping templates defined in the integration request.
    ///           </li>
    ///           <li>
    ///             <code>WHEN_NO_TEMPLATES</code>: passes the method request body through the integration request to the back end without transformation
    ///             when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request
    ///             of an unmapped content-type will be rejected with an HTTP <code>415 Unsupported Media Type</code> response.
    ///           </li>
    ///           <li>
    ///             <code>NEVER</code>: rejects the method request with an HTTP <code>415 Unsupported Media Type</code> response when either the method
    ///             request content type does not match any content type associated with the mapping templates defined in the integration request or
    ///             no mapping template is defined in the integration request.
    ///           </li>
    ///         </ul>
    ///       </div>
    public let passthroughBehavior: String?
    /// <p>A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of  <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> must be a valid and unique method request parameter name.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.</p>
    public let requestTemplates: [String:String]?
    /// <p>Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.</p>
    public let timeoutInMillis: Int
    /// <p>Specifies the TLS configuration for an integration.</p>
    public let tlsConfig: TlsConfig?
    /// <p>Specifies an API method integration type. The valid value is one of the following:</p>
    ///         <ul>
    ///             <li><code>AWS</code>: for integrating the API method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration.</li>
    ///             <li><code>AWS_PROXY</code>: for integrating the API method request with the Lambda function-invoking action with the client request passed through as-is. This integration is also referred to as the Lambda proxy integration.</li>
    ///             <li><code>HTTP</code>: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC. This integration is also referred to as the HTTP custom integration.</li>
    ///             <li><code>HTTP_PROXY</code>: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC, with the client request passed through as-is. This is also referred to as the HTTP proxy integration.</li>
    ///             <li><code>MOCK</code>: for integrating the API method request with API Gateway as a "loop-back" endpoint without invoking any backend.</li>
    ///         </ul>
    ///         <p>For the HTTP and HTTP proxy integrations, each integration can specify a protocol (<code>http/https</code>), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a <code>connectionType</code> of <code>VPC_LINK</code> is referred to as a private integration and uses a <a>VpcLink</a> to connect API Gateway to a network load balancer of a VPC.</p>
    public let type: IntegrationType?
    /// <p>Specifies Uniform Resource Identifier (URI) of the integration endpoint.</p>
    /// <ul>
    /// <li><p> For <code>HTTP</code> or <code>HTTP_PROXY</code> integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the <a target="_blank" href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">RFC-3986 specification</a>, for either standard integration, where <code>connectionType</code> is not <code>VPC_LINK</code>, or private integration, where <code>connectionType</code> is <code>VPC_LINK</code>. For a private HTTP integration, the URI is not used for routing. </p>
    /// </li>
    /// <li><p> For <code>AWS</code> or <code>AWS_PROXY</code> integrations, the URI is of the form <code>arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}</code>. Here, <code>{Region}</code> is the API Gateway region (e.g., <code>us-east-1</code>); <code>{service}</code> is the name of the integrated AWS service (e.g., <code>s3</code>); and <code>{subdomain}</code> is a designated subdomain supported by certain AWS service for fast host-name lookup. <code>action</code> can be used for an AWS service action-based API, using an <code>Action={name}&{p1}={v1}&p2={v2}...</code> query string. The ensuing <code>{service_api}</code> refers to a supported action <code>{name}</code> plus any required input parameters. Alternatively, <code>path</code> can be used for an AWS service path-based API. The ensuing  <code>service_api</code> refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of <code><a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html">GetObject</a></code>, the <code>uri</code> can be either <code>arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key}</code> or  <code>arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}</code></p>
    /// </li></ul>
    public let uri: String?

    public init (
        cacheKeyParameters: [String]? = nil,
        cacheNamespace: String? = nil,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandling: ContentHandlingStrategy? = nil,
        credentials: String? = nil,
        httpMethod: String? = nil,
        integrationResponses: [String:IntegrationResponse]? = nil,
        passthroughBehavior: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        timeoutInMillis: Int = 0,
        tlsConfig: TlsConfig? = nil,
        type: IntegrationType? = nil,
        uri: String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

extension IntegrationResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandling = contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtostring0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseTemplates)
            for (dictKey0, mapofstringtostring0) in responseTemplates {
                try responseTemplatesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let selectionPattern = selectionPattern {
            try encodeContainer.encode(selectionPattern, forKey: .selectionPattern)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

extension IntegrationResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntegrationResponse(contentHandling: \(String(describing: contentHandling)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), selectionPattern: \(String(describing: selectionPattern)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Represents an integration response. The status code must map to an existing <a>MethodResponse</a>, and parameters and templates can be used to transform the back-end response.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct IntegrationResponse: Equatable {
    /// <p>Specifies how to handle response payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p>
    ///     <ul>
    ///       <li><p><code>CONVERT_TO_BINARY</code>: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p></li>
    ///       <li><p><code>CONVERT_TO_TEXT</code>: Converts a response payload from a binary blob to a Base64-encoded string.</p></li>
    ///     </ul>
    ///     <p>If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.</p>
    public let contentHandling: ContentHandlingStrategy?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the back end.
    ///             The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. The mapped non-static value must match the pattern of <code>integration.response.header.{name}</code> or <code>integration.response.body.{JSON-expression}</code>, where <code>name</code> is a valid and unique response header name and <code>JSON-expression</code> is a valid JSON expression without the <code>$</code> prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>
    public let responseTemplates: [String:String]?
    /// <p>Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the <code>.+</code> regex to match error response. However, make sure that the error response does not contain any newline (<code>\n</code>) character in such cases. If the back end is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.</p>
    public let selectionPattern: String?
    /// <p>Specifies the status code that is used to map the integration response to an existing <a>MethodResponse</a>.</p>
    public let statusCode: String?

    public init (
        contentHandling: ContentHandlingStrategy? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        selectionPattern: String? = nil,
        statusCode: String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

/// <p>The integration type. The valid value is <code>HTTP</code> for integrating an API method with an HTTP backend; <code>AWS</code> with any AWS service endpoints; <code>MOCK</code> for testing without actually invoking the backend; <code>HTTP_PROXY</code> for integrating with the HTTP proxy integration; <code>AWS_PROXY</code> for integrating with the Lambda proxy integration. </p>
public enum IntegrationType {
    case aws
    case awsProxy
    case http
    case httpProxy
    case mock
    case sdkUnknown(String)
}

extension IntegrationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntegrationType] {
        return [
            .aws,
            .awsProxy,
            .http,
            .httpProxy,
            .mock,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aws: return "AWS"
        case .awsProxy: return "AWS_PROXY"
        case .http: return "HTTP"
        case .httpProxy: return "HTTP_PROXY"
        case .mock: return "MOCK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request exceeded the rate limit. Retry after the specified time period.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var retryAfterSeconds: String?

    public init (
        message: String? = nil,
        retryAfterSeconds: String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LocationStatusType {
    case documented
    case undocumented
    case sdkUnknown(String)
}

extension LocationStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LocationStatusType] {
        return [
            .documented,
            .undocumented,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .documented: return "DOCUMENTED"
        case .undocumented: return "UNDOCUMENTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LocationStatusType(rawValue: rawValue) ?? LocationStatusType.sdkUnknown(rawValue)
    }
}

extension Method: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyRequired = apiKeyRequired {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for listofstring0 in authorizationScopes {
                try authorizationScopesContainer.encode(listofstring0)
            }
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType, forKey: .authorizationType)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let methodIntegration = methodIntegration {
            try encodeContainer.encode(methodIntegration, forKey: .methodIntegration)
        }
        if let methodResponses = methodResponses {
            var methodResponsesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .methodResponses)
            for (dictKey0, mapofmethodresponse0) in methodResponses {
                try methodResponsesContainer.encode(mapofmethodresponse0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestModels)
            for (dictKey0, mapofstringtostring0) in requestModels {
                try requestModelsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestParameters)
            for (dictKey0, mapofstringtoboolean0) in requestParameters {
                try requestParametersContainer.encode(mapofstringtoboolean0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestValidatorId = requestValidatorId {
            try encodeContainer.encode(requestValidatorId, forKey: .requestValidatorId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([String: MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [String:MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [String:MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

extension Method: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Method(apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), httpMethod: \(String(describing: httpMethod)), methodIntegration: \(String(describing: methodIntegration)), methodResponses: \(String(describing: methodResponses)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), requestValidatorId: \(String(describing: requestValidatorId)))"}
}

/// <p>
///             Represents a client-facing interface by which the client calls the API to access back-end resources. A <b>Method</b> resource is
///             integrated with an <a>Integration</a> resource. Both consist of a request and one or more responses. The method request takes
///             the client input that is passed to the back end through the integration request. A method response returns the output from
///             the back end to the client through an integration response. A method request is embodied in a <b>Method</b> resource, whereas
///             an integration request is embodied in an <a>Integration</a> resource.  On the other hand, a method response is represented
///             by a <a>MethodResponse</a> resource, whereas an integration response is represented by an <a>IntegrationResponse</a> resource.
///         </p>
///         <div class="remarks">
///           <p></p>
///           <h4>Example: Retrive the GET method on a specified resource</h4>
///           <h5>Request</h5>
///           <p>The following example request retrieves the information about the GET method on an API resource (<code>3kzxbg5sa2</code>) of an API (<code>fugvjdxtri</code>). </p>
///           <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1
/// Content-Type: application/json
/// Host: apigateway.us-east-1.amazonaws.com
/// X-Amz-Date: 20160603T210259Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
///           <h5>Response</h5>
///           <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
///           <pre><code>{
///   "_links": {
///     "curies": [
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
///         "name": "integration",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
///         "name": "integrationresponse",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html",
///         "name": "method",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
///         "name": "methodresponse",
///         "templated": true
///       }
///     ],
///     "self": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET",
///       "name": "GET",
///       "title": "GET"
///     },
///     "integration:put": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///     },
///     "method:delete": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
///     },
///     "method:integration": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///     },
///     "method:responses": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///       "name": "200",
///       "title": "200"
///     },
///     "method:update": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
///     },
///     "methodresponse:put": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}",
///       "templated": true
///     }
///   },
///   "apiKeyRequired": true,
///   "authorizationType": "NONE",
///   "httpMethod": "GET",
///   "_embedded": {
///     "method:integration": {
///       "_links": {
///         "self": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integration:delete": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integration:responses": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
///           "name": "200",
///           "title": "200"
///         },
///         "integration:update": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integrationresponse:put": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}",
///           "templated": true
///         }
///       },
///       "cacheKeyParameters": [],
///       "cacheNamespace": "3kzxbg5sa2",
///       "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
///       "httpMethod": "POST",
///       "passthroughBehavior": "WHEN_NO_MATCH",
///       "requestParameters": {
///         "integration.request.header.Content-Type": "'application/x-amz-json-1.1'"
///       },
///       "requestTemplates": {
///         "application/json": "{\n}"
///       },
///       "type": "AWS",
///       "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams",
///       "_embedded": {
///         "integration:responses": {
///           "_links": {
///             "self": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
///               "name": "200",
///               "title": "200"
///             },
///             "integrationresponse:delete": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
///             },
///             "integrationresponse:update": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
///             }
///           },
///           "responseParameters": {
///             "method.response.header.Content-Type": "'application/xml'"
///           },
///           "responseTemplates": {
///             "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E\")"
///           },
///           "statusCode": "200"
///         }
///       }
///     },
///     "method:responses": {
///       "_links": {
///         "self": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///           "name": "200",
///           "title": "200"
///         },
///         "methodresponse:delete": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///         },
///         "methodresponse:update": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///         }
///       },
///       "responseModels": {
///         "application/json": "Empty"
///       },
///       "responseParameters": {
///         "method.response.header.Content-Type": false
///       },
///       "statusCode": "200"
///     }
///   }
/// }</code></pre>
///           <p>In the example above, the response template for the <code>200 OK</code> response maps the JSON output from the <code>ListStreams</code> action in the back end to an XML output. The mapping template is URL-encoded as <code>%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E</code> and the output is decoded using the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#util-templat-reference">$util.urlDecode()</a> helper function.</p>
///       </div>
///       <div class="seeAlso">
///         <a>MethodResponse</a>, <a>Integration</a>, <a>IntegrationResponse</a>, <a>Resource</a>,
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings.html">Set up an API's method</a>
///       </div>
public struct Method: Equatable {
    /// <p>A boolean flag specifying whether a valid <a>ApiKey</a> is required to invoke this method.</p>
    public let apiKeyRequired: Bool?
    /// <p>A list of authorization scopes configured on the method. The scopes are used with a <code>COGNITO_USER_POOLS</code> authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    public let authorizationScopes: [String]?
    /// <p>The method's authorization type. Valid values are <code>NONE</code> for open access, <code>AWS_IAM</code> for using AWS IAM permissions, <code>CUSTOM</code> for using a custom authorizer, or <code>COGNITO_USER_POOLS</code> for using a Cognito user pool.</p>
    public let authorizationType: String?
    /// <p>The identifier of an <a>Authorizer</a> to use on this method. The <code>authorizationType</code> must be <code>CUSTOM</code>.</p>
    public let authorizerId: String?
    /// <p>The method's HTTP verb.</p>
    public let httpMethod: String?
    /// <p>Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.</p>
    ///       <div class="remarks">
    ///         <p></p>
    ///         <h4>Example: </h4>
    ///         <h5>Request</h5>
    ///         <p></p>
    ///         <pre><code>GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// Content-Length: 117
    /// X-Amz-Date: 20160613T213210Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": [
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
    ///         "name": "integration",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///         "name": "integrationresponse",
    ///         "templated": true
    ///       }
    ///     ],
    ///     "self": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integration:delete": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integration:responses": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200",
    ///       "name": "200",
    ///       "title": "200"
    ///     },
    ///     "integration:update": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integrationresponse:put": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/{status_code}",
    ///       "templated": true
    ///     }
    ///   },
    ///   "cacheKeyParameters": [],
    ///   "cacheNamespace": "0cjtch",
    ///   "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
    ///   "httpMethod": "POST",
    ///   "passthroughBehavior": "WHEN_NO_MATCH",
    ///   "requestTemplates": {
    ///     "application/json": "{\n    \"a\":  \"$input.params('operand1')\",\n    \"b\":  \"$input.params('operand2')\", \n    \"op\": \"$input.params('operator')\"   \n}"
    ///   },
    ///   "type": "AWS",
    ///   "uri": "arn:aws:apigateway:us-west-2:lambda:path//2015-03-31/functions/arn:aws:lambda:us-west-2:123456789012:function:Calc/invocations",
    ///   "_embedded": {
    ///     "integration:responses": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "integrationresponse:delete": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200"
    ///         },
    ///         "integrationresponse:update": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200"
    ///         }
    ///       },
    ///       "responseParameters": {
    ///         "method.response.header.operator": "integration.response.body.op",
    ///         "method.response.header.operand_2": "integration.response.body.b",
    ///         "method.response.header.operand_1": "integration.response.body.a"
    ///       },
    ///       "responseTemplates": {
    ///         "application/json": "#set($res = $input.path('$'))\n{\n    \"result\": \"$res.a, $res.b, $res.op => $res.c\",\n  \"a\" : \"$res.a\",\n  \"b\" : \"$res.b\",\n  \"op\" : \"$res.op\",\n  \"c\" : \"$res.c\"\n}"
    ///       },
    ///       "selectionPattern": "",
    ///       "statusCode": "200"
    ///     }
    ///   }
    /// }</code></pre>
    ///         <p></p>
    ///       </div>
    ///       <div class="seeAlso">
    ///         <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-integration.html">AWS CLI</a>
    ///       </div>
    public let methodIntegration: Integration?
    /// <p>Gets a method response associated with a given HTTP status code. </p>
    ///       <div class="remarks">
    ///         <p>The collection of method responses are encapsulated in a key-value map, where the key is a response's HTTP status code and the value is a <a>MethodResponse</a> resource that specifies the response returned to the caller from the back end through the integration response.</p>
    ///         <h4>Example: Get a 200 OK response of a GET method</h4>
    ///         <h5>Request</h5>
    ///         <p></p>
    ///         <pre><code>GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200 HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// Content-Length: 117
    /// X-Amz-Date: 20160613T215008Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": {
    ///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
    ///       "name": "methodresponse",
    ///       "templated": true
    ///     },
    ///     "self": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200",
    ///       "title": "200"
    ///     },
    ///     "methodresponse:delete": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200"
    ///     },
    ///     "methodresponse:update": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200"
    ///     }
    ///   },
    ///   "responseModels": {
    ///     "application/json": "Empty"
    ///   },
    ///   "responseParameters": {
    ///     "method.response.header.operator": false,
    ///     "method.response.header.operand_2": false,
    ///     "method.response.header.operand_1": false
    ///   },
    ///   "statusCode": "200"
    /// }</code></pre>
    ///         <p></p>
    ///       </div>
    ///       <div class="seeAlso">
    ///         <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-method-response.html">AWS CLI</a>
    ///       </div>
    public let methodResponses: [String:MethodResponse]?
    /// <p>A human-friendly operation identifier for the method. For example, you can assign the <code>operationName</code> of <code>ListPets</code> for the <code>GET /pets</code> method in the <code>PetStore</code> example.</p>
    public let operationName: String?
    /// <p>A key-value map specifying data schemas, represented by <a>Model</a> resources, (as the mapped value) of the request payloads of given content types (as the mapping key).</p>
    public let requestModels: [String:String]?
    /// <p>A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of  <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (<code>true</code>) or optional (<code>false</code>).  The method request parameter names defined here are available in <a>Integration</a> to be mapped to integration request parameters or templates.</p>
    public let requestParameters: [String:Bool]?
    /// <p>The identifier of a <a>RequestValidator</a> for request validation.</p>
    public let requestValidatorId: String?

    public init (
        apiKeyRequired: Bool? = nil,
        authorizationScopes: [String]? = nil,
        authorizationType: String? = nil,
        authorizerId: String? = nil,
        httpMethod: String? = nil,
        methodIntegration: Integration? = nil,
        methodResponses: [String:MethodResponse]? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:Bool]? = nil,
        requestValidatorId: String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

extension MethodResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseModels)
            for (dictKey0, mapofstringtostring0) in responseModels {
                try responseModelsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtoboolean0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtoboolean0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

extension MethodResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MethodResponse(responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template. <!-- API Gateway sends back the status code to the caller as the HTTP status code. Parameters and models can be used to transform the response from the method's integration.--></p>
///         <div class="remarks">
///           <p></p>
///           <h4>Example: A <b>MethodResponse</b> instance of an API</h4>
///           <h5>Request</h5>
///           <p>The example request retrieves a <b>MethodResponse</b> of the 200 status code.</p>
///           <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200 HTTP/1.1
/// Content-Type: application/json
/// Host: apigateway.us-east-1.amazonaws.com
/// X-Amz-Date: 20160603T222952Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
///           <h5>Response</h5>
///           <p>The successful response returns <code>200 OK</code> status and a payload as follows:</p>
///           <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
///       "name": "methodresponse",
///       "templated": true
///     },
///     "self": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///       "title": "200"
///     },
///     "methodresponse:delete": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///     },
///     "methodresponse:update": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///     }
///   },
///   "responseModels": {
///     "application/json": "Empty"
///   },
///   "responseParameters": {
///     "method.response.header.Content-Type": false
///   },
///   "statusCode": "200"
/// }</code></pre>
///           <p></p>
///       </div>
///       <div class="seeAlso">
///         <a>Method</a>, <a>IntegrationResponse</a>, <a>Integration</a>
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct MethodResponse: Equatable {
    /// <p>Specifies the <a>Model</a> resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a <a>Model</a> name as the value.</p>
    public let responseModels: [String:String]?
    /// <p>A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's <a>IntegrationResponse</a>. The integration response data that can be mapped include an integration response header expressed in <code>integration.response.header.{name}</code>, a static value enclosed within a pair of single quotes (e.g., <code>'application/json'</code>), or a JSON expression from the back-end response payload in the form of <code>integration.response.body.{JSON-expression}</code>, where <code>JSON-expression</code> is a valid JSON expression without the <code>$</code> prefix.)</p>
    public let responseParameters: [String:Bool]?
    /// <p>The method response's status code.</p>
    public let statusCode: String?

    public init (
        responseModels: [String:String]? = nil,
        responseParameters: [String:Bool]? = nil,
        statusCode: String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

extension MethodSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheDataEncrypted
        case cacheTtlInSeconds
        case cachingEnabled
        case dataTraceEnabled
        case loggingLevel
        case metricsEnabled
        case requireAuthorizationForCacheControl
        case throttlingBurstLimit
        case throttlingRateLimit
        case unauthorizedCacheControlHeaderStrategy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cacheDataEncrypted != false {
            try encodeContainer.encode(cacheDataEncrypted, forKey: .cacheDataEncrypted)
        }
        if cacheTtlInSeconds != 0 {
            try encodeContainer.encode(cacheTtlInSeconds, forKey: .cacheTtlInSeconds)
        }
        if cachingEnabled != false {
            try encodeContainer.encode(cachingEnabled, forKey: .cachingEnabled)
        }
        if dataTraceEnabled != false {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if let loggingLevel = loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if metricsEnabled != false {
            try encodeContainer.encode(metricsEnabled, forKey: .metricsEnabled)
        }
        if requireAuthorizationForCacheControl != false {
            try encodeContainer.encode(requireAuthorizationForCacheControl, forKey: .requireAuthorizationForCacheControl)
        }
        if throttlingBurstLimit != 0 {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if throttlingRateLimit != 0.0 {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
        if let unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy {
            try encodeContainer.encode(unauthorizedCacheControlHeaderStrategy.rawValue, forKey: .unauthorizedCacheControlHeaderStrategy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .metricsEnabled)
        metricsEnabled = metricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let dataTraceEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dataTraceEnabled)
        dataTraceEnabled = dataTraceEnabledDecoded
        let throttlingBurstLimitDecoded = try containerValues.decode(Int.self, forKey: .throttlingBurstLimit)
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decode(Double.self, forKey: .throttlingRateLimit)
        throttlingRateLimit = throttlingRateLimitDecoded
        let cachingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cachingEnabled)
        cachingEnabled = cachingEnabledDecoded
        let cacheTtlInSecondsDecoded = try containerValues.decode(Int.self, forKey: .cacheTtlInSeconds)
        cacheTtlInSeconds = cacheTtlInSecondsDecoded
        let cacheDataEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .cacheDataEncrypted)
        cacheDataEncrypted = cacheDataEncryptedDecoded
        let requireAuthorizationForCacheControlDecoded = try containerValues.decode(Bool.self, forKey: .requireAuthorizationForCacheControl)
        requireAuthorizationForCacheControl = requireAuthorizationForCacheControlDecoded
        let unauthorizedCacheControlHeaderStrategyDecoded = try containerValues.decodeIfPresent(UnauthorizedCacheControlHeaderStrategy.self, forKey: .unauthorizedCacheControlHeaderStrategy)
        unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategyDecoded
    }
}

extension MethodSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MethodSetting(cacheDataEncrypted: \(String(describing: cacheDataEncrypted)), cacheTtlInSeconds: \(String(describing: cacheTtlInSeconds)), cachingEnabled: \(String(describing: cachingEnabled)), dataTraceEnabled: \(String(describing: dataTraceEnabled)), loggingLevel: \(String(describing: loggingLevel)), metricsEnabled: \(String(describing: metricsEnabled)), requireAuthorizationForCacheControl: \(String(describing: requireAuthorizationForCacheControl)), throttlingBurstLimit: \(String(describing: throttlingBurstLimit)), throttlingRateLimit: \(String(describing: throttlingRateLimit)), unauthorizedCacheControlHeaderStrategy: \(String(describing: unauthorizedCacheControlHeaderStrategy)))"}
}

/// <p>Specifies the method setting properties.</p>
public struct MethodSetting: Equatable {
    /// <p>Specifies whether the cached responses are encrypted. The PATCH path for this setting is <code>/{method_setting_key}/caching/dataEncrypted</code>, and the value is a Boolean.</p>
    public let cacheDataEncrypted: Bool
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached. The PATCH path for this setting is <code>/{method_setting_key}/caching/ttlInSeconds</code>, and the value is an integer.</p>
    public let cacheTtlInSeconds: Int
    /// <p>Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached. The PATCH path for this setting is <code>/{method_setting_key}/caching/enabled</code>, and the value is a Boolean.</p>
    public let cachingEnabled: Bool
    /// <p>Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs. The PATCH path for this setting is <code>/{method_setting_key}/logging/dataTrace</code>, and the value is a Boolean.</p>
    public let dataTraceEnabled: Bool
    /// <p>Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. The PATCH path for this setting is <code>/{method_setting_key}/logging/loglevel</code>, and the available levels are <code>OFF</code>, <code>ERROR</code>, and <code>INFO</code>. Choose <code>ERROR</code> to write only error-level entries to CloudWatch Logs, or choose <code>INFO</code> to include all <code>ERROR</code> events as well as extra informational events.</p>
    public let loggingLevel: String?
    /// <p>Specifies whether Amazon CloudWatch metrics are enabled for this method. The PATCH path for this setting is <code>/{method_setting_key}/metrics/enabled</code>, and the value is a Boolean.</p>
    public let metricsEnabled: Bool
    /// <p>Specifies whether authorization is required for a cache invalidation request. The PATCH path for this setting is <code>/{method_setting_key}/caching/requireAuthorizationForCacheControl</code>, and the value is a Boolean.</p>
    public let requireAuthorizationForCacheControl: Bool
    /// <p>Specifies the throttling burst limit. The PATCH path for this setting is <code>/{method_setting_key}/throttling/burstLimit</code>, and the value is an integer.</p>
    public let throttlingBurstLimit: Int
    /// <p>Specifies the throttling rate limit. The PATCH path for this setting is <code>/{method_setting_key}/throttling/rateLimit</code>, and the value is a double.</p>
    public let throttlingRateLimit: Double
    /// <p>Specifies how to handle unauthorized requests for cache invalidation. The PATCH path for this setting is <code>/{method_setting_key}/caching/unauthorizedCacheControlHeaderStrategy</code>, and the available values are <code>FAIL_WITH_403</code>, <code>SUCCEED_WITH_RESPONSE_HEADER</code>, <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code>.</p>
    public let unauthorizedCacheControlHeaderStrategy: UnauthorizedCacheControlHeaderStrategy?

    public init (
        cacheDataEncrypted: Bool = false,
        cacheTtlInSeconds: Int = 0,
        cachingEnabled: Bool = false,
        dataTraceEnabled: Bool = false,
        loggingLevel: String? = nil,
        metricsEnabled: Bool = false,
        requireAuthorizationForCacheControl: Bool = false,
        throttlingBurstLimit: Int = 0,
        throttlingRateLimit: Double = 0.0,
        unauthorizedCacheControlHeaderStrategy: UnauthorizedCacheControlHeaderStrategy? = nil
    )
    {
        self.cacheDataEncrypted = cacheDataEncrypted
        self.cacheTtlInSeconds = cacheTtlInSeconds
        self.cachingEnabled = cachingEnabled
        self.dataTraceEnabled = dataTraceEnabled
        self.loggingLevel = loggingLevel
        self.metricsEnabled = metricsEnabled
        self.requireAuthorizationForCacheControl = requireAuthorizationForCacheControl
        self.throttlingBurstLimit = throttlingBurstLimit
        self.throttlingRateLimit = throttlingRateLimit
        self.unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy
    }
}

extension MethodSnapshot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired
        case authorizationType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if apiKeyRequired != false {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType, forKey: .authorizationType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let apiKeyRequiredDecoded = try containerValues.decode(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
    }
}

extension MethodSnapshot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MethodSnapshot(apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationType: \(String(describing: authorizationType)))"}
}

/// <p>Represents a summary of a <a>Method</a> resource, given a particular date and time.</p>
public struct MethodSnapshot: Equatable {
    /// <p>Specifies whether the method requires a valid <a>ApiKey</a>.</p>
    public let apiKeyRequired: Bool
    /// <p>The method's authorization type. Valid values are <code>NONE</code> for open access, <code>AWS_IAM</code> for using AWS IAM permissions, <code>CUSTOM</code> for using a custom authorizer, or <code>COGNITO_USER_POOLS</code> for using a Cognito user pool.</p>
    public let authorizationType: String?

    public init (
        apiKeyRequired: Bool = false,
        authorizationType: String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationType = authorizationType
    }
}

extension Model: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension Model: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Model(contentType: \(String(describing: contentType)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

/// <p>Represents the data structure of a method's request or response payload.</p>
///       <div class="remarks">
///         <p>A request model defines the data structure of the client-supplied request payload. A response model defines the data structure of the response payload returned by the back end. Although not required, models are useful for mapping payloads between the front end and back end.</p>
///         <p>A model is used for generating an API's SDK, validating the input request body, and creating a skeletal mapping template.</p>
///       </div>
///       <div class="seeAlso">
///         <a>Method</a>, <a>MethodResponse</a>, <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html">Models and Mappings</a>
///       </div>
public struct Model: Equatable {
    /// <p>The content-type for the model.</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>The identifier for the model resource.</p>
    public let id: String?
    /// <p>The name of the model. Must be an alphanumeric string.</p>
    public let name: String?
    /// <p>The schema for the model. For <code>application/json</code> models, this should be <a target="_blank" href="https://tools.ietf.org/html/draft-zyp-json-schema-04">JSON schema draft 4</a> model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.</p>
    public let schema: String?

    public init (
        contentType: String? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

extension MutualTlsAuthentication: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case truststoreUri
        case truststoreVersion
        case truststoreWarnings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
        if let truststoreWarnings = truststoreWarnings {
            var truststoreWarningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .truststoreWarnings)
            for listofstring0 in truststoreWarnings {
                try truststoreWarningsContainer.encode(listofstring0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
        let truststoreWarningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .truststoreWarnings)
        var truststoreWarningsDecoded0:[String]? = nil
        if let truststoreWarningsContainer = truststoreWarningsContainer {
            truststoreWarningsDecoded0 = [String]()
            for string0 in truststoreWarningsContainer {
                if let string0 = string0 {
                    truststoreWarningsDecoded0?.append(string0)
                }
            }
        }
        truststoreWarnings = truststoreWarningsDecoded0
    }
}

extension MutualTlsAuthentication: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MutualTlsAuthentication(truststoreUri: \(String(describing: truststoreUri)), truststoreVersion: \(String(describing: truststoreVersion)), truststoreWarnings: \(String(describing: truststoreWarnings)))"}
}

/// <p>If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your custom domain name.</p>
public struct MutualTlsAuthentication: Equatable {
    /// <p>An Amazon S3 URL that specifies the truststore for mutual TLS authentication,
    ///             for example <code>s3://bucket-name/key-name</code>.
    ///             The truststore can contain certificates from public or private certificate authorities.
    ///             To update the truststore, upload a new version to S3, and then update your custom domain
    ///             name to use the new version. To update the truststore, you must have permissions to
    ///             access the S3 object.</p>
    public let truststoreUri: String?
    /// <p>The version of the S3 object that contains your truststore. To
    ///             specify a version, you must have versioning enabled for the S3 bucket.</p>
    public let truststoreVersion: String?
    /// <p>A list of warnings that API Gateway returns while processing your truststore. Invalid
    ///             certificates produce warnings. Mutual TLS is still enabled, but some clients might not
    ///             be able to access your API. To resolve warnings, upload a new truststore to S3, and then
    ///             update you domain name to use the new version.</p>
    public let truststoreWarnings: [String]?

    public init (
        truststoreUri: String? = nil,
        truststoreVersion: String? = nil,
        truststoreWarnings: [String]? = nil
    )
    {
        self.truststoreUri = truststoreUri
        self.truststoreVersion = truststoreVersion
        self.truststoreWarnings = truststoreWarnings
    }
}

extension MutualTlsAuthenticationInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case truststoreUri
        case truststoreVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
    }
}

extension MutualTlsAuthenticationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MutualTlsAuthenticationInput(truststoreUri: \(String(describing: truststoreUri)), truststoreVersion: \(String(describing: truststoreVersion)))"}
}

/// <p>If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your custom domain name.</p>
public struct MutualTlsAuthenticationInput: Equatable {
    /// <p>An Amazon S3 resource ARN that specifies the truststore for mutual TLS authentication,
    ///             for example,
    ///             <code>s3://bucket-name/key-name</code>.
    ///             The truststore can contain certificates from public or private certificate authorities.
    ///             To update the truststore, upload a new version to S3, and then update your custom domain
    ///             name to use the new version. To update the truststore, you must have permissions to
    ///             access the S3 object.</p>
    public let truststoreUri: String?
    /// <p>The version of the S3 object that contains your truststore. To
    ///             specify a version, you must have versioning enabled for the S3 bucket.</p>
    public let truststoreVersion: String?

    public init (
        truststoreUri: String? = nil,
        truststoreVersion: String? = nil
    )
    {
        self.truststoreUri = truststoreUri
        self.truststoreVersion = truststoreVersion
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource is not found. Make sure that the request URI is correct.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Op {
    case add
    case copy
    case move
    case remove
    case replace
    case test
    case sdkUnknown(String)
}

extension Op : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Op] {
        return [
            .add,
            .copy,
            .move,
            .remove,
            .replace,
            .test,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .add: return "add"
        case .copy: return "copy"
        case .move: return "move"
        case .remove: return "remove"
        case .replace: return "replace"
        case .test: return "test"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Op(rawValue: rawValue) ?? Op.sdkUnknown(rawValue)
    }
}

extension PatchOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case from
        case op
        case path
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let from = from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let op = op {
            try encodeContainer.encode(op.rawValue, forKey: .op)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opDecoded = try containerValues.decodeIfPresent(Op.self, forKey: .op)
        op = opDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let fromDecoded = try containerValues.decodeIfPresent(String.self, forKey: .from)
        from = fromDecoded
    }
}

extension PatchOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchOperation(from: \(String(describing: from)), op: \(String(describing: op)), path: \(String(describing: path)), value: \(String(describing: value)))"}
}

/// A single patch operation to apply to the specified resource. Please refer to
///         http://tools.ietf.org/html/rfc6902#section-4 for an explanation of how each operation is used.
public struct PatchOperation: Equatable {
    /// <p>The <code>copy</code> update operation's source as identified by a <code>JSON-Pointer</code> value referencing the location within the targeted resource to copy the value from. For example, to promote a canary deployment, you copy the canary deployment ID to the affiliated deployment ID by calling a PATCH request on a <a>Stage</a> resource with <code>"op":"copy"</code>, <code>"from":"/canarySettings/deploymentId"</code> and <code>"path":"/deploymentId"</code>.</p>
    public let from: String?
    /// <p> An update operation to be performed with this PATCH request. The valid value can be <code>add</code>, <code>remove</code>,  <code>replace</code> or <code>copy</code>. Not all valid operations are supported for a given resource. Support of the operations depends on specific operational contexts. Attempts to apply an unsupported operation on a resource will return an error message.</p>
    public let op: Op?
    /// <p>The <code>op</code> operation's target, as identified by a <a href="https://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-08">JSON Pointer</a> value that references a location within the targeted resource. For example, if the target resource has an updateable property of <code>{"name":"value"}</code>, the path for this property is <code>/name</code>. If the <code>name</code> property value is a JSON object (e.g., <code>{"name": {"child/name": "child-value"}}</code>), the path for the <code>child/name</code> property will be <code>/name/child~1name</code>. Any slash ("/") character appearing in path names must be escaped with "~1", as shown in the example above. Each <code>op</code> operation can have only one <code>path</code> associated with it.</p>
    public let path: String?
    /// <p>The new target value of the update operation. It is applicable for the <code>add</code> or <code>replace</code> operation. When using AWS CLI to update a property of a JSON value, enclose the JSON object with a pair of single quotes in a Linux shell, e.g., '{"a": ...}'. In a Windows shell, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a>.</p>
    public let value: String?

    public init (
        from: String? = nil,
        op: Op? = nil,
        path: String? = nil,
        value: String? = nil
    )
    {
        self.from = from
        self.op = op
        self.path = path
        self.value = value
    }
}

public struct PutGatewayResponseInputBodyMiddleware: Middleware {
    public let id: String = "PutGatewayResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutGatewayResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<PutGatewayResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutGatewayResponseInput>
    public typealias MOutput = OperationOutput<PutGatewayResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutGatewayResponseOutputError>
}

extension PutGatewayResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutGatewayResponseInput(responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), responseType: \(String(describing: responseType)), restApiId: \(String(describing: restApiId)), statusCode: \(String(describing: statusCode)))"}
}

extension PutGatewayResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case responseParameters
        case responseTemplates
        case statusCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtostring0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseTemplates)
            for (dictKey0, mapofstringtostring0) in responseTemplates {
                try responseTemplatesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }
}

public struct PutGatewayResponseInputHeadersMiddleware: Middleware {
    public let id: String = "PutGatewayResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutGatewayResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<PutGatewayResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutGatewayResponseInput>
    public typealias MOutput = OperationOutput<PutGatewayResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutGatewayResponseOutputError>
}

public struct PutGatewayResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "PutGatewayResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutGatewayResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<PutGatewayResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutGatewayResponseInput>
    public typealias MOutput = OperationOutput<PutGatewayResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutGatewayResponseOutputError>
}

/// <p>Creates a customization of a <a>GatewayResponse</a> of a specified response type and status code on the given <a>RestApi</a>.</p>
public struct PutGatewayResponseInput: Equatable {
    /// <p><p>Response parameters (paths, query strings and headers) of the <a>GatewayResponse</a> as a string-to-string map of key-value  pairs.</p></p>
    public let responseParameters: [String:String]?
    /// <p><p>Response templates of the <a>GatewayResponse</a> as a string-to-string map of key-value pairs.</p></p>
    public let responseTemplates: [String:String]?
    /// <p>[Required] <p>The response type of the associated <a>GatewayResponse</a>. Valid values are <ul><li>ACCESS_DENIED</li><li>API_CONFIGURATION_ERROR</li><li>AUTHORIZER_FAILURE</li><li> AUTHORIZER_CONFIGURATION_ERROR</li><li>BAD_REQUEST_PARAMETERS</li><li>BAD_REQUEST_BODY</li><li>DEFAULT_4XX</li><li>DEFAULT_5XX</li><li>EXPIRED_TOKEN</li><li>INVALID_SIGNATURE</li><li>INTEGRATION_FAILURE</li><li>INTEGRATION_TIMEOUT</li><li>INVALID_API_KEY</li><li>MISSING_AUTHENTICATION_TOKEN</li><li> QUOTA_EXCEEDED</li><li>REQUEST_TOO_LARGE</li><li>RESOURCE_NOT_FOUND</li><li>THROTTLED</li><li>UNAUTHORIZED</li><li>UNSUPPORTED_MEDIA_TYPE</li></ul> </p></p>
    public let responseType: GatewayResponseType?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// The HTTP status code of the <a>GatewayResponse</a>.
    public let statusCode: String?

    public init (
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        responseType: GatewayResponseType? = nil,
        restApiId: String? = nil,
        statusCode: String? = nil
    )
    {
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct PutGatewayResponseInputBody: Equatable {
    public let statusCode: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
}

extension PutGatewayResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case responseParameters
        case responseTemplates
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
    }
}

extension PutGatewayResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutGatewayResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutGatewayResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutGatewayResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutGatewayResponseOutputResponse(defaultResponse: \(String(describing: defaultResponse)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), responseType: \(String(describing: responseType)), statusCode: \(String(describing: statusCode)))"}
}

extension PutGatewayResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutGatewayResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.defaultResponse = output.defaultResponse
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.responseType = output.responseType
            self.statusCode = output.statusCode
        } else {
            self.defaultResponse = false
            self.responseParameters = nil
            self.responseTemplates = nil
            self.responseType = nil
            self.statusCode = nil
        }
    }
}

/// <p>A gateway response of a given response type and status code, with optional response parameters and mapping templates.</p>
///         <div class="remarks">
///             For more information about valid gateway response types, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html">Gateway Response Types Supported by API Gateway</a>
///             <div class="example">
///     <h4>Example: Get a Gateway Response of a given response type</h4>
///     <h5>Request</h5>
///     <p>This example shows how to get a gateway response of the <code>MISSING_AUTHENTICATION_TOKEN</code> type.</p>
///     <pre><code>GET /restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN HTTP/1.1
/// Host: beta-apigateway.us-east-1.amazonaws.com
/// Content-Type: application/json
/// X-Amz-Date: 20170503T202516Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=1b52460e3159c1a26cff29093855d50ea141c1c5b937528fecaf60f51129697a
/// Cache-Control: no-cache
/// Postman-Token: 3b2a1ce9-c848-2e26-2e2f-9c2caefbed45
/// </code></pre>
///     <p>The response type is specified as a URL path.</p>
///     <h5>Response</h5>
///     <p>The successful operation returns the <code>200 OK</code> status code and a payload similar to the following:</p>
///     <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html",
///       "name": "gatewayresponse",
///       "templated": true
///     },
///     "self": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     },
///     "gatewayresponse:delete": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     },
///     "gatewayresponse:put": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///       "templated": true
///     },
///     "gatewayresponse:update": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     }
///   },
///   "defaultResponse": false,
///   "responseParameters": {
///     "gatewayresponse.header.x-request-path": "method.request.path.petId",
///     "gatewayresponse.header.Access-Control-Allow-Origin": "'a.b.c'",
///     "gatewayresponse.header.x-request-query": "method.request.querystring.q",
///     "gatewayresponse.header.x-request-header": "method.request.header.Accept"
///   },
///   "responseTemplates": {
///     "application/json": "{\n     \"message\": $context.error.messageString,\n     \"type\":  \"$context.error.responseType\",\n     \"stage\":  \"$context.stage\",\n     \"resourcePath\":  \"$context.resourcePath\",\n     \"stageVariables.a\":  \"$stageVariables.a\",\n     \"statusCode\": \"'404'\"\n}"
///   },
///   "responseType": "MISSING_AUTHENTICATION_TOKEN",
///   "statusCode": "404"
/// }</code></pre>
///     <p></p>
///   </div>
///         </div>
///         <div class="seeAlso">
///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html">Customize Gateway Responses</a>
///         </div>
public struct PutGatewayResponseOutputResponse: Equatable {
    /// <p>A Boolean flag to indicate whether this <a>GatewayResponse</a> is the default gateway response (<code>true</code>) or not (<code>false</code>). A default gateway response is one generated by API Gateway without any customization by an API developer. </p>
    public let defaultResponse: Bool
    /// <p>Response parameters (paths, query strings and headers) of the <a>GatewayResponse</a> as a string-to-string map of key-value  pairs.</p>
    public let responseParameters: [String:String]?
    /// <p>Response templates of the <a>GatewayResponse</a> as a string-to-string map of key-value pairs.</p>
    public let responseTemplates: [String:String]?
    /// <p>The response type of the associated <a>GatewayResponse</a>. Valid values are <ul><li>ACCESS_DENIED</li><li>API_CONFIGURATION_ERROR</li><li>AUTHORIZER_FAILURE</li><li> AUTHORIZER_CONFIGURATION_ERROR</li><li>BAD_REQUEST_PARAMETERS</li><li>BAD_REQUEST_BODY</li><li>DEFAULT_4XX</li><li>DEFAULT_5XX</li><li>EXPIRED_TOKEN</li><li>INVALID_SIGNATURE</li><li>INTEGRATION_FAILURE</li><li>INTEGRATION_TIMEOUT</li><li>INVALID_API_KEY</li><li>MISSING_AUTHENTICATION_TOKEN</li><li> QUOTA_EXCEEDED</li><li>REQUEST_TOO_LARGE</li><li>RESOURCE_NOT_FOUND</li><li>THROTTLED</li><li>UNAUTHORIZED</li><li>UNSUPPORTED_MEDIA_TYPE</li></ul> </p>
    public let responseType: GatewayResponseType?
    /// <p>The HTTP status code for this <a>GatewayResponse</a>.</p>
    public let statusCode: String?

    public init (
        defaultResponse: Bool = false,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        responseType: GatewayResponseType? = nil,
        statusCode: String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

struct PutGatewayResponseOutputResponseBody: Equatable {
    public let responseType: GatewayResponseType?
    public let statusCode: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let defaultResponse: Bool
}

extension PutGatewayResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decode(Bool.self, forKey: .defaultResponse)
        defaultResponse = defaultResponseDecoded
    }
}

public struct PutIntegrationInputBodyMiddleware: Middleware {
    public let id: String = "PutIntegrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIntegrationInput>
    public typealias MOutput = OperationOutput<PutIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIntegrationOutputError>
}

extension PutIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutIntegrationInput(cacheKeyParameters: \(String(describing: cacheKeyParameters)), cacheNamespace: \(String(describing: cacheNamespace)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandling: \(String(describing: contentHandling)), credentials: \(String(describing: credentials)), httpMethod: \(String(describing: httpMethod)), integrationHttpMethod: \(String(describing: integrationHttpMethod)), passthroughBehavior: \(String(describing: passthroughBehavior)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)), type: \(String(describing: type)), uri: \(String(describing: uri)))"}
}

extension PutIntegrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case integrationHttpMethod = "httpMethod"
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheKeyParameters = cacheKeyParameters {
            var cacheKeyParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cacheKeyParameters)
            for listofstring0 in cacheKeyParameters {
                try cacheKeyParametersContainer.encode(listofstring0)
            }
        }
        if let cacheNamespace = cacheNamespace {
            try encodeContainer.encode(cacheNamespace, forKey: .cacheNamespace)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandling = contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let credentials = credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let integrationHttpMethod = integrationHttpMethod {
            try encodeContainer.encode(integrationHttpMethod, forKey: .integrationHttpMethod)
        }
        if let passthroughBehavior = passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior, forKey: .passthroughBehavior)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestParameters)
            for (dictKey0, mapofstringtostring0) in requestParameters {
                try requestParametersContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestTemplates)
            for (dictKey0, mapofstringtostring0) in requestTemplates {
                try requestTemplatesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timeoutInMillis = timeoutInMillis {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

public struct PutIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "PutIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIntegrationInput>
    public typealias MOutput = OperationOutput<PutIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIntegrationOutputError>
}

public struct PutIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIntegrationInput>
    public typealias MOutput = OperationOutput<PutIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIntegrationOutputError>
}

/// <p>Sets up a method's integration.</p>
public struct PutIntegrationInput: Equatable {
    /// <p>A list of request parameters whose values API Gateway caches. To be valid values for <code>cacheKeyParameters</code>, these parameters must also be specified for <a>Method</a> <code>requestParameters</code>.</p>
    public let cacheKeyParameters: [String]?
    /// <p>Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the <code>cacheNamespace</code>. You can specify the same <code>cacheNamespace</code> across resources to return the same cached data for requests to different resources.</p>
    public let cacheNamespace: String?
    /// <p>The (<a href="https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id"><code>id</code></a>) of the <a>VpcLink</a> used for the integration when <code>connectionType=VPC_LINK</code> and undefined, otherwise.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. The valid value is <code>INTERNET</code> for connections through the public routable internet or <code>VPC_LINK</code> for private connections between API Gateway and a network load balancer in a VPC. The default value is <code>INTERNET</code>.</p>
    public let connectionType: ConnectionType?
    /// <p>Specifies how to handle request payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p>
    ///   <ul>
    ///     <li><p><code>CONVERT_TO_BINARY</code>: Converts a request payload from a Base64-encoded string to the corresponding binary blob.</p></li>
    ///     <li><p><code>CONVERT_TO_TEXT</code>: Converts a request payload from a binary blob to a Base64-encoded string.</p></li>
    ///   </ul>
    ///   <p>If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the <code>passthroughBehavior</code> is configured to support payload pass-through.</p>
    public let contentHandling: ContentHandlingStrategy?
    /// <p>Specifies whether credentials are required for a put integration.</p>
    public let credentials: String?
    /// <p>[Required] Specifies a put integration request's HTTP method.</p>
    public let httpMethod: String?
    /// <p>Specifies a put integration HTTP method. When the integration type is HTTP or AWS, this field is required.</p>
    public let integrationHttpMethod: String?
    /// <p>Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the <code>requestTemplates</code> property on the Integration resource. There are three valid values:  <code>WHEN_NO_MATCH</code>, <code>WHEN_NO_TEMPLATES</code>, and <code>NEVER</code>.
    ///         </p>
    ///         <ul>
    ///            <li><p><code>WHEN_NO_MATCH</code> passes the request body for unmapped content types through to the integration back end without transformation.</p></li>
    ///            <li><p><code>NEVER</code> rejects unmapped content types with an HTTP 415 'Unsupported Media Type' response.</p></li>
    ///            <li><p><code>WHEN_NO_TEMPLATES</code> allows pass-through when the integration has NO content types mapped to templates. However if there is at least one content type defined, unmapped content types will be rejected with the same 415 response.</p></li>
    ///         </ul>
    public let passthroughBehavior: String?
    /// <p>A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of  <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> must be a valid and unique method request parameter name.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.</p>
    public let requestTemplates: [String:String]?
    /// <p>[Required] Specifies a put integration request's resource ID.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.</p>
    public let timeoutInMillis: Int?
    public let tlsConfig: TlsConfig?
    /// <p>[Required] Specifies a put integration input's type.</p>
    public let type: IntegrationType?
    /// <p>Specifies Uniform Resource Identifier (URI) of the integration endpoint.</p>
    /// <ul>
    /// <li><p> For <code>HTTP</code> or <code>HTTP_PROXY</code> integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the <a target="_blank" href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">RFC-3986 specification</a>, for either standard integration, where <code>connectionType</code> is not <code>VPC_LINK</code>, or private integration, where <code>connectionType</code> is <code>VPC_LINK</code>. For a private HTTP integration, the URI is not used for routing. </p>
    /// </li>
    /// <li><p> For <code>AWS</code> or <code>AWS_PROXY</code> integrations, the URI is of the form <code>arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}</code>. Here, <code>{Region}</code> is the API Gateway region (e.g., <code>us-east-1</code>); <code>{service}</code> is the name of the integrated AWS service (e.g., <code>s3</code>); and <code>{subdomain}</code> is a designated subdomain supported by certain AWS service for fast host-name lookup. <code>action</code> can be used for an AWS service action-based API, using an <code>Action={name}&{p1}={v1}&p2={v2}...</code> query string. The ensuing <code>{service_api}</code> refers to a supported action <code>{name}</code> plus any required input parameters. Alternatively, <code>path</code> can be used for an AWS service path-based API. The ensuing  <code>service_api</code> refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of <code><a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html">GetObject</a></code>, the <code>uri</code> can be either <code>arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key}</code> or  <code>arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}</code></p>
    /// </li></ul>
    public let uri: String?

    public init (
        cacheKeyParameters: [String]? = nil,
        cacheNamespace: String? = nil,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandling: ContentHandlingStrategy? = nil,
        credentials: String? = nil,
        httpMethod: String? = nil,
        integrationHttpMethod: String? = nil,
        passthroughBehavior: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil,
        timeoutInMillis: Int? = nil,
        tlsConfig: TlsConfig? = nil,
        type: IntegrationType? = nil,
        uri: String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationHttpMethod = integrationHttpMethod
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct PutIntegrationInputBody: Equatable {
    public let type: IntegrationType?
    public let integrationHttpMethod: String?
    public let uri: String?
    public let connectionType: ConnectionType?
    public let connectionId: String?
    public let credentials: String?
    public let requestParameters: [String:String]?
    public let requestTemplates: [String:String]?
    public let passthroughBehavior: String?
    public let cacheNamespace: String?
    public let cacheKeyParameters: [String]?
    public let contentHandling: ContentHandlingStrategy?
    public let timeoutInMillis: Int?
    public let tlsConfig: TlsConfig?
}

extension PutIntegrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case integrationHttpMethod = "httpMethod"
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .type)
        type = typeDecoded
        let integrationHttpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationHttpMethod)
        integrationHttpMethod = integrationHttpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension PutIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutIntegrationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutIntegrationOutputResponse(cacheKeyParameters: \(String(describing: cacheKeyParameters)), cacheNamespace: \(String(describing: cacheNamespace)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandling: \(String(describing: contentHandling)), credentials: \(String(describing: credentials)), httpMethod: \(String(describing: httpMethod)), integrationResponses: \(String(describing: integrationResponses)), passthroughBehavior: \(String(describing: passthroughBehavior)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)), type: \(String(describing: type)), uri: \(String(describing: uri)))"}
}

extension PutIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cacheKeyParameters = output.cacheKeyParameters
            self.cacheNamespace = output.cacheNamespace
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandling = output.contentHandling
            self.credentials = output.credentials
            self.httpMethod = output.httpMethod
            self.integrationResponses = output.integrationResponses
            self.passthroughBehavior = output.passthroughBehavior
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
            self.type = output.type
            self.uri = output.uri
        } else {
            self.cacheKeyParameters = nil
            self.cacheNamespace = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandling = nil
            self.credentials = nil
            self.httpMethod = nil
            self.integrationResponses = nil
            self.passthroughBehavior = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
            self.type = nil
            self.uri = nil
        }
    }
}

/// <p>Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.</p>
///         <div class="remarks">In the API Gateway console, the built-in Lambda integration is an AWS integration.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct PutIntegrationOutputResponse: Equatable {
    /// <p>A list of request parameters whose values API Gateway caches. To be valid values for <code>cacheKeyParameters</code>, these parameters must also be specified for <a>Method</a> <code>requestParameters</code>.</p>
    public let cacheKeyParameters: [String]?
    /// <p>Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the <code>cacheNamespace</code>. You can specify the same <code>cacheNamespace</code> across resources to return the same cached data for requests to different resources.</p>
    public let cacheNamespace: String?
    /// <p>The (<a href="https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id"><code>id</code></a>) of the <a>VpcLink</a> used for the integration when <code>connectionType=VPC_LINK</code> and undefined, otherwise.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. The valid value is <code>INTERNET</code> for connections through the public routable internet or <code>VPC_LINK</code> for private connections between API Gateway and a network load balancer in a VPC. The default value is <code>INTERNET</code>.</p>
    public let connectionType: ConnectionType?
    /// <p>Specifies how to handle request payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p>
    ///       <ul>
    ///         <li><p><code>CONVERT_TO_BINARY</code>: Converts a request payload from a Base64-encoded string to the corresponding binary blob.</p></li>
    ///         <li><p><code>CONVERT_TO_TEXT</code>: Converts a request payload from a binary blob to a Base64-encoded string.</p></li>
    ///       </ul>
    ///       <p>If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the <code>passthroughBehavior</code> is configured to support payload pass-through.</p>
    public let contentHandling: ContentHandlingStrategy?
    /// <p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string <code>arn:aws:iam::\*:user/\*</code>. To use resource-based permissions on supported AWS services, specify null.</p>
    public let credentials: String?
    /// <p>Specifies the integration's HTTP method type.</p>
    public let httpMethod: String?
    /// <p>Specifies the integration's responses.</p>
    ///         <div class="remarks">
    ///     <p></p>
    ///     <h4>Example: Get integration responses of a method</h4>
    ///     <h5>Request</h5>
    ///     <p></p>
    ///     <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200 HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// X-Amz-Date: 20160607T191449Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160607/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    /// </code></pre>
    ///     <h5>Response</h5>
    ///     <p>The successful response returns <code>200 OK</code> status and a payload as follows:</p>
    ///     <pre><code>{
    ///   "_links": {
    ///     "curies": {
    ///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///       "name": "integrationresponse",
    ///       "templated": true
    ///     },
    ///     "self": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///       "title": "200"
    ///     },
    ///     "integrationresponse:delete": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///     },
    ///     "integrationresponse:update": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///     }
    ///   },
    ///   "responseParameters": {
    ///     "method.response.header.Content-Type": "'application/xml'"
    ///   },
    ///   "responseTemplates": {
    ///     "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n"
    ///   },
    ///   "statusCode": "200"
    /// }</code></pre>
    ///     <p></p>
    ///         </div>
    ///         <div class="seeAlso">
    ///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
    ///         </div>
    public let integrationResponses: [String:IntegrationResponse]?
    /// <div>
    ///         <p>
    ///             Specifies how the method request body of an unmapped content type will be passed through the integration request
    ///             to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration
    ///             or the content type does not match any of the mapped content types, as specified in <code>requestTemplates</code>.
    ///             The valid value is one of the following:
    ///         </p>
    ///         <ul>
    ///           <li>
    ///             <code>WHEN_NO_MATCH</code>: passes the method request body through the integration request to the back end without transformation
    ///             when the method request content type does not match any content type associated with the mapping templates defined in the integration request.
    ///           </li>
    ///           <li>
    ///             <code>WHEN_NO_TEMPLATES</code>: passes the method request body through the integration request to the back end without transformation
    ///             when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request
    ///             of an unmapped content-type will be rejected with an HTTP <code>415 Unsupported Media Type</code> response.
    ///           </li>
    ///           <li>
    ///             <code>NEVER</code>: rejects the method request with an HTTP <code>415 Unsupported Media Type</code> response when either the method
    ///             request content type does not match any content type associated with the mapping templates defined in the integration request or
    ///             no mapping template is defined in the integration request.
    ///           </li>
    ///         </ul>
    ///       </div>
    public let passthroughBehavior: String?
    /// <p>A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of  <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> must be a valid and unique method request parameter name.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.</p>
    public let requestTemplates: [String:String]?
    /// <p>Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.</p>
    public let timeoutInMillis: Int
    /// <p>Specifies the TLS configuration for an integration.</p>
    public let tlsConfig: TlsConfig?
    /// <p>Specifies an API method integration type. The valid value is one of the following:</p>
    ///         <ul>
    ///             <li><code>AWS</code>: for integrating the API method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration.</li>
    ///             <li><code>AWS_PROXY</code>: for integrating the API method request with the Lambda function-invoking action with the client request passed through as-is. This integration is also referred to as the Lambda proxy integration.</li>
    ///             <li><code>HTTP</code>: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC. This integration is also referred to as the HTTP custom integration.</li>
    ///             <li><code>HTTP_PROXY</code>: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC, with the client request passed through as-is. This is also referred to as the HTTP proxy integration.</li>
    ///             <li><code>MOCK</code>: for integrating the API method request with API Gateway as a "loop-back" endpoint without invoking any backend.</li>
    ///         </ul>
    ///         <p>For the HTTP and HTTP proxy integrations, each integration can specify a protocol (<code>http/https</code>), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a <code>connectionType</code> of <code>VPC_LINK</code> is referred to as a private integration and uses a <a>VpcLink</a> to connect API Gateway to a network load balancer of a VPC.</p>
    public let type: IntegrationType?
    /// <p>Specifies Uniform Resource Identifier (URI) of the integration endpoint.</p>
    /// <ul>
    /// <li><p> For <code>HTTP</code> or <code>HTTP_PROXY</code> integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the <a target="_blank" href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">RFC-3986 specification</a>, for either standard integration, where <code>connectionType</code> is not <code>VPC_LINK</code>, or private integration, where <code>connectionType</code> is <code>VPC_LINK</code>. For a private HTTP integration, the URI is not used for routing. </p>
    /// </li>
    /// <li><p> For <code>AWS</code> or <code>AWS_PROXY</code> integrations, the URI is of the form <code>arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}</code>. Here, <code>{Region}</code> is the API Gateway region (e.g., <code>us-east-1</code>); <code>{service}</code> is the name of the integrated AWS service (e.g., <code>s3</code>); and <code>{subdomain}</code> is a designated subdomain supported by certain AWS service for fast host-name lookup. <code>action</code> can be used for an AWS service action-based API, using an <code>Action={name}&{p1}={v1}&p2={v2}...</code> query string. The ensuing <code>{service_api}</code> refers to a supported action <code>{name}</code> plus any required input parameters. Alternatively, <code>path</code> can be used for an AWS service path-based API. The ensuing  <code>service_api</code> refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of <code><a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html">GetObject</a></code>, the <code>uri</code> can be either <code>arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key}</code> or  <code>arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}</code></p>
    /// </li></ul>
    public let uri: String?

    public init (
        cacheKeyParameters: [String]? = nil,
        cacheNamespace: String? = nil,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandling: ContentHandlingStrategy? = nil,
        credentials: String? = nil,
        httpMethod: String? = nil,
        integrationResponses: [String:IntegrationResponse]? = nil,
        passthroughBehavior: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        timeoutInMillis: Int = 0,
        tlsConfig: TlsConfig? = nil,
        type: IntegrationType? = nil,
        uri: String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct PutIntegrationOutputResponseBody: Equatable {
    public let type: IntegrationType?
    public let httpMethod: String?
    public let uri: String?
    public let connectionType: ConnectionType?
    public let connectionId: String?
    public let credentials: String?
    public let requestParameters: [String:String]?
    public let requestTemplates: [String:String]?
    public let passthroughBehavior: String?
    public let contentHandling: ContentHandlingStrategy?
    public let timeoutInMillis: Int
    public let cacheNamespace: String?
    public let cacheKeyParameters: [String]?
    public let integrationResponses: [String:IntegrationResponse]?
    public let tlsConfig: TlsConfig?
}

extension PutIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([String: IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [String:IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [String:IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

public struct PutIntegrationResponseInputBodyMiddleware: Middleware {
    public let id: String = "PutIntegrationResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIntegrationResponseInput>
    public typealias MOutput = OperationOutput<PutIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIntegrationResponseOutputError>
}

extension PutIntegrationResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutIntegrationResponseInput(contentHandling: \(String(describing: contentHandling)), httpMethod: \(String(describing: httpMethod)), resourceId: \(String(describing: resourceId)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), restApiId: \(String(describing: restApiId)), selectionPattern: \(String(describing: selectionPattern)), statusCode: \(String(describing: statusCode)))"}
}

extension PutIntegrationResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandling = contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtostring0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseTemplates)
            for (dictKey0, mapofstringtostring0) in responseTemplates {
                try responseTemplatesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let selectionPattern = selectionPattern {
            try encodeContainer.encode(selectionPattern, forKey: .selectionPattern)
        }
    }
}

public struct PutIntegrationResponseInputHeadersMiddleware: Middleware {
    public let id: String = "PutIntegrationResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIntegrationResponseInput>
    public typealias MOutput = OperationOutput<PutIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIntegrationResponseOutputError>
}

public struct PutIntegrationResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "PutIntegrationResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIntegrationResponseInput>
    public typealias MOutput = OperationOutput<PutIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIntegrationResponseOutputError>
}

/// <p>Represents a put integration response request.</p>
public struct PutIntegrationResponseInput: Equatable {
    /// <p>Specifies how to handle response payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p>
    ///     <ul>
    ///       <li><p><code>CONVERT_TO_BINARY</code>: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p></li>
    ///       <li><p><code>CONVERT_TO_TEXT</code>: Converts a response payload from a binary blob to a Base64-encoded string.</p></li>
    ///     </ul>
    ///     <p>If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.</p>
    public let contentHandling: ContentHandlingStrategy?
    /// <p>[Required] Specifies a put integration response request's HTTP method.</p>
    public let httpMethod: String?
    /// <p>[Required] Specifies a put integration response request's resource identifier.</p>
    public let resourceId: String?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the back end.
    ///             The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. The mapped non-static value must match the pattern of <code>integration.response.header.{name}</code> or <code>integration.response.body.{JSON-expression}</code>, where <code>name</code> must be a valid and unique response header name and <code>JSON-expression</code> a valid JSON expression without the <code>$</code> prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>Specifies a put integration response's templates.</p>
    public let responseTemplates: [String:String]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>Specifies the selection pattern of a put integration response.</p>
    public let selectionPattern: String?
    /// <p>[Required] Specifies the status code that is used to map the integration response to an existing <a>MethodResponse</a>.</p>
    public let statusCode: String?

    public init (
        contentHandling: ContentHandlingStrategy? = nil,
        httpMethod: String? = nil,
        resourceId: String? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        restApiId: String? = nil,
        selectionPattern: String? = nil,
        statusCode: String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.restApiId = restApiId
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct PutIntegrationResponseInputBody: Equatable {
    public let selectionPattern: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let contentHandling: ContentHandlingStrategy?
}

extension PutIntegrationResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

extension PutIntegrationResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutIntegrationResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutIntegrationResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutIntegrationResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutIntegrationResponseOutputResponse(contentHandling: \(String(describing: contentHandling)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), selectionPattern: \(String(describing: selectionPattern)), statusCode: \(String(describing: statusCode)))"}
}

extension PutIntegrationResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentHandling = output.contentHandling
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.selectionPattern = output.selectionPattern
            self.statusCode = output.statusCode
        } else {
            self.contentHandling = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.selectionPattern = nil
            self.statusCode = nil
        }
    }
}

/// <p>Represents an integration response. The status code must map to an existing <a>MethodResponse</a>, and parameters and templates can be used to transform the back-end response.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct PutIntegrationResponseOutputResponse: Equatable {
    /// <p>Specifies how to handle response payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p>
    ///     <ul>
    ///       <li><p><code>CONVERT_TO_BINARY</code>: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p></li>
    ///       <li><p><code>CONVERT_TO_TEXT</code>: Converts a response payload from a binary blob to a Base64-encoded string.</p></li>
    ///     </ul>
    ///     <p>If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.</p>
    public let contentHandling: ContentHandlingStrategy?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the back end.
    ///             The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. The mapped non-static value must match the pattern of <code>integration.response.header.{name}</code> or <code>integration.response.body.{JSON-expression}</code>, where <code>name</code> is a valid and unique response header name and <code>JSON-expression</code> is a valid JSON expression without the <code>$</code> prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>
    public let responseTemplates: [String:String]?
    /// <p>Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the <code>.+</code> regex to match error response. However, make sure that the error response does not contain any newline (<code>\n</code>) character in such cases. If the back end is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.</p>
    public let selectionPattern: String?
    /// <p>Specifies the status code that is used to map the integration response to an existing <a>MethodResponse</a>.</p>
    public let statusCode: String?

    public init (
        contentHandling: ContentHandlingStrategy? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        selectionPattern: String? = nil,
        statusCode: String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct PutIntegrationResponseOutputResponseBody: Equatable {
    public let statusCode: String?
    public let selectionPattern: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let contentHandling: ContentHandlingStrategy?
}

extension PutIntegrationResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

public struct PutMethodInputBodyMiddleware: Middleware {
    public let id: String = "PutMethodInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMethodInput>
    public typealias MOutput = OperationOutput<PutMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMethodOutputError>
}

extension PutMethodInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutMethodInput(apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), httpMethod: \(String(describing: httpMethod)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), requestValidatorId: \(String(describing: requestValidatorId)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)))"}
}

extension PutMethodInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if apiKeyRequired != false {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for listofstring0 in authorizationScopes {
                try authorizationScopesContainer.encode(listofstring0)
            }
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType, forKey: .authorizationType)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestModels)
            for (dictKey0, mapofstringtostring0) in requestModels {
                try requestModelsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestParameters)
            for (dictKey0, mapofstringtoboolean0) in requestParameters {
                try requestParametersContainer.encode(mapofstringtoboolean0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestValidatorId = requestValidatorId {
            try encodeContainer.encode(requestValidatorId, forKey: .requestValidatorId)
        }
    }
}

public struct PutMethodInputHeadersMiddleware: Middleware {
    public let id: String = "PutMethodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMethodInput>
    public typealias MOutput = OperationOutput<PutMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMethodOutputError>
}

public struct PutMethodInputQueryItemMiddleware: Middleware {
    public let id: String = "PutMethodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMethodInput>
    public typealias MOutput = OperationOutput<PutMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMethodOutputError>
}

/// <p>Request to add a method to an existing <a>Resource</a> resource.</p>
public struct PutMethodInput: Equatable {
    /// <p>Specifies whether the method required a valid <a>ApiKey</a>.</p>
    public let apiKeyRequired: Bool
    /// <p>A list of authorization scopes configured on the method. The scopes are used with a <code>COGNITO_USER_POOLS</code> authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    public let authorizationScopes: [String]?
    /// <p>[Required] The method's authorization type. Valid values are <code>NONE</code> for open access, <code>AWS_IAM</code> for using AWS IAM permissions, <code>CUSTOM</code> for using a custom authorizer, or <code>COGNITO_USER_POOLS</code> for using a Cognito user pool.</p>
    public let authorizationType: String?
    /// <p>Specifies the identifier of an <a>Authorizer</a> to use on this Method, if the type is CUSTOM or COGNITO_USER_POOLS. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    public let authorizerId: String?
    /// <p>[Required] Specifies the method request's HTTP method type.</p>
    public let httpMethod: String?
    /// <p>A human-friendly operation identifier for the method. For example, you can assign the <code>operationName</code> of <code>ListPets</code> for the <code>GET /pets</code> method in the <code>PetStore</code> example.</p>
    public let operationName: String?
    /// <p>Specifies the <a>Model</a> resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a <a>Model</a> name as the value.</p>
    public let requestModels: [String:String]?
    /// <p>A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key defines a method request parameter name matching the pattern of  <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (<code>true</code>) or optional (<code>false</code>).  The method request parameter names defined here are available in <a>Integration</a> to be mapped to integration request parameters or body-mapping templates.</p>
    public let requestParameters: [String:Bool]?
    /// <p>The identifier of a <a>RequestValidator</a> for validating the method request.</p>
    public let requestValidatorId: String?
    /// <p>[Required] The <a>Resource</a> identifier for the new <a>Method</a> resource.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        apiKeyRequired: Bool = false,
        authorizationScopes: [String]? = nil,
        authorizationType: String? = nil,
        authorizerId: String? = nil,
        httpMethod: String? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:Bool]? = nil,
        requestValidatorId: String? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct PutMethodInputBody: Equatable {
    public let authorizationType: String?
    public let authorizerId: String?
    public let apiKeyRequired: Bool
    public let operationName: String?
    public let requestParameters: [String:Bool]?
    public let requestModels: [String:String]?
    public let requestValidatorId: String?
    public let authorizationScopes: [String]?
}

extension PutMethodInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decode(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

extension PutMethodOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMethodOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutMethodOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMethodOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutMethodOutputResponse(apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), httpMethod: \(String(describing: httpMethod)), methodIntegration: \(String(describing: methodIntegration)), methodResponses: \(String(describing: methodResponses)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), requestValidatorId: \(String(describing: requestValidatorId)))"}
}

extension PutMethodOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutMethodOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.httpMethod = output.httpMethod
            self.methodIntegration = output.methodIntegration
            self.methodResponses = output.methodResponses
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.requestValidatorId = output.requestValidatorId
        } else {
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.httpMethod = nil
            self.methodIntegration = nil
            self.methodResponses = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.requestValidatorId = nil
        }
    }
}

/// <p>
///             Represents a client-facing interface by which the client calls the API to access back-end resources. A <b>Method</b> resource is
///             integrated with an <a>Integration</a> resource. Both consist of a request and one or more responses. The method request takes
///             the client input that is passed to the back end through the integration request. A method response returns the output from
///             the back end to the client through an integration response. A method request is embodied in a <b>Method</b> resource, whereas
///             an integration request is embodied in an <a>Integration</a> resource.  On the other hand, a method response is represented
///             by a <a>MethodResponse</a> resource, whereas an integration response is represented by an <a>IntegrationResponse</a> resource.
///         </p>
///         <div class="remarks">
///           <p></p>
///           <h4>Example: Retrive the GET method on a specified resource</h4>
///           <h5>Request</h5>
///           <p>The following example request retrieves the information about the GET method on an API resource (<code>3kzxbg5sa2</code>) of an API (<code>fugvjdxtri</code>). </p>
///           <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1
/// Content-Type: application/json
/// Host: apigateway.us-east-1.amazonaws.com
/// X-Amz-Date: 20160603T210259Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
///           <h5>Response</h5>
///           <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
///           <pre><code>{
///   "_links": {
///     "curies": [
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
///         "name": "integration",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
///         "name": "integrationresponse",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html",
///         "name": "method",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
///         "name": "methodresponse",
///         "templated": true
///       }
///     ],
///     "self": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET",
///       "name": "GET",
///       "title": "GET"
///     },
///     "integration:put": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///     },
///     "method:delete": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
///     },
///     "method:integration": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///     },
///     "method:responses": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///       "name": "200",
///       "title": "200"
///     },
///     "method:update": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
///     },
///     "methodresponse:put": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}",
///       "templated": true
///     }
///   },
///   "apiKeyRequired": true,
///   "authorizationType": "NONE",
///   "httpMethod": "GET",
///   "_embedded": {
///     "method:integration": {
///       "_links": {
///         "self": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integration:delete": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integration:responses": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
///           "name": "200",
///           "title": "200"
///         },
///         "integration:update": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integrationresponse:put": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}",
///           "templated": true
///         }
///       },
///       "cacheKeyParameters": [],
///       "cacheNamespace": "3kzxbg5sa2",
///       "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
///       "httpMethod": "POST",
///       "passthroughBehavior": "WHEN_NO_MATCH",
///       "requestParameters": {
///         "integration.request.header.Content-Type": "'application/x-amz-json-1.1'"
///       },
///       "requestTemplates": {
///         "application/json": "{\n}"
///       },
///       "type": "AWS",
///       "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams",
///       "_embedded": {
///         "integration:responses": {
///           "_links": {
///             "self": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
///               "name": "200",
///               "title": "200"
///             },
///             "integrationresponse:delete": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
///             },
///             "integrationresponse:update": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
///             }
///           },
///           "responseParameters": {
///             "method.response.header.Content-Type": "'application/xml'"
///           },
///           "responseTemplates": {
///             "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E\")"
///           },
///           "statusCode": "200"
///         }
///       }
///     },
///     "method:responses": {
///       "_links": {
///         "self": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///           "name": "200",
///           "title": "200"
///         },
///         "methodresponse:delete": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///         },
///         "methodresponse:update": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///         }
///       },
///       "responseModels": {
///         "application/json": "Empty"
///       },
///       "responseParameters": {
///         "method.response.header.Content-Type": false
///       },
///       "statusCode": "200"
///     }
///   }
/// }</code></pre>
///           <p>In the example above, the response template for the <code>200 OK</code> response maps the JSON output from the <code>ListStreams</code> action in the back end to an XML output. The mapping template is URL-encoded as <code>%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E</code> and the output is decoded using the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#util-templat-reference">$util.urlDecode()</a> helper function.</p>
///       </div>
///       <div class="seeAlso">
///         <a>MethodResponse</a>, <a>Integration</a>, <a>IntegrationResponse</a>, <a>Resource</a>,
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings.html">Set up an API's method</a>
///       </div>
public struct PutMethodOutputResponse: Equatable {
    /// <p>A boolean flag specifying whether a valid <a>ApiKey</a> is required to invoke this method.</p>
    public let apiKeyRequired: Bool?
    /// <p>A list of authorization scopes configured on the method. The scopes are used with a <code>COGNITO_USER_POOLS</code> authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    public let authorizationScopes: [String]?
    /// <p>The method's authorization type. Valid values are <code>NONE</code> for open access, <code>AWS_IAM</code> for using AWS IAM permissions, <code>CUSTOM</code> for using a custom authorizer, or <code>COGNITO_USER_POOLS</code> for using a Cognito user pool.</p>
    public let authorizationType: String?
    /// <p>The identifier of an <a>Authorizer</a> to use on this method. The <code>authorizationType</code> must be <code>CUSTOM</code>.</p>
    public let authorizerId: String?
    /// <p>The method's HTTP verb.</p>
    public let httpMethod: String?
    /// <p>Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.</p>
    ///       <div class="remarks">
    ///         <p></p>
    ///         <h4>Example: </h4>
    ///         <h5>Request</h5>
    ///         <p></p>
    ///         <pre><code>GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// Content-Length: 117
    /// X-Amz-Date: 20160613T213210Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": [
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
    ///         "name": "integration",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///         "name": "integrationresponse",
    ///         "templated": true
    ///       }
    ///     ],
    ///     "self": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integration:delete": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integration:responses": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200",
    ///       "name": "200",
    ///       "title": "200"
    ///     },
    ///     "integration:update": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integrationresponse:put": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/{status_code}",
    ///       "templated": true
    ///     }
    ///   },
    ///   "cacheKeyParameters": [],
    ///   "cacheNamespace": "0cjtch",
    ///   "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
    ///   "httpMethod": "POST",
    ///   "passthroughBehavior": "WHEN_NO_MATCH",
    ///   "requestTemplates": {
    ///     "application/json": "{\n    \"a\":  \"$input.params('operand1')\",\n    \"b\":  \"$input.params('operand2')\", \n    \"op\": \"$input.params('operator')\"   \n}"
    ///   },
    ///   "type": "AWS",
    ///   "uri": "arn:aws:apigateway:us-west-2:lambda:path//2015-03-31/functions/arn:aws:lambda:us-west-2:123456789012:function:Calc/invocations",
    ///   "_embedded": {
    ///     "integration:responses": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "integrationresponse:delete": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200"
    ///         },
    ///         "integrationresponse:update": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200"
    ///         }
    ///       },
    ///       "responseParameters": {
    ///         "method.response.header.operator": "integration.response.body.op",
    ///         "method.response.header.operand_2": "integration.response.body.b",
    ///         "method.response.header.operand_1": "integration.response.body.a"
    ///       },
    ///       "responseTemplates": {
    ///         "application/json": "#set($res = $input.path('$'))\n{\n    \"result\": \"$res.a, $res.b, $res.op => $res.c\",\n  \"a\" : \"$res.a\",\n  \"b\" : \"$res.b\",\n  \"op\" : \"$res.op\",\n  \"c\" : \"$res.c\"\n}"
    ///       },
    ///       "selectionPattern": "",
    ///       "statusCode": "200"
    ///     }
    ///   }
    /// }</code></pre>
    ///         <p></p>
    ///       </div>
    ///       <div class="seeAlso">
    ///         <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-integration.html">AWS CLI</a>
    ///       </div>
    public let methodIntegration: Integration?
    /// <p>Gets a method response associated with a given HTTP status code. </p>
    ///       <div class="remarks">
    ///         <p>The collection of method responses are encapsulated in a key-value map, where the key is a response's HTTP status code and the value is a <a>MethodResponse</a> resource that specifies the response returned to the caller from the back end through the integration response.</p>
    ///         <h4>Example: Get a 200 OK response of a GET method</h4>
    ///         <h5>Request</h5>
    ///         <p></p>
    ///         <pre><code>GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200 HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// Content-Length: 117
    /// X-Amz-Date: 20160613T215008Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": {
    ///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
    ///       "name": "methodresponse",
    ///       "templated": true
    ///     },
    ///     "self": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200",
    ///       "title": "200"
    ///     },
    ///     "methodresponse:delete": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200"
    ///     },
    ///     "methodresponse:update": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200"
    ///     }
    ///   },
    ///   "responseModels": {
    ///     "application/json": "Empty"
    ///   },
    ///   "responseParameters": {
    ///     "method.response.header.operator": false,
    ///     "method.response.header.operand_2": false,
    ///     "method.response.header.operand_1": false
    ///   },
    ///   "statusCode": "200"
    /// }</code></pre>
    ///         <p></p>
    ///       </div>
    ///       <div class="seeAlso">
    ///         <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-method-response.html">AWS CLI</a>
    ///       </div>
    public let methodResponses: [String:MethodResponse]?
    /// <p>A human-friendly operation identifier for the method. For example, you can assign the <code>operationName</code> of <code>ListPets</code> for the <code>GET /pets</code> method in the <code>PetStore</code> example.</p>
    public let operationName: String?
    /// <p>A key-value map specifying data schemas, represented by <a>Model</a> resources, (as the mapped value) of the request payloads of given content types (as the mapping key).</p>
    public let requestModels: [String:String]?
    /// <p>A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of  <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (<code>true</code>) or optional (<code>false</code>).  The method request parameter names defined here are available in <a>Integration</a> to be mapped to integration request parameters or templates.</p>
    public let requestParameters: [String:Bool]?
    /// <p>The identifier of a <a>RequestValidator</a> for request validation.</p>
    public let requestValidatorId: String?

    public init (
        apiKeyRequired: Bool? = nil,
        authorizationScopes: [String]? = nil,
        authorizationType: String? = nil,
        authorizerId: String? = nil,
        httpMethod: String? = nil,
        methodIntegration: Integration? = nil,
        methodResponses: [String:MethodResponse]? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:Bool]? = nil,
        requestValidatorId: String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

struct PutMethodOutputResponseBody: Equatable {
    public let httpMethod: String?
    public let authorizationType: String?
    public let authorizerId: String?
    public let apiKeyRequired: Bool?
    public let requestValidatorId: String?
    public let operationName: String?
    public let requestParameters: [String:Bool]?
    public let requestModels: [String:String]?
    public let methodResponses: [String:MethodResponse]?
    public let methodIntegration: Integration?
    public let authorizationScopes: [String]?
}

extension PutMethodOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([String: MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [String:MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [String:MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

public struct PutMethodResponseInputBodyMiddleware: Middleware {
    public let id: String = "PutMethodResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMethodResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMethodResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMethodResponseInput>
    public typealias MOutput = OperationOutput<PutMethodResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMethodResponseOutputError>
}

extension PutMethodResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutMethodResponseInput(httpMethod: \(String(describing: httpMethod)), resourceId: \(String(describing: resourceId)), responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), restApiId: \(String(describing: restApiId)), statusCode: \(String(describing: statusCode)))"}
}

extension PutMethodResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case responseModels
        case responseParameters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseModels)
            for (dictKey0, mapofstringtostring0) in responseModels {
                try responseModelsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtoboolean0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtoboolean0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct PutMethodResponseInputHeadersMiddleware: Middleware {
    public let id: String = "PutMethodResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMethodResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMethodResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMethodResponseInput>
    public typealias MOutput = OperationOutput<PutMethodResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMethodResponseOutputError>
}

public struct PutMethodResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "PutMethodResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMethodResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMethodResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMethodResponseInput>
    public typealias MOutput = OperationOutput<PutMethodResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMethodResponseOutputError>
}

/// <p>Request to add a <a>MethodResponse</a> to an existing <a>Method</a> resource.</p>
public struct PutMethodResponseInput: Equatable {
    /// <p>[Required] The HTTP verb of the <a>Method</a> resource.</p>
    public let httpMethod: String?
    /// <p>[Required] The <a>Resource</a> identifier for the <a>Method</a> resource.</p>
    public let resourceId: String?
    /// <p>Specifies the <a>Model</a> resources used for the response's content type. Response models are represented as a key/value map, with a content type as the key and a <a>Model</a> name as the value.</p>
    public let responseModels: [String:String]?
    /// <p>A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header name and the associated value is a Boolean flag indicating whether the method response parameter is required or not. The method response header names must match the pattern of <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. The response parameter names defined here are available in the integration response to be mapped from an integration response header expressed in <code>integration.response.header.{name}</code>, a static value enclosed within a pair of single quotes (e.g., <code>'application/json'</code>), or a JSON expression from the back-end response payload in the form of <code>integration.response.body.{JSON-expression}</code>, where <code>JSON-expression</code> is a valid JSON expression without the <code>$</code> prefix.)</p>
    public let responseParameters: [String:Bool]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The method response's status code.</p>
    public let statusCode: String?

    public init (
        httpMethod: String? = nil,
        resourceId: String? = nil,
        responseModels: [String:String]? = nil,
        responseParameters: [String:Bool]? = nil,
        restApiId: String? = nil,
        statusCode: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct PutMethodResponseInputBody: Equatable {
    public let responseParameters: [String:Bool]?
    public let responseModels: [String:String]?
}

extension PutMethodResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case responseModels
        case responseParameters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseParametersContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

extension PutMethodResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMethodResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutMethodResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMethodResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutMethodResponseOutputResponse(responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), statusCode: \(String(describing: statusCode)))"}
}

extension PutMethodResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutMethodResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.statusCode = output.statusCode
        } else {
            self.responseModels = nil
            self.responseParameters = nil
            self.statusCode = nil
        }
    }
}

/// <p>Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template. <!-- API Gateway sends back the status code to the caller as the HTTP status code. Parameters and models can be used to transform the response from the method's integration.--></p>
///         <div class="remarks">
///           <p></p>
///           <h4>Example: A <b>MethodResponse</b> instance of an API</h4>
///           <h5>Request</h5>
///           <p>The example request retrieves a <b>MethodResponse</b> of the 200 status code.</p>
///           <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200 HTTP/1.1
/// Content-Type: application/json
/// Host: apigateway.us-east-1.amazonaws.com
/// X-Amz-Date: 20160603T222952Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
///           <h5>Response</h5>
///           <p>The successful response returns <code>200 OK</code> status and a payload as follows:</p>
///           <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
///       "name": "methodresponse",
///       "templated": true
///     },
///     "self": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///       "title": "200"
///     },
///     "methodresponse:delete": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///     },
///     "methodresponse:update": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///     }
///   },
///   "responseModels": {
///     "application/json": "Empty"
///   },
///   "responseParameters": {
///     "method.response.header.Content-Type": false
///   },
///   "statusCode": "200"
/// }</code></pre>
///           <p></p>
///       </div>
///       <div class="seeAlso">
///         <a>Method</a>, <a>IntegrationResponse</a>, <a>Integration</a>
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct PutMethodResponseOutputResponse: Equatable {
    /// <p>Specifies the <a>Model</a> resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a <a>Model</a> name as the value.</p>
    public let responseModels: [String:String]?
    /// <p>A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's <a>IntegrationResponse</a>. The integration response data that can be mapped include an integration response header expressed in <code>integration.response.header.{name}</code>, a static value enclosed within a pair of single quotes (e.g., <code>'application/json'</code>), or a JSON expression from the back-end response payload in the form of <code>integration.response.body.{JSON-expression}</code>, where <code>JSON-expression</code> is a valid JSON expression without the <code>$</code> prefix.)</p>
    public let responseParameters: [String:Bool]?
    /// <p>The method response's status code.</p>
    public let statusCode: String?

    public init (
        responseModels: [String:String]? = nil,
        responseParameters: [String:Bool]? = nil,
        statusCode: String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

struct PutMethodResponseOutputResponseBody: Equatable {
    public let statusCode: String?
    public let responseParameters: [String:Bool]?
    public let responseModels: [String:String]?
}

extension PutMethodResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

public enum PutMode {
    case merge
    case overwrite
    case sdkUnknown(String)
}

extension PutMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PutMode] {
        return [
            .merge,
            .overwrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .merge: return "merge"
        case .overwrite: return "overwrite"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PutMode(rawValue: rawValue) ?? PutMode.sdkUnknown(rawValue)
    }
}

public struct PutRestApiInputBodyMiddleware: Middleware {
    public let id: String = "PutRestApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRestApiInput>
    public typealias MOutput = OperationOutput<PutRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRestApiOutputError>
}

extension PutRestApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRestApiInput(body: \(String(describing: body)), failOnWarnings: \(String(describing: failOnWarnings)), mode: \(String(describing: mode)), parameters: \(String(describing: parameters)), restApiId: \(String(describing: restApiId)))"}
}

extension PutRestApiInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

public struct PutRestApiInputHeadersMiddleware: Middleware {
    public let id: String = "PutRestApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRestApiInput>
    public typealias MOutput = OperationOutput<PutRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRestApiOutputError>
}

public struct PutRestApiInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRestApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let mode = input.operationInput.mode {
            let modeQueryItem = URLQueryItem(name: "mode".urlPercentEncoding(), value: String(mode.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(modeQueryItem)
        }
        let failOnWarningsQueryItem = URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: String(input.operationInput.failOnWarnings).urlPercentEncoding())
        input.builder.withQueryItem(failOnWarningsQueryItem)
        if let parameters = input.operationInput.parameters {
            let currentQueryItemNames = input.builder.currentQueryItems.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    input.builder.withQueryItem(queryItem)
                }
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRestApiInput>
    public typealias MOutput = OperationOutput<PutRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRestApiOutputError>
}

/// <p>A PUT request to update an existing API, with external API definitions specified as the request body.</p>
public struct PutRestApiInput: Equatable {
    /// <p>[Required] The PUT request body containing external API definitions. Currently, only OpenAPI definition JSON/YAML files are supported. The maximum size of the API definition file is 6MB.</p>
    public let body: Data?
    /// <p>A query parameter to indicate whether to rollback the API update (<code>true</code>) or not (<code>false</code>)
    ///             when a warning is encountered. The default value is <code>false</code>.</p>
    public let failOnWarnings: Bool
    /// <p>The <code>mode</code> query parameter to specify the update mode. Valid values are "merge" and "overwrite". By default,
    ///         the update mode is "merge".</p>
    public let mode: PutMode?
    /// <p>Custom header parameters as part of the request. For example, to exclude <a>DocumentationParts</a> from an imported API, set <code>ignore=documentation</code> as a <code>parameters</code> value, as in the AWS CLI command of <code>aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'</code>.</p>
    public let parameters: [String:String]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        body: Data? = nil,
        failOnWarnings: Bool = false,
        mode: PutMode? = nil,
        parameters: [String:String]? = nil,
        restApiId: String? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.mode = mode
        self.parameters = parameters
        self.restApiId = restApiId
    }
}

struct PutRestApiInputBody: Equatable {
    public let body: Data?
}

extension PutRestApiInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension PutRestApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRestApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRestApiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRestApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRestApiOutputResponse(apiKeySource: \(String(describing: apiKeySource)), binaryMediaTypes: \(String(describing: binaryMediaTypes)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), endpointConfiguration: \(String(describing: endpointConfiguration)), id: \(String(describing: id)), minimumCompressionSize: \(String(describing: minimumCompressionSize)), name: \(String(describing: name)), policy: \(String(describing: policy)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

extension PutRestApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRestApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// <p>Represents a REST API.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct PutRestApiOutputResponse: Equatable {
    /// <p>The source of the API key for metering requests according to a usage plan. Valid values are: <ul><li><code>HEADER</code> to read the API key from the <code>X-API-Key</code> header of a request. </li><li><code>AUTHORIZER</code> to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</li></ul></p>
    public let apiKeySource: ApiKeySourceType?
    /// <p>The list of binary media types supported by the <a>RestApi</a>. By default, the <a>RestApi</a> supports only UTF-8-encoded text payloads.</p>
    public let binaryMediaTypes: [String]?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The API's description.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default <code>execute-api</code> endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>The endpoint configuration of this <a>RestApi</a> showing the endpoint types of the API.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>The API's identifier. This identifier is unique across all of your APIs in API Gateway.</p>
    public let id: String?
    /// <p>A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.</p>
    public let minimumCompressionSize: Int?
    /// <p>The API's name.</p>
    public let name: String?
    /// <p>A stringified JSON policy document that applies to this RestApi regardless of the caller and <a>Method</a> configuration.</p>
    public let policy: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when <code>failonwarnings</code> is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiKeySource: ApiKeySourceType? = nil,
        binaryMediaTypes: [String]? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        endpointConfiguration: EndpointConfiguration? = nil,
        id: String? = nil,
        minimumCompressionSize: Int? = nil,
        name: String? = nil,
        policy: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct PutRestApiOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let createdDate: Date?
    public let version: String?
    public let warnings: [String]?
    public let binaryMediaTypes: [String]?
    public let minimumCompressionSize: Int?
    public let apiKeySource: ApiKeySourceType?
    public let endpointConfiguration: EndpointConfiguration?
    public let policy: String?
    public let tags: [String:String]?
    public let disableExecuteApiEndpoint: Bool
}

extension PutRestApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

public enum QuotaPeriodType {
    case day
    case month
    case week
    case sdkUnknown(String)
}

extension QuotaPeriodType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QuotaPeriodType] {
        return [
            .day,
            .month,
            .week,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .day: return "DAY"
        case .month: return "MONTH"
        case .week: return "WEEK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QuotaPeriodType(rawValue: rawValue) ?? QuotaPeriodType.sdkUnknown(rawValue)
    }
}

extension QuotaSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit
        case offset
        case period
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if offset != 0 {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if let period = period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let offsetDecoded = try containerValues.decode(Int.self, forKey: .offset)
        offset = offsetDecoded
        let periodDecoded = try containerValues.decodeIfPresent(QuotaPeriodType.self, forKey: .period)
        period = periodDecoded
    }
}

extension QuotaSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuotaSettings(limit: \(String(describing: limit)), offset: \(String(describing: offset)), period: \(String(describing: period)))"}
}

/// <p>Quotas configured for a usage plan.</p>
public struct QuotaSettings: Equatable {
    /// <p>The maximum number of requests that can be made in a given time period.</p>
    public let limit: Int
    /// <p>The day that a time period starts. For example, with a time period of <code>WEEK</code>, an offset of <code>0</code> starts on Sunday, and an offset of <code>1</code> starts on Monday.</p>
    public let offset: Int
    /// <p>The time period in which the limit applies. Valid values are "DAY", "WEEK" or "MONTH".</p>
    public let period: QuotaPeriodType?

    public init (
        limit: Int = 0,
        offset: Int = 0,
        period: QuotaPeriodType? = nil
    )
    {
        self.limit = limit
        self.offset = offset
        self.period = period
    }
}

extension RequestValidator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if validateRequestBody != false {
            try encodeContainer.encode(validateRequestBody, forKey: .validateRequestBody)
        }
        if validateRequestParameters != false {
            try encodeContainer.encode(validateRequestParameters, forKey: .validateRequestParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decode(Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decode(Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

extension RequestValidator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestValidator(id: \(String(describing: id)), name: \(String(describing: name)), validateRequestBody: \(String(describing: validateRequestBody)), validateRequestParameters: \(String(describing: validateRequestParameters)))"}
}

/// <p>A set of validation rules for incoming <a>Method</a> requests.</p>
///         <div class="remarks">
///           <p>In OpenAPI, a <a>RequestValidator</a> of an API is defined by the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.requestValidator.html">x-amazon-apigateway-request-validators.requestValidator</a> object. It the referenced using the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validator">x-amazon-apigateway-request-validator</a> property.</p>
///         </div>
///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html">Enable Basic Request Validation in API Gateway</a></div>
public struct RequestValidator: Equatable {
    /// <p>The identifier of this <a>RequestValidator</a>.</p>
    public let id: String?
    /// <p>The name of this <a>RequestValidator</a></p>
    public let name: String?
    /// <p>A Boolean flag to indicate whether to validate a request body according to the configured <a>Model</a> schema.</p>
    public let validateRequestBody: Bool
    /// <p>A Boolean flag to indicate whether to validate request parameters (<code>true</code>) or not (<code>false</code>).</p>
    public let validateRequestParameters: Bool

    public init (
        id: String? = nil,
        name: String? = nil,
        validateRequestBody: Bool = false,
        validateRequestParameters: Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parentId = parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let pathPart = pathPart {
            try encodeContainer.encode(pathPart, forKey: .pathPart)
        }
        if let resourceMethods = resourceMethods {
            var resourceMethodsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resourceMethods)
            for (dictKey0, mapofmethod0) in resourceMethods {
                try resourceMethodsContainer.encode(mapofmethod0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([String: Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [String:Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [String:Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(id: \(String(describing: id)), parentId: \(String(describing: parentId)), path: \(String(describing: path)), pathPart: \(String(describing: pathPart)), resourceMethods: \(String(describing: resourceMethods)))"}
}

/// <p>Represents an API resource.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct Resource: Equatable {
    /// <p>The resource's identifier.</p>
    public let id: String?
    /// <p>The parent resource's identifier.</p>
    public let parentId: String?
    /// <p>The full path for this resource.</p>
    public let path: String?
    /// <p>The last path segment for this resource.</p>
    public let pathPart: String?
    /// <p>Gets an API resource's method of a given HTTP verb.</p>
    ///       <div class="remarks">
    ///         <p>The resource methods are a map of methods indexed by methods' HTTP verbs enabled on the resource. This method map is included in the <code>200 OK</code> response of the <code>GET /restapis/{restapi_id}/resources/{resource_id}</code> or <code>GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods</code> request.</p>
    ///         <h4>Example: Get the GET method of an API resource</h4>
    ///         <h5>Request</h5>
    ///         <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// X-Amz-Date: 20170223T031827Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20170223/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": [
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
    ///         "name": "integration",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///         "name": "integrationresponse",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html",
    ///         "name": "method",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
    ///         "name": "methodresponse",
    ///         "templated": true
    ///       }
    ///     ],
    ///     "self": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET",
    ///       "name": "GET",
    ///       "title": "GET"
    ///     },
    ///     "integration:put": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///     },
    ///     "method:delete": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
    ///     },
    ///     "method:integration": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///     },
    ///     "method:responses": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
    ///       "name": "200",
    ///       "title": "200"
    ///     },
    ///     "method:update": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
    ///     },
    ///     "methodresponse:put": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}",
    ///       "templated": true
    ///     }
    ///   },
    ///   "apiKeyRequired": false,
    ///   "authorizationType": "NONE",
    ///   "httpMethod": "GET",
    ///   "_embedded": {
    ///     "method:integration": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integration:delete": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integration:responses": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "integration:update": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integrationresponse:put": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}",
    ///           "templated": true
    ///         }
    ///       },
    ///       "cacheKeyParameters": [],
    ///       "cacheNamespace": "3kzxbg5sa2",
    ///       "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
    ///       "httpMethod": "POST",
    ///       "passthroughBehavior": "WHEN_NO_MATCH",
    ///       "requestParameters": {
    ///         "integration.request.header.Content-Type": "'application/x-amz-json-1.1'"
    ///       },
    ///       "requestTemplates": {
    ///         "application/json": "{\n}"
    ///       },
    ///       "type": "AWS",
    ///       "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams",
    ///       "_embedded": {
    ///         "integration:responses": {
    ///           "_links": {
    ///             "self": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///               "name": "200",
    ///               "title": "200"
    ///             },
    ///             "integrationresponse:delete": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///             },
    ///             "integrationresponse:update": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///             }
    ///           },
    ///           "responseParameters": {
    ///             "method.response.header.Content-Type": "'application/xml'"
    ///           },
    ///           "responseTemplates": {
    ///             "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n"
    ///           },
    ///           "statusCode": "200"
    ///         }
    ///       }
    ///     },
    ///     "method:responses": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "methodresponse:delete": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
    ///         },
    ///         "methodresponse:update": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
    ///         }
    ///       },
    ///       "responseModels": {
    ///         "application/json": "Empty"
    ///       },
    ///       "responseParameters": {
    ///         "method.response.header.Content-Type": false
    ///       },
    ///       "statusCode": "200"
    ///     }
    ///   }
    /// }</code></pre>
    ///         <p>If the <code>OPTIONS</code> is enabled on the resource, you can follow the example here to get that method. Just replace the <code>GET</code> of the last path segment in the request URL with <code>OPTIONS</code>.</p>
    ///       </div>
    ///       <div class="seeAlso">
    ///       </div>
    public let resourceMethods: [String:Method]?

    public init (
        id: String? = nil,
        parentId: String? = nil,
        path: String? = nil,
        pathPart: String? = nil,
        resourceMethods: [String:Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

extension RestApi: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySource = apiKeySource {
            try encodeContainer.encode(apiKeySource.rawValue, forKey: .apiKeySource)
        }
        if let binaryMediaTypes = binaryMediaTypes {
            var binaryMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binaryMediaTypes)
            for listofstring0 in binaryMediaTypes {
                try binaryMediaTypesContainer.encode(listofstring0)
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableExecuteApiEndpoint != false {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let endpointConfiguration = endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let minimumCompressionSize = minimumCompressionSize {
            try encodeContainer.encode(minimumCompressionSize, forKey: .minimumCompressionSize)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let warnings = warnings {
            var warningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .warnings)
            for listofstring0 in warnings {
                try warningsContainer.encode(listofstring0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension RestApi: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestApi(apiKeySource: \(String(describing: apiKeySource)), binaryMediaTypes: \(String(describing: binaryMediaTypes)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), endpointConfiguration: \(String(describing: endpointConfiguration)), id: \(String(describing: id)), minimumCompressionSize: \(String(describing: minimumCompressionSize)), name: \(String(describing: name)), policy: \(String(describing: policy)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

/// <p>Represents a REST API.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct RestApi: Equatable {
    /// <p>The source of the API key for metering requests according to a usage plan. Valid values are: <ul><li><code>HEADER</code> to read the API key from the <code>X-API-Key</code> header of a request. </li><li><code>AUTHORIZER</code> to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</li></ul></p>
    public let apiKeySource: ApiKeySourceType?
    /// <p>The list of binary media types supported by the <a>RestApi</a>. By default, the <a>RestApi</a> supports only UTF-8-encoded text payloads.</p>
    public let binaryMediaTypes: [String]?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The API's description.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default <code>execute-api</code> endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>The endpoint configuration of this <a>RestApi</a> showing the endpoint types of the API.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>The API's identifier. This identifier is unique across all of your APIs in API Gateway.</p>
    public let id: String?
    /// <p>A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.</p>
    public let minimumCompressionSize: Int?
    /// <p>The API's name.</p>
    public let name: String?
    /// <p>A stringified JSON policy document that applies to this RestApi regardless of the caller and <a>Method</a> configuration.</p>
    public let policy: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when <code>failonwarnings</code> is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiKeySource: ApiKeySourceType? = nil,
        binaryMediaTypes: [String]? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        endpointConfiguration: EndpointConfiguration? = nil,
        id: String? = nil,
        minimumCompressionSize: Int? = nil,
        name: String? = nil,
        policy: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

extension SdkConfigurationProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue
        case description
        case friendlyName
        case name
        case `required` = "required"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let friendlyName = friendlyName {
            try encodeContainer.encode(friendlyName, forKey: .friendlyName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let friendlyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let requiredDecoded = try containerValues.decode(Bool.self, forKey: .required)
        `required` = requiredDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension SdkConfigurationProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SdkConfigurationProperty(defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), friendlyName: \(String(describing: friendlyName)), name: \(String(describing: name)), required: \(String(describing: `required`)))"}
}

/// <p>A configuration property of an SDK type.</p>
public struct SdkConfigurationProperty: Equatable {
    /// <p>A boolean flag of an <a>SdkType</a> configuration property to indicate if the associated SDK configuration property is required (<code>true</code>) or not (<code>false</code>).</p>
    public let `required`: Bool
    /// <p>The default value of an <a>SdkType</a> configuration property.</p>
    public let defaultValue: String?
    /// <p>The description of an <a>SdkType</a> configuration property.</p>
    public let description: String?
    /// <p>The user-friendly name of an <a>SdkType</a> configuration property.</p>
    public let friendlyName: String?
    /// <p>The name of a an <a>SdkType</a> configuration property.</p>
    public let name: String?

    public init (
        `required`: Bool = false,
        defaultValue: String? = nil,
        description: String? = nil,
        friendlyName: String? = nil,
        name: String? = nil
    )
    {
        self.`required` = `required`
        self.defaultValue = defaultValue
        self.description = description
        self.friendlyName = friendlyName
        self.name = name
    }
}

extension SdkType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationProperties
        case description
        case friendlyName
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationProperties = configurationProperties {
            var configurationPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationProperties)
            for listofsdkconfigurationproperty0 in configurationProperties {
                try configurationPropertiesContainer.encode(listofsdkconfigurationproperty0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let friendlyName = friendlyName {
            try encodeContainer.encode(friendlyName, forKey: .friendlyName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let friendlyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let configurationPropertiesContainer = try containerValues.decodeIfPresent([SdkConfigurationProperty?].self, forKey: .configurationProperties)
        var configurationPropertiesDecoded0:[SdkConfigurationProperty]? = nil
        if let configurationPropertiesContainer = configurationPropertiesContainer {
            configurationPropertiesDecoded0 = [SdkConfigurationProperty]()
            for structure0 in configurationPropertiesContainer {
                if let structure0 = structure0 {
                    configurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        configurationProperties = configurationPropertiesDecoded0
    }
}

extension SdkType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SdkType(configurationProperties: \(String(describing: configurationProperties)), description: \(String(describing: description)), friendlyName: \(String(describing: friendlyName)), id: \(String(describing: id)))"}
}

/// <p>A type of SDK that API Gateway can generate.</p>
public struct SdkType: Equatable {
    /// <p>A list of configuration properties of an <a>SdkType</a>.</p>
    public let configurationProperties: [SdkConfigurationProperty]?
    /// <p>The description of an <a>SdkType</a>.</p>
    public let description: String?
    /// <p>The user-friendly name of an <a>SdkType</a> instance.</p>
    public let friendlyName: String?
    /// <p>The identifier of an <a>SdkType</a> instance.</p>
    public let id: String?

    public init (
        configurationProperties: [SdkConfigurationProperty]? = nil,
        description: String? = nil,
        friendlyName: String? = nil,
        id: String? = nil
    )
    {
        self.configurationProperties = configurationProperties
        self.description = description
        self.friendlyName = friendlyName
        self.id = id
    }
}

public enum SecurityPolicy {
    case tls10
    case tls12
    case sdkUnknown(String)
}

extension SecurityPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SecurityPolicy] {
        return [
            .tls10,
            .tls12,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .tls10: return "TLS_1_0"
        case .tls12: return "TLS_1_2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SecurityPolicy(rawValue: rawValue) ?? SecurityPolicy.sdkUnknown(rawValue)
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested service is not available. For details see the accompanying error message. Retry after the specified time period.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var retryAfterSeconds: String?

    public init (
        message: String? = nil,
        retryAfterSeconds: String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Stage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if cacheClusterEnabled != false {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize.rawValue, forKey: .cacheClusterSize)
        }
        if let cacheClusterStatus = cacheClusterStatus {
            try encodeContainer.encode(cacheClusterStatus.rawValue, forKey: .cacheClusterStatus)
        }
        if let canarySettings = canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate.timeIntervalSince1970, forKey: .lastUpdatedDate)
        }
        if let methodSettings = methodSettings {
            var methodSettingsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .methodSettings)
            for (dictKey0, mapofmethodsettings0) in methodSettings {
                try methodSettingsContainer.encode(mapofmethodsettings0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if tracingEnabled != false {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .variables)
            for (dictKey0, mapofstringtostring0) in variables {
                try variablesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let webAclArn = webAclArn {
            try encodeContainer.encode(webAclArn, forKey: .webAclArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([String: MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [String:MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [String:MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension Stage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Stage(accessLogSettings: \(String(describing: accessLogSettings)), cacheClusterEnabled: \(String(describing: cacheClusterEnabled)), cacheClusterSize: \(String(describing: cacheClusterSize)), cacheClusterStatus: \(String(describing: cacheClusterStatus)), canarySettings: \(String(describing: canarySettings)), clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), documentationVersion: \(String(describing: documentationVersion)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), methodSettings: \(String(describing: methodSettings)), stageName: \(String(describing: stageName)), tags: \(String(describing: tags)), tracingEnabled: \(String(describing: tracingEnabled)), variables: \(String(describing: variables)), webAclArn: \(String(describing: webAclArn)))"}
}

/// <p>Represents a unique identifier for a version of a deployed <a>RestApi</a> that is callable by users.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html">Deploy an API</a>
///       </div>
public struct Stage: Equatable {
    /// <p>Settings for logging access in this stage.</p>
    public let accessLogSettings: AccessLogSettings?
    /// <p>Specifies whether a cache cluster is enabled for the stage.</p>
    public let cacheClusterEnabled: Bool
    /// <p>The size of the cache cluster for the stage, if enabled.</p>
    public let cacheClusterSize: CacheClusterSize?
    /// <p>The status of the cache cluster for the stage, if enabled.</p>
    public let cacheClusterStatus: CacheClusterStatus?
    /// <p>Settings for the canary deployment in this stage.</p>
    public let canarySettings: CanarySettings?
    /// <p>The identifier of a client certificate for an API stage.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the stage was created.</p>
    public let createdDate: Date?
    /// <p>The identifier of the <a>Deployment</a> that the stage points to.</p>
    public let deploymentId: String?
    /// <p>The stage's description.</p>
    public let description: String?
    /// <p>The version of the associated API documentation.</p>
    public let documentationVersion: String?
    /// <p>The timestamp when the stage last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>A map that defines the method settings for a <a>Stage</a> resource. Keys (designated as <code>/{method_setting_key</code> below) are method paths defined as <code>{resource_path}/{http_method}</code> for an individual method override, or <code>/\*/\*</code> for overriding all methods in the stage.  <!-- Any forward slash ("/") characters in the <code>resource_path</code> part must be encoded as "~1" as in, for example, <code>~1resource~1sub-resource/GET</code>.--></p>
    public let methodSettings: [String:MethodSetting]?
    /// <p>The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.</p>
    public let stageName: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>Specifies whether active tracing with X-ray is enabled for the <a>Stage</a>.</p>
    public let tracingEnabled: Bool
    /// <p>A map that defines the stage variables for a <a>Stage</a> resource. Variable names can
    ///           have alphanumeric and underscore characters, and the values must match <code>[A-Za-z0-9-._~:/?#&=,]+</code>.</p>
    public let variables: [String:String]?
    /// <p>The ARN of the WebAcl associated with the <a>Stage</a>.</p>
    public let webAclArn: String?

    public init (
        accessLogSettings: AccessLogSettings? = nil,
        cacheClusterEnabled: Bool = false,
        cacheClusterSize: CacheClusterSize? = nil,
        cacheClusterStatus: CacheClusterStatus? = nil,
        canarySettings: CanarySettings? = nil,
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        documentationVersion: String? = nil,
        lastUpdatedDate: Date? = nil,
        methodSettings: [String:MethodSetting]? = nil,
        stageName: String? = nil,
        tags: [String:String]? = nil,
        tracingEnabled: Bool = false,
        variables: [String:String]? = nil,
        webAclArn: String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

extension StageKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case restApiId
        case stageName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let restApiId = restApiId {
            try encodeContainer.encode(restApiId, forKey: .restApiId)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restApiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension StageKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StageKey(restApiId: \(String(describing: restApiId)), stageName: \(String(describing: stageName)))"}
}

/// <p>A reference to a unique stage identified in the format <code>{restApiId}/{stage}</code>.</p>
public struct StageKey: Equatable {
    /// <p>The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>The stage name associated with the stage key.</p>
    public let stageName: String?

    public init (
        restApiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p>Adds or updates a tag on a given resource.</p>
public struct TagResourceInput: Equatable {
    /// <p>[Required] The ARN of a resource that can be tagged.</p>
    public let resourceArn: String?
    /// <p>[Required] The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TestInvokeAuthorizerInputBodyMiddleware: Middleware {
    public let id: String = "TestInvokeAuthorizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestInvokeAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<TestInvokeAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestInvokeAuthorizerInput>
    public typealias MOutput = OperationOutput<TestInvokeAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestInvokeAuthorizerOutputError>
}

extension TestInvokeAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestInvokeAuthorizerInput(additionalContext: \(String(describing: additionalContext)), authorizerId: \(String(describing: authorizerId)), body: \(String(describing: body)), headers: \(String(describing: headers)), multiValueHeaders: \(String(describing: multiValueHeaders)), pathWithQueryString: \(String(describing: pathWithQueryString)), restApiId: \(String(describing: restApiId)), stageVariables: \(String(describing: stageVariables)))"}
}

extension TestInvokeAuthorizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalContext
        case body
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalContext = additionalContext {
            var additionalContextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .additionalContext)
            for (dictKey0, mapofstringtostring0) in additionalContext {
                try additionalContextContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .headers)
            for (dictKey0, mapofstringtostring0) in headers {
                try headersContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let multiValueHeaders = multiValueHeaders {
            var multiValueHeadersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .multiValueHeaders)
            for (dictKey0, mapofstringtolist0) in multiValueHeaders {
                try multiValueHeadersContainer.encode(mapofstringtolist0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let pathWithQueryString = pathWithQueryString {
            try encodeContainer.encode(pathWithQueryString, forKey: .pathWithQueryString)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stageVariables)
            for (dictKey0, mapofstringtostring0) in stageVariables {
                try stageVariablesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TestInvokeAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "TestInvokeAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestInvokeAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<TestInvokeAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestInvokeAuthorizerInput>
    public typealias MOutput = OperationOutput<TestInvokeAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestInvokeAuthorizerOutputError>
}

public struct TestInvokeAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "TestInvokeAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestInvokeAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<TestInvokeAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestInvokeAuthorizerInput>
    public typealias MOutput = OperationOutput<TestInvokeAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestInvokeAuthorizerOutputError>
}

/// <p>Make a request to simulate the execution of an <a>Authorizer</a>.</p>
public struct TestInvokeAuthorizerInput: Equatable {
    /// <p>[Optional] A key-value map of additional context variables.</p>
    public let additionalContext: [String:String]?
    /// <p>[Required] Specifies a test invoke authorizer request's <a>Authorizer</a> ID.</p>
    public let authorizerId: String?
    /// <p>[Optional] The simulated request body of an incoming invocation request.</p>
    public let body: String?
    /// <p>[Required] A key-value map of headers to simulate an incoming invocation request. This is where the incoming authorization token, or identity source, should be specified.</p>
    public let headers: [String:String]?
    /// <p>[Optional] The headers as a map from string to list of values to simulate an incoming invocation request. This is where the incoming authorization token, or identity source, may be specified.</p>
    public let multiValueHeaders: [String:[String]]?
    /// <p>[Optional] The URI path, including query string, of the simulated invocation request. Use this to specify path parameters and query string parameters.</p>
    public let pathWithQueryString: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>A key-value map of stage variables to simulate an invocation on a deployed <a>Stage</a>.</p>
    public let stageVariables: [String:String]?

    public init (
        additionalContext: [String:String]? = nil,
        authorizerId: String? = nil,
        body: String? = nil,
        headers: [String:String]? = nil,
        multiValueHeaders: [String:[String]]? = nil,
        pathWithQueryString: String? = nil,
        restApiId: String? = nil,
        stageVariables: [String:String]? = nil
    )
    {
        self.additionalContext = additionalContext
        self.authorizerId = authorizerId
        self.body = body
        self.headers = headers
        self.multiValueHeaders = multiValueHeaders
        self.pathWithQueryString = pathWithQueryString
        self.restApiId = restApiId
        self.stageVariables = stageVariables
    }
}

struct TestInvokeAuthorizerInputBody: Equatable {
    public let headers: [String:String]?
    public let multiValueHeaders: [String:[String]]?
    public let pathWithQueryString: String?
    public let body: String?
    public let stageVariables: [String:String]?
    public let additionalContext: [String:String]?
}

extension TestInvokeAuthorizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalContext
        case body
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .headers)
        var headersDecoded0: [String:String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [String:String]()
            for (key0, string0) in headersContainer {
                if let string0 = string0 {
                    headersDecoded0?[key0] = string0
                }
            }
        }
        headers = headersDecoded0
        let multiValueHeadersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .multiValueHeaders)
        var multiValueHeadersDecoded0: [String:[String]]? = nil
        if let multiValueHeadersContainer = multiValueHeadersContainer {
            multiValueHeadersDecoded0 = [String:[String]]()
            for (key0, listofstring0) in multiValueHeadersContainer {
                var listofstring0Decoded0: [String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                multiValueHeadersDecoded0?[key0] = listofstring0Decoded0
            }
        }
        multiValueHeaders = multiValueHeadersDecoded0
        let pathWithQueryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathWithQueryString)
        pathWithQueryString = pathWithQueryStringDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [String:String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [String:String]()
            for (key0, string0) in stageVariablesContainer {
                if let string0 = string0 {
                    stageVariablesDecoded0?[key0] = string0
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let additionalContextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .additionalContext)
        var additionalContextDecoded0: [String:String]? = nil
        if let additionalContextContainer = additionalContextContainer {
            additionalContextDecoded0 = [String:String]()
            for (key0, string0) in additionalContextContainer {
                if let string0 = string0 {
                    additionalContextDecoded0?[key0] = string0
                }
            }
        }
        additionalContext = additionalContextDecoded0
    }
}

extension TestInvokeAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestInvokeAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestInvokeAuthorizerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestInvokeAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestInvokeAuthorizerOutputResponse(authorization: \(String(describing: authorization)), claims: \(String(describing: claims)), clientStatus: \(String(describing: clientStatus)), latency: \(String(describing: latency)), log: \(String(describing: log)), policy: \(String(describing: policy)), principalId: \(String(describing: principalId)))"}
}

extension TestInvokeAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestInvokeAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorization = output.authorization
            self.claims = output.claims
            self.clientStatus = output.clientStatus
            self.latency = output.latency
            self.log = output.log
            self.policy = output.policy
            self.principalId = output.principalId
        } else {
            self.authorization = nil
            self.claims = nil
            self.clientStatus = 0
            self.latency = 0
            self.log = nil
            self.policy = nil
            self.principalId = nil
        }
    }
}

/// <p>Represents the response of the test invoke request for a custom <a>Authorizer</a></p>
public struct TestInvokeAuthorizerOutputResponse: Equatable {
    public let authorization: [String:[String]]?
    /// <p>The <a href="https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims">open identity claims</a>, with any supported custom attributes, returned from the Cognito Your User Pool configured for the API.</p>
    public let claims: [String:String]?
    /// <p>The HTTP status code that the client would have received. Value is 0 if the authorizer succeeded.</p>
    public let clientStatus: Int
    /// <p>The execution latency of the test authorizer request.</p>
    public let latency: Int
    /// <p>The API Gateway execution log for the test authorizer request.</p>
    public let log: String?
    /// <p>The JSON policy document returned by the <a>Authorizer</a></p>
    public let policy: String?
    /// <p>The principal identity returned by the <a>Authorizer</a></p>
    public let principalId: String?

    public init (
        authorization: [String:[String]]? = nil,
        claims: [String:String]? = nil,
        clientStatus: Int = 0,
        latency: Int = 0,
        log: String? = nil,
        policy: String? = nil,
        principalId: String? = nil
    )
    {
        self.authorization = authorization
        self.claims = claims
        self.clientStatus = clientStatus
        self.latency = latency
        self.log = log
        self.policy = policy
        self.principalId = principalId
    }
}

struct TestInvokeAuthorizerOutputResponseBody: Equatable {
    public let clientStatus: Int
    public let log: String?
    public let latency: Int
    public let principalId: String?
    public let policy: String?
    public let authorization: [String:[String]]?
    public let claims: [String:String]?
}

extension TestInvokeAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorization
        case claims
        case clientStatus
        case latency
        case log
        case policy
        case principalId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientStatusDecoded = try containerValues.decode(Int.self, forKey: .clientStatus)
        clientStatus = clientStatusDecoded
        let logDecoded = try containerValues.decodeIfPresent(String.self, forKey: .log)
        log = logDecoded
        let latencyDecoded = try containerValues.decode(Int.self, forKey: .latency)
        latency = latencyDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let authorizationContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .authorization)
        var authorizationDecoded0: [String:[String]]? = nil
        if let authorizationContainer = authorizationContainer {
            authorizationDecoded0 = [String:[String]]()
            for (key0, listofstring0) in authorizationContainer {
                var listofstring0Decoded0: [String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                authorizationDecoded0?[key0] = listofstring0Decoded0
            }
        }
        authorization = authorizationDecoded0
        let claimsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .claims)
        var claimsDecoded0: [String:String]? = nil
        if let claimsContainer = claimsContainer {
            claimsDecoded0 = [String:String]()
            for (key0, string0) in claimsContainer {
                if let string0 = string0 {
                    claimsDecoded0?[key0] = string0
                }
            }
        }
        claims = claimsDecoded0
    }
}

public struct TestInvokeMethodInputBodyMiddleware: Middleware {
    public let id: String = "TestInvokeMethodInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestInvokeMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<TestInvokeMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestInvokeMethodInput>
    public typealias MOutput = OperationOutput<TestInvokeMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestInvokeMethodOutputError>
}

extension TestInvokeMethodInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestInvokeMethodInput(body: \(String(describing: body)), clientCertificateId: \(String(describing: clientCertificateId)), headers: \(String(describing: headers)), httpMethod: \(String(describing: httpMethod)), multiValueHeaders: \(String(describing: multiValueHeaders)), pathWithQueryString: \(String(describing: pathWithQueryString)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)), stageVariables: \(String(describing: stageVariables)))"}
}

extension TestInvokeMethodInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body
        case clientCertificateId
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .headers)
            for (dictKey0, mapofstringtostring0) in headers {
                try headersContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let multiValueHeaders = multiValueHeaders {
            var multiValueHeadersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .multiValueHeaders)
            for (dictKey0, mapofstringtolist0) in multiValueHeaders {
                try multiValueHeadersContainer.encode(mapofstringtolist0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let pathWithQueryString = pathWithQueryString {
            try encodeContainer.encode(pathWithQueryString, forKey: .pathWithQueryString)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stageVariables)
            for (dictKey0, mapofstringtostring0) in stageVariables {
                try stageVariablesContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TestInvokeMethodInputHeadersMiddleware: Middleware {
    public let id: String = "TestInvokeMethodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestInvokeMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<TestInvokeMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestInvokeMethodInput>
    public typealias MOutput = OperationOutput<TestInvokeMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestInvokeMethodOutputError>
}

public struct TestInvokeMethodInputQueryItemMiddleware: Middleware {
    public let id: String = "TestInvokeMethodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestInvokeMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<TestInvokeMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestInvokeMethodInput>
    public typealias MOutput = OperationOutput<TestInvokeMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestInvokeMethodOutputError>
}

/// <p>Make a request to simulate the execution of a <a>Method</a>.</p>
public struct TestInvokeMethodInput: Equatable {
    /// <p>The simulated request body of an incoming invocation request.</p>
    public let body: String?
    /// <p>A <a>ClientCertificate</a> identifier to use in the test invocation. API Gateway will use the certificate when making the HTTPS request to the defined back-end endpoint.</p>
    public let clientCertificateId: String?
    /// <p>A key-value map of headers to simulate an incoming invocation request.</p>
    public let headers: [String:String]?
    /// <p>[Required] Specifies a test invoke method request's HTTP method.</p>
    public let httpMethod: String?
    /// <p>The headers as a map from string to list of values to simulate an incoming invocation request.</p>
    public let multiValueHeaders: [String:[String]]?
    /// <p>The URI path, including query string, of the simulated invocation request. Use this to specify path parameters and query string parameters.</p>
    public let pathWithQueryString: String?
    /// <p>[Required] Specifies a test invoke method request's resource ID.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>A key-value map of stage variables to simulate an invocation on a deployed <a>Stage</a>.</p>
    public let stageVariables: [String:String]?

    public init (
        body: String? = nil,
        clientCertificateId: String? = nil,
        headers: [String:String]? = nil,
        httpMethod: String? = nil,
        multiValueHeaders: [String:[String]]? = nil,
        pathWithQueryString: String? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil,
        stageVariables: [String:String]? = nil
    )
    {
        self.body = body
        self.clientCertificateId = clientCertificateId
        self.headers = headers
        self.httpMethod = httpMethod
        self.multiValueHeaders = multiValueHeaders
        self.pathWithQueryString = pathWithQueryString
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.stageVariables = stageVariables
    }
}

struct TestInvokeMethodInputBody: Equatable {
    public let pathWithQueryString: String?
    public let body: String?
    public let headers: [String:String]?
    public let multiValueHeaders: [String:[String]]?
    public let clientCertificateId: String?
    public let stageVariables: [String:String]?
}

extension TestInvokeMethodInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
        case clientCertificateId
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathWithQueryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathWithQueryString)
        pathWithQueryString = pathWithQueryStringDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let headersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .headers)
        var headersDecoded0: [String:String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [String:String]()
            for (key0, string0) in headersContainer {
                if let string0 = string0 {
                    headersDecoded0?[key0] = string0
                }
            }
        }
        headers = headersDecoded0
        let multiValueHeadersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .multiValueHeaders)
        var multiValueHeadersDecoded0: [String:[String]]? = nil
        if let multiValueHeadersContainer = multiValueHeadersContainer {
            multiValueHeadersDecoded0 = [String:[String]]()
            for (key0, listofstring0) in multiValueHeadersContainer {
                var listofstring0Decoded0: [String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                multiValueHeadersDecoded0?[key0] = listofstring0Decoded0
            }
        }
        multiValueHeaders = multiValueHeadersDecoded0
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [String:String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [String:String]()
            for (key0, string0) in stageVariablesContainer {
                if let string0 = string0 {
                    stageVariablesDecoded0?[key0] = string0
                }
            }
        }
        stageVariables = stageVariablesDecoded0
    }
}

extension TestInvokeMethodOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestInvokeMethodOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestInvokeMethodOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestInvokeMethodOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestInvokeMethodOutputResponse(body: \(String(describing: body)), headers: \(String(describing: headers)), latency: \(String(describing: latency)), log: \(String(describing: log)), multiValueHeaders: \(String(describing: multiValueHeaders)), status: \(String(describing: status)))"}
}

extension TestInvokeMethodOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestInvokeMethodOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.body = output.body
            self.headers = output.headers
            self.latency = output.latency
            self.log = output.log
            self.multiValueHeaders = output.multiValueHeaders
            self.status = output.status
        } else {
            self.body = nil
            self.headers = nil
            self.latency = 0
            self.log = nil
            self.multiValueHeaders = nil
            self.status = 0
        }
    }
}

/// <p>Represents the response of the test invoke request in the HTTP method.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-test-method.html#how-to-test-method-console">Test API using the API Gateway console</a>
///       </div>
public struct TestInvokeMethodOutputResponse: Equatable {
    /// <p>The body of the HTTP response.</p>
    public let body: String?
    /// <p>The headers of the HTTP response.</p>
    public let headers: [String:String]?
    /// <p>The execution latency of the test invoke request.</p>
    public let latency: Int
    /// <p>The API Gateway execution log for the test invoke request.</p>
    public let log: String?
    /// <p>The headers of the HTTP response as a map from string to list of values.</p>
    public let multiValueHeaders: [String:[String]]?
    /// <p>The HTTP status code.</p>
    public let status: Int

    public init (
        body: String? = nil,
        headers: [String:String]? = nil,
        latency: Int = 0,
        log: String? = nil,
        multiValueHeaders: [String:[String]]? = nil,
        status: Int = 0
    )
    {
        self.body = body
        self.headers = headers
        self.latency = latency
        self.log = log
        self.multiValueHeaders = multiValueHeaders
        self.status = status
    }
}

struct TestInvokeMethodOutputResponseBody: Equatable {
    public let status: Int
    public let body: String?
    public let headers: [String:String]?
    public let multiValueHeaders: [String:[String]]?
    public let log: String?
    public let latency: Int
}

extension TestInvokeMethodOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
        case headers
        case latency
        case log
        case multiValueHeaders
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let headersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .headers)
        var headersDecoded0: [String:String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [String:String]()
            for (key0, string0) in headersContainer {
                if let string0 = string0 {
                    headersDecoded0?[key0] = string0
                }
            }
        }
        headers = headersDecoded0
        let multiValueHeadersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .multiValueHeaders)
        var multiValueHeadersDecoded0: [String:[String]]? = nil
        if let multiValueHeadersContainer = multiValueHeadersContainer {
            multiValueHeadersDecoded0 = [String:[String]]()
            for (key0, listofstring0) in multiValueHeadersContainer {
                var listofstring0Decoded0: [String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                multiValueHeadersDecoded0?[key0] = listofstring0Decoded0
            }
        }
        multiValueHeaders = multiValueHeadersDecoded0
        let logDecoded = try containerValues.decodeIfPresent(String.self, forKey: .log)
        log = logDecoded
        let latencyDecoded = try containerValues.decode(Int.self, forKey: .latency)
        latency = latencyDecoded
    }
}

extension ThrottleSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case burstLimit
        case rateLimit
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if burstLimit != 0 {
            try encodeContainer.encode(burstLimit, forKey: .burstLimit)
        }
        if rateLimit != 0.0 {
            try encodeContainer.encode(rateLimit, forKey: .rateLimit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let burstLimitDecoded = try containerValues.decode(Int.self, forKey: .burstLimit)
        burstLimit = burstLimitDecoded
        let rateLimitDecoded = try containerValues.decode(Double.self, forKey: .rateLimit)
        rateLimit = rateLimitDecoded
    }
}

extension ThrottleSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottleSettings(burstLimit: \(String(describing: burstLimit)), rateLimit: \(String(describing: rateLimit)))"}
}

/// <p> The API request rate limits.</p>
public struct ThrottleSettings: Equatable {
    /// <p>The API request burst limit, the maximum rate limit over a time ranging from one to a few seconds, depending upon whether the underlying token bucket is at its full capacity.</p>
    public let burstLimit: Int
    /// <p>The API request steady-state rate limit.</p>
    public let rateLimit: Double

    public init (
        burstLimit: Int = 0,
        rateLimit: Double = 0.0
    )
    {
        self.burstLimit = burstLimit
        self.rateLimit = rateLimit
    }
}

extension TlsConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insecureSkipVerification
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if insecureSkipVerification != false {
            try encodeContainer.encode(insecureSkipVerification, forKey: .insecureSkipVerification)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insecureSkipVerificationDecoded = try containerValues.decode(Bool.self, forKey: .insecureSkipVerification)
        insecureSkipVerification = insecureSkipVerificationDecoded
    }
}

extension TlsConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TlsConfig(insecureSkipVerification: \(String(describing: insecureSkipVerification)))"}
}

public struct TlsConfig: Equatable {
    /// <p>Specifies whether or not API Gateway skips verification that the certificate for an integration endpoint is
    ///             issued by a <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-supported-certificate-authorities-for-http-endpoints.html">supported certificate authority</a>. This isn’t recommended, but it enables you to
    ///             use certificates that are signed by private certificate authorities, or certificates
    ///             that are self-signed. If enabled, API Gateway still performs basic certificate
    ///             validation, which includes checking the certificate's expiration date, hostname, and
    ///             presence of a root certificate authority. Supported only for <code>HTTP</code> and
    ///             <code>HTTP_PROXY</code> integrations.</p>
    public let insecureSkipVerification: Bool

    public init (
        insecureSkipVerification: Bool = false
    )
    {
        self.insecureSkipVerification = insecureSkipVerification
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has reached its throttling limit. Retry after the specified time period.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var retryAfterSeconds: String?

    public init (
        message: String? = nil,
        retryAfterSeconds: String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum UnauthorizedCacheControlHeaderStrategy {
    case failWith403
    case succeedWithoutResponseHeader
    case succeedWithResponseHeader
    case sdkUnknown(String)
}

extension UnauthorizedCacheControlHeaderStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UnauthorizedCacheControlHeaderStrategy] {
        return [
            .failWith403,
            .succeedWithoutResponseHeader,
            .succeedWithResponseHeader,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failWith403: return "FAIL_WITH_403"
        case .succeedWithoutResponseHeader: return "SUCCEED_WITHOUT_RESPONSE_HEADER"
        case .succeedWithResponseHeader: return "SUCCEED_WITH_RESPONSE_HEADER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UnauthorizedCacheControlHeaderStrategy(rawValue: rawValue) ?? UnauthorizedCacheControlHeaderStrategy.sdkUnknown(rawValue)
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is denied because the caller has insufficient permissions.</p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

/// <p>Removes a tag from a given resource.</p>
public struct UntagResourceInput: Equatable {
    /// <p>[Required] The ARN of a resource that can be tagged.</p>
    public let resourceArn: String?
    /// <p>[Required] The Tag keys to delete.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAccountInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountInput>
    public typealias MOutput = OperationOutput<UpdateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountOutputError>
}

extension UpdateAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountInput(patchOperations: \(String(describing: patchOperations)))"}
}

extension UpdateAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateAccountInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountInput>
    public typealias MOutput = OperationOutput<UpdateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountOutputError>
}

public struct UpdateAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountInput>
    public typealias MOutput = OperationOutput<UpdateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountOutputError>
}

/// <p>Requests API Gateway to change information about the current <a>Account</a> resource.</p>
public struct UpdateAccountInput: Equatable {
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?

    public init (
        patchOperations: [PatchOperation]? = nil
    )
    {
        self.patchOperations = patchOperations
    }
}

struct UpdateAccountInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountOutputResponse(apiKeyVersion: \(String(describing: apiKeyVersion)), cloudwatchRoleArn: \(String(describing: cloudwatchRoleArn)), features: \(String(describing: features)), throttleSettings: \(String(describing: throttleSettings)))"}
}

extension UpdateAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeyVersion = output.apiKeyVersion
            self.cloudwatchRoleArn = output.cloudwatchRoleArn
            self.features = output.features
            self.throttleSettings = output.throttleSettings
        } else {
            self.apiKeyVersion = nil
            self.cloudwatchRoleArn = nil
            self.features = nil
            self.throttleSettings = nil
        }
    }
}

/// <p>Represents an AWS account that is associated with API Gateway.</p>
///         <div class="remarks">
///           <p>To view the account info, call <code>GET</code> on this resource.</p>
///           <h4>Error Codes</h4>
///           <p>The following exception may be thrown when the request fails.</p>
///           <ul>
///             <li>UnauthorizedException</li>
///             <li>NotFoundException</li>
///             <li>TooManyRequestsException</li>
///           </ul>
///           <p>For detailed error code information, including the corresponding HTTP Status Codes, see <a href="https://docs.aws.amazon.com/apigateway/api-reference/handling-errors/#api-error-codes">API Gateway Error Codes</a></p>
///             <h4>Example: Get the information about an account.</h4>
///             <h5>Request</h5>
///             <pre><code>GET /account HTTP/1.1
/// Content-Type: application/json
/// Host: apigateway.us-east-1.amazonaws.com
/// X-Amz-Date: 20160531T184618Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
///             </code></pre>
///             <h5>Response</h5>
///             <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
///             <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/account-apigateway-{rel}.html",
///       "name": "account",
///       "templated": true
///     },
///     "self": {
///       "href": "/account"
///     },
///     "account:update": {
///       "href": "/account"
///     }
///   },
///   "cloudwatchRoleArn": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
///   "throttleSettings": {
///     "rateLimit": 500,
///     "burstLimit": 1000
///   }
/// }
///             </code></pre>
///             <p>In addition to making the REST API call directly, you can use the AWS CLI and an AWS SDK to access this resource.</p>
///         </div>
///         <div class="seeAlso">
///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-limits.html">API Gateway Limits</a>
///             <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html">Developer Guide</a>,
///             <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-account.html">AWS CLI</a>
///         </div>
public struct UpdateAccountOutputResponse: Equatable {
    /// <p>The version of the API keys used for the account.</p>
    public let apiKeyVersion: String?
    /// <p>The ARN of an Amazon CloudWatch role for the current <a>Account</a>. </p>
    public let cloudwatchRoleArn: String?
    /// <p>A list of features supported for the account. When usage plans are enabled, the features list will include an entry of <code>"UsagePlans"</code>.</p>
    public let features: [String]?
    /// <p>Specifies the API request limits configured for the current <a>Account</a>.</p>
    public let throttleSettings: ThrottleSettings?

    public init (
        apiKeyVersion: String? = nil,
        cloudwatchRoleArn: String? = nil,
        features: [String]? = nil,
        throttleSettings: ThrottleSettings? = nil
    )
    {
        self.apiKeyVersion = apiKeyVersion
        self.cloudwatchRoleArn = cloudwatchRoleArn
        self.features = features
        self.throttleSettings = throttleSettings
    }
}

struct UpdateAccountOutputResponseBody: Equatable {
    public let cloudwatchRoleArn: String?
    public let throttleSettings: ThrottleSettings?
    public let features: [String]?
    public let apiKeyVersion: String?
}

extension UpdateAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeyVersion
        case cloudwatchRoleArn
        case features
        case throttleSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudwatchRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudwatchRoleArn)
        cloudwatchRoleArn = cloudwatchRoleArnDecoded
        let throttleSettingsDecoded = try containerValues.decodeIfPresent(ThrottleSettings.self, forKey: .throttleSettings)
        throttleSettings = throttleSettingsDecoded
        let featuresContainer = try containerValues.decodeIfPresent([String?].self, forKey: .features)
        var featuresDecoded0:[String]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [String]()
            for string0 in featuresContainer {
                if let string0 = string0 {
                    featuresDecoded0?.append(string0)
                }
            }
        }
        features = featuresDecoded0
        let apiKeyVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeyVersion)
        apiKeyVersion = apiKeyVersionDecoded
    }
}

public struct UpdateApiKeyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApiKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiKeyInput>
    public typealias MOutput = OperationOutput<UpdateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiKeyOutputError>
}

extension UpdateApiKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiKeyInput(apiKey: \(String(describing: apiKey)), patchOperations: \(String(describing: patchOperations)))"}
}

extension UpdateApiKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateApiKeyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApiKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiKeyInput>
    public typealias MOutput = OperationOutput<UpdateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiKeyOutputError>
}

public struct UpdateApiKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApiKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiKeyInput>
    public typealias MOutput = OperationOutput<UpdateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiKeyOutputError>
}

/// <p>A request to change information about an <a>ApiKey</a> resource.</p>
public struct UpdateApiKeyInput: Equatable {
    /// <p>[Required] The identifier of the <a>ApiKey</a> resource to be updated.</p>
    public let apiKey: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?

    public init (
        apiKey: String? = nil,
        patchOperations: [PatchOperation]? = nil
    )
    {
        self.apiKey = apiKey
        self.patchOperations = patchOperations
    }
}

struct UpdateApiKeyInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateApiKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateApiKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiKeyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiKeyOutputResponse(createdDate: \(String(describing: createdDate)), customerId: \(String(describing: customerId)), description: \(String(describing: description)), enabled: \(String(describing: enabled)), id: \(String(describing: id)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), name: \(String(describing: name)), stageKeys: \(String(describing: stageKeys)), tags: \(String(describing: tags)), value: \(String(describing: value)))"}
}

extension UpdateApiKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdDate = output.createdDate
            self.customerId = output.customerId
            self.description = output.description
            self.enabled = output.enabled
            self.id = output.id
            self.lastUpdatedDate = output.lastUpdatedDate
            self.name = output.name
            self.stageKeys = output.stageKeys
            self.tags = output.tags
            self.value = output.value
        } else {
            self.createdDate = nil
            self.customerId = nil
            self.description = nil
            self.enabled = false
            self.id = nil
            self.lastUpdatedDate = nil
            self.name = nil
            self.stageKeys = nil
            self.tags = nil
            self.value = nil
        }
    }
}

/// <p>A resource that can be distributed to callers for executing <a>Method</a> resources that require an API key. API keys can be mapped to any <a>Stage</a> on any <a>RestApi</a>, which indicates that the callers with the API key can make requests to that stage.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html">Use API Keys</a>
///       </div>
public struct UpdateApiKeyOutputResponse: Equatable {
    /// <p>The timestamp when the API Key was created.</p>
    public let createdDate: Date?
    /// <p>An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.</p>
    public let customerId: String?
    /// <p>The description of the API Key.</p>
    public let description: String?
    /// <p>Specifies whether the API Key can be used by callers.</p>
    public let enabled: Bool
    /// <p>The identifier of the API Key.</p>
    public let id: String?
    /// <p>The timestamp when the API Key was last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>The name of the API Key.</p>
    public let name: String?
    /// <p>A list of <a>Stage</a> resources that are associated with the <a>ApiKey</a> resource.</p>
    public let stageKeys: [String]?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The value of the API Key.</p>
    public let value: String?

    public init (
        createdDate: Date? = nil,
        customerId: String? = nil,
        description: String? = nil,
        enabled: Bool = false,
        id: String? = nil,
        lastUpdatedDate: Date? = nil,
        name: String? = nil,
        stageKeys: [String]? = nil,
        tags: [String:String]? = nil,
        value: String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct UpdateApiKeyOutputResponseBody: Equatable {
    public let id: String?
    public let value: String?
    public let name: String?
    public let customerId: String?
    public let description: String?
    public let enabled: Bool
    public let createdDate: Date?
    public let lastUpdatedDate: Date?
    public let stageKeys: [String]?
    public let tags: [String:String]?
}

extension UpdateApiKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateAuthorizerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAuthorizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthorizerInput>
    public typealias MOutput = OperationOutput<UpdateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthorizerOutputError>
}

extension UpdateAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuthorizerInput(authorizerId: \(String(describing: authorizerId)), patchOperations: \(String(describing: patchOperations)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateAuthorizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthorizerInput>
    public typealias MOutput = OperationOutput<UpdateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthorizerOutputError>
}

public struct UpdateAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthorizerInput>
    public typealias MOutput = OperationOutput<UpdateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthorizerOutputError>
}

/// <p>Request to update an existing <a>Authorizer</a> resource.</p>
public struct UpdateAuthorizerInput: Equatable {
    /// <p>[Required] The identifier of the <a>Authorizer</a> resource.</p>
    public let authorizerId: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        authorizerId: String? = nil,
        patchOperations: [PatchOperation]? = nil,
        restApiId: String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateAuthorizerInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateAuthorizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAuthorizerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuthorizerOutputResponse(authType: \(String(describing: authType)), authorizerCredentials: \(String(describing: authorizerCredentials)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerUri: \(String(describing: authorizerUri)), id: \(String(describing: id)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), name: \(String(describing: name)), providerARNs: \(String(describing: providerARNs)), type: \(String(describing: type)))"}
}

extension UpdateAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authType = output.authType
            self.authorizerCredentials = output.authorizerCredentials
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerUri = output.authorizerUri
            self.id = output.id
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.name = output.name
            self.providerARNs = output.providerARNs
            self.type = output.type
        } else {
            self.authType = nil
            self.authorizerCredentials = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerUri = nil
            self.id = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.name = nil
            self.providerARNs = nil
            self.type = nil
        }
    }
}

/// <p>Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html">Use Lambda Function as Authorizer</a>
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html">Use Cognito User Pool as Authorizer</a>
///       </div>
public struct UpdateAuthorizerOutputResponse: Equatable {
    /// <p>Optional customer-defined field, used in OpenAPI imports and exports without functional impact.</p>
    public let authType: String?
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.</p>
    public let authorizerCredentials: String?
    /// <p>The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.</p>
    public let authorizerResultTtlInSeconds: Int?
    /// <p>Specifies the authorizer's Uniform Resource Identifier (URI). For <code>TOKEN</code> or <code>REQUEST</code> authorizers, this must be a well-formed Lambda function URI, for example, <code>arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations</code>. In general, the URI has this form  <code>arn:aws:apigateway:{region}:lambda:path/{service_api}</code>, where <code>{region}</code> is the same as the region hosting the Lambda function, <code>path</code> indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial <code>/</code>. For Lambda functions, this is usually of the form <code>/2015-03-31/functions/[FunctionARN]/invocations</code>.</p>
    public let authorizerUri: String?
    /// <p>The identifier for the authorizer resource.</p>
    public let id: String?
    /// <p>The identity source for which authorization is requested. <ul><li>For a <code>TOKEN</code> or <code>COGNITO_USER_POOLS</code> authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is <code>Auth</code>, the header mapping expression is  <code>method.request.header.Auth</code>.</li><li>For the <code>REQUEST</code> authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an <code>Auth</code> header, a <code>Name</code> query string parameter are defined as identity sources, this value is <code>method.request.header.Auth, method.request.querystring.Name</code>.  These parameters will be used to derive the authorization caching key and to perform runtime validation of the <code>REQUEST</code> authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.</li></ul></p>
    public let identitySource: String?
    /// <p>A validation expression for the incoming identity token. For <code>TOKEN</code> authorizers, this value is a regular expression. For <code>COGNITO_USER_POOLS</code> authorizers, API Gateway will match the <code>aud</code> field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the <code>REQUEST</code> authorizer.</p>
    public let identityValidationExpression: String?
    /// <p>[Required] The name of the authorizer.</p>
    public let name: String?
    /// <p>A list of the Amazon Cognito user pool ARNs for the <code>COGNITO_USER_POOLS</code> authorizer. Each element is of this format: <code>arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}</code>. For a <code>TOKEN</code> or <code>REQUEST</code> authorizer, this is not defined.</p>
    public let providerARNs: [String]?
    /// <p>The authorizer type. Valid values are <code>TOKEN</code> for a Lambda function using a single authorization token submitted in a custom header, <code>REQUEST</code> for a Lambda function using incoming request parameters, and <code>COGNITO_USER_POOLS</code> for using an Amazon Cognito user pool.</p>
    public let type: AuthorizerType?

    public init (
        authType: String? = nil,
        authorizerCredentials: String? = nil,
        authorizerResultTtlInSeconds: Int? = nil,
        authorizerUri: String? = nil,
        id: String? = nil,
        identitySource: String? = nil,
        identityValidationExpression: String? = nil,
        name: String? = nil,
        providerARNs: [String]? = nil,
        type: AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

struct UpdateAuthorizerOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let type: AuthorizerType?
    public let providerARNs: [String]?
    public let authType: String?
    public let authorizerUri: String?
    public let authorizerCredentials: String?
    public let identitySource: String?
    public let identityValidationExpression: String?
    public let authorizerResultTtlInSeconds: Int?
}

extension UpdateAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

public struct UpdateBasePathMappingInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBasePathMappingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBasePathMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBasePathMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBasePathMappingInput>
    public typealias MOutput = OperationOutput<UpdateBasePathMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBasePathMappingOutputError>
}

extension UpdateBasePathMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBasePathMappingInput(basePath: \(String(describing: basePath)), domainName: \(String(describing: domainName)), patchOperations: \(String(describing: patchOperations)))"}
}

extension UpdateBasePathMappingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateBasePathMappingInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBasePathMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBasePathMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBasePathMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBasePathMappingInput>
    public typealias MOutput = OperationOutput<UpdateBasePathMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBasePathMappingOutputError>
}

public struct UpdateBasePathMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBasePathMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBasePathMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBasePathMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBasePathMappingInput>
    public typealias MOutput = OperationOutput<UpdateBasePathMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBasePathMappingOutputError>
}

/// <p>A request to change information about the <a>BasePathMapping</a> resource.</p>
public struct UpdateBasePathMappingInput: Equatable {
    /// <p>[Required] The base path of the <a>BasePathMapping</a> resource to change.</p>
    ///         <p>To specify an empty base path, set this parameter to <code>'(none)'</code>.</p>
    public let basePath: String?
    /// <p>[Required] The domain name of the <a>BasePathMapping</a> resource to change.</p>
    public let domainName: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?

    public init (
        basePath: String? = nil,
        domainName: String? = nil,
        patchOperations: [PatchOperation]? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
        self.patchOperations = patchOperations
    }
}

struct UpdateBasePathMappingInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateBasePathMappingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateBasePathMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBasePathMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBasePathMappingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBasePathMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBasePathMappingOutputResponse(basePath: \(String(describing: basePath)), restApiId: \(String(describing: restApiId)), stage: \(String(describing: stage)))"}
}

extension UpdateBasePathMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBasePathMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.basePath = output.basePath
            self.restApiId = output.restApiId
            self.stage = output.stage
        } else {
            self.basePath = nil
            self.restApiId = nil
            self.stage = nil
        }
    }
}

/// <p>Represents the base path that callers of the API must provide as part of the URL after the domain name.</p>
///         <div class="remarks">A custom domain name plus a <code>BasePathMapping</code> specification identifies a deployed <a>RestApi</a> in a given stage of the owner <a>Account</a>.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">Use Custom Domain Names</a>
///       </div>
public struct UpdateBasePathMappingOutputResponse: Equatable {
    /// <p>The base path name that callers of the API must provide as part of the URL after the domain name.</p>
    public let basePath: String?
    /// <p>The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>The name of the associated stage.</p>
    public let stage: String?

    public init (
        basePath: String? = nil,
        restApiId: String? = nil,
        stage: String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct UpdateBasePathMappingOutputResponseBody: Equatable {
    public let basePath: String?
    public let restApiId: String?
    public let stage: String?
}

extension UpdateBasePathMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

public struct UpdateClientCertificateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateClientCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClientCertificateInput>
    public typealias MOutput = OperationOutput<UpdateClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClientCertificateOutputError>
}

extension UpdateClientCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClientCertificateInput(clientCertificateId: \(String(describing: clientCertificateId)), patchOperations: \(String(describing: patchOperations)))"}
}

extension UpdateClientCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateClientCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateClientCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClientCertificateInput>
    public typealias MOutput = OperationOutput<UpdateClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClientCertificateOutputError>
}

public struct UpdateClientCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateClientCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClientCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClientCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClientCertificateInput>
    public typealias MOutput = OperationOutput<UpdateClientCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClientCertificateOutputError>
}

/// <p>A request to change information about an <a>ClientCertificate</a> resource.</p>
public struct UpdateClientCertificateInput: Equatable {
    /// <p>[Required] The identifier of the <a>ClientCertificate</a> resource to be updated.</p>
    public let clientCertificateId: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?

    public init (
        clientCertificateId: String? = nil,
        patchOperations: [PatchOperation]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.patchOperations = patchOperations
    }
}

struct UpdateClientCertificateInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateClientCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateClientCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClientCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClientCertificateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClientCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClientCertificateOutputResponse(clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), expirationDate: \(String(describing: expirationDate)), pemEncodedCertificate: \(String(describing: pemEncodedCertificate)), tags: \(String(describing: tags)))"}
}

extension UpdateClientCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateClientCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.pemEncodedCertificate = output.pemEncodedCertificate
            self.tags = output.tags
        } else {
            self.clientCertificateId = nil
            self.createdDate = nil
            self.description = nil
            self.expirationDate = nil
            self.pemEncodedCertificate = nil
            self.tags = nil
        }
    }
}

/// <p>Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.</p>
///         <div class="remarks">Client certificates are used to authenticate an API by the backend server. To authenticate an API client (or user), use IAM roles and policies, a custom <a>Authorizer</a> or an Amazon Cognito user pool.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html">Use Client-Side Certificate</a>
///       </div>
public struct UpdateClientCertificateOutputResponse: Equatable {
    /// <p>The identifier of the client certificate.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the client certificate was created.</p>
    public let createdDate: Date?
    /// <p>The description of the client certificate.</p>
    public let description: String?
    /// <p>The timestamp when the client certificate will expire.</p>
    public let expirationDate: Date?
    /// <p>The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .</p>
    public let pemEncodedCertificate: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        expirationDate: Date? = nil,
        pemEncodedCertificate: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

struct UpdateClientCertificateOutputResponseBody: Equatable {
    public let clientCertificateId: String?
    public let description: String?
    public let pemEncodedCertificate: String?
    public let createdDate: Date?
    public let expirationDate: Date?
    public let tags: [String:String]?
}

extension UpdateClientCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeploymentInput>
    public typealias MOutput = OperationOutput<UpdateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeploymentOutputError>
}

extension UpdateDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeploymentInput(deploymentId: \(String(describing: deploymentId)), patchOperations: \(String(describing: patchOperations)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeploymentInput>
    public typealias MOutput = OperationOutput<UpdateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeploymentOutputError>
}

public struct UpdateDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeploymentInput>
    public typealias MOutput = OperationOutput<UpdateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeploymentOutputError>
}

/// <p>Requests API Gateway to change information about a <a>Deployment</a> resource.</p>
public struct UpdateDeploymentInput: Equatable {
    /// <p>The replacement identifier for the <a>Deployment</a> resource to change information about.</p>
    public let deploymentId: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        deploymentId: String? = nil,
        patchOperations: [PatchOperation]? = nil,
        restApiId: String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateDeploymentInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeploymentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeploymentOutputResponse(apiSummary: \(String(describing: apiSummary)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), id: \(String(describing: id)))"}
}

extension UpdateDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiSummary = output.apiSummary
            self.createdDate = output.createdDate
            self.description = output.description
            self.id = output.id
        } else {
            self.apiSummary = nil
            self.createdDate = nil
            self.description = nil
            self.id = nil
        }
    }
}

/// <p>An immutable representation of a <a>RestApi</a> resource that can be called by users using <a>Stages</a>. A deployment must be associated with a <a>Stage</a> for it to be callable over the Internet.</p>
///         <div class="remarks">To create a deployment, call <code>POST</code> on the <a>Deployments</a> resource of a <a>RestApi</a>.
///             To view, update, or delete a deployment, call <code>GET</code>, <code>PATCH</code>, or <code>DELETE</code> on the specified deployment resource (<code>/restapis/{restapi_id}/deployments/{deployment_id}</code>).</div>
///         <div class="seeAlso"><a>RestApi</a>, <a>Deployments</a>, <a>Stage</a>,
///             <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html">AWS CLI</a>,
///             <a href="https://aws.amazon.com/tools/">AWS SDKs</a>
///         </div>
public struct UpdateDeploymentOutputResponse: Equatable {
    /// <p>A summary of the <a>RestApi</a> at the date and time that the deployment resource was created.</p>
    public let apiSummary: [String:[String:MethodSnapshot]]?
    /// <p>The date and time that the deployment resource was created.</p>
    public let createdDate: Date?
    /// <p>The description for the deployment resource.</p>
    public let description: String?
    /// <p>The identifier for the deployment resource.</p>
    public let id: String?

    public init (
        apiSummary: [String:[String:MethodSnapshot]]? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        id: String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

struct UpdateDeploymentOutputResponseBody: Equatable {
    public let id: String?
    public let description: String?
    public let createdDate: Date?
    public let apiSummary: [String:[String:MethodSnapshot]]?
}

extension UpdateDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([String: [String: MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [String:[String:MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [String:[String:MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [String: MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [String: MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

public struct UpdateDocumentationPartInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDocumentationPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentationPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentationPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentationPartInput>
    public typealias MOutput = OperationOutput<UpdateDocumentationPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentationPartOutputError>
}

extension UpdateDocumentationPartInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentationPartInput(documentationPartId: \(String(describing: documentationPartId)), patchOperations: \(String(describing: patchOperations)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateDocumentationPartInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateDocumentationPartInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDocumentationPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentationPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentationPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentationPartInput>
    public typealias MOutput = OperationOutput<UpdateDocumentationPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentationPartOutputError>
}

public struct UpdateDocumentationPartInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDocumentationPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentationPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentationPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentationPartInput>
    public typealias MOutput = OperationOutput<UpdateDocumentationPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentationPartOutputError>
}

/// <p>Updates an existing documentation part of a given API.</p>
public struct UpdateDocumentationPartInput: Equatable {
    /// <p>[Required] The identifier of the to-be-updated documentation part.</p>
    public let documentationPartId: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        documentationPartId: String? = nil,
        patchOperations: [PatchOperation]? = nil,
        restApiId: String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateDocumentationPartInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateDocumentationPartInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDocumentationPartOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentationPartOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentationPartOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentationPartOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentationPartOutputResponse(id: \(String(describing: id)), location: \(String(describing: location)), properties: \(String(describing: properties)))"}
}

extension UpdateDocumentationPartOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDocumentationPartOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.location = output.location
            self.properties = output.properties
        } else {
            self.id = nil
            self.location = nil
            self.properties = nil
        }
    }
}

/// <p>A documentation part for a targeted API entity.</p>
///     <div class="remarks">
///       <p>A documentation part consists of a content map (<code>properties</code>) and a target (<code>location</code>). The target specifies an API entity to which the documentation content applies. The supported API entity types are <code>API</code>, <code>AUTHORIZER</code>, <code>MODEL</code>, <code>RESOURCE</code>, <code>METHOD</code>, <code>PATH_PARAMETER</code>, <code>QUERY_PARAMETER</code>, <code>REQUEST_HEADER</code>, <code>REQUEST_BODY</code>, <code>RESPONSE</code>, <code>RESPONSE_HEADER</code>, and <code>RESPONSE_BODY</code>. Valid <code>location</code> fields depend on the API entity type. All valid fields are not required.</p>
///       <p>The content map is a JSON string of API-specific key-value pairs. Although an API can use any shape for the content map, only the OpenAPI-compliant documentation fields will be injected into the associated API entity definition in the exported OpenAPI definition file.</p></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a>DocumentationParts</a>
///     </div>
public struct UpdateDocumentationPartOutputResponse: Equatable {
    /// <p>The <a>DocumentationPart</a> identifier, generated by API Gateway when the <code>DocumentationPart</code> is created.</p>
    public let id: String?
    /// <p>The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.</p>
    public let location: DocumentationPartLocation?
    /// <p>A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., <code>"{ \"description\": \"The API does ...\" }"</code>.  Only OpenAPI-compliant documentation-related fields from the <literal>properties</literal> map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of <code>x-amazon-apigateway-documentation</code>.</p>
    public let properties: String?

    public init (
        id: String? = nil,
        location: DocumentationPartLocation? = nil,
        properties: String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

struct UpdateDocumentationPartOutputResponseBody: Equatable {
    public let id: String?
    public let location: DocumentationPartLocation?
    public let properties: String?
}

extension UpdateDocumentationPartOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case location
        case properties
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

public struct UpdateDocumentationVersionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDocumentationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentationVersionInput>
    public typealias MOutput = OperationOutput<UpdateDocumentationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentationVersionOutputError>
}

extension UpdateDocumentationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentationVersionInput(documentationVersion: \(String(describing: documentationVersion)), patchOperations: \(String(describing: patchOperations)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateDocumentationVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateDocumentationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDocumentationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentationVersionInput>
    public typealias MOutput = OperationOutput<UpdateDocumentationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentationVersionOutputError>
}

public struct UpdateDocumentationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDocumentationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentationVersionInput>
    public typealias MOutput = OperationOutput<UpdateDocumentationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentationVersionOutputError>
}

/// <p>Updates an existing documentation version of an API.</p>
public struct UpdateDocumentationVersionInput: Equatable {
    /// <p>[Required] The version identifier of the to-be-updated documentation version.</p>
    public let documentationVersion: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>..</p>
    public let restApiId: String?

    public init (
        documentationVersion: String? = nil,
        patchOperations: [PatchOperation]? = nil,
        restApiId: String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateDocumentationVersionInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateDocumentationVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDocumentationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentationVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentationVersionOutputResponse(createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), version: \(String(describing: version)))"}
}

extension UpdateDocumentationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDocumentationVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdDate = output.createdDate
            self.description = output.description
            self.version = output.version
        } else {
            self.createdDate = nil
            self.description = nil
            self.version = nil
        }
    }
}

/// <p>A snapshot of the documentation of an API.</p>
///     <div class="remarks"><p>Publishing API documentation involves creating a documentation version associated with an API stage and exporting the versioned documentation to an external (e.g., OpenAPI) file.</p></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html">Documenting an API</a>, <a>DocumentationPart</a>, <a>DocumentationVersions</a>
///     </div>
public struct UpdateDocumentationVersionOutputResponse: Equatable {
    /// <p>The date when the API documentation snapshot is created.</p>
    public let createdDate: Date?
    /// <p>The description of the API documentation snapshot.</p>
    public let description: String?
    /// <p>The version identifier of the API documentation snapshot.</p>
    public let version: String?

    public init (
        createdDate: Date? = nil,
        description: String? = nil,
        version: String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

struct UpdateDocumentationVersionOutputResponseBody: Equatable {
    public let version: String?
    public let createdDate: Date?
    public let description: String?
}

extension UpdateDocumentationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdDate
        case description
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct UpdateDomainNameInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDomainNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainNameInput>
    public typealias MOutput = OperationOutput<UpdateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainNameOutputError>
}

extension UpdateDomainNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainNameInput(domainName: \(String(describing: domainName)), patchOperations: \(String(describing: patchOperations)))"}
}

extension UpdateDomainNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateDomainNameInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDomainNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainNameInput>
    public typealias MOutput = OperationOutput<UpdateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainNameOutputError>
}

public struct UpdateDomainNameInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDomainNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainNameInput>
    public typealias MOutput = OperationOutput<UpdateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainNameOutputError>
}

/// <p>A request to change information about the <a>DomainName</a> resource.</p>
public struct UpdateDomainNameInput: Equatable {
    /// <p>[Required] The name of the <a>DomainName</a> resource to be changed.</p>
    public let domainName: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?

    public init (
        domainName: String? = nil,
        patchOperations: [PatchOperation]? = nil
    )
    {
        self.domainName = domainName
        self.patchOperations = patchOperations
    }
}

struct UpdateDomainNameInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateDomainNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDomainNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainNameOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainNameOutputResponse(certificateArn: \(String(describing: certificateArn)), certificateName: \(String(describing: certificateName)), certificateUploadDate: \(String(describing: certificateUploadDate)), distributionDomainName: \(String(describing: distributionDomainName)), distributionHostedZoneId: \(String(describing: distributionHostedZoneId)), domainName: \(String(describing: domainName)), domainNameStatus: \(String(describing: domainNameStatus)), domainNameStatusMessage: \(String(describing: domainNameStatusMessage)), endpointConfiguration: \(String(describing: endpointConfiguration)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)), regionalCertificateArn: \(String(describing: regionalCertificateArn)), regionalCertificateName: \(String(describing: regionalCertificateName)), regionalDomainName: \(String(describing: regionalDomainName)), regionalHostedZoneId: \(String(describing: regionalHostedZoneId)), securityPolicy: \(String(describing: securityPolicy)), tags: \(String(describing: tags)))"}
}

extension UpdateDomainNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateArn = output.certificateArn
            self.certificateName = output.certificateName
            self.certificateUploadDate = output.certificateUploadDate
            self.distributionDomainName = output.distributionDomainName
            self.distributionHostedZoneId = output.distributionHostedZoneId
            self.domainName = output.domainName
            self.domainNameStatus = output.domainNameStatus
            self.domainNameStatusMessage = output.domainNameStatusMessage
            self.endpointConfiguration = output.endpointConfiguration
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.regionalCertificateArn = output.regionalCertificateArn
            self.regionalCertificateName = output.regionalCertificateName
            self.regionalDomainName = output.regionalDomainName
            self.regionalHostedZoneId = output.regionalHostedZoneId
            self.securityPolicy = output.securityPolicy
            self.tags = output.tags
        } else {
            self.certificateArn = nil
            self.certificateName = nil
            self.certificateUploadDate = nil
            self.distributionDomainName = nil
            self.distributionHostedZoneId = nil
            self.domainName = nil
            self.domainNameStatus = nil
            self.domainNameStatusMessage = nil
            self.endpointConfiguration = nil
            self.mutualTlsAuthentication = nil
            self.regionalCertificateArn = nil
            self.regionalCertificateName = nil
            self.regionalDomainName = nil
            self.regionalHostedZoneId = nil
            self.securityPolicy = nil
            self.tags = nil
        }
    }
}

/// <p>Represents a custom domain name as a user-friendly host name of an API (<a>RestApi</a>).</p>
///         <div class="Remarks">
///             <p>When you deploy an API, API Gateway creates a default host name for the API. This default API host name is of the <code>{restapi-id}.execute-api.{region}.amazonaws.com</code> format. With the default host name, you can access the API's root resource with the URL of <code>https://{restapi-id}.execute-api.{region}.amazonaws.com/{stage}/</code>. When you set up a custom domain name of <code>apis.example.com</code> for this API, you can then access the same resource using the URL of the <code>https://apis.examples.com/myApi</code>, where <code>myApi</code> is the base path mapping (<a>BasePathMapping</a>) of your API under the custom domain name.
///             </p>
///         </div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">Set a Custom Host Name for an API</a>
///       </div>
public struct UpdateDomainNameOutputResponse: Equatable {
    /// <p>The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.</p>
    public let certificateArn: String?
    /// <p>The name of the certificate that will be used by edge-optimized endpoint for this domain name.</p>
    public let certificateName: String?
    /// <p>The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.</p>
    public let certificateUploadDate: Date?
    /// <p>The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the <a target="_blank" href="https://aws.amazon.com/documentation/cloudfront/">Amazon CloudFront documentation</a>.</p>
    public let distributionDomainName: String?
    /// <p>The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is <code>Z2FDTNDATAQYW2</code> for all the regions. For more information, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html">Set up a Regional Custom Domain Name</a> and <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region">AWS Regions and Endpoints for API Gateway</a>. </p>
    public let distributionHostedZoneId: String?
    /// <p>The custom domain name as an API host name, for example, <code>my-api.example.com</code>.</p>
    public let domainName: String?
    /// <p>The status of the <a>DomainName</a> migration. The valid values are <code>AVAILABLE</code> and <code>UPDATING</code>. If the status is <code>UPDATING</code>, the domain cannot be modified further until the existing operation is complete. If it is <code>AVAILABLE</code>, the domain can be updated.</p>
    public let domainNameStatus: DomainNameStatus?
    /// <p>An optional text message containing detailed information about status of the <a>DomainName</a> migration.</p>
    public let domainNameStatusMessage: String?
    /// <p>The endpoint configuration of this <a>DomainName</a> showing the endpoint types of the domain name.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.</p>
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    /// <p>The reference to an AWS-managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.</p>
    public let regionalCertificateArn: String?
    /// <p>The name of the certificate that will be used for validating the regional domain name.</p>
    public let regionalCertificateName: String?
    /// <p>The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.</p>
    public let regionalDomainName: String?
    /// <p>The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html">Set up a Regional Custom Domain Name</a> and  <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region">AWS Regions and Endpoints for API Gateway</a>. </p>
    public let regionalHostedZoneId: String?
    /// <p>The Transport Layer Security (TLS) version + cipher suite for this <a>DomainName</a>. The valid values are <code>TLS_1_0</code> and <code>TLS_1_2</code>.</p>
    public let securityPolicy: SecurityPolicy?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        certificateArn: String? = nil,
        certificateName: String? = nil,
        certificateUploadDate: Date? = nil,
        distributionDomainName: String? = nil,
        distributionHostedZoneId: String? = nil,
        domainName: String? = nil,
        domainNameStatus: DomainNameStatus? = nil,
        domainNameStatusMessage: String? = nil,
        endpointConfiguration: EndpointConfiguration? = nil,
        mutualTlsAuthentication: MutualTlsAuthentication? = nil,
        regionalCertificateArn: String? = nil,
        regionalCertificateName: String? = nil,
        regionalDomainName: String? = nil,
        regionalHostedZoneId: String? = nil,
        securityPolicy: SecurityPolicy? = nil,
        tags: [String:String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct UpdateDomainNameOutputResponseBody: Equatable {
    public let domainName: String?
    public let certificateName: String?
    public let certificateArn: String?
    public let certificateUploadDate: Date?
    public let regionalDomainName: String?
    public let regionalHostedZoneId: String?
    public let regionalCertificateName: String?
    public let regionalCertificateArn: String?
    public let distributionDomainName: String?
    public let distributionHostedZoneId: String?
    public let endpointConfiguration: EndpointConfiguration?
    public let domainNameStatus: DomainNameStatus?
    public let domainNameStatusMessage: String?
    public let securityPolicy: SecurityPolicy?
    public let tags: [String:String]?
    public let mutualTlsAuthentication: MutualTlsAuthentication?
}

extension UpdateDomainNameOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
    }
}

public struct UpdateGatewayResponseInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGatewayResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayResponseInput>
    public typealias MOutput = OperationOutput<UpdateGatewayResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayResponseOutputError>
}

extension UpdateGatewayResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayResponseInput(patchOperations: \(String(describing: patchOperations)), responseType: \(String(describing: responseType)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateGatewayResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateGatewayResponseInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGatewayResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayResponseInput>
    public typealias MOutput = OperationOutput<UpdateGatewayResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayResponseOutputError>
}

public struct UpdateGatewayResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGatewayResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayResponseInput>
    public typealias MOutput = OperationOutput<UpdateGatewayResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayResponseOutputError>
}

/// <p>Updates a <a>GatewayResponse</a> of a specified response type on the given <a>RestApi</a>.</p>
public struct UpdateGatewayResponseInput: Equatable {
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] <p>The response type of the associated <a>GatewayResponse</a>. Valid values are <ul><li>ACCESS_DENIED</li><li>API_CONFIGURATION_ERROR</li><li>AUTHORIZER_FAILURE</li><li> AUTHORIZER_CONFIGURATION_ERROR</li><li>BAD_REQUEST_PARAMETERS</li><li>BAD_REQUEST_BODY</li><li>DEFAULT_4XX</li><li>DEFAULT_5XX</li><li>EXPIRED_TOKEN</li><li>INVALID_SIGNATURE</li><li>INTEGRATION_FAILURE</li><li>INTEGRATION_TIMEOUT</li><li>INVALID_API_KEY</li><li>MISSING_AUTHENTICATION_TOKEN</li><li> QUOTA_EXCEEDED</li><li>REQUEST_TOO_LARGE</li><li>RESOURCE_NOT_FOUND</li><li>THROTTLED</li><li>UNAUTHORIZED</li><li>UNSUPPORTED_MEDIA_TYPE</li></ul> </p></p>
    public let responseType: GatewayResponseType?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        patchOperations: [PatchOperation]? = nil,
        responseType: GatewayResponseType? = nil,
        restApiId: String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

struct UpdateGatewayResponseInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateGatewayResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateGatewayResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayResponseOutputResponse(defaultResponse: \(String(describing: defaultResponse)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), responseType: \(String(describing: responseType)), statusCode: \(String(describing: statusCode)))"}
}

extension UpdateGatewayResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGatewayResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.defaultResponse = output.defaultResponse
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.responseType = output.responseType
            self.statusCode = output.statusCode
        } else {
            self.defaultResponse = false
            self.responseParameters = nil
            self.responseTemplates = nil
            self.responseType = nil
            self.statusCode = nil
        }
    }
}

/// <p>A gateway response of a given response type and status code, with optional response parameters and mapping templates.</p>
///         <div class="remarks">
///             For more information about valid gateway response types, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html">Gateway Response Types Supported by API Gateway</a>
///             <div class="example">
///     <h4>Example: Get a Gateway Response of a given response type</h4>
///     <h5>Request</h5>
///     <p>This example shows how to get a gateway response of the <code>MISSING_AUTHENTICATION_TOKEN</code> type.</p>
///     <pre><code>GET /restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN HTTP/1.1
/// Host: beta-apigateway.us-east-1.amazonaws.com
/// Content-Type: application/json
/// X-Amz-Date: 20170503T202516Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=1b52460e3159c1a26cff29093855d50ea141c1c5b937528fecaf60f51129697a
/// Cache-Control: no-cache
/// Postman-Token: 3b2a1ce9-c848-2e26-2e2f-9c2caefbed45
/// </code></pre>
///     <p>The response type is specified as a URL path.</p>
///     <h5>Response</h5>
///     <p>The successful operation returns the <code>200 OK</code> status code and a payload similar to the following:</p>
///     <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html",
///       "name": "gatewayresponse",
///       "templated": true
///     },
///     "self": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     },
///     "gatewayresponse:delete": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     },
///     "gatewayresponse:put": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
///       "templated": true
///     },
///     "gatewayresponse:update": {
///       "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
///     }
///   },
///   "defaultResponse": false,
///   "responseParameters": {
///     "gatewayresponse.header.x-request-path": "method.request.path.petId",
///     "gatewayresponse.header.Access-Control-Allow-Origin": "'a.b.c'",
///     "gatewayresponse.header.x-request-query": "method.request.querystring.q",
///     "gatewayresponse.header.x-request-header": "method.request.header.Accept"
///   },
///   "responseTemplates": {
///     "application/json": "{\n     \"message\": $context.error.messageString,\n     \"type\":  \"$context.error.responseType\",\n     \"stage\":  \"$context.stage\",\n     \"resourcePath\":  \"$context.resourcePath\",\n     \"stageVariables.a\":  \"$stageVariables.a\",\n     \"statusCode\": \"'404'\"\n}"
///   },
///   "responseType": "MISSING_AUTHENTICATION_TOKEN",
///   "statusCode": "404"
/// }</code></pre>
///     <p></p>
///   </div>
///         </div>
///         <div class="seeAlso">
///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html">Customize Gateway Responses</a>
///         </div>
public struct UpdateGatewayResponseOutputResponse: Equatable {
    /// <p>A Boolean flag to indicate whether this <a>GatewayResponse</a> is the default gateway response (<code>true</code>) or not (<code>false</code>). A default gateway response is one generated by API Gateway without any customization by an API developer. </p>
    public let defaultResponse: Bool
    /// <p>Response parameters (paths, query strings and headers) of the <a>GatewayResponse</a> as a string-to-string map of key-value  pairs.</p>
    public let responseParameters: [String:String]?
    /// <p>Response templates of the <a>GatewayResponse</a> as a string-to-string map of key-value pairs.</p>
    public let responseTemplates: [String:String]?
    /// <p>The response type of the associated <a>GatewayResponse</a>. Valid values are <ul><li>ACCESS_DENIED</li><li>API_CONFIGURATION_ERROR</li><li>AUTHORIZER_FAILURE</li><li> AUTHORIZER_CONFIGURATION_ERROR</li><li>BAD_REQUEST_PARAMETERS</li><li>BAD_REQUEST_BODY</li><li>DEFAULT_4XX</li><li>DEFAULT_5XX</li><li>EXPIRED_TOKEN</li><li>INVALID_SIGNATURE</li><li>INTEGRATION_FAILURE</li><li>INTEGRATION_TIMEOUT</li><li>INVALID_API_KEY</li><li>MISSING_AUTHENTICATION_TOKEN</li><li> QUOTA_EXCEEDED</li><li>REQUEST_TOO_LARGE</li><li>RESOURCE_NOT_FOUND</li><li>THROTTLED</li><li>UNAUTHORIZED</li><li>UNSUPPORTED_MEDIA_TYPE</li></ul> </p>
    public let responseType: GatewayResponseType?
    /// <p>The HTTP status code for this <a>GatewayResponse</a>.</p>
    public let statusCode: String?

    public init (
        defaultResponse: Bool = false,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        responseType: GatewayResponseType? = nil,
        statusCode: String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

struct UpdateGatewayResponseOutputResponseBody: Equatable {
    public let responseType: GatewayResponseType?
    public let statusCode: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let defaultResponse: Bool
}

extension UpdateGatewayResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decode(Bool.self, forKey: .defaultResponse)
        defaultResponse = defaultResponseDecoded
    }
}

public struct UpdateIntegrationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIntegrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationOutputError>
}

extension UpdateIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIntegrationInput(httpMethod: \(String(describing: httpMethod)), patchOperations: \(String(describing: patchOperations)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateIntegrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationOutputError>
}

public struct UpdateIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationOutputError>
}

/// <p>Represents an update integration request.</p>
public struct UpdateIntegrationInput: Equatable {
    /// <p>[Required] Represents an update integration request's HTTP method.</p>
    public let httpMethod: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] Represents an update integration request's resource identifier.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        httpMethod: String? = nil,
        patchOperations: [PatchOperation]? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct UpdateIntegrationInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateIntegrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIntegrationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIntegrationOutputResponse(cacheKeyParameters: \(String(describing: cacheKeyParameters)), cacheNamespace: \(String(describing: cacheNamespace)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandling: \(String(describing: contentHandling)), credentials: \(String(describing: credentials)), httpMethod: \(String(describing: httpMethod)), integrationResponses: \(String(describing: integrationResponses)), passthroughBehavior: \(String(describing: passthroughBehavior)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)), type: \(String(describing: type)), uri: \(String(describing: uri)))"}
}

extension UpdateIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cacheKeyParameters = output.cacheKeyParameters
            self.cacheNamespace = output.cacheNamespace
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandling = output.contentHandling
            self.credentials = output.credentials
            self.httpMethod = output.httpMethod
            self.integrationResponses = output.integrationResponses
            self.passthroughBehavior = output.passthroughBehavior
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
            self.type = output.type
            self.uri = output.uri
        } else {
            self.cacheKeyParameters = nil
            self.cacheNamespace = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandling = nil
            self.credentials = nil
            self.httpMethod = nil
            self.integrationResponses = nil
            self.passthroughBehavior = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
            self.type = nil
            self.uri = nil
        }
    }
}

/// <p>Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.</p>
///         <div class="remarks">In the API Gateway console, the built-in Lambda integration is an AWS integration.</div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct UpdateIntegrationOutputResponse: Equatable {
    /// <p>A list of request parameters whose values API Gateway caches. To be valid values for <code>cacheKeyParameters</code>, these parameters must also be specified for <a>Method</a> <code>requestParameters</code>.</p>
    public let cacheKeyParameters: [String]?
    /// <p>Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the <code>cacheNamespace</code>. You can specify the same <code>cacheNamespace</code> across resources to return the same cached data for requests to different resources.</p>
    public let cacheNamespace: String?
    /// <p>The (<a href="https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id"><code>id</code></a>) of the <a>VpcLink</a> used for the integration when <code>connectionType=VPC_LINK</code> and undefined, otherwise.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. The valid value is <code>INTERNET</code> for connections through the public routable internet or <code>VPC_LINK</code> for private connections between API Gateway and a network load balancer in a VPC. The default value is <code>INTERNET</code>.</p>
    public let connectionType: ConnectionType?
    /// <p>Specifies how to handle request payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p>
    ///       <ul>
    ///         <li><p><code>CONVERT_TO_BINARY</code>: Converts a request payload from a Base64-encoded string to the corresponding binary blob.</p></li>
    ///         <li><p><code>CONVERT_TO_TEXT</code>: Converts a request payload from a binary blob to a Base64-encoded string.</p></li>
    ///       </ul>
    ///       <p>If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the <code>passthroughBehavior</code> is configured to support payload pass-through.</p>
    public let contentHandling: ContentHandlingStrategy?
    /// <p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string <code>arn:aws:iam::\*:user/\*</code>. To use resource-based permissions on supported AWS services, specify null.</p>
    public let credentials: String?
    /// <p>Specifies the integration's HTTP method type.</p>
    public let httpMethod: String?
    /// <p>Specifies the integration's responses.</p>
    ///         <div class="remarks">
    ///     <p></p>
    ///     <h4>Example: Get integration responses of a method</h4>
    ///     <h5>Request</h5>
    ///     <p></p>
    ///     <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200 HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// X-Amz-Date: 20160607T191449Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160607/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    /// </code></pre>
    ///     <h5>Response</h5>
    ///     <p>The successful response returns <code>200 OK</code> status and a payload as follows:</p>
    ///     <pre><code>{
    ///   "_links": {
    ///     "curies": {
    ///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///       "name": "integrationresponse",
    ///       "templated": true
    ///     },
    ///     "self": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///       "title": "200"
    ///     },
    ///     "integrationresponse:delete": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///     },
    ///     "integrationresponse:update": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///     }
    ///   },
    ///   "responseParameters": {
    ///     "method.response.header.Content-Type": "'application/xml'"
    ///   },
    ///   "responseTemplates": {
    ///     "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n"
    ///   },
    ///   "statusCode": "200"
    /// }</code></pre>
    ///     <p></p>
    ///         </div>
    ///         <div class="seeAlso">
    ///           <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
    ///         </div>
    public let integrationResponses: [String:IntegrationResponse]?
    /// <div>
    ///         <p>
    ///             Specifies how the method request body of an unmapped content type will be passed through the integration request
    ///             to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration
    ///             or the content type does not match any of the mapped content types, as specified in <code>requestTemplates</code>.
    ///             The valid value is one of the following:
    ///         </p>
    ///         <ul>
    ///           <li>
    ///             <code>WHEN_NO_MATCH</code>: passes the method request body through the integration request to the back end without transformation
    ///             when the method request content type does not match any content type associated with the mapping templates defined in the integration request.
    ///           </li>
    ///           <li>
    ///             <code>WHEN_NO_TEMPLATES</code>: passes the method request body through the integration request to the back end without transformation
    ///             when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request
    ///             of an unmapped content-type will be rejected with an HTTP <code>415 Unsupported Media Type</code> response.
    ///           </li>
    ///           <li>
    ///             <code>NEVER</code>: rejects the method request with an HTTP <code>415 Unsupported Media Type</code> response when either the method
    ///             request content type does not match any content type associated with the mapping templates defined in the integration request or
    ///             no mapping template is defined in the integration request.
    ///           </li>
    ///         </ul>
    ///       </div>
    public let passthroughBehavior: String?
    /// <p>A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of  <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> must be a valid and unique method request parameter name.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.</p>
    public let requestTemplates: [String:String]?
    /// <p>Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.</p>
    public let timeoutInMillis: Int
    /// <p>Specifies the TLS configuration for an integration.</p>
    public let tlsConfig: TlsConfig?
    /// <p>Specifies an API method integration type. The valid value is one of the following:</p>
    ///         <ul>
    ///             <li><code>AWS</code>: for integrating the API method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration.</li>
    ///             <li><code>AWS_PROXY</code>: for integrating the API method request with the Lambda function-invoking action with the client request passed through as-is. This integration is also referred to as the Lambda proxy integration.</li>
    ///             <li><code>HTTP</code>: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC. This integration is also referred to as the HTTP custom integration.</li>
    ///             <li><code>HTTP_PROXY</code>: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC, with the client request passed through as-is. This is also referred to as the HTTP proxy integration.</li>
    ///             <li><code>MOCK</code>: for integrating the API method request with API Gateway as a "loop-back" endpoint without invoking any backend.</li>
    ///         </ul>
    ///         <p>For the HTTP and HTTP proxy integrations, each integration can specify a protocol (<code>http/https</code>), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a <code>connectionType</code> of <code>VPC_LINK</code> is referred to as a private integration and uses a <a>VpcLink</a> to connect API Gateway to a network load balancer of a VPC.</p>
    public let type: IntegrationType?
    /// <p>Specifies Uniform Resource Identifier (URI) of the integration endpoint.</p>
    /// <ul>
    /// <li><p> For <code>HTTP</code> or <code>HTTP_PROXY</code> integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the <a target="_blank" href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">RFC-3986 specification</a>, for either standard integration, where <code>connectionType</code> is not <code>VPC_LINK</code>, or private integration, where <code>connectionType</code> is <code>VPC_LINK</code>. For a private HTTP integration, the URI is not used for routing. </p>
    /// </li>
    /// <li><p> For <code>AWS</code> or <code>AWS_PROXY</code> integrations, the URI is of the form <code>arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}</code>. Here, <code>{Region}</code> is the API Gateway region (e.g., <code>us-east-1</code>); <code>{service}</code> is the name of the integrated AWS service (e.g., <code>s3</code>); and <code>{subdomain}</code> is a designated subdomain supported by certain AWS service for fast host-name lookup. <code>action</code> can be used for an AWS service action-based API, using an <code>Action={name}&{p1}={v1}&p2={v2}...</code> query string. The ensuing <code>{service_api}</code> refers to a supported action <code>{name}</code> plus any required input parameters. Alternatively, <code>path</code> can be used for an AWS service path-based API. The ensuing  <code>service_api</code> refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of <code><a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html">GetObject</a></code>, the <code>uri</code> can be either <code>arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key}</code> or  <code>arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}</code></p>
    /// </li></ul>
    public let uri: String?

    public init (
        cacheKeyParameters: [String]? = nil,
        cacheNamespace: String? = nil,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandling: ContentHandlingStrategy? = nil,
        credentials: String? = nil,
        httpMethod: String? = nil,
        integrationResponses: [String:IntegrationResponse]? = nil,
        passthroughBehavior: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        timeoutInMillis: Int = 0,
        tlsConfig: TlsConfig? = nil,
        type: IntegrationType? = nil,
        uri: String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct UpdateIntegrationOutputResponseBody: Equatable {
    public let type: IntegrationType?
    public let httpMethod: String?
    public let uri: String?
    public let connectionType: ConnectionType?
    public let connectionId: String?
    public let credentials: String?
    public let requestParameters: [String:String]?
    public let requestTemplates: [String:String]?
    public let passthroughBehavior: String?
    public let contentHandling: ContentHandlingStrategy?
    public let timeoutInMillis: Int
    public let cacheNamespace: String?
    public let cacheKeyParameters: [String]?
    public let integrationResponses: [String:IntegrationResponse]?
    public let tlsConfig: TlsConfig?
}

extension UpdateIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([String: IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [String:IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [String:IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

public struct UpdateIntegrationResponseInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIntegrationResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationResponseInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationResponseOutputError>
}

extension UpdateIntegrationResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIntegrationResponseInput(httpMethod: \(String(describing: httpMethod)), patchOperations: \(String(describing: patchOperations)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)), statusCode: \(String(describing: statusCode)))"}
}

extension UpdateIntegrationResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateIntegrationResponseInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIntegrationResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationResponseInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationResponseOutputError>
}

public struct UpdateIntegrationResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIntegrationResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationResponseInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationResponseOutputError>
}

/// <p>Represents an update integration response request.</p>
public struct UpdateIntegrationResponseInput: Equatable {
    /// <p>[Required] Specifies an update integration response request's HTTP method.</p>
    public let httpMethod: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] Specifies an update integration response request's resource identifier.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] Specifies an update integration response request's status code.</p>
    public let statusCode: String?

    public init (
        httpMethod: String? = nil,
        patchOperations: [PatchOperation]? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil,
        statusCode: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct UpdateIntegrationResponseInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateIntegrationResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateIntegrationResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIntegrationResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIntegrationResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIntegrationResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIntegrationResponseOutputResponse(contentHandling: \(String(describing: contentHandling)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), selectionPattern: \(String(describing: selectionPattern)), statusCode: \(String(describing: statusCode)))"}
}

extension UpdateIntegrationResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentHandling = output.contentHandling
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.selectionPattern = output.selectionPattern
            self.statusCode = output.statusCode
        } else {
            self.contentHandling = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.selectionPattern = nil
            self.statusCode = nil
        }
    }
}

/// <p>Represents an integration response. The status code must map to an existing <a>MethodResponse</a>, and parameters and templates can be used to transform the back-end response.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct UpdateIntegrationResponseOutputResponse: Equatable {
    /// <p>Specifies how to handle response payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p>
    ///     <ul>
    ///       <li><p><code>CONVERT_TO_BINARY</code>: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p></li>
    ///       <li><p><code>CONVERT_TO_TEXT</code>: Converts a response payload from a binary blob to a Base64-encoded string.</p></li>
    ///     </ul>
    ///     <p>If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.</p>
    public let contentHandling: ContentHandlingStrategy?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the back end.
    ///             The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. The mapped non-static value must match the pattern of <code>integration.response.header.{name}</code> or <code>integration.response.body.{JSON-expression}</code>, where <code>name</code> is a valid and unique response header name and <code>JSON-expression</code> is a valid JSON expression without the <code>$</code> prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>
    public let responseTemplates: [String:String]?
    /// <p>Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the <code>.+</code> regex to match error response. However, make sure that the error response does not contain any newline (<code>\n</code>) character in such cases. If the back end is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.</p>
    public let selectionPattern: String?
    /// <p>Specifies the status code that is used to map the integration response to an existing <a>MethodResponse</a>.</p>
    public let statusCode: String?

    public init (
        contentHandling: ContentHandlingStrategy? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        selectionPattern: String? = nil,
        statusCode: String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct UpdateIntegrationResponseOutputResponseBody: Equatable {
    public let statusCode: String?
    public let selectionPattern: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let contentHandling: ContentHandlingStrategy?
}

extension UpdateIntegrationResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

public struct UpdateMethodInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMethodInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMethodInput>
    public typealias MOutput = OperationOutput<UpdateMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMethodOutputError>
}

extension UpdateMethodInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMethodInput(httpMethod: \(String(describing: httpMethod)), patchOperations: \(String(describing: patchOperations)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateMethodInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateMethodInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMethodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMethodInput>
    public typealias MOutput = OperationOutput<UpdateMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMethodOutputError>
}

public struct UpdateMethodInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMethodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMethodInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMethodInput>
    public typealias MOutput = OperationOutput<UpdateMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMethodOutputError>
}

/// <p>Request to update an existing <a>Method</a> resource.</p>
public struct UpdateMethodInput: Equatable {
    /// <p>[Required] The HTTP verb of the <a>Method</a> resource.</p>
    public let httpMethod: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The <a>Resource</a> identifier for the <a>Method</a> resource.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        httpMethod: String? = nil,
        patchOperations: [PatchOperation]? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct UpdateMethodInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateMethodInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateMethodOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMethodOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMethodOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMethodOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMethodOutputResponse(apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), httpMethod: \(String(describing: httpMethod)), methodIntegration: \(String(describing: methodIntegration)), methodResponses: \(String(describing: methodResponses)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), requestValidatorId: \(String(describing: requestValidatorId)))"}
}

extension UpdateMethodOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMethodOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.httpMethod = output.httpMethod
            self.methodIntegration = output.methodIntegration
            self.methodResponses = output.methodResponses
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.requestValidatorId = output.requestValidatorId
        } else {
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.httpMethod = nil
            self.methodIntegration = nil
            self.methodResponses = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.requestValidatorId = nil
        }
    }
}

/// <p>
///             Represents a client-facing interface by which the client calls the API to access back-end resources. A <b>Method</b> resource is
///             integrated with an <a>Integration</a> resource. Both consist of a request and one or more responses. The method request takes
///             the client input that is passed to the back end through the integration request. A method response returns the output from
///             the back end to the client through an integration response. A method request is embodied in a <b>Method</b> resource, whereas
///             an integration request is embodied in an <a>Integration</a> resource.  On the other hand, a method response is represented
///             by a <a>MethodResponse</a> resource, whereas an integration response is represented by an <a>IntegrationResponse</a> resource.
///         </p>
///         <div class="remarks">
///           <p></p>
///           <h4>Example: Retrive the GET method on a specified resource</h4>
///           <h5>Request</h5>
///           <p>The following example request retrieves the information about the GET method on an API resource (<code>3kzxbg5sa2</code>) of an API (<code>fugvjdxtri</code>). </p>
///           <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1
/// Content-Type: application/json
/// Host: apigateway.us-east-1.amazonaws.com
/// X-Amz-Date: 20160603T210259Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
///           <h5>Response</h5>
///           <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
///           <pre><code>{
///   "_links": {
///     "curies": [
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
///         "name": "integration",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
///         "name": "integrationresponse",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html",
///         "name": "method",
///         "templated": true
///       },
///       {
///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
///         "name": "methodresponse",
///         "templated": true
///       }
///     ],
///     "self": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET",
///       "name": "GET",
///       "title": "GET"
///     },
///     "integration:put": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///     },
///     "method:delete": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
///     },
///     "method:integration": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///     },
///     "method:responses": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///       "name": "200",
///       "title": "200"
///     },
///     "method:update": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
///     },
///     "methodresponse:put": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}",
///       "templated": true
///     }
///   },
///   "apiKeyRequired": true,
///   "authorizationType": "NONE",
///   "httpMethod": "GET",
///   "_embedded": {
///     "method:integration": {
///       "_links": {
///         "self": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integration:delete": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integration:responses": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
///           "name": "200",
///           "title": "200"
///         },
///         "integration:update": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
///         },
///         "integrationresponse:put": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}",
///           "templated": true
///         }
///       },
///       "cacheKeyParameters": [],
///       "cacheNamespace": "3kzxbg5sa2",
///       "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
///       "httpMethod": "POST",
///       "passthroughBehavior": "WHEN_NO_MATCH",
///       "requestParameters": {
///         "integration.request.header.Content-Type": "'application/x-amz-json-1.1'"
///       },
///       "requestTemplates": {
///         "application/json": "{\n}"
///       },
///       "type": "AWS",
///       "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams",
///       "_embedded": {
///         "integration:responses": {
///           "_links": {
///             "self": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
///               "name": "200",
///               "title": "200"
///             },
///             "integrationresponse:delete": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
///             },
///             "integrationresponse:update": {
///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
///             }
///           },
///           "responseParameters": {
///             "method.response.header.Content-Type": "'application/xml'"
///           },
///           "responseTemplates": {
///             "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E\")"
///           },
///           "statusCode": "200"
///         }
///       }
///     },
///     "method:responses": {
///       "_links": {
///         "self": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///           "name": "200",
///           "title": "200"
///         },
///         "methodresponse:delete": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///         },
///         "methodresponse:update": {
///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///         }
///       },
///       "responseModels": {
///         "application/json": "Empty"
///       },
///       "responseParameters": {
///         "method.response.header.Content-Type": false
///       },
///       "statusCode": "200"
///     }
///   }
/// }</code></pre>
///           <p>In the example above, the response template for the <code>200 OK</code> response maps the JSON output from the <code>ListStreams</code> action in the back end to an XML output. The mapping template is URL-encoded as <code>%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E</code> and the output is decoded using the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#util-templat-reference">$util.urlDecode()</a> helper function.</p>
///       </div>
///       <div class="seeAlso">
///         <a>MethodResponse</a>, <a>Integration</a>, <a>IntegrationResponse</a>, <a>Resource</a>,
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings.html">Set up an API's method</a>
///       </div>
public struct UpdateMethodOutputResponse: Equatable {
    /// <p>A boolean flag specifying whether a valid <a>ApiKey</a> is required to invoke this method.</p>
    public let apiKeyRequired: Bool?
    /// <p>A list of authorization scopes configured on the method. The scopes are used with a <code>COGNITO_USER_POOLS</code> authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    public let authorizationScopes: [String]?
    /// <p>The method's authorization type. Valid values are <code>NONE</code> for open access, <code>AWS_IAM</code> for using AWS IAM permissions, <code>CUSTOM</code> for using a custom authorizer, or <code>COGNITO_USER_POOLS</code> for using a Cognito user pool.</p>
    public let authorizationType: String?
    /// <p>The identifier of an <a>Authorizer</a> to use on this method. The <code>authorizationType</code> must be <code>CUSTOM</code>.</p>
    public let authorizerId: String?
    /// <p>The method's HTTP verb.</p>
    public let httpMethod: String?
    /// <p>Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.</p>
    ///       <div class="remarks">
    ///         <p></p>
    ///         <h4>Example: </h4>
    ///         <h5>Request</h5>
    ///         <p></p>
    ///         <pre><code>GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// Content-Length: 117
    /// X-Amz-Date: 20160613T213210Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": [
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
    ///         "name": "integration",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///         "name": "integrationresponse",
    ///         "templated": true
    ///       }
    ///     ],
    ///     "self": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integration:delete": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integration:responses": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200",
    ///       "name": "200",
    ///       "title": "200"
    ///     },
    ///     "integration:update": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
    ///     },
    ///     "integrationresponse:put": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/{status_code}",
    ///       "templated": true
    ///     }
    ///   },
    ///   "cacheKeyParameters": [],
    ///   "cacheNamespace": "0cjtch",
    ///   "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
    ///   "httpMethod": "POST",
    ///   "passthroughBehavior": "WHEN_NO_MATCH",
    ///   "requestTemplates": {
    ///     "application/json": "{\n    \"a\":  \"$input.params('operand1')\",\n    \"b\":  \"$input.params('operand2')\", \n    \"op\": \"$input.params('operator')\"   \n}"
    ///   },
    ///   "type": "AWS",
    ///   "uri": "arn:aws:apigateway:us-west-2:lambda:path//2015-03-31/functions/arn:aws:lambda:us-west-2:123456789012:function:Calc/invocations",
    ///   "_embedded": {
    ///     "integration:responses": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "integrationresponse:delete": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200"
    ///         },
    ///         "integrationresponse:update": {
    ///           "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200"
    ///         }
    ///       },
    ///       "responseParameters": {
    ///         "method.response.header.operator": "integration.response.body.op",
    ///         "method.response.header.operand_2": "integration.response.body.b",
    ///         "method.response.header.operand_1": "integration.response.body.a"
    ///       },
    ///       "responseTemplates": {
    ///         "application/json": "#set($res = $input.path('$'))\n{\n    \"result\": \"$res.a, $res.b, $res.op => $res.c\",\n  \"a\" : \"$res.a\",\n  \"b\" : \"$res.b\",\n  \"op\" : \"$res.op\",\n  \"c\" : \"$res.c\"\n}"
    ///       },
    ///       "selectionPattern": "",
    ///       "statusCode": "200"
    ///     }
    ///   }
    /// }</code></pre>
    ///         <p></p>
    ///       </div>
    ///       <div class="seeAlso">
    ///         <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-integration.html">AWS CLI</a>
    ///       </div>
    public let methodIntegration: Integration?
    /// <p>Gets a method response associated with a given HTTP status code. </p>
    ///       <div class="remarks">
    ///         <p>The collection of method responses are encapsulated in a key-value map, where the key is a response's HTTP status code and the value is a <a>MethodResponse</a> resource that specifies the response returned to the caller from the back end through the integration response.</p>
    ///         <h4>Example: Get a 200 OK response of a GET method</h4>
    ///         <h5>Request</h5>
    ///         <p></p>
    ///         <pre><code>GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200 HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// Content-Length: 117
    /// X-Amz-Date: 20160613T215008Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <p>The successful response returns a <code>200 OK</code> status code and a payload similar to the following:</p>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": {
    ///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
    ///       "name": "methodresponse",
    ///       "templated": true
    ///     },
    ///     "self": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200",
    ///       "title": "200"
    ///     },
    ///     "methodresponse:delete": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200"
    ///     },
    ///     "methodresponse:update": {
    ///       "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200"
    ///     }
    ///   },
    ///   "responseModels": {
    ///     "application/json": "Empty"
    ///   },
    ///   "responseParameters": {
    ///     "method.response.header.operator": false,
    ///     "method.response.header.operand_2": false,
    ///     "method.response.header.operand_1": false
    ///   },
    ///   "statusCode": "200"
    /// }</code></pre>
    ///         <p></p>
    ///       </div>
    ///       <div class="seeAlso">
    ///         <a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-method-response.html">AWS CLI</a>
    ///       </div>
    public let methodResponses: [String:MethodResponse]?
    /// <p>A human-friendly operation identifier for the method. For example, you can assign the <code>operationName</code> of <code>ListPets</code> for the <code>GET /pets</code> method in the <code>PetStore</code> example.</p>
    public let operationName: String?
    /// <p>A key-value map specifying data schemas, represented by <a>Model</a> resources, (as the mapped value) of the request payloads of given content types (as the mapping key).</p>
    public let requestModels: [String:String]?
    /// <p>A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of  <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (<code>true</code>) or optional (<code>false</code>).  The method request parameter names defined here are available in <a>Integration</a> to be mapped to integration request parameters or templates.</p>
    public let requestParameters: [String:Bool]?
    /// <p>The identifier of a <a>RequestValidator</a> for request validation.</p>
    public let requestValidatorId: String?

    public init (
        apiKeyRequired: Bool? = nil,
        authorizationScopes: [String]? = nil,
        authorizationType: String? = nil,
        authorizerId: String? = nil,
        httpMethod: String? = nil,
        methodIntegration: Integration? = nil,
        methodResponses: [String:MethodResponse]? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:Bool]? = nil,
        requestValidatorId: String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

struct UpdateMethodOutputResponseBody: Equatable {
    public let httpMethod: String?
    public let authorizationType: String?
    public let authorizerId: String?
    public let apiKeyRequired: Bool?
    public let requestValidatorId: String?
    public let operationName: String?
    public let requestParameters: [String:Bool]?
    public let requestModels: [String:String]?
    public let methodResponses: [String:MethodResponse]?
    public let methodIntegration: Integration?
    public let authorizationScopes: [String]?
}

extension UpdateMethodOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([String: MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [String:MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [String:MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

public struct UpdateMethodResponseInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMethodResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMethodResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMethodResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMethodResponseInput>
    public typealias MOutput = OperationOutput<UpdateMethodResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMethodResponseOutputError>
}

extension UpdateMethodResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMethodResponseInput(httpMethod: \(String(describing: httpMethod)), patchOperations: \(String(describing: patchOperations)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)), statusCode: \(String(describing: statusCode)))"}
}

extension UpdateMethodResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateMethodResponseInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMethodResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMethodResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMethodResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMethodResponseInput>
    public typealias MOutput = OperationOutput<UpdateMethodResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMethodResponseOutputError>
}

public struct UpdateMethodResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMethodResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMethodResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMethodResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMethodResponseInput>
    public typealias MOutput = OperationOutput<UpdateMethodResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMethodResponseOutputError>
}

/// <p>A request to update an existing <a>MethodResponse</a> resource.</p>
public struct UpdateMethodResponseInput: Equatable {
    /// <p>[Required] The HTTP verb of the <a>Method</a> resource.</p>
    public let httpMethod: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The <a>Resource</a> identifier for the <a>MethodResponse</a> resource.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The status code for the <a>MethodResponse</a> resource.</p>
    public let statusCode: String?

    public init (
        httpMethod: String? = nil,
        patchOperations: [PatchOperation]? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil,
        statusCode: String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct UpdateMethodResponseInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateMethodResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateMethodResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMethodResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMethodResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMethodResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMethodResponseOutputResponse(responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), statusCode: \(String(describing: statusCode)))"}
}

extension UpdateMethodResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMethodResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.statusCode = output.statusCode
        } else {
            self.responseModels = nil
            self.responseParameters = nil
            self.statusCode = nil
        }
    }
}

/// <p>Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template. <!-- API Gateway sends back the status code to the caller as the HTTP status code. Parameters and models can be used to transform the response from the method's integration.--></p>
///         <div class="remarks">
///           <p></p>
///           <h4>Example: A <b>MethodResponse</b> instance of an API</h4>
///           <h5>Request</h5>
///           <p>The example request retrieves a <b>MethodResponse</b> of the 200 status code.</p>
///           <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200 HTTP/1.1
/// Content-Type: application/json
/// Host: apigateway.us-east-1.amazonaws.com
/// X-Amz-Date: 20160603T222952Z
/// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
///           <h5>Response</h5>
///           <p>The successful response returns <code>200 OK</code> status and a payload as follows:</p>
///           <pre><code>{
///   "_links": {
///     "curies": {
///       "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
///       "name": "methodresponse",
///       "templated": true
///     },
///     "self": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
///       "title": "200"
///     },
///     "methodresponse:delete": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///     },
///     "methodresponse:update": {
///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
///     }
///   },
///   "responseModels": {
///     "application/json": "Empty"
///   },
///   "responseParameters": {
///     "method.response.header.Content-Type": false
///   },
///   "statusCode": "200"
/// }</code></pre>
///           <p></p>
///       </div>
///       <div class="seeAlso">
///         <a>Method</a>, <a>IntegrationResponse</a>, <a>Integration</a>
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Creating an API</a>
///       </div>
public struct UpdateMethodResponseOutputResponse: Equatable {
    /// <p>Specifies the <a>Model</a> resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a <a>Model</a> name as the value.</p>
    public let responseModels: [String:String]?
    /// <p>A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's <a>IntegrationResponse</a>. The integration response data that can be mapped include an integration response header expressed in <code>integration.response.header.{name}</code>, a static value enclosed within a pair of single quotes (e.g., <code>'application/json'</code>), or a JSON expression from the back-end response payload in the form of <code>integration.response.body.{JSON-expression}</code>, where <code>JSON-expression</code> is a valid JSON expression without the <code>$</code> prefix.)</p>
    public let responseParameters: [String:Bool]?
    /// <p>The method response's status code.</p>
    public let statusCode: String?

    public init (
        responseModels: [String:String]? = nil,
        responseParameters: [String:Bool]? = nil,
        statusCode: String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

struct UpdateMethodResponseOutputResponseBody: Equatable {
    public let statusCode: String?
    public let responseParameters: [String:Bool]?
    public let responseModels: [String:String]?
}

extension UpdateMethodResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

public struct UpdateModelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelInput>
    public typealias MOutput = OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelOutputError>
}

extension UpdateModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateModelInput(modelName: \(String(describing: modelName)), patchOperations: \(String(describing: patchOperations)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateModelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelInput>
    public typealias MOutput = OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelOutputError>
}

public struct UpdateModelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelInput>
    public typealias MOutput = OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelOutputError>
}

/// <p>Request to update an existing model in an existing <a>RestApi</a> resource.</p>
public struct UpdateModelInput: Equatable {
    /// <p>[Required] The name of the model to update.</p>
    public let modelName: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        modelName: String? = nil,
        patchOperations: [PatchOperation]? = nil,
        restApiId: String? = nil
    )
    {
        self.modelName = modelName
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateModelInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateModelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateModelOutputResponse(contentType: \(String(describing: contentType)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

extension UpdateModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentType = output.contentType
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.schema = nil
        }
    }
}

/// <p>Represents the data structure of a method's request or response payload.</p>
///       <div class="remarks">
///         <p>A request model defines the data structure of the client-supplied request payload. A response model defines the data structure of the response payload returned by the back end. Although not required, models are useful for mapping payloads between the front end and back end.</p>
///         <p>A model is used for generating an API's SDK, validating the input request body, and creating a skeletal mapping template.</p>
///       </div>
///       <div class="seeAlso">
///         <a>Method</a>, <a>MethodResponse</a>, <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html">Models and Mappings</a>
///       </div>
public struct UpdateModelOutputResponse: Equatable {
    /// <p>The content-type for the model.</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>The identifier for the model resource.</p>
    public let id: String?
    /// <p>The name of the model. Must be an alphanumeric string.</p>
    public let name: String?
    /// <p>The schema for the model. For <code>application/json</code> models, this should be <a target="_blank" href="https://tools.ietf.org/html/draft-zyp-json-schema-04">JSON schema draft 4</a> model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.</p>
    public let schema: String?

    public init (
        contentType: String? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

struct UpdateModelOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let schema: String?
    public let contentType: String?
}

extension UpdateModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

public struct UpdateRequestValidatorInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRequestValidatorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRequestValidatorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRequestValidatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRequestValidatorInput>
    public typealias MOutput = OperationOutput<UpdateRequestValidatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRequestValidatorOutputError>
}

extension UpdateRequestValidatorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRequestValidatorInput(patchOperations: \(String(describing: patchOperations)), requestValidatorId: \(String(describing: requestValidatorId)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateRequestValidatorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateRequestValidatorInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRequestValidatorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRequestValidatorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRequestValidatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRequestValidatorInput>
    public typealias MOutput = OperationOutput<UpdateRequestValidatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRequestValidatorOutputError>
}

public struct UpdateRequestValidatorInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRequestValidatorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRequestValidatorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRequestValidatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRequestValidatorInput>
    public typealias MOutput = OperationOutput<UpdateRequestValidatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRequestValidatorOutputError>
}

/// <p>Updates a <a>RequestValidator</a> of a given <a>RestApi</a>.</p>
public struct UpdateRequestValidatorInput: Equatable {
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The identifier of <a>RequestValidator</a> to be updated.</p>
    public let requestValidatorId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        patchOperations: [PatchOperation]? = nil,
        requestValidatorId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

struct UpdateRequestValidatorInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateRequestValidatorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateRequestValidatorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRequestValidatorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRequestValidatorOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRequestValidatorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRequestValidatorOutputResponse(id: \(String(describing: id)), name: \(String(describing: name)), validateRequestBody: \(String(describing: validateRequestBody)), validateRequestParameters: \(String(describing: validateRequestParameters)))"}
}

extension UpdateRequestValidatorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRequestValidatorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.name = output.name
            self.validateRequestBody = output.validateRequestBody
            self.validateRequestParameters = output.validateRequestParameters
        } else {
            self.id = nil
            self.name = nil
            self.validateRequestBody = false
            self.validateRequestParameters = false
        }
    }
}

/// <p>A set of validation rules for incoming <a>Method</a> requests.</p>
///         <div class="remarks">
///           <p>In OpenAPI, a <a>RequestValidator</a> of an API is defined by the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.requestValidator.html">x-amazon-apigateway-request-validators.requestValidator</a> object. It the referenced using the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validator">x-amazon-apigateway-request-validator</a> property.</p>
///         </div>
///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html">Enable Basic Request Validation in API Gateway</a></div>
public struct UpdateRequestValidatorOutputResponse: Equatable {
    /// <p>The identifier of this <a>RequestValidator</a>.</p>
    public let id: String?
    /// <p>The name of this <a>RequestValidator</a></p>
    public let name: String?
    /// <p>A Boolean flag to indicate whether to validate a request body according to the configured <a>Model</a> schema.</p>
    public let validateRequestBody: Bool
    /// <p>A Boolean flag to indicate whether to validate request parameters (<code>true</code>) or not (<code>false</code>).</p>
    public let validateRequestParameters: Bool

    public init (
        id: String? = nil,
        name: String? = nil,
        validateRequestBody: Bool = false,
        validateRequestParameters: Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct UpdateRequestValidatorOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let validateRequestBody: Bool
    public let validateRequestParameters: Bool
}

extension UpdateRequestValidatorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decode(Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decode(Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

public struct UpdateResourceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceOutputError>
}

extension UpdateResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceInput(patchOperations: \(String(describing: patchOperations)), resourceId: \(String(describing: resourceId)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceOutputError>
}

public struct UpdateResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceOutputError>
}

/// <p>Request to change information about a <a>Resource</a> resource.</p>
public struct UpdateResourceInput: Equatable {
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The identifier of the <a>Resource</a> resource.</p>
    public let resourceId: String?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        patchOperations: [PatchOperation]? = nil,
        resourceId: String? = nil,
        restApiId: String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct UpdateResourceInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceOutputResponse(id: \(String(describing: id)), parentId: \(String(describing: parentId)), path: \(String(describing: path)), pathPart: \(String(describing: pathPart)), resourceMethods: \(String(describing: resourceMethods)))"}
}

extension UpdateResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.parentId = output.parentId
            self.path = output.path
            self.pathPart = output.pathPart
            self.resourceMethods = output.resourceMethods
        } else {
            self.id = nil
            self.parentId = nil
            self.path = nil
            self.pathPart = nil
            self.resourceMethods = nil
        }
    }
}

/// <p>Represents an API resource.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct UpdateResourceOutputResponse: Equatable {
    /// <p>The resource's identifier.</p>
    public let id: String?
    /// <p>The parent resource's identifier.</p>
    public let parentId: String?
    /// <p>The full path for this resource.</p>
    public let path: String?
    /// <p>The last path segment for this resource.</p>
    public let pathPart: String?
    /// <p>Gets an API resource's method of a given HTTP verb.</p>
    ///       <div class="remarks">
    ///         <p>The resource methods are a map of methods indexed by methods' HTTP verbs enabled on the resource. This method map is included in the <code>200 OK</code> response of the <code>GET /restapis/{restapi_id}/resources/{resource_id}</code> or <code>GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods</code> request.</p>
    ///         <h4>Example: Get the GET method of an API resource</h4>
    ///         <h5>Request</h5>
    ///         <pre><code>GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1
    /// Content-Type: application/json
    /// Host: apigateway.us-east-1.amazonaws.com
    /// X-Amz-Date: 20170223T031827Z
    /// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20170223/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}</code></pre>
    ///         <h5>Response</h5>
    ///         <pre><code>{
    ///   "_links": {
    ///     "curies": [
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
    ///         "name": "integration",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
    ///         "name": "integrationresponse",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html",
    ///         "name": "method",
    ///         "templated": true
    ///       },
    ///       {
    ///         "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
    ///         "name": "methodresponse",
    ///         "templated": true
    ///       }
    ///     ],
    ///     "self": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET",
    ///       "name": "GET",
    ///       "title": "GET"
    ///     },
    ///     "integration:put": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///     },
    ///     "method:delete": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
    ///     },
    ///     "method:integration": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///     },
    ///     "method:responses": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
    ///       "name": "200",
    ///       "title": "200"
    ///     },
    ///     "method:update": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
    ///     },
    ///     "methodresponse:put": {
    ///       "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}",
    ///       "templated": true
    ///     }
    ///   },
    ///   "apiKeyRequired": false,
    ///   "authorizationType": "NONE",
    ///   "httpMethod": "GET",
    ///   "_embedded": {
    ///     "method:integration": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integration:delete": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integration:responses": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "integration:update": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
    ///         },
    ///         "integrationresponse:put": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}",
    ///           "templated": true
    ///         }
    ///       },
    ///       "cacheKeyParameters": [],
    ///       "cacheNamespace": "3kzxbg5sa2",
    ///       "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
    ///       "httpMethod": "POST",
    ///       "passthroughBehavior": "WHEN_NO_MATCH",
    ///       "requestParameters": {
    ///         "integration.request.header.Content-Type": "'application/x-amz-json-1.1'"
    ///       },
    ///       "requestTemplates": {
    ///         "application/json": "{\n}"
    ///       },
    ///       "type": "AWS",
    ///       "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams",
    ///       "_embedded": {
    ///         "integration:responses": {
    ///           "_links": {
    ///             "self": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
    ///               "name": "200",
    ///               "title": "200"
    ///             },
    ///             "integrationresponse:delete": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///             },
    ///             "integrationresponse:update": {
    ///               "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
    ///             }
    ///           },
    ///           "responseParameters": {
    ///             "method.response.header.Content-Type": "'application/xml'"
    ///           },
    ///           "responseTemplates": {
    ///             "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n"
    ///           },
    ///           "statusCode": "200"
    ///         }
    ///       }
    ///     },
    ///     "method:responses": {
    ///       "_links": {
    ///         "self": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
    ///           "name": "200",
    ///           "title": "200"
    ///         },
    ///         "methodresponse:delete": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
    ///         },
    ///         "methodresponse:update": {
    ///           "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
    ///         }
    ///       },
    ///       "responseModels": {
    ///         "application/json": "Empty"
    ///       },
    ///       "responseParameters": {
    ///         "method.response.header.Content-Type": false
    ///       },
    ///       "statusCode": "200"
    ///     }
    ///   }
    /// }</code></pre>
    ///         <p>If the <code>OPTIONS</code> is enabled on the resource, you can follow the example here to get that method. Just replace the <code>GET</code> of the last path segment in the request URL with <code>OPTIONS</code>.</p>
    ///       </div>
    ///       <div class="seeAlso">
    ///       </div>
    public let resourceMethods: [String:Method]?

    public init (
        id: String? = nil,
        parentId: String? = nil,
        path: String? = nil,
        pathPart: String? = nil,
        resourceMethods: [String:Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

struct UpdateResourceOutputResponseBody: Equatable {
    public let id: String?
    public let parentId: String?
    public let pathPart: String?
    public let path: String?
    public let resourceMethods: [String:Method]?
}

extension UpdateResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([String: Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [String:Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [String:Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

public struct UpdateRestApiInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRestApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRestApiInput>
    public typealias MOutput = OperationOutput<UpdateRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRestApiOutputError>
}

extension UpdateRestApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRestApiInput(patchOperations: \(String(describing: patchOperations)), restApiId: \(String(describing: restApiId)))"}
}

extension UpdateRestApiInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateRestApiInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRestApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRestApiInput>
    public typealias MOutput = OperationOutput<UpdateRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRestApiOutputError>
}

public struct UpdateRestApiInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRestApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRestApiInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRestApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRestApiInput>
    public typealias MOutput = OperationOutput<UpdateRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRestApiOutputError>
}

/// <p>Request to update an existing <a>RestApi</a> resource in your collection.</p>
public struct UpdateRestApiInput: Equatable {
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?

    public init (
        patchOperations: [PatchOperation]? = nil,
        restApiId: String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateRestApiInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateRestApiInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateRestApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRestApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRestApiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRestApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRestApiOutputResponse(apiKeySource: \(String(describing: apiKeySource)), binaryMediaTypes: \(String(describing: binaryMediaTypes)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), endpointConfiguration: \(String(describing: endpointConfiguration)), id: \(String(describing: id)), minimumCompressionSize: \(String(describing: minimumCompressionSize)), name: \(String(describing: name)), policy: \(String(describing: policy)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

extension UpdateRestApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRestApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// <p>Represents a REST API.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html">Create an API</a>
///       </div>
public struct UpdateRestApiOutputResponse: Equatable {
    /// <p>The source of the API key for metering requests according to a usage plan. Valid values are: <ul><li><code>HEADER</code> to read the API key from the <code>X-API-Key</code> header of a request. </li><li><code>AUTHORIZER</code> to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.</li></ul></p>
    public let apiKeySource: ApiKeySourceType?
    /// <p>The list of binary media types supported by the <a>RestApi</a>. By default, the <a>RestApi</a> supports only UTF-8-encoded text payloads.</p>
    public let binaryMediaTypes: [String]?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The API's description.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default <code>execute-api</code> endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>The endpoint configuration of this <a>RestApi</a> showing the endpoint types of the API.</p>
    public let endpointConfiguration: EndpointConfiguration?
    /// <p>The API's identifier. This identifier is unique across all of your APIs in API Gateway.</p>
    public let id: String?
    /// <p>A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.</p>
    public let minimumCompressionSize: Int?
    /// <p>The API's name.</p>
    public let name: String?
    /// <p>A stringified JSON policy document that applies to this RestApi regardless of the caller and <a>Method</a> configuration.</p>
    public let policy: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when <code>failonwarnings</code> is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiKeySource: ApiKeySourceType? = nil,
        binaryMediaTypes: [String]? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        endpointConfiguration: EndpointConfiguration? = nil,
        id: String? = nil,
        minimumCompressionSize: Int? = nil,
        name: String? = nil,
        policy: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct UpdateRestApiOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let createdDate: Date?
    public let version: String?
    public let warnings: [String]?
    public let binaryMediaTypes: [String]?
    public let minimumCompressionSize: Int?
    public let apiKeySource: ApiKeySourceType?
    public let endpointConfiguration: EndpointConfiguration?
    public let policy: String?
    public let tags: [String:String]?
    public let disableExecuteApiEndpoint: Bool
}

extension UpdateRestApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

public struct UpdateStageInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStageInput>
    public typealias MOutput = OperationOutput<UpdateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStageOutputError>
}

extension UpdateStageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStageInput(patchOperations: \(String(describing: patchOperations)), restApiId: \(String(describing: restApiId)), stageName: \(String(describing: stageName)))"}
}

extension UpdateStageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateStageInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStageInput>
    public typealias MOutput = OperationOutput<UpdateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStageOutputError>
}

public struct UpdateStageInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStageInput>
    public typealias MOutput = OperationOutput<UpdateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStageOutputError>
}

/// <p>Requests API Gateway to change information about a <a>Stage</a> resource.</p>
public struct UpdateStageInput: Equatable {
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The string identifier of the associated <a>RestApi</a>.</p>
    public let restApiId: String?
    /// <p>[Required] The name of the <a>Stage</a> resource to change information about.</p>
    public let stageName: String?

    public init (
        patchOperations: [PatchOperation]? = nil,
        restApiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct UpdateStageInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateStageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateStageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStageOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStageOutputResponse(accessLogSettings: \(String(describing: accessLogSettings)), cacheClusterEnabled: \(String(describing: cacheClusterEnabled)), cacheClusterSize: \(String(describing: cacheClusterSize)), cacheClusterStatus: \(String(describing: cacheClusterStatus)), canarySettings: \(String(describing: canarySettings)), clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), documentationVersion: \(String(describing: documentationVersion)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), methodSettings: \(String(describing: methodSettings)), stageName: \(String(describing: stageName)), tags: \(String(describing: tags)), tracingEnabled: \(String(describing: tracingEnabled)), variables: \(String(describing: variables)), webAclArn: \(String(describing: webAclArn)))"}
}

extension UpdateStageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateStageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessLogSettings = output.accessLogSettings
            self.cacheClusterEnabled = output.cacheClusterEnabled
            self.cacheClusterSize = output.cacheClusterSize
            self.cacheClusterStatus = output.cacheClusterStatus
            self.canarySettings = output.canarySettings
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.documentationVersion = output.documentationVersion
            self.lastUpdatedDate = output.lastUpdatedDate
            self.methodSettings = output.methodSettings
            self.stageName = output.stageName
            self.tags = output.tags
            self.tracingEnabled = output.tracingEnabled
            self.variables = output.variables
            self.webAclArn = output.webAclArn
        } else {
            self.accessLogSettings = nil
            self.cacheClusterEnabled = false
            self.cacheClusterSize = nil
            self.cacheClusterStatus = nil
            self.canarySettings = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.description = nil
            self.documentationVersion = nil
            self.lastUpdatedDate = nil
            self.methodSettings = nil
            self.stageName = nil
            self.tags = nil
            self.tracingEnabled = false
            self.variables = nil
            self.webAclArn = nil
        }
    }
}

/// <p>Represents a unique identifier for a version of a deployed <a>RestApi</a> that is callable by users.</p>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html">Deploy an API</a>
///       </div>
public struct UpdateStageOutputResponse: Equatable {
    /// <p>Settings for logging access in this stage.</p>
    public let accessLogSettings: AccessLogSettings?
    /// <p>Specifies whether a cache cluster is enabled for the stage.</p>
    public let cacheClusterEnabled: Bool
    /// <p>The size of the cache cluster for the stage, if enabled.</p>
    public let cacheClusterSize: CacheClusterSize?
    /// <p>The status of the cache cluster for the stage, if enabled.</p>
    public let cacheClusterStatus: CacheClusterStatus?
    /// <p>Settings for the canary deployment in this stage.</p>
    public let canarySettings: CanarySettings?
    /// <p>The identifier of a client certificate for an API stage.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the stage was created.</p>
    public let createdDate: Date?
    /// <p>The identifier of the <a>Deployment</a> that the stage points to.</p>
    public let deploymentId: String?
    /// <p>The stage's description.</p>
    public let description: String?
    /// <p>The version of the associated API documentation.</p>
    public let documentationVersion: String?
    /// <p>The timestamp when the stage last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>A map that defines the method settings for a <a>Stage</a> resource. Keys (designated as <code>/{method_setting_key</code> below) are method paths defined as <code>{resource_path}/{http_method}</code> for an individual method override, or <code>/\*/\*</code> for overriding all methods in the stage.  <!-- Any forward slash ("/") characters in the <code>resource_path</code> part must be encoded as "~1" as in, for example, <code>~1resource~1sub-resource/GET</code>.--></p>
    public let methodSettings: [String:MethodSetting]?
    /// <p>The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.</p>
    public let stageName: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>Specifies whether active tracing with X-ray is enabled for the <a>Stage</a>.</p>
    public let tracingEnabled: Bool
    /// <p>A map that defines the stage variables for a <a>Stage</a> resource. Variable names can
    ///           have alphanumeric and underscore characters, and the values must match <code>[A-Za-z0-9-._~:/?#&=,]+</code>.</p>
    public let variables: [String:String]?
    /// <p>The ARN of the WebAcl associated with the <a>Stage</a>.</p>
    public let webAclArn: String?

    public init (
        accessLogSettings: AccessLogSettings? = nil,
        cacheClusterEnabled: Bool = false,
        cacheClusterSize: CacheClusterSize? = nil,
        cacheClusterStatus: CacheClusterStatus? = nil,
        canarySettings: CanarySettings? = nil,
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        documentationVersion: String? = nil,
        lastUpdatedDate: Date? = nil,
        methodSettings: [String:MethodSetting]? = nil,
        stageName: String? = nil,
        tags: [String:String]? = nil,
        tracingEnabled: Bool = false,
        variables: [String:String]? = nil,
        webAclArn: String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

struct UpdateStageOutputResponseBody: Equatable {
    public let deploymentId: String?
    public let clientCertificateId: String?
    public let stageName: String?
    public let description: String?
    public let cacheClusterEnabled: Bool
    public let cacheClusterSize: CacheClusterSize?
    public let cacheClusterStatus: CacheClusterStatus?
    public let methodSettings: [String:MethodSetting]?
    public let variables: [String:String]?
    public let documentationVersion: String?
    public let accessLogSettings: AccessLogSettings?
    public let canarySettings: CanarySettings?
    public let tracingEnabled: Bool
    public let webAclArn: String?
    public let tags: [String:String]?
    public let createdDate: Date?
    public let lastUpdatedDate: Date?
}

extension UpdateStageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([String: MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [String:MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [String:MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

public struct UpdateUsageInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUsageInput>
    public typealias MOutput = OperationOutput<UpdateUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUsageOutputError>
}

extension UpdateUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUsageInput(keyId: \(String(describing: keyId)), patchOperations: \(String(describing: patchOperations)), usagePlanId: \(String(describing: usagePlanId)))"}
}

extension UpdateUsageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateUsageInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUsageInput>
    public typealias MOutput = OperationOutput<UpdateUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUsageOutputError>
}

public struct UpdateUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUsageInput>
    public typealias MOutput = OperationOutput<UpdateUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUsageOutputError>
}

/// <p>The PATCH request to grant a temporary extension to the remaining quota of a usage plan associated with a specified API key.</p>
public struct UpdateUsageInput: Equatable {
    /// <p>[Required] The identifier of the API key associated with the usage plan in which a temporary extension is granted to the remaining quota.</p>
    public let keyId: String?
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The Id of the usage plan associated with the usage data.</p>
    public let usagePlanId: String?

    public init (
        keyId: String? = nil,
        patchOperations: [PatchOperation]? = nil,
        usagePlanId: String? = nil
    )
    {
        self.keyId = keyId
        self.patchOperations = patchOperations
        self.usagePlanId = usagePlanId
    }
}

struct UpdateUsageInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateUsageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUsageOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUsageOutputResponse(endDate: \(String(describing: endDate)), items: \(String(describing: items)), position: \(String(describing: position)), startDate: \(String(describing: startDate)), usagePlanId: \(String(describing: usagePlanId)))"}
}

extension UpdateUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endDate = output.endDate
            self.items = output.items
            self.startDate = output.startDate
            self.usagePlanId = output.usagePlanId
        } else {
            self.endDate = nil
            self.items = nil
            self.startDate = nil
            self.usagePlanId = nil
        }
        self.position = nil
    }
}

/// <p>Represents the usage data of a usage plan.</p>
///     <div class="remarks"></div>
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>,
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-usage-plans-with-console.html#api-gateway-usage-plan-manage-usage">Manage Usage in a Usage Plan</a>
///     </div>
public struct UpdateUsageOutputResponse: Equatable {
    /// <p>The ending date of the usage data.</p>
    public let endDate: String?
    /// <p>The usage data, as daily logs of used and remaining quotas, over the specified time interval indexed over the API keys in a usage plan. For example, <code>{..., "values" : { "{api_key}" : [ [0, 100], [10, 90], [100, 10]]}</code>, where <code>{api_key}</code> stands for an API key value and the daily log entry is of the format <code>[used quota, remaining quota]</code>.</p>
    public let items: [String:[[Int]]]?
    /// <p>The current pagination position in the paged result set.</p>
    public let position: String?
    /// <p>The starting date of the usage data.</p>
    public let startDate: String?
    /// <p>The plan Id associated with this usage data.</p>
    public let usagePlanId: String?

    public init (
        endDate: String? = nil,
        items: [String:[[Int]]]? = nil,
        position: String? = nil,
        startDate: String? = nil,
        usagePlanId: String? = nil
    )
    {
        self.endDate = endDate
        self.items = items
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

struct UpdateUsageOutputResponseBody: Equatable {
    public let usagePlanId: String?
    public let startDate: String?
    public let endDate: String?
    public let items: [String:[[Int]]]?
}

extension UpdateUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endDate
        case items = "values"
        case startDate
        case usagePlanId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usagePlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usagePlanId)
        usagePlanId = usagePlanIdDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
        let itemsContainer = try containerValues.decodeIfPresent([String: [[Int?]?]?].self, forKey: .items)
        var itemsDecoded0: [String:[[Int]]]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [String:[[Int]]]()
            for (key0, listofusage0) in itemsContainer {
                var listofusage0Decoded0: [[Int]]? = nil
                if let listofusage0 = listofusage0 {
                    listofusage0Decoded0 = [[Int]]()
                    for list1 in listofusage0 {
                        var list1Decoded1: [Int]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Int]()
                            for long2 in list1 {
                                if let long2 = long2 {
                                    list1Decoded1?.append(long2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            listofusage0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                itemsDecoded0?[key0] = listofusage0Decoded0
            }
        }
        items = itemsDecoded0
    }
}

public struct UpdateUsagePlanInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUsagePlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUsagePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUsagePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUsagePlanInput>
    public typealias MOutput = OperationOutput<UpdateUsagePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUsagePlanOutputError>
}

extension UpdateUsagePlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUsagePlanInput(patchOperations: \(String(describing: patchOperations)), usagePlanId: \(String(describing: usagePlanId)))"}
}

extension UpdateUsagePlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateUsagePlanInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUsagePlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUsagePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUsagePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUsagePlanInput>
    public typealias MOutput = OperationOutput<UpdateUsagePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUsagePlanOutputError>
}

public struct UpdateUsagePlanInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUsagePlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUsagePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUsagePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUsagePlanInput>
    public typealias MOutput = OperationOutput<UpdateUsagePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUsagePlanOutputError>
}

/// <p>The PATCH request to update a usage plan of a given plan Id.</p>
public struct UpdateUsagePlanInput: Equatable {
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The Id of the to-be-updated usage plan.</p>
    public let usagePlanId: String?

    public init (
        patchOperations: [PatchOperation]? = nil,
        usagePlanId: String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.usagePlanId = usagePlanId
    }
}

struct UpdateUsagePlanInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateUsagePlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateUsagePlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUsagePlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUsagePlanOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUsagePlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUsagePlanOutputResponse(apiStages: \(String(describing: apiStages)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), productCode: \(String(describing: productCode)), quota: \(String(describing: quota)), tags: \(String(describing: tags)), throttle: \(String(describing: throttle)))"}
}

extension UpdateUsagePlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateUsagePlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiStages = output.apiStages
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.productCode = output.productCode
            self.quota = output.quota
            self.tags = output.tags
            self.throttle = output.throttle
        } else {
            self.apiStages = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.productCode = nil
            self.quota = nil
            self.tags = nil
            self.throttle = nil
        }
    }
}

/// <p>Represents a usage plan than can specify who can assess associated API stages with specified request limits and quotas.</p>
///       <div class="remarks">
///         <p>In a usage plan, you associate an API by specifying the API's Id and a stage name of the specified API. You add plan customers by adding API keys to the plan. </p>
///       </div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>
///       </div>
public struct UpdateUsagePlanOutputResponse: Equatable {
    /// <p>The associated API stages of a usage plan.</p>
    public let apiStages: [ApiStage]?
    /// <p>The description of a usage plan.</p>
    public let description: String?
    /// <p>The identifier of a <a>UsagePlan</a> resource.</p>
    public let id: String?
    /// <p>The name of a usage plan.</p>
    public let name: String?
    /// <p>The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace.</p>
    public let productCode: String?
    /// <p>The maximum number of permitted requests per a given unit time interval.</p>
    public let quota: QuotaSettings?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The request throttle limits of a usage plan.</p>
    public let throttle: ThrottleSettings?

    public init (
        apiStages: [ApiStage]? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        productCode: String? = nil,
        quota: QuotaSettings? = nil,
        tags: [String:String]? = nil,
        throttle: ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct UpdateUsagePlanOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let apiStages: [ApiStage]?
    public let throttle: ThrottleSettings?
    public let quota: QuotaSettings?
    public let productCode: String?
    public let tags: [String:String]?
}

extension UpdateUsagePlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateVpcLinkInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVpcLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVpcLinkInput>
    public typealias MOutput = OperationOutput<UpdateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVpcLinkOutputError>
}

extension UpdateVpcLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVpcLinkInput(patchOperations: \(String(describing: patchOperations)), vpcLinkId: \(String(describing: vpcLinkId)))"}
}

extension UpdateVpcLinkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

public struct UpdateVpcLinkInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVpcLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVpcLinkInput>
    public typealias MOutput = OperationOutput<UpdateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVpcLinkOutputError>
}

public struct UpdateVpcLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVpcLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVpcLinkInput>
    public typealias MOutput = OperationOutput<UpdateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVpcLinkOutputError>
}

/// <p>Updates an existing <a>VpcLink</a> of a specified identifier.</p>
public struct UpdateVpcLinkInput: Equatable {
    /// <p>A list of update operations to be applied to the specified resource and in the order specified in this list.</p>
    public let patchOperations: [PatchOperation]?
    /// <p>[Required] The identifier of the  <a>VpcLink</a>. It is used in an <a>Integration</a> to reference this <a>VpcLink</a>.</p>
    public let vpcLinkId: String?

    public init (
        patchOperations: [PatchOperation]? = nil,
        vpcLinkId: String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.vpcLinkId = vpcLinkId
    }
}

struct UpdateVpcLinkInputBody: Equatable {
    public let patchOperations: [PatchOperation]?
}

extension UpdateVpcLinkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchOperations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateVpcLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVpcLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVpcLinkOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVpcLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVpcLinkOutputResponse(description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), tags: \(String(describing: tags)), targetArns: \(String(describing: targetArns)))"}
}

extension UpdateVpcLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.targetArns = output.targetArns
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.targetArns = nil
        }
    }
}

/// <p>An API Gateway VPC link for a <a>RestApi</a> to access resources in an Amazon Virtual Private Cloud (VPC).</p>
///         <div class="remarks">
///           <p><p>To enable access to a resource in an Amazon Virtual Private Cloud through Amazon API Gateway, you, as an API developer, create a <a>VpcLink</a> resource targeted for one or more network load balancers of the VPC and then integrate an API method with a private integration that uses the <a>VpcLink</a>. The private integration has an integration type of <code>HTTP</code> or <code>HTTP_PROXY</code> and has a connection type of <code>VPC_LINK</code>. The integration uses the <code>connectionId</code> property to identify the <a>VpcLink</a> used.</p></p>
///         </div>
public struct UpdateVpcLinkOutputResponse: Equatable {
    /// <p>The description of the VPC link.</p>
    public let description: String?
    /// <p>The identifier of the  <a>VpcLink</a>. It is used in an <a>Integration</a> to reference this <a>VpcLink</a>.</p>
    public let id: String?
    /// <p>The name used to label and identify the VPC link.</p>
    public let name: String?
    /// <p>The status of the VPC link. The valid values are <code>AVAILABLE</code>, <code>PENDING</code>, <code>DELETING</code>, or <code>FAILED</code>. Deploying an API will wait if the status is <code>PENDING</code> and will fail if the status is <code>DELETING</code>.</p>
    public let status: VpcLinkStatus?
    /// <p>A description about the VPC link status.</p>
    public let statusMessage: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.</p>
    public let targetArns: [String]?

    public init (
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        status: VpcLinkStatus? = nil,
        statusMessage: String? = nil,
        tags: [String:String]? = nil,
        targetArns: [String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct UpdateVpcLinkOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let targetArns: [String]?
    public let status: VpcLinkStatus?
    public let statusMessage: String?
    public let tags: [String:String]?
}

extension UpdateVpcLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UsagePlan: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiStages = apiStages {
            var apiStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .apiStages)
            for listofapistage0 in apiStages {
                try apiStagesContainer.encode(listofapistage0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productCode = productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let quota = quota {
            try encodeContainer.encode(quota, forKey: .quota)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let throttle = throttle {
            try encodeContainer.encode(throttle, forKey: .throttle)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UsagePlan: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsagePlan(apiStages: \(String(describing: apiStages)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), productCode: \(String(describing: productCode)), quota: \(String(describing: quota)), tags: \(String(describing: tags)), throttle: \(String(describing: throttle)))"}
}

/// <p>Represents a usage plan than can specify who can assess associated API stages with specified request limits and quotas.</p>
///       <div class="remarks">
///         <p>In a usage plan, you associate an API by specifying the API's Id and a stage name of the specified API. You add plan customers by adding API keys to the plan. </p>
///       </div>
///       <div class="seeAlso">
///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>
///       </div>
public struct UsagePlan: Equatable {
    /// <p>The associated API stages of a usage plan.</p>
    public let apiStages: [ApiStage]?
    /// <p>The description of a usage plan.</p>
    public let description: String?
    /// <p>The identifier of a <a>UsagePlan</a> resource.</p>
    public let id: String?
    /// <p>The name of a usage plan.</p>
    public let name: String?
    /// <p>The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace.</p>
    public let productCode: String?
    /// <p>The maximum number of permitted requests per a given unit time interval.</p>
    public let quota: QuotaSettings?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The request throttle limits of a usage plan.</p>
    public let throttle: ThrottleSettings?

    public init (
        apiStages: [ApiStage]? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        productCode: String? = nil,
        quota: QuotaSettings? = nil,
        tags: [String:String]? = nil,
        throttle: ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

extension UsagePlanKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case type
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UsagePlanKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsagePlanKey(id: \(String(describing: id)), name: \(String(describing: name)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Represents a usage plan key to identify a plan customer.</p>
///     <div class="remarks">
///       <p>To associate an API stage with a selected API key in a usage plan, you must create a UsagePlanKey resource to represent the selected <a>ApiKey</a>.</p>
///     </div>"
///     <div class="seeAlso">
///       <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html">Create and Use Usage Plans</a>
///     </div>
public struct UsagePlanKey: Equatable {
    /// <p>The Id of a usage plan key.</p>
    public let id: String?
    /// <p>The name of a usage plan key.</p>
    public let name: String?
    /// <p>The type of a usage plan key. Currently, the valid key type is <code>API_KEY</code>.</p>
    public let type: String?
    /// <p>The value of a usage plan key.</p>
    public let value: String?

    public init (
        id: String? = nil,
        name: String? = nil,
        type: String? = nil,
        value: String? = nil
    )
    {
        self.id = id
        self.name = name
        self.type = type
        self.value = value
    }
}

extension VpcLink: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targetArns = targetArns {
            var targetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetArns)
            for listofstring0 in targetArns {
                try targetArnsContainer.encode(listofstring0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension VpcLink: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcLink(description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), tags: \(String(describing: tags)), targetArns: \(String(describing: targetArns)))"}
}

/// <p>An API Gateway VPC link for a <a>RestApi</a> to access resources in an Amazon Virtual Private Cloud (VPC).</p>
///         <div class="remarks">
///           <p><p>To enable access to a resource in an Amazon Virtual Private Cloud through Amazon API Gateway, you, as an API developer, create a <a>VpcLink</a> resource targeted for one or more network load balancers of the VPC and then integrate an API method with a private integration that uses the <a>VpcLink</a>. The private integration has an integration type of <code>HTTP</code> or <code>HTTP_PROXY</code> and has a connection type of <code>VPC_LINK</code>. The integration uses the <code>connectionId</code> property to identify the <a>VpcLink</a> used.</p></p>
///         </div>
public struct VpcLink: Equatable {
    /// <p>The description of the VPC link.</p>
    public let description: String?
    /// <p>The identifier of the  <a>VpcLink</a>. It is used in an <a>Integration</a> to reference this <a>VpcLink</a>.</p>
    public let id: String?
    /// <p>The name used to label and identify the VPC link.</p>
    public let name: String?
    /// <p>The status of the VPC link. The valid values are <code>AVAILABLE</code>, <code>PENDING</code>, <code>DELETING</code>, or <code>FAILED</code>. Deploying an API will wait if the status is <code>PENDING</code> and will fail if the status is <code>DELETING</code>.</p>
    public let status: VpcLinkStatus?
    /// <p>A description about the VPC link status.</p>
    public let statusMessage: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.</p>
    public let targetArns: [String]?

    public init (
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        status: VpcLinkStatus? = nil,
        statusMessage: String? = nil,
        tags: [String:String]? = nil,
        targetArns: [String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

public enum VpcLinkStatus {
    case available
    case deleting
    case failed
    case pending
    case sdkUnknown(String)
}

extension VpcLinkStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VpcLinkStatus] {
        return [
            .available,
            .deleting,
            .failed,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VpcLinkStatus(rawValue: rawValue) ?? VpcLinkStatus.sdkUnknown(rawValue)
    }
}
