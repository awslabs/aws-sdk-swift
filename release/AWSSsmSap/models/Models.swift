// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SsmSapClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appRegistryArn = "AppRegistryArn"
        case arn = "Arn"
        case components = "Components"
        case id = "Id"
        case lastUpdated = "LastUpdated"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appRegistryArn = self.appRegistryArn {
            try encodeContainer.encode(appRegistryArn, forKey: .appRegistryArn)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentid0 in components {
                try componentsContainer.encode(componentid0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ApplicationType.self, forKey: .type)
        type = typeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let appRegistryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appRegistryArn)
        appRegistryArn = appRegistryArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .components)
        var componentsDecoded0:[Swift.String]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String]()
            for string0 in componentsContainer {
                if let string0 = string0 {
                    componentsDecoded0?.append(string0)
                }
            }
        }
        components = componentsDecoded0
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension SsmSapClientTypes {
    ///
    public struct Application: Swift.Equatable {
        ///
        public var appRegistryArn: Swift.String?
        ///
        public var arn: Swift.String?
        ///
        public var components: [Swift.String]?
        ///
        public var id: Swift.String?
        ///
        public var lastUpdated: ClientRuntime.Date?
        ///
        public var status: SsmSapClientTypes.ApplicationStatus?
        ///
        public var statusMessage: Swift.String?
        ///
        public var type: SsmSapClientTypes.ApplicationType?

        public init (
            appRegistryArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            components: [Swift.String]? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            status: SsmSapClientTypes.ApplicationStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: SsmSapClientTypes.ApplicationType? = nil
        )
        {
            self.appRegistryArn = appRegistryArn
            self.arn = arn
            self.components = components
            self.id = id
            self.lastUpdated = lastUpdated
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension SsmSapClientTypes.ApplicationCredential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialType = "CredentialType"
        case databaseName = "DatabaseName"
        case secretId = "SecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialType = self.credentialType {
            try encodeContainer.encode(credentialType.rawValue, forKey: .credentialType)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let secretId = self.secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let credentialTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.CredentialType.self, forKey: .credentialType)
        credentialType = credentialTypeDecoded
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension SsmSapClientTypes.ApplicationCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationCredential(credentialType: \(Swift.String(describing: credentialType)), databaseName: \(Swift.String(describing: databaseName)), secretId: \"CONTENT_REDACTED\")"}
}

extension SsmSapClientTypes {
    ///
    public struct ApplicationCredential: Swift.Equatable {
        ///
        /// This member is required.
        public var credentialType: SsmSapClientTypes.CredentialType?
        ///
        /// This member is required.
        public var databaseName: Swift.String?
        ///
        /// This member is required.
        public var secretId: Swift.String?

        public init (
            credentialType: SsmSapClientTypes.CredentialType? = nil,
            databaseName: Swift.String? = nil,
            secretId: Swift.String? = nil
        )
        {
            self.credentialType = credentialType
            self.databaseName = databaseName
            self.secretId = secretId
        }
    }

}

extension SsmSapClientTypes {
    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case deleting
        case failed
        case registering
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .activated,
                .deleting,
                .failed,
                .registering,
                .starting,
                .stopped,
                .stopping,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .registering: return "REGISTERING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ApplicationType.self, forKey: .type)
        type = typeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SsmSapClientTypes {
    ///
    public struct ApplicationSummary: Swift.Equatable {
        ///
        public var arn: Swift.String?
        ///
        public var id: Swift.String?
        ///
        public var tags: [Swift.String:Swift.String]?
        ///
        public var type: SsmSapClientTypes.ApplicationType?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: SsmSapClientTypes.ApplicationType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.tags = tags
            self.type = type
        }
    }

}

extension SsmSapClientTypes {
    public enum ApplicationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hana
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationType] {
            return [
                .hana,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hana: return "HANA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationType(rawValue: rawValue) ?? ApplicationType.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.Component: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
        case componentType = "ComponentType"
        case databases = "Databases"
        case hosts = "Hosts"
        case lastUpdated = "LastUpdated"
        case primaryHost = "PrimaryHost"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType.rawValue, forKey: .componentType)
        }
        if let databases = databases {
            var databasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .databases)
            for databaseid0 in databases {
                try databasesContainer.encode(databaseid0)
            }
        }
        if let hosts = hosts {
            var hostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hosts)
            for host0 in hosts {
                try hostsContainer.encode(host0)
            }
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let primaryHost = self.primaryHost {
            try encodeContainer.encode(primaryHost, forKey: .primaryHost)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ComponentType.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ComponentStatus.self, forKey: .status)
        status = statusDecoded
        let databasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .databases)
        var databasesDecoded0:[Swift.String]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [Swift.String]()
            for string0 in databasesContainer {
                if let string0 = string0 {
                    databasesDecoded0?.append(string0)
                }
            }
        }
        databases = databasesDecoded0
        let hostsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.Host?].self, forKey: .hosts)
        var hostsDecoded0:[SsmSapClientTypes.Host]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [SsmSapClientTypes.Host]()
            for structure0 in hostsContainer {
                if let structure0 = structure0 {
                    hostsDecoded0?.append(structure0)
                }
            }
        }
        hosts = hostsDecoded0
        let primaryHostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryHost)
        primaryHost = primaryHostDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension SsmSapClientTypes {
    ///
    public struct Component: Swift.Equatable {
        ///
        public var applicationId: Swift.String?
        ///
        public var componentId: Swift.String?
        ///
        public var componentType: SsmSapClientTypes.ComponentType?
        ///
        public var databases: [Swift.String]?
        ///
        public var hosts: [SsmSapClientTypes.Host]?
        ///
        public var lastUpdated: ClientRuntime.Date?
        ///
        public var primaryHost: Swift.String?
        ///
        public var status: SsmSapClientTypes.ComponentStatus?

        public init (
            applicationId: Swift.String? = nil,
            componentId: Swift.String? = nil,
            componentType: SsmSapClientTypes.ComponentType? = nil,
            databases: [Swift.String]? = nil,
            hosts: [SsmSapClientTypes.Host]? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            primaryHost: Swift.String? = nil,
            status: SsmSapClientTypes.ComponentStatus? = nil
        )
        {
            self.applicationId = applicationId
            self.componentId = componentId
            self.componentType = componentType
            self.databases = databases
            self.hosts = hosts
            self.lastUpdated = lastUpdated
            self.primaryHost = primaryHost
            self.status = status
        }
    }

}

extension SsmSapClientTypes {
    public enum ComponentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentStatus] {
            return [
                .activated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentStatus(rawValue: rawValue) ?? ComponentStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.ComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
        case componentType = "ComponentType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType.rawValue, forKey: .componentType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ComponentType.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SsmSapClientTypes {
    ///
    public struct ComponentSummary: Swift.Equatable {
        ///
        public var applicationId: Swift.String?
        ///
        public var componentId: Swift.String?
        ///
        public var componentType: SsmSapClientTypes.ComponentType?
        ///
        public var tags: [Swift.String:Swift.String]?

        public init (
            applicationId: Swift.String? = nil,
            componentId: Swift.String? = nil,
            componentType: SsmSapClientTypes.ComponentType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.applicationId = applicationId
            self.componentId = componentId
            self.componentType = componentType
            self.tags = tags
        }
    }

}

extension SsmSapClientTypes {
    public enum ComponentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hana
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentType] {
            return [
                .hana,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hana: return "HANA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentType(rawValue: rawValue) ?? ComponentType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmSapClientTypes {
    public enum CredentialType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case admin
        case sdkUnknown(Swift.String)

        public static var allCases: [CredentialType] {
            return [
                .admin,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CredentialType(rawValue: rawValue) ?? CredentialType.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.Database: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case componentId = "ComponentId"
        case credentials = "Credentials"
        case databaseId = "DatabaseId"
        case databaseName = "DatabaseName"
        case databaseType = "DatabaseType"
        case lastUpdated = "LastUpdated"
        case primaryHost = "PrimaryHost"
        case sqlPort = "SQLPort"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for applicationcredential0 in credentials {
                try credentialsContainer.encode(applicationcredential0)
            }
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let databaseType = self.databaseType {
            try encodeContainer.encode(databaseType.rawValue, forKey: .databaseType)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let primaryHost = self.primaryHost {
            try encodeContainer.encode(primaryHost, forKey: .primaryHost)
        }
        if let sqlPort = self.sqlPort {
            try encodeContainer.encode(sqlPort, forKey: .sqlPort)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let credentialsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ApplicationCredential?].self, forKey: .credentials)
        var credentialsDecoded0:[SsmSapClientTypes.ApplicationCredential]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [SsmSapClientTypes.ApplicationCredential]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let databaseTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.DatabaseType.self, forKey: .databaseType)
        databaseType = databaseTypeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.DatabaseStatus.self, forKey: .status)
        status = statusDecoded
        let primaryHostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryHost)
        primaryHost = primaryHostDecoded
        let sqlPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sqlPort)
        sqlPort = sqlPortDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension SsmSapClientTypes {
    ///
    public struct Database: Swift.Equatable {
        ///
        public var applicationId: Swift.String?
        ///
        public var arn: Swift.String?
        ///
        public var componentId: Swift.String?
        ///
        public var credentials: [SsmSapClientTypes.ApplicationCredential]?
        ///
        public var databaseId: Swift.String?
        ///
        public var databaseName: Swift.String?
        ///
        public var databaseType: SsmSapClientTypes.DatabaseType?
        ///
        public var lastUpdated: ClientRuntime.Date?
        ///
        public var primaryHost: Swift.String?
        ///
        public var sqlPort: Swift.Int?
        ///
        public var status: SsmSapClientTypes.DatabaseStatus?

        public init (
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            componentId: Swift.String? = nil,
            credentials: [SsmSapClientTypes.ApplicationCredential]? = nil,
            databaseId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databaseType: SsmSapClientTypes.DatabaseType? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            primaryHost: Swift.String? = nil,
            sqlPort: Swift.Int? = nil,
            status: SsmSapClientTypes.DatabaseStatus? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.componentId = componentId
            self.credentials = credentials
            self.databaseId = databaseId
            self.databaseName = databaseName
            self.databaseType = databaseType
            self.lastUpdated = lastUpdated
            self.primaryHost = primaryHost
            self.sqlPort = sqlPort
            self.status = status
        }
    }

}

extension SsmSapClientTypes {
    public enum DatabaseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case running
        case starting
        case stopped
        case unknown
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseStatus] {
            return [
                .running,
                .starting,
                .stopped,
                .unknown,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatabaseStatus(rawValue: rawValue) ?? DatabaseStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes.DatabaseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case componentId = "ComponentId"
        case databaseId = "DatabaseId"
        case databaseType = "DatabaseType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let databaseType = self.databaseType {
            try encodeContainer.encode(databaseType.rawValue, forKey: .databaseType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.DatabaseType.self, forKey: .databaseType)
        databaseType = databaseTypeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SsmSapClientTypes {
    ///
    public struct DatabaseSummary: Swift.Equatable {
        ///
        public var applicationId: Swift.String?
        ///
        public var arn: Swift.String?
        ///
        public var componentId: Swift.String?
        ///
        public var databaseId: Swift.String?
        ///
        public var databaseType: SsmSapClientTypes.DatabaseType?
        ///
        public var tags: [Swift.String:Swift.String]?

        public init (
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            componentId: Swift.String? = nil,
            databaseId: Swift.String? = nil,
            databaseType: SsmSapClientTypes.DatabaseType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.componentId = componentId
            self.databaseId = databaseId
            self.databaseType = databaseType
            self.tags = tags
        }
    }

}

extension SsmSapClientTypes {
    public enum DatabaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case system
        case tenant
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseType] {
            return [
                .system,
                .tenant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .system: return "SYSTEM"
            case .tenant: return "TENANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatabaseType(rawValue: rawValue) ?? DatabaseType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteResourcePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
        case sourceResourceArn = "SourceResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let sourceResourceArn = self.sourceResourceArn {
            try encodeContainer.encode(sourceResourceArn, forKey: .sourceResourceArn)
        }
    }
}

extension DeleteResourcePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-resource-permission"
    }
}

public struct DeleteResourcePermissionInput: Swift.Equatable {
    ///
    public var actionType: SsmSapClientTypes.PermissionActionType?
    ///
    /// This member is required.
    public var resourceArn: Swift.String?
    ///
    public var sourceResourceArn: Swift.String?

    public init (
        actionType: SsmSapClientTypes.PermissionActionType? = nil,
        resourceArn: Swift.String? = nil,
        sourceResourceArn: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.resourceArn = resourceArn
        self.sourceResourceArn = sourceResourceArn
    }
}

struct DeleteResourcePermissionInputBody: Swift.Equatable {
    let actionType: SsmSapClientTypes.PermissionActionType?
    let sourceResourceArn: Swift.String?
    let resourceArn: Swift.String?
}

extension DeleteResourcePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
        case sourceResourceArn = "SourceResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.PermissionActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let sourceResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceResourceArn)
        sourceResourceArn = sourceResourceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourcePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourcePermissionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteResourcePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DeleteResourcePermissionOutputResponse: Swift.Equatable {
    ///
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct DeleteResourcePermissionOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
}

extension DeleteResourcePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension DeregisterApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
    }
}

extension DeregisterApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deregister-application"
    }
}

public struct DeregisterApplicationInput: Swift.Equatable {
    ///
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeregisterApplicationInputBody: Swift.Equatable {
    let applicationId: Swift.String?
}

extension DeregisterApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
    }
}

extension DeregisterApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case applicationId = "ApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
    }
}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-application"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    ///
    public var applicationArn: Swift.String?
    ///
    public var applicationId: Swift.String?

    public init (
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
    }
}

struct GetApplicationInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let applicationArn: Swift.String?
}

extension GetApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case applicationId = "ApplicationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension GetApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
            self.tags = output.tags
        } else {
            self.application = nil
            self.tags = nil
        }
    }
}

public struct GetApplicationOutputResponse: Swift.Equatable {
    ///
    public var application: SsmSapClientTypes.Application?
    ///
    public var tags: [Swift.String:Swift.String]?

    public init (
        application: SsmSapClientTypes.Application? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.application = application
        self.tags = tags
    }
}

struct GetApplicationOutputResponseBody: Swift.Equatable {
    let application: SsmSapClientTypes.Application?
    let tags: [Swift.String:Swift.String]?
}

extension GetApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application = "Application"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
    }
}

extension GetComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-component"
    }
}

public struct GetComponentInput: Swift.Equatable {
    ///
    /// This member is required.
    public var applicationId: Swift.String?
    ///
    /// This member is required.
    public var componentId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        componentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.componentId = componentId
    }
}

struct GetComponentInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let componentId: Swift.String?
}

extension GetComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
    }
}

extension GetComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.component = output.component
        } else {
            self.component = nil
        }
    }
}

public struct GetComponentOutputResponse: Swift.Equatable {
    ///
    public var component: SsmSapClientTypes.Component?

    public init (
        component: SsmSapClientTypes.Component? = nil
    )
    {
        self.component = component
    }
}

struct GetComponentOutputResponseBody: Swift.Equatable {
    let component: SsmSapClientTypes.Component?
}

extension GetComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component = "Component"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

extension GetDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
        case databaseArn = "DatabaseArn"
        case databaseId = "DatabaseId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let databaseArn = self.databaseArn {
            try encodeContainer.encode(databaseArn, forKey: .databaseArn)
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
    }
}

extension GetDatabaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-database"
    }
}

public struct GetDatabaseInput: Swift.Equatable {
    ///
    public var applicationId: Swift.String?
    ///
    public var componentId: Swift.String?
    ///
    public var databaseArn: Swift.String?
    ///
    public var databaseId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        componentId: Swift.String? = nil,
        databaseArn: Swift.String? = nil,
        databaseId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.componentId = componentId
        self.databaseArn = databaseArn
        self.databaseId = databaseId
    }
}

struct GetDatabaseInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let componentId: Swift.String?
    let databaseId: Swift.String?
    let databaseArn: Swift.String?
}

extension GetDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
        case databaseArn = "DatabaseArn"
        case databaseId = "DatabaseId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseArn)
        databaseArn = databaseArnDecoded
    }
}

extension GetDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDatabaseOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
            self.tags = output.tags
        } else {
            self.database = nil
            self.tags = nil
        }
    }
}

public struct GetDatabaseOutputResponse: Swift.Equatable {
    ///
    public var database: SsmSapClientTypes.Database?
    ///
    public var tags: [Swift.String:Swift.String]?

    public init (
        database: SsmSapClientTypes.Database? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.database = database
        self.tags = tags
    }
}

struct GetDatabaseOutputResponseBody: Swift.Equatable {
    let database: SsmSapClientTypes.Database?
    let tags: [Swift.String:Swift.String]?
}

extension GetDatabaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationId = self.operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
    }
}

extension GetOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-operation"
    }
}

public struct GetOperationInput: Swift.Equatable {
    ///
    /// This member is required.
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct GetOperationInputBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension GetOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension GetOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOperationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetOperationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operation = output.operation
        } else {
            self.operation = nil
        }
    }
}

public struct GetOperationOutputResponse: Swift.Equatable {
    ///
    public var operation: SsmSapClientTypes.Operation?

    public init (
        operation: SsmSapClientTypes.Operation? = nil
    )
    {
        self.operation = operation
    }
}

struct GetOperationOutputResponseBody: Swift.Equatable {
    let operation: SsmSapClientTypes.Operation?
}

extension GetOperationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "Operation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
    }
}

extension GetResourcePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension GetResourcePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-resource-permission"
    }
}

public struct GetResourcePermissionInput: Swift.Equatable {
    ///
    public var actionType: SsmSapClientTypes.PermissionActionType?
    ///
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        actionType: SsmSapClientTypes.PermissionActionType? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.resourceArn = resourceArn
    }
}

struct GetResourcePermissionInputBody: Swift.Equatable {
    let actionType: SsmSapClientTypes.PermissionActionType?
    let resourceArn: Swift.String?
}

extension GetResourcePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.PermissionActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetResourcePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourcePermissionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourcePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetResourcePermissionOutputResponse: Swift.Equatable {
    ///
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetResourcePermissionOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetResourcePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension SsmSapClientTypes.Host: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostIp = "HostIp"
        case hostName = "HostName"
        case hostRole = "HostRole"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostIp = self.hostIp {
            try encodeContainer.encode(hostIp, forKey: .hostIp)
        }
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let hostRole = self.hostRole {
            try encodeContainer.encode(hostRole.rawValue, forKey: .hostRole)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let hostRoleDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.HostRole.self, forKey: .hostRole)
        hostRole = hostRoleDecoded
        let hostIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostIp)
        hostIp = hostIpDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension SsmSapClientTypes {
    ///
    public struct Host: Swift.Equatable {
        ///
        public var hostIp: Swift.String?
        ///
        public var hostName: Swift.String?
        ///
        public var hostRole: SsmSapClientTypes.HostRole?
        ///
        public var instanceId: Swift.String?

        public init (
            hostIp: Swift.String? = nil,
            hostName: Swift.String? = nil,
            hostRole: SsmSapClientTypes.HostRole? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.hostIp = hostIp
            self.hostName = hostName
            self.hostRole = hostRole
            self.instanceId = instanceId
        }
    }

}

extension SsmSapClientTypes {
    public enum HostRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case leader
        case standby
        case unknown
        case worker
        case sdkUnknown(Swift.String)

        public static var allCases: [HostRole] {
            return [
                .leader,
                .standby,
                .unknown,
                .worker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .leader: return "LEADER"
            case .standby: return "STANDBY"
            case .unknown: return "UNKNOWN"
            case .worker: return "WORKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HostRole(rawValue: rawValue) ?? HostRole.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    ///
    public var maxResults: Swift.Int?
    ///
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Swift.Equatable {
    ///
    public var applications: [SsmSapClientTypes.ApplicationSummary]?
    ///
    public var nextToken: Swift.String?

    public init (
        applications: [SsmSapClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    let applications: [SsmSapClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[SsmSapClientTypes.ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [SsmSapClientTypes.ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-components"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    ///
    public var applicationId: Swift.String?
    ///
    public var maxResults: Swift.Int?
    ///
    public var nextToken: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentsInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListComponentsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.components = output.components
            self.nextToken = output.nextToken
        } else {
            self.components = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutputResponse: Swift.Equatable {
    ///
    public var components: [SsmSapClientTypes.ComponentSummary]?
    ///
    public var nextToken: Swift.String?

    public init (
        components: [SsmSapClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.components = components
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputResponseBody: Swift.Equatable {
    let components: [SsmSapClientTypes.ComponentSummary]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components = "Components"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ComponentSummary?].self, forKey: .components)
        var componentsDecoded0:[SsmSapClientTypes.ComponentSummary]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [SsmSapClientTypes.ComponentSummary]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-databases"
    }
}

public struct ListDatabasesInput: Swift.Equatable {
    ///
    public var applicationId: Swift.String?
    ///
    public var componentId: Swift.String?
    ///
    public var maxResults: Swift.Int?
    ///
    public var nextToken: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        componentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.componentId = componentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatabasesInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let componentId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case componentId = "ComponentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatabasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatabasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatabasesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatabasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databases = output.databases
            self.nextToken = output.nextToken
        } else {
            self.databases = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutputResponse: Swift.Equatable {
    ///
    public var databases: [SsmSapClientTypes.DatabaseSummary]?
    ///
    public var nextToken: Swift.String?

    public init (
        databases: [SsmSapClientTypes.DatabaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputResponseBody: Swift.Equatable {
    let databases: [SsmSapClientTypes.DatabaseSummary]?
    let nextToken: Swift.String?
}

extension ListDatabasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databases = "Databases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databasesContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.DatabaseSummary?].self, forKey: .databases)
        var databasesDecoded0:[SsmSapClientTypes.DatabaseSummary]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [SsmSapClientTypes.DatabaseSummary]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    ///
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    ///
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SsmSapClientTypes.Operation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case id = "Id"
        case lastUpdatedTime = "LastUpdatedTime"
        case properties = "Properties"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case startTime = "StartTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, operationProperties0) in properties {
                guard let operationProperties0 = operationProperties0 else {
                    try propertiesContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try propertiesContainer.encode(operationProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:Swift.String?]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in propertiesContainer {
                propertiesDecoded0?[key0] = string0
            }
        }
        properties = propertiesDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension SsmSapClientTypes {
    ///
    public struct Operation: Swift.Equatable {
        ///
        public var endTime: ClientRuntime.Date?
        ///
        public var id: Swift.String?
        ///
        public var lastUpdatedTime: ClientRuntime.Date?
        ///
        public var properties: [Swift.String:Swift.String?]?
        ///
        public var resourceArn: Swift.String?
        ///
        public var resourceId: Swift.String?
        ///
        public var resourceType: Swift.String?
        ///
        public var startTime: ClientRuntime.Date?
        ///
        public var status: SsmSapClientTypes.OperationStatus?
        ///
        public var statusMessage: Swift.String?
        ///
        public var type: Swift.String?

        public init (
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            properties: [Swift.String:Swift.String?]? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: SsmSapClientTypes.OperationStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.properties = properties
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension SsmSapClientTypes {
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case inprogress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .error,
                .inprogress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .inprogress: return "INPROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmSapClientTypes {
    public enum PermissionActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case restore
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionActionType] {
            return [
                .restore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .restore: return "RESTORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionActionType(rawValue: rawValue) ?? PermissionActionType.sdkUnknown(rawValue)
        }
    }
}

extension PutResourcePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
        case sourceResourceArn = "SourceResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let sourceResourceArn = self.sourceResourceArn {
            try encodeContainer.encode(sourceResourceArn, forKey: .sourceResourceArn)
        }
    }
}

extension PutResourcePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/put-resource-permission"
    }
}

public struct PutResourcePermissionInput: Swift.Equatable {
    ///
    /// This member is required.
    public var actionType: SsmSapClientTypes.PermissionActionType?
    ///
    /// This member is required.
    public var resourceArn: Swift.String?
    ///
    /// This member is required.
    public var sourceResourceArn: Swift.String?

    public init (
        actionType: SsmSapClientTypes.PermissionActionType? = nil,
        resourceArn: Swift.String? = nil,
        sourceResourceArn: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.resourceArn = resourceArn
        self.sourceResourceArn = sourceResourceArn
    }
}

struct PutResourcePermissionInputBody: Swift.Equatable {
    let actionType: SsmSapClientTypes.PermissionActionType?
    let sourceResourceArn: Swift.String?
    let resourceArn: Swift.String?
}

extension PutResourcePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case resourceArn = "ResourceArn"
        case sourceResourceArn = "SourceResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.PermissionActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let sourceResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceResourceArn)
        sourceResourceArn = sourceResourceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension PutResourcePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutResourcePermissionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutResourcePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct PutResourcePermissionOutputResponse: Swift.Equatable {
    ///
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct PutResourcePermissionOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutResourcePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension RegisterApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case applicationType = "ApplicationType"
        case credentials = "Credentials"
        case instances = "Instances"
        case sapInstanceNumber = "SapInstanceNumber"
        case sid = "Sid"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let applicationType = self.applicationType {
            try encodeContainer.encode(applicationType.rawValue, forKey: .applicationType)
        }
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for applicationcredential0 in credentials {
                try credentialsContainer.encode(applicationcredential0)
            }
        }
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for instanceid0 in instances {
                try instancesContainer.encode(instanceid0)
            }
        }
        if let sapInstanceNumber = self.sapInstanceNumber {
            try encodeContainer.encode(sapInstanceNumber, forKey: .sapInstanceNumber)
        }
        if let sid = self.sid {
            try encodeContainer.encode(sid, forKey: .sid)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension RegisterApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/register-application"
    }
}

public struct RegisterApplicationInput: Swift.Equatable {
    ///
    /// This member is required.
    public var applicationId: Swift.String?
    ///
    /// This member is required.
    public var applicationType: SsmSapClientTypes.ApplicationType?
    ///
    /// This member is required.
    public var credentials: [SsmSapClientTypes.ApplicationCredential]?
    ///
    /// This member is required.
    public var instances: [Swift.String]?
    ///
    public var sapInstanceNumber: Swift.String?
    ///
    public var sid: Swift.String?
    ///
    public var tags: [Swift.String:Swift.String]?

    public init (
        applicationId: Swift.String? = nil,
        applicationType: SsmSapClientTypes.ApplicationType? = nil,
        credentials: [SsmSapClientTypes.ApplicationCredential]? = nil,
        instances: [Swift.String]? = nil,
        sapInstanceNumber: Swift.String? = nil,
        sid: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.applicationType = applicationType
        self.credentials = credentials
        self.instances = instances
        self.sapInstanceNumber = sapInstanceNumber
        self.sid = sid
        self.tags = tags
    }
}

struct RegisterApplicationInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let applicationType: SsmSapClientTypes.ApplicationType?
    let instances: [Swift.String]?
    let sapInstanceNumber: Swift.String?
    let sid: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let credentials: [SsmSapClientTypes.ApplicationCredential]?
}

extension RegisterApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case applicationType = "ApplicationType"
        case credentials = "Credentials"
        case instances = "Instances"
        case sapInstanceNumber = "SapInstanceNumber"
        case sid = "Sid"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationTypeDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.ApplicationType.self, forKey: .applicationType)
        applicationType = applicationTypeDecoded
        let instancesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instances)
        var instancesDecoded0:[Swift.String]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [Swift.String]()
            for string0 in instancesContainer {
                if let string0 = string0 {
                    instancesDecoded0?.append(string0)
                }
            }
        }
        instances = instancesDecoded0
        let sapInstanceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sapInstanceNumber)
        sapInstanceNumber = sapInstanceNumberDecoded
        let sidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sid)
        sid = sidDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let credentialsContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ApplicationCredential?].self, forKey: .credentials)
        var credentialsDecoded0:[SsmSapClientTypes.ApplicationCredential]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [SsmSapClientTypes.ApplicationCredential]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
    }
}

extension RegisterApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterApplicationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
            self.operationId = output.operationId
        } else {
            self.application = nil
            self.operationId = nil
        }
    }
}

public struct RegisterApplicationOutputResponse: Swift.Equatable {
    ///
    public var application: SsmSapClientTypes.Application?
    ///
    public var operationId: Swift.String?

    public init (
        application: SsmSapClientTypes.Application? = nil,
        operationId: Swift.String? = nil
    )
    {
        self.application = application
        self.operationId = operationId
    }
}

struct RegisterApplicationOutputResponseBody: Swift.Equatable {
    let application: SsmSapClientTypes.Application?
    let operationId: Swift.String?
}

extension RegisterApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application = "Application"
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(SsmSapClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    ///
    /// This member is required.
    public var resourceArn: Swift.String?
    ///
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    ///
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds/updates or removes credentials for applications registered with AWS Systems Manager for SAP.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateApplicationSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case credentialsToAddOrUpdate = "CredentialsToAddOrUpdate"
        case credentialsToRemove = "CredentialsToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let credentialsToAddOrUpdate = credentialsToAddOrUpdate {
            var credentialsToAddOrUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentialsToAddOrUpdate)
            for applicationcredential0 in credentialsToAddOrUpdate {
                try credentialsToAddOrUpdateContainer.encode(applicationcredential0)
            }
        }
        if let credentialsToRemove = credentialsToRemove {
            var credentialsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentialsToRemove)
            for applicationcredential0 in credentialsToRemove {
                try credentialsToRemoveContainer.encode(applicationcredential0)
            }
        }
    }
}

extension UpdateApplicationSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-application-settings"
    }
}

public struct UpdateApplicationSettingsInput: Swift.Equatable {
    ///
    /// This member is required.
    public var applicationId: Swift.String?
    ///
    public var credentialsToAddOrUpdate: [SsmSapClientTypes.ApplicationCredential]?
    ///
    public var credentialsToRemove: [SsmSapClientTypes.ApplicationCredential]?

    public init (
        applicationId: Swift.String? = nil,
        credentialsToAddOrUpdate: [SsmSapClientTypes.ApplicationCredential]? = nil,
        credentialsToRemove: [SsmSapClientTypes.ApplicationCredential]? = nil
    )
    {
        self.applicationId = applicationId
        self.credentialsToAddOrUpdate = credentialsToAddOrUpdate
        self.credentialsToRemove = credentialsToRemove
    }
}

struct UpdateApplicationSettingsInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let credentialsToAddOrUpdate: [SsmSapClientTypes.ApplicationCredential]?
    let credentialsToRemove: [SsmSapClientTypes.ApplicationCredential]?
}

extension UpdateApplicationSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case credentialsToAddOrUpdate = "CredentialsToAddOrUpdate"
        case credentialsToRemove = "CredentialsToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let credentialsToAddOrUpdateContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ApplicationCredential?].self, forKey: .credentialsToAddOrUpdate)
        var credentialsToAddOrUpdateDecoded0:[SsmSapClientTypes.ApplicationCredential]? = nil
        if let credentialsToAddOrUpdateContainer = credentialsToAddOrUpdateContainer {
            credentialsToAddOrUpdateDecoded0 = [SsmSapClientTypes.ApplicationCredential]()
            for structure0 in credentialsToAddOrUpdateContainer {
                if let structure0 = structure0 {
                    credentialsToAddOrUpdateDecoded0?.append(structure0)
                }
            }
        }
        credentialsToAddOrUpdate = credentialsToAddOrUpdateDecoded0
        let credentialsToRemoveContainer = try containerValues.decodeIfPresent([SsmSapClientTypes.ApplicationCredential?].self, forKey: .credentialsToRemove)
        var credentialsToRemoveDecoded0:[SsmSapClientTypes.ApplicationCredential]? = nil
        if let credentialsToRemoveContainer = credentialsToRemoveContainer {
            credentialsToRemoveDecoded0 = [SsmSapClientTypes.ApplicationCredential]()
            for structure0 in credentialsToRemoveContainer {
                if let structure0 = structure0 {
                    credentialsToRemoveDecoded0?.append(structure0)
                }
            }
        }
        credentialsToRemove = credentialsToRemoveDecoded0
    }
}

extension UpdateApplicationSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApplicationSettingsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateApplicationSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.operationIds = output.operationIds
        } else {
            self.message = nil
            self.operationIds = nil
        }
    }
}

public struct UpdateApplicationSettingsOutputResponse: Swift.Equatable {
    ///
    public var message: Swift.String?
    ///
    public var operationIds: [Swift.String]?

    public init (
        message: Swift.String? = nil,
        operationIds: [Swift.String]? = nil
    )
    {
        self.message = message
        self.operationIds = operationIds
    }
}

struct UpdateApplicationSettingsOutputResponseBody: Swift.Equatable {
    let message: Swift.String?
    let operationIds: [Swift.String]?
}

extension UpdateApplicationSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case operationIds = "OperationIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let operationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .operationIds)
        var operationIdsDecoded0:[Swift.String]? = nil
        if let operationIdsContainer = operationIdsContainer {
            operationIdsDecoded0 = [Swift.String]()
            for string0 in operationIdsContainer {
                if let string0 = string0 {
                    operationIdsDecoded0?.append(string0)
                }
            }
        }
        operationIds = operationIdsDecoded0
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
