// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ASN1Subject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commonName = "CommonName"
        case country = "Country"
        case distinguishedNameQualifier = "DistinguishedNameQualifier"
        case generationQualifier = "GenerationQualifier"
        case givenName = "GivenName"
        case initials = "Initials"
        case locality = "Locality"
        case organization = "Organization"
        case organizationalUnit = "OrganizationalUnit"
        case pseudonym = "Pseudonym"
        case serialNumber = "SerialNumber"
        case state = "State"
        case surname = "Surname"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commonName = commonName {
            try encodeContainer.encode(commonName, forKey: .commonName)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let distinguishedNameQualifier = distinguishedNameQualifier {
            try encodeContainer.encode(distinguishedNameQualifier, forKey: .distinguishedNameQualifier)
        }
        if let generationQualifier = generationQualifier {
            try encodeContainer.encode(generationQualifier, forKey: .generationQualifier)
        }
        if let givenName = givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let initials = initials {
            try encodeContainer.encode(initials, forKey: .initials)
        }
        if let locality = locality {
            try encodeContainer.encode(locality, forKey: .locality)
        }
        if let organization = organization {
            try encodeContainer.encode(organization, forKey: .organization)
        }
        if let organizationalUnit = organizationalUnit {
            try encodeContainer.encode(organizationalUnit, forKey: .organizationalUnit)
        }
        if let pseudonym = pseudonym {
            try encodeContainer.encode(pseudonym, forKey: .pseudonym)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let surname = surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .country)
        country = countryDecoded
        let organizationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organization)
        organization = organizationDecoded
        let organizationalUnitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnit)
        organizationalUnit = organizationalUnitDecoded
        let distinguishedNameQualifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distinguishedNameQualifier)
        distinguishedNameQualifier = distinguishedNameQualifierDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let commonNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commonName)
        commonName = commonNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let localityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locality)
        locality = localityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .surname)
        surname = surnameDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let initialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initials)
        initials = initialsDecoded
        let pseudonymDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pseudonym)
        pseudonym = pseudonymDecoded
        let generationQualifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationQualifier)
        generationQualifier = generationQualifierDecoded
    }
}

extension ASN1Subject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ASN1Subject(commonName: \(String(describing: commonName)), country: \(String(describing: country)), distinguishedNameQualifier: \(String(describing: distinguishedNameQualifier)), generationQualifier: \(String(describing: generationQualifier)), givenName: \(String(describing: givenName)), initials: \(String(describing: initials)), locality: \(String(describing: locality)), organization: \(String(describing: organization)), organizationalUnit: \(String(describing: organizationalUnit)), pseudonym: \(String(describing: pseudonym)), serialNumber: \(String(describing: serialNumber)), state: \(String(describing: state)), surname: \(String(describing: surname)), title: \(String(describing: title)))"}
}

/// <p>Contains information about the certificate subject. The <code>Subject</code> field in
/// 			the certificate identifies the entity that owns or controls the public key in the
/// 			certificate. The entity can be a user, computer, device, or service. The <code>Subject
/// 			</code>must contain an X.500 distinguished name (DN). A DN is a sequence of relative
/// 			distinguished names (RDNs). The RDNs are separated by commas in the certificate.</p>
public struct ASN1Subject: Equatable {
    /// <p>For CA and end-entity certificates in a private PKI, the common name (CN) can be any
    /// 			string within the length limit. </p>
    /// 		       <p>Note: In publicly trusted certificates, the common name must be a fully qualified
    /// 			domain name (FQDN) associated with the certificate subject.</p>
    public let commonName: String?
    /// <p>Two-digit code that specifies the country in which the certificate subject
    /// 			located.</p>
    public let country: String?
    /// <p>Disambiguating information for the certificate subject.</p>
    public let distinguishedNameQualifier: String?
    /// <p>Typically a qualifier appended to the name of an individual. Examples include Jr. for
    /// 			junior, Sr. for senior, and III for third.</p>
    public let generationQualifier: String?
    /// <p>First name.</p>
    public let givenName: String?
    /// <p>Concatenation that typically contains the first letter of the <b>GivenName</b>, the first letter of the middle name if one exists, and the
    /// 			first letter of the <b>Surname</b>.</p>
    public let initials: String?
    /// <p>The locality (such as a city or town) in which the certificate subject is
    /// 			located.</p>
    public let locality: String?
    /// <p>Legal name of the organization with which the certificate subject is affiliated.
    /// 		</p>
    public let organization: String?
    /// <p>A subdivision or unit of the organization (such as sales or finance) with which the
    /// 			certificate subject is affiliated.</p>
    public let organizationalUnit: String?
    /// <p>Typically a shortened version of a longer <b>GivenName</b>.
    /// 			For example, Jonathan is often shortened to John. Elizabeth is often shortened to Beth,
    /// 			Liz, or Eliza.</p>
    public let pseudonym: String?
    /// <p>The certificate serial number.</p>
    public let serialNumber: String?
    /// <p>State in which the subject of the certificate is located.</p>
    public let state: String?
    /// <p>Family name. In the US and the UK, for example, the surname of an individual is
    /// 			ordered last. In Asian cultures the surname is typically ordered first.</p>
    public let surname: String?
    /// <p>A title such as Mr. or Ms., which is pre-pended to the name to refer formally to the
    /// 			certificate subject.</p>
    public let title: String?

    public init (
        commonName: String? = nil,
        country: String? = nil,
        distinguishedNameQualifier: String? = nil,
        generationQualifier: String? = nil,
        givenName: String? = nil,
        initials: String? = nil,
        locality: String? = nil,
        organization: String? = nil,
        organizationalUnit: String? = nil,
        pseudonym: String? = nil,
        serialNumber: String? = nil,
        state: String? = nil,
        surname: String? = nil,
        title: String? = nil
    )
    {
        self.commonName = commonName
        self.country = country
        self.distinguishedNameQualifier = distinguishedNameQualifier
        self.generationQualifier = generationQualifier
        self.givenName = givenName
        self.initials = initials
        self.locality = locality
        self.organization = organization
        self.organizationalUnit = organizationalUnit
        self.pseudonym = pseudonym
        self.serialNumber = serialNumber
        self.state = state
        self.surname = surname
        self.title = title
    }
}

extension AccessDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLocation = "AccessLocation"
        case accessMethod = "AccessMethod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLocation = accessLocation {
            try encodeContainer.encode(accessLocation, forKey: .accessLocation)
        }
        if let accessMethod = accessMethod {
            try encodeContainer.encode(accessMethod, forKey: .accessMethod)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessMethodDecoded = try containerValues.decodeIfPresent(AccessMethod.self, forKey: .accessMethod)
        accessMethod = accessMethodDecoded
        let accessLocationDecoded = try containerValues.decodeIfPresent(GeneralName.self, forKey: .accessLocation)
        accessLocation = accessLocationDecoded
    }
}

extension AccessDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDescription(accessLocation: \(String(describing: accessLocation)), accessMethod: \(String(describing: accessMethod)))"}
}

/// <p>Provides access information used by the <code>authorityInfoAccess</code> and
/// 				<code>subjectInfoAccess</code> extensions described in <a href="https://tools.ietf.org/html/rfc5280">RFC 5280</a>.</p>
public struct AccessDescription: Equatable {
    /// <p>The location of <code>AccessDescription</code> information.</p>
    public let accessLocation: GeneralName?
    /// <p>The type and format of <code>AccessDescription</code> information.</p>
    public let accessMethod: AccessMethod?

    public init (
        accessLocation: GeneralName? = nil,
        accessMethod: AccessMethod? = nil
    )
    {
        self.accessLocation = accessLocation
        self.accessMethod = accessMethod
    }
}

extension AccessMethod: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessMethodType = "AccessMethodType"
        case customObjectIdentifier = "CustomObjectIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessMethodType = accessMethodType {
            try encodeContainer.encode(accessMethodType.rawValue, forKey: .accessMethodType)
        }
        if let customObjectIdentifier = customObjectIdentifier {
            try encodeContainer.encode(customObjectIdentifier, forKey: .customObjectIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customObjectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customObjectIdentifier)
        customObjectIdentifier = customObjectIdentifierDecoded
        let accessMethodTypeDecoded = try containerValues.decodeIfPresent(AccessMethodType.self, forKey: .accessMethodType)
        accessMethodType = accessMethodTypeDecoded
    }
}

extension AccessMethod: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessMethod(accessMethodType: \(String(describing: accessMethodType)), customObjectIdentifier: \(String(describing: customObjectIdentifier)))"}
}

/// <p>Describes the type and format of extension access. Only one of
/// 				<code>CustomObjectIdentifier</code> or <code>AccessMethodType</code> may be
/// 			provided. Providing both results in <code>InvalidArgsException</code>.</p>
public struct AccessMethod: Equatable {
    /// <p>Specifies the <code>AccessMethod</code>.</p>
    public let accessMethodType: AccessMethodType?
    /// <p>An object identifier (OID) specifying the <code>AccessMethod</code>. The OID must
    /// 			satisfy the regular expression shown below. For more information, see NIST's definition
    /// 			of <a href="https://csrc.nist.gov/glossary/term/Object_Identifier">Object Identifier
    /// 				(OID)</a>.</p>
    public let customObjectIdentifier: String?

    public init (
        accessMethodType: AccessMethodType? = nil,
        customObjectIdentifier: String? = nil
    )
    {
        self.accessMethodType = accessMethodType
        self.customObjectIdentifier = customObjectIdentifier
    }
}

public enum AccessMethodType {
    case caRepository
    case resourcePkiManifest
    case resourcePkiNotify
    case sdkUnknown(String)
}

extension AccessMethodType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessMethodType] {
        return [
            .caRepository,
            .resourcePkiManifest,
            .resourcePkiNotify,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .caRepository: return "CA_REPOSITORY"
        case .resourcePkiManifest: return "RESOURCE_PKI_MANIFEST"
        case .resourcePkiNotify: return "RESOURCE_PKI_NOTIFY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessMethodType(rawValue: rawValue) ?? AccessMethodType.sdkUnknown(rawValue)
    }
}

public enum ActionType {
    case getcertificate
    case issuecertificate
    case listpermissions
    case sdkUnknown(String)
}

extension ActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionType] {
        return [
            .getcertificate,
            .issuecertificate,
            .listpermissions,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .getcertificate: return "GetCertificate"
        case .issuecertificate: return "IssueCertificate"
        case .listpermissions: return "ListPermissions"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
    }
}

extension ApiPassthrough: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case extensions = "Extensions"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let extensions = extensions {
            try encodeContainer.encode(extensions, forKey: .extensions)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionsDecoded = try containerValues.decodeIfPresent(Extensions.self, forKey: .extensions)
        extensions = extensionsDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(ASN1Subject.self, forKey: .subject)
        subject = subjectDecoded
    }
}

extension ApiPassthrough: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiPassthrough(extensions: \(String(describing: extensions)), subject: \(String(describing: subject)))"}
}

/// <p>Contains X.509 certificate information to be placed in an issued certificate. An
/// 				<code>APIPassthrough</code> or <code>APICSRPassthrough</code> template variant must
/// 			be selected, or else this parameter is ignored. </p>
/// 		       <p>If conflicting or duplicate certificate information is supplied from other sources,
/// 			ACM Private CA applies <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/UsingTemplates.html#template-order-of-operations">order of
/// 				operation rules</a> to determine what information is used.</p>
public struct ApiPassthrough: Equatable {
    /// <p>Specifies X.509 extension information for a certificate.</p>
    public let extensions: Extensions?
    /// <p>Contains information about the certificate subject. The <code>Subject</code> field in
    /// 			the certificate identifies the entity that owns or controls the public key in the
    /// 			certificate. The entity can be a user, computer, device, or service. The <code>Subject
    /// 			</code>must contain an X.500 distinguished name (DN). A DN is a sequence of relative
    /// 			distinguished names (RDNs). The RDNs are separated by commas in the certificate.</p>
    public let subject: ASN1Subject?

    public init (
        extensions: Extensions? = nil,
        subject: ASN1Subject? = nil
    )
    {
        self.extensions = extensions
        self.subject = subject
    }
}

public enum AuditReportResponseFormat {
    case csv
    case json
    case sdkUnknown(String)
}

extension AuditReportResponseFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuditReportResponseFormat] {
        return [
            .csv,
            .json,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .json: return "JSON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuditReportResponseFormat(rawValue: rawValue) ?? AuditReportResponseFormat.sdkUnknown(rawValue)
    }
}

public enum AuditReportStatus {
    case creating
    case failed
    case success
    case sdkUnknown(String)
}

extension AuditReportStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuditReportStatus] {
        return [
            .creating,
            .failed,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creating: return "CREATING"
        case .failed: return "FAILED"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuditReportStatus(rawValue: rawValue) ?? AuditReportStatus.sdkUnknown(rawValue)
    }
}

extension CertificateAuthority: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case certificateAuthorityConfiguration = "CertificateAuthorityConfiguration"
        case createdAt = "CreatedAt"
        case failureReason = "FailureReason"
        case keyStorageSecurityStandard = "KeyStorageSecurityStandard"
        case lastStateChangeAt = "LastStateChangeAt"
        case notAfter = "NotAfter"
        case notBefore = "NotBefore"
        case ownerAccount = "OwnerAccount"
        case restorableUntil = "RestorableUntil"
        case revocationConfiguration = "RevocationConfiguration"
        case serial = "Serial"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificateAuthorityConfiguration = certificateAuthorityConfiguration {
            try encodeContainer.encode(certificateAuthorityConfiguration, forKey: .certificateAuthorityConfiguration)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let keyStorageSecurityStandard = keyStorageSecurityStandard {
            try encodeContainer.encode(keyStorageSecurityStandard.rawValue, forKey: .keyStorageSecurityStandard)
        }
        if let lastStateChangeAt = lastStateChangeAt {
            try encodeContainer.encode(lastStateChangeAt.timeIntervalSince1970, forKey: .lastStateChangeAt)
        }
        if let notAfter = notAfter {
            try encodeContainer.encode(notAfter.timeIntervalSince1970, forKey: .notAfter)
        }
        if let notBefore = notBefore {
            try encodeContainer.encode(notBefore.timeIntervalSince1970, forKey: .notBefore)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let restorableUntil = restorableUntil {
            try encodeContainer.encode(restorableUntil.timeIntervalSince1970, forKey: .restorableUntil)
        }
        if let revocationConfiguration = revocationConfiguration {
            try encodeContainer.encode(revocationConfiguration, forKey: .revocationConfiguration)
        }
        if let serial = serial {
            try encodeContainer.encode(serial, forKey: .serial)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastStateChangeAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStateChangeAt)
        lastStateChangeAt = lastStateChangeAtDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CertificateAuthorityType.self, forKey: .type)
        type = typeDecoded
        let serialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serial)
        serial = serialDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CertificateAuthorityStatus.self, forKey: .status)
        status = statusDecoded
        let notBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let notAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .notAfter)
        notAfter = notAfterDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let certificateAuthorityConfigurationDecoded = try containerValues.decodeIfPresent(CertificateAuthorityConfiguration.self, forKey: .certificateAuthorityConfiguration)
        certificateAuthorityConfiguration = certificateAuthorityConfigurationDecoded
        let revocationConfigurationDecoded = try containerValues.decodeIfPresent(RevocationConfiguration.self, forKey: .revocationConfiguration)
        revocationConfiguration = revocationConfigurationDecoded
        let restorableUntilDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .restorableUntil)
        restorableUntil = restorableUntilDecoded
        let keyStorageSecurityStandardDecoded = try containerValues.decodeIfPresent(KeyStorageSecurityStandard.self, forKey: .keyStorageSecurityStandard)
        keyStorageSecurityStandard = keyStorageSecurityStandardDecoded
    }
}

extension CertificateAuthority: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateAuthority(arn: \(String(describing: arn)), certificateAuthorityConfiguration: \(String(describing: certificateAuthorityConfiguration)), createdAt: \(String(describing: createdAt)), failureReason: \(String(describing: failureReason)), keyStorageSecurityStandard: \(String(describing: keyStorageSecurityStandard)), lastStateChangeAt: \(String(describing: lastStateChangeAt)), notAfter: \(String(describing: notAfter)), notBefore: \(String(describing: notBefore)), ownerAccount: \(String(describing: ownerAccount)), restorableUntil: \(String(describing: restorableUntil)), revocationConfiguration: \(String(describing: revocationConfiguration)), serial: \(String(describing: serial)), status: \(String(describing: status)), type: \(String(describing: type)))"}
}

/// <p>Contains information about your private certificate authority (CA). Your private CA
/// 			can issue and revoke X.509 digital certificates. Digital certificates verify that the
/// 			entity named in the certificate <b>Subject</b> field owns or
/// 			controls the public key contained in the <b>Subject Public Key
/// 				Info</b> field. Call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a> action to create your private CA. You must then
/// 			call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_GetCertificateAuthorityCertificate.html">GetCertificateAuthorityCertificate</a> action to retrieve a private CA
/// 			certificate signing request (CSR). Sign the CSR with your ACM Private CA-hosted or on-premises
/// 			root or subordinate CA certificate. Call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ImportCertificateAuthorityCertificate.html">ImportCertificateAuthorityCertificate</a> action to import the signed
/// 			certificate into AWS Certificate Manager (ACM). </p>
public struct CertificateAuthority: Equatable {
    /// <p>Amazon Resource Name (ARN) for your private certificate authority (CA). The format is
    /// 					<code>
    ///                <i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>.</p>
    public let arn: String?
    /// <p>Your private CA configuration.</p>
    public let certificateAuthorityConfiguration: CertificateAuthorityConfiguration?
    /// <p>Date and time at which your private CA was created.</p>
    public let createdAt: Date?
    /// <p>Reason the request to create your private CA failed.</p>
    public let failureReason: FailureReason?
    /// <p>Defines a cryptographic key management compliance standard used for handling CA keys. </p>
    /// 		       <p>Default: FIPS_140_2_LEVEL_3_OR_HIGHER</p>
    /// 		       <p>Note: AWS Region ap-northeast-3 supports only FIPS_140_2_LEVEL_2_OR_HIGHER. You must
    /// 			explicitly specify this parameter and value when creating a CA in that Region.
    /// 			Specifying a different value (or no value) results in an
    /// 				<code>InvalidArgsException</code> with the message "A certificate authority cannot
    /// 			be created in this region with the specified security standard."</p>
    public let keyStorageSecurityStandard: KeyStorageSecurityStandard?
    /// <p>Date and time at which your private CA was last updated.</p>
    public let lastStateChangeAt: Date?
    /// <p>Date and time after which your private CA certificate is not valid.</p>
    public let notAfter: Date?
    /// <p>Date and time before which your private CA certificate is not valid.</p>
    public let notBefore: Date?
    /// <p>The AWS account ID that owns the certificate authority.</p>
    public let ownerAccount: String?
    /// <p>The period during which a deleted CA can be restored. For more information, see the
    /// 				<code>PermanentDeletionTimeInDays</code> parameter of the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_DeleteCertificateAuthorityRequest.html">DeleteCertificateAuthorityRequest</a> action. </p>
    public let restorableUntil: Date?
    /// <p>Information about the certificate revocation list (CRL) created and maintained by your
    /// 			private CA. </p>
    public let revocationConfiguration: RevocationConfiguration?
    /// <p>Serial number of your private CA.</p>
    public let serial: String?
    /// <p>Status of your private CA.</p>
    public let status: CertificateAuthorityStatus?
    /// <p>Type of your private CA.</p>
    public let type: CertificateAuthorityType?

    public init (
        arn: String? = nil,
        certificateAuthorityConfiguration: CertificateAuthorityConfiguration? = nil,
        createdAt: Date? = nil,
        failureReason: FailureReason? = nil,
        keyStorageSecurityStandard: KeyStorageSecurityStandard? = nil,
        lastStateChangeAt: Date? = nil,
        notAfter: Date? = nil,
        notBefore: Date? = nil,
        ownerAccount: String? = nil,
        restorableUntil: Date? = nil,
        revocationConfiguration: RevocationConfiguration? = nil,
        serial: String? = nil,
        status: CertificateAuthorityStatus? = nil,
        type: CertificateAuthorityType? = nil
    )
    {
        self.arn = arn
        self.certificateAuthorityConfiguration = certificateAuthorityConfiguration
        self.createdAt = createdAt
        self.failureReason = failureReason
        self.keyStorageSecurityStandard = keyStorageSecurityStandard
        self.lastStateChangeAt = lastStateChangeAt
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.ownerAccount = ownerAccount
        self.restorableUntil = restorableUntil
        self.revocationConfiguration = revocationConfiguration
        self.serial = serial
        self.status = status
        self.type = type
    }
}

extension CertificateAuthorityConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csrExtensions = "CsrExtensions"
        case keyAlgorithm = "KeyAlgorithm"
        case signingAlgorithm = "SigningAlgorithm"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csrExtensions = csrExtensions {
            try encodeContainer.encode(csrExtensions, forKey: .csrExtensions)
        }
        if let keyAlgorithm = keyAlgorithm {
            try encodeContainer.encode(keyAlgorithm.rawValue, forKey: .keyAlgorithm)
        }
        if let signingAlgorithm = signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm.rawValue, forKey: .signingAlgorithm)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyAlgorithmDecoded = try containerValues.decodeIfPresent(KeyAlgorithm.self, forKey: .keyAlgorithm)
        keyAlgorithm = keyAlgorithmDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(SigningAlgorithm.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(ASN1Subject.self, forKey: .subject)
        subject = subjectDecoded
        let csrExtensionsDecoded = try containerValues.decodeIfPresent(CsrExtensions.self, forKey: .csrExtensions)
        csrExtensions = csrExtensionsDecoded
    }
}

extension CertificateAuthorityConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateAuthorityConfiguration(csrExtensions: \(String(describing: csrExtensions)), keyAlgorithm: \(String(describing: keyAlgorithm)), signingAlgorithm: \(String(describing: signingAlgorithm)), subject: \(String(describing: subject)))"}
}

/// <p>Contains configuration information for your private certificate authority (CA). This
/// 			includes information about the class of public key algorithm and the key pair that your
/// 			private CA creates when it issues a certificate. It also includes the signature
/// 			algorithm that it uses when issuing certificates, and its X.500 distinguished name. You
/// 			must specify this information when you call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a> action. </p>
public struct CertificateAuthorityConfiguration: Equatable {
    /// <p>Specifies information to be added to the extension section of the certificate signing
    /// 			request (CSR).</p>
    public let csrExtensions: CsrExtensions?
    /// <p>Type of the public key algorithm and size, in bits, of the key pair that your CA
    /// 			creates when it issues a certificate. When you create a subordinate CA, you must use a
    /// 			key algorithm supported by the parent CA.</p>
    public let keyAlgorithm: KeyAlgorithm?
    /// <p>Name of the algorithm your private CA uses to sign certificate requests.</p>
    /// 		       <p>This parameter should not be confused with the <code>SigningAlgorithm</code> parameter
    /// 			used to sign certificates when they are issued.</p>
    public let signingAlgorithm: SigningAlgorithm?
    /// <p>Structure that contains X.500 distinguished name information for your private
    /// 			CA.</p>
    public let subject: ASN1Subject?

    public init (
        csrExtensions: CsrExtensions? = nil,
        keyAlgorithm: KeyAlgorithm? = nil,
        signingAlgorithm: SigningAlgorithm? = nil,
        subject: ASN1Subject? = nil
    )
    {
        self.csrExtensions = csrExtensions
        self.keyAlgorithm = keyAlgorithm
        self.signingAlgorithm = signingAlgorithm
        self.subject = subject
    }
}

public enum CertificateAuthorityStatus {
    case active
    case creating
    case deleted
    case disabled
    case expired
    case failed
    case pendingCertificate
    case sdkUnknown(String)
}

extension CertificateAuthorityStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CertificateAuthorityStatus] {
        return [
            .active,
            .creating,
            .deleted,
            .disabled,
            .expired,
            .failed,
            .pendingCertificate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleted: return "DELETED"
        case .disabled: return "DISABLED"
        case .expired: return "EXPIRED"
        case .failed: return "FAILED"
        case .pendingCertificate: return "PENDING_CERTIFICATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CertificateAuthorityStatus(rawValue: rawValue) ?? CertificateAuthorityStatus.sdkUnknown(rawValue)
    }
}

public enum CertificateAuthorityType {
    case root
    case subordinate
    case sdkUnknown(String)
}

extension CertificateAuthorityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CertificateAuthorityType] {
        return [
            .root,
            .subordinate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .root: return "ROOT"
        case .subordinate: return "SUBORDINATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CertificateAuthorityType(rawValue: rawValue) ?? CertificateAuthorityType.sdkUnknown(rawValue)
    }
}

extension CertificateMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateMismatchException(message: \(String(describing: message)))"}
}

extension CertificateMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CertificateMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate authority certificate you are importing does not comply with
/// 			conditions specified in the certificate that signed it.</p>
public struct CertificateMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateMismatchExceptionBody: Equatable {
    public let message: String?
}

extension CertificateMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A previous update to your private CA is still ongoing.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateCertificateAuthorityAuditReportInputBodyMiddleware: Middleware {
    public let id: String = "CreateCertificateAuthorityAuditReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCertificateAuthorityAuditReportInput>
    public typealias MOutput = OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCertificateAuthorityAuditReportOutputError>
}

extension CreateCertificateAuthorityAuditReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCertificateAuthorityAuditReportInput(auditReportResponseFormat: \(String(describing: auditReportResponseFormat)), certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), s3BucketName: \(String(describing: s3BucketName)))"}
}

extension CreateCertificateAuthorityAuditReportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auditReportResponseFormat = "AuditReportResponseFormat"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case s3BucketName = "S3BucketName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditReportResponseFormat = auditReportResponseFormat {
            try encodeContainer.encode(auditReportResponseFormat.rawValue, forKey: .auditReportResponseFormat)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
    }
}

public struct CreateCertificateAuthorityAuditReportInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCertificateAuthorityAuditReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCertificateAuthorityAuditReportInput>
    public typealias MOutput = OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCertificateAuthorityAuditReportOutputError>
}

public struct CreateCertificateAuthorityAuditReportInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCertificateAuthorityAuditReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCertificateAuthorityAuditReportInput>
    public typealias MOutput = OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCertificateAuthorityAuditReportOutputError>
}

public struct CreateCertificateAuthorityAuditReportInput: Equatable {
    /// <p>The format in which to create the report. This can be either <b>JSON</b> or <b>CSV</b>.</p>
    public let auditReportResponseFormat: AuditReportResponseFormat?
    /// <p>The Amazon Resource Name (ARN) of the CA to be audited. This is of the form:</p>
    /// 		       <p>
    ///             <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>.</p>
    public let certificateAuthorityArn: String?
    /// <p>The name of the S3 bucket that will contain the audit report.</p>
    public let s3BucketName: String?

    public init (
        auditReportResponseFormat: AuditReportResponseFormat? = nil,
        certificateAuthorityArn: String? = nil,
        s3BucketName: String? = nil
    )
    {
        self.auditReportResponseFormat = auditReportResponseFormat
        self.certificateAuthorityArn = certificateAuthorityArn
        self.s3BucketName = s3BucketName
    }
}

struct CreateCertificateAuthorityAuditReportInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let s3BucketName: String?
    public let auditReportResponseFormat: AuditReportResponseFormat?
}

extension CreateCertificateAuthorityAuditReportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditReportResponseFormat = "AuditReportResponseFormat"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case s3BucketName = "S3BucketName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let auditReportResponseFormatDecoded = try containerValues.decodeIfPresent(AuditReportResponseFormat.self, forKey: .auditReportResponseFormat)
        auditReportResponseFormat = auditReportResponseFormatDecoded
    }
}

extension CreateCertificateAuthorityAuditReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCertificateAuthorityAuditReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestInProgressException" : self = .requestInProgressException(try RequestInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCertificateAuthorityAuditReportOutputError: Equatable {
    case invalidArgsException(InvalidArgsException)
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case requestInProgressException(RequestInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCertificateAuthorityAuditReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCertificateAuthorityAuditReportOutputResponse(auditReportId: \(String(describing: auditReportId)), s3Key: \(String(describing: s3Key)))"}
}

extension CreateCertificateAuthorityAuditReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCertificateAuthorityAuditReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.auditReportId = output.auditReportId
            self.s3Key = output.s3Key
        } else {
            self.auditReportId = nil
            self.s3Key = nil
        }
    }
}

public struct CreateCertificateAuthorityAuditReportOutputResponse: Equatable {
    /// <p>An alphanumeric string that contains a report identifier.</p>
    public let auditReportId: String?
    /// <p>The <b>key</b> that uniquely identifies the report file in
    /// 			your S3 bucket.</p>
    public let s3Key: String?

    public init (
        auditReportId: String? = nil,
        s3Key: String? = nil
    )
    {
        self.auditReportId = auditReportId
        self.s3Key = s3Key
    }
}

struct CreateCertificateAuthorityAuditReportOutputResponseBody: Equatable {
    public let auditReportId: String?
    public let s3Key: String?
}

extension CreateCertificateAuthorityAuditReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditReportId = "AuditReportId"
        case s3Key = "S3Key"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditReportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditReportId)
        auditReportId = auditReportIdDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

public struct CreateCertificateAuthorityInputBodyMiddleware: Middleware {
    public let id: String = "CreateCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<CreateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCertificateAuthorityOutputError>
}

extension CreateCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCertificateAuthorityInput(certificateAuthorityConfiguration: \(String(describing: certificateAuthorityConfiguration)), certificateAuthorityType: \(String(describing: certificateAuthorityType)), idempotencyToken: \(String(describing: idempotencyToken)), keyStorageSecurityStandard: \(String(describing: keyStorageSecurityStandard)), revocationConfiguration: \(String(describing: revocationConfiguration)), tags: \(String(describing: tags)))"}
}

extension CreateCertificateAuthorityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityConfiguration = "CertificateAuthorityConfiguration"
        case certificateAuthorityType = "CertificateAuthorityType"
        case idempotencyToken = "IdempotencyToken"
        case keyStorageSecurityStandard = "KeyStorageSecurityStandard"
        case revocationConfiguration = "RevocationConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityConfiguration = certificateAuthorityConfiguration {
            try encodeContainer.encode(certificateAuthorityConfiguration, forKey: .certificateAuthorityConfiguration)
        }
        if let certificateAuthorityType = certificateAuthorityType {
            try encodeContainer.encode(certificateAuthorityType.rawValue, forKey: .certificateAuthorityType)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let keyStorageSecurityStandard = keyStorageSecurityStandard {
            try encodeContainer.encode(keyStorageSecurityStandard.rawValue, forKey: .keyStorageSecurityStandard)
        }
        if let revocationConfiguration = revocationConfiguration {
            try encodeContainer.encode(revocationConfiguration, forKey: .revocationConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<CreateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCertificateAuthorityOutputError>
}

public struct CreateCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<CreateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCertificateAuthorityOutputError>
}

public struct CreateCertificateAuthorityInput: Equatable {
    /// <p>Name and bit size of the private key algorithm, the name of the signing algorithm, and
    /// 			X.500 certificate subject information.</p>
    public let certificateAuthorityConfiguration: CertificateAuthorityConfiguration?
    /// <p>The type of the certificate authority.</p>
    public let certificateAuthorityType: CertificateAuthorityType?
    /// <p>Custom string that can be used to distinguish between calls to the <b>CreateCertificateAuthority</b> action. Idempotency tokens for
    /// 				<b>CreateCertificateAuthority</b> time out after five
    /// 			minutes. Therefore, if you call <b>CreateCertificateAuthority</b> multiple times with the same idempotency
    /// 			token within five minutes, ACM Private CA recognizes that you are requesting only certificate
    /// 			authority and will issue only one. If you change the idempotency token for each call,
    /// 			PCA recognizes that you are requesting multiple certificate authorities.</p>
    public let idempotencyToken: String?
    /// <p>Specifies a
    /// 			cryptographic key management compliance standard used for handling CA keys.</p>
    /// 		       <p>Default: FIPS_140_2_LEVEL_3_OR_HIGHER</p>
    /// 		       <p>Note: <code>FIPS_140_2_LEVEL_3_OR_HIGHER</code> is not supported in Region
    /// 			ap-northeast-3. When creating a CA in the ap-northeast-3, you must provide
    /// 				<code>FIPS_140_2_LEVEL_2_OR_HIGHER</code> as the argument for
    /// 				<code>KeyStorageSecurityStandard</code>. Failure to do this results in an
    /// 				<code>InvalidArgsException</code> with the message, "A certificate authority cannot
    /// 			be created in this region with the specified security standard."</p>
    public let keyStorageSecurityStandard: KeyStorageSecurityStandard?
    /// <p>Contains a Boolean value that you can use to enable a certification revocation list
    /// 			(CRL) for the CA, the name of the S3 bucket to which ACM Private CA will write the CRL, and an
    /// 			optional CNAME alias that you can use to hide the name of your bucket in the <b>CRL Distribution Points</b> extension of your CA certificate. For
    /// 			more information, see the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CrlConfiguration.html">CrlConfiguration</a> structure.
    /// 		</p>
    public let revocationConfiguration: RevocationConfiguration?
    /// <p>Key-value pairs that will be attached to the new private CA. You can associate up to
    /// 			50 tags with a private CA. For information using tags with IAM to manage permissions,
    /// 			see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html">Controlling Access Using IAM Tags</a>.</p>
    public let tags: [Tag]?

    public init (
        certificateAuthorityConfiguration: CertificateAuthorityConfiguration? = nil,
        certificateAuthorityType: CertificateAuthorityType? = nil,
        idempotencyToken: String? = nil,
        keyStorageSecurityStandard: KeyStorageSecurityStandard? = nil,
        revocationConfiguration: RevocationConfiguration? = nil,
        tags: [Tag]? = nil
    )
    {
        self.certificateAuthorityConfiguration = certificateAuthorityConfiguration
        self.certificateAuthorityType = certificateAuthorityType
        self.idempotencyToken = idempotencyToken
        self.keyStorageSecurityStandard = keyStorageSecurityStandard
        self.revocationConfiguration = revocationConfiguration
        self.tags = tags
    }
}

struct CreateCertificateAuthorityInputBody: Equatable {
    public let certificateAuthorityConfiguration: CertificateAuthorityConfiguration?
    public let revocationConfiguration: RevocationConfiguration?
    public let certificateAuthorityType: CertificateAuthorityType?
    public let idempotencyToken: String?
    public let keyStorageSecurityStandard: KeyStorageSecurityStandard?
    public let tags: [Tag]?
}

extension CreateCertificateAuthorityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityConfiguration = "CertificateAuthorityConfiguration"
        case certificateAuthorityType = "CertificateAuthorityType"
        case idempotencyToken = "IdempotencyToken"
        case keyStorageSecurityStandard = "KeyStorageSecurityStandard"
        case revocationConfiguration = "RevocationConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityConfigurationDecoded = try containerValues.decodeIfPresent(CertificateAuthorityConfiguration.self, forKey: .certificateAuthorityConfiguration)
        certificateAuthorityConfiguration = certificateAuthorityConfigurationDecoded
        let revocationConfigurationDecoded = try containerValues.decodeIfPresent(RevocationConfiguration.self, forKey: .revocationConfiguration)
        revocationConfiguration = revocationConfigurationDecoded
        let certificateAuthorityTypeDecoded = try containerValues.decodeIfPresent(CertificateAuthorityType.self, forKey: .certificateAuthorityType)
        certificateAuthorityType = certificateAuthorityTypeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let keyStorageSecurityStandardDecoded = try containerValues.decodeIfPresent(KeyStorageSecurityStandard.self, forKey: .keyStorageSecurityStandard)
        keyStorageSecurityStandard = keyStorageSecurityStandardDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyException" : self = .invalidPolicyException(try InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCertificateAuthorityOutputError: Equatable {
    case invalidArgsException(InvalidArgsException)
    case invalidPolicyException(InvalidPolicyException)
    case invalidTagException(InvalidTagException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCertificateAuthorityOutputResponse(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)))"}
}

extension CreateCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateAuthorityArn = output.certificateAuthorityArn
        } else {
            self.certificateAuthorityArn = nil
        }
    }
}

public struct CreateCertificateAuthorityOutputResponse: Equatable {
    /// <p>If successful, the Amazon Resource Name (ARN) of the certificate authority (CA). This
    /// 			is of the form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>.
    /// 		</p>
    public let certificateAuthorityArn: String?

    public init (
        certificateAuthorityArn: String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct CreateCertificateAuthorityOutputResponseBody: Equatable {
    public let certificateAuthorityArn: String?
}

extension CreateCertificateAuthorityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

public struct CreatePermissionInputBodyMiddleware: Middleware {
    public let id: String = "CreatePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePermissionInput>
    public typealias MOutput = OperationOutput<CreatePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePermissionOutputError>
}

extension CreatePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePermissionInput(actions: \(String(describing: actions)), certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), principal: \(String(describing: principal)), sourceAccount: \(String(describing: sourceAccount)))"}
}

extension CreatePermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case principal = "Principal"
        case sourceAccount = "SourceAccount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0.rawValue)
            }
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let sourceAccount = sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
    }
}

public struct CreatePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePermissionInput>
    public typealias MOutput = OperationOutput<CreatePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePermissionOutputError>
}

public struct CreatePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePermissionInput>
    public typealias MOutput = OperationOutput<CreatePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePermissionOutputError>
}

public struct CreatePermissionInput: Equatable {
    /// <p>The actions that the specified AWS service principal can use. These include
    /// 				<code>IssueCertificate</code>, <code>GetCertificate</code>, and
    /// 				<code>ListPermissions</code>.</p>
    public let actions: [ActionType]?
    /// <p>The Amazon Resource Name (ARN) of the CA that grants the permissions. You can find the
    /// 			ARN by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities</a> action. This must have the following form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>.
    /// 		</p>
    public let certificateAuthorityArn: String?
    /// <p>The AWS service or identity that receives the permission. At this time, the only
    /// 			valid principal is <code>acm.amazonaws.com</code>.</p>
    public let principal: String?
    /// <p>The ID of the calling account.</p>
    public let sourceAccount: String?

    public init (
        actions: [ActionType]? = nil,
        certificateAuthorityArn: String? = nil,
        principal: String? = nil,
        sourceAccount: String? = nil
    )
    {
        self.actions = actions
        self.certificateAuthorityArn = certificateAuthorityArn
        self.principal = principal
        self.sourceAccount = sourceAccount
    }
}

struct CreatePermissionInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let principal: String?
    public let sourceAccount: String?
    public let actions: [ActionType]?
}

extension CreatePermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case principal = "Principal"
        case sourceAccount = "SourceAccount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
        let actionsContainer = try containerValues.decodeIfPresent([ActionType?].self, forKey: .actions)
        var actionsDecoded0:[ActionType]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [ActionType]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension CreatePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PermissionAlreadyExistsException" : self = .permissionAlreadyExistsException(try PermissionAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePermissionOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case permissionAlreadyExistsException(PermissionAlreadyExistsException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePermissionOutputResponse()"}
}

extension CreatePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreatePermissionOutputResponse: Equatable {

    public init() {}
}

struct CreatePermissionOutputResponseBody: Equatable {
}

extension CreatePermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CrlConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customCname = "CustomCname"
        case enabled = "Enabled"
        case expirationInDays = "ExpirationInDays"
        case s3BucketName = "S3BucketName"
        case s3ObjectAcl = "S3ObjectAcl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customCname = customCname {
            try encodeContainer.encode(customCname, forKey: .customCname)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let expirationInDays = expirationInDays {
            try encodeContainer.encode(expirationInDays, forKey: .expirationInDays)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3ObjectAcl = s3ObjectAcl {
            try encodeContainer.encode(s3ObjectAcl.rawValue, forKey: .s3ObjectAcl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let expirationInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expirationInDays)
        expirationInDays = expirationInDaysDecoded
        let customCnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customCname)
        customCname = customCnameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3ObjectAclDecoded = try containerValues.decodeIfPresent(S3ObjectAcl.self, forKey: .s3ObjectAcl)
        s3ObjectAcl = s3ObjectAclDecoded
    }
}

extension CrlConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrlConfiguration(customCname: \(String(describing: customCname)), enabled: \(String(describing: enabled)), expirationInDays: \(String(describing: expirationInDays)), s3BucketName: \(String(describing: s3BucketName)), s3ObjectAcl: \(String(describing: s3ObjectAcl)))"}
}

/// <p>Contains configuration information for a certificate revocation list (CRL). Your
/// 			private certificate authority (CA) creates base CRLs. Delta CRLs are not supported. You
/// 			can enable CRLs for your new or an existing private CA by setting the <b>Enabled</b> parameter to <code>true</code>. Your private CA
/// 			writes CRLs to an S3 bucket that you specify in the <b>S3BucketName</b> parameter. You can hide the name of your bucket by
/// 			specifying a value for the <b>CustomCname</b> parameter. Your
/// 			private CA copies the CNAME or the S3 bucket name to the <b>CRL
/// 				Distribution Points</b> extension of each certificate it issues. Your S3
/// 			bucket policy must give write permission to ACM Private CA. </p>
/// 		       <p>ACM Private CA assets that are stored in Amazon S3 can be protected with encryption.
///   For more information, see <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaCreateCa.html#crl-encryption">Encrypting Your
/// 			CRLs</a>.</p>
/// 		       <p>Your private CA uses the value in the <b>ExpirationInDays</b> parameter to calculate the <b>nextUpdate</b> field in the CRL. The CRL is refreshed at 1/2 the age of next
/// 			update or when a certificate is revoked. When a certificate is revoked, it is recorded
/// 			in the next CRL that is generated and in the next audit report. Only time valid
/// 			certificates are listed in the CRL. Expired certificates are not included. </p>
/// 		       <p>CRLs contain the following fields:</p>
/// 		       <ul>
///             <li>
/// 				           <p>
///                   <b>Version</b>: The current version number defined
/// 					in RFC 5280 is V2. The integer value is 0x1. </p>
/// 			         </li>
///             <li>
/// 				           <p>
///                   <b>Signature Algorithm</b>: The name of the
/// 					algorithm used to sign the CRL.</p>
/// 			         </li>
///             <li>
/// 				           <p>
///                   <b>Issuer</b>: The X.500 distinguished name of your
/// 					private CA that issued the CRL.</p>
/// 			         </li>
///             <li>
/// 				           <p>
///                   <b>Last Update</b>: The issue date and time of this
/// 					CRL.</p>
/// 			         </li>
///             <li>
/// 				           <p>
///                   <b>Next Update</b>: The day and time by which the
/// 					next CRL will be issued.</p>
/// 			         </li>
///             <li>
/// 				           <p>
///                   <b>Revoked Certificates</b>: List of revoked
/// 					certificates. Each list item contains the following information.</p>
/// 				           <ul>
///                   <li>
/// 						               <p>
///                         <b>Serial Number</b>: The serial number, in
/// 							hexadecimal format, of the revoked certificate.</p>
/// 					             </li>
///                   <li>
/// 						               <p>
///                         <b>Revocation Date</b>: Date and time the
/// 							certificate was revoked.</p>
/// 					             </li>
///                   <li>
/// 						               <p>
///                         <b>CRL Entry Extensions</b>: Optional
/// 							extensions for the CRL entry.</p>
/// 						               <ul>
///                         <li>
/// 								                   <p>
///                               <b>X509v3 CRL Reason Code</b>:
/// 									Reason the certificate was revoked.</p>
/// 							                 </li>
///                      </ul>
/// 					             </li>
///                </ul>
/// 			         </li>
///             <li>
/// 				           <p>
///                   <b>CRL Extensions</b>: Optional extensions for the
/// 					CRL.</p>
/// 				           <ul>
///                   <li>
/// 						               <p>
///                         <b>X509v3 Authority Key Identifier</b>:
/// 							Identifies the public key associated with the private key used to sign
/// 							the certificate.</p>
/// 					             </li>
///                   <li>
/// 						               <p>
///                         <b>X509v3 CRL Number:</b>: Decimal sequence
/// 							number for the CRL.</p>
/// 					             </li>
///                </ul>
/// 			         </li>
///             <li>
/// 				           <p>
///                   <b>Signature Algorithm</b>: Algorithm used by your
/// 					private CA to sign the CRL.</p>
/// 			         </li>
///             <li>
/// 				           <p>
///                   <b>Signature Value</b>: Signature computed over the
/// 					CRL.</p>
/// 			         </li>
///          </ul>
/// 		       <p>Certificate revocation lists created by ACM Private CA are DER-encoded. You can use the
/// 			following OpenSSL command to list a CRL.</p>
/// 		       <p>
///             <code>openssl crl -inform DER -text -in <i>crl_path</i>
/// 			-noout</code>
///          </p>
public struct CrlConfiguration: Equatable {
    /// <p>Name inserted into the certificate <b>CRL Distribution
    /// 				Points</b> extension that enables the use of an alias for the CRL
    /// 			distribution point. Use this value if you don't want the name of your S3 bucket to be
    /// 			public.</p>
    public let customCname: String?
    /// <p>Boolean value that specifies whether certificate revocation lists (CRLs) are enabled.
    /// 			You can use this value to enable certificate revocation for a new CA when you call the
    /// 				<a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a> action or for an existing CA when you call the
    /// 				<a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_UpdateCertificateAuthority.html">UpdateCertificateAuthority</a> action. </p>
    public let enabled: Bool
    /// <p>Validity period of the CRL in days.</p>
    public let expirationInDays: Int?
    /// <p>Name of the S3 bucket that contains the CRL. If you do not provide a value for the
    /// 				<b>CustomCname</b> argument, the name of your S3 bucket
    /// 			is placed into the <b>CRL Distribution Points</b> extension of
    /// 			the issued certificate. You can change the name of your bucket by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_UpdateCertificateAuthority.html">UpdateCertificateAuthority</a> action. You must specify a
    /// 			<a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaCreateCa.html#s3-policies">bucket policy</a> that
    /// 			allows ACM Private CA to write the CRL to your bucket.</p>
    public let s3BucketName: String?
    /// <p>Determines whether the CRL will be publicly readable or privately held in the CRL
    /// 			Amazon S3 bucket. If you choose PUBLIC_READ, the CRL will be accessible over the public
    /// 			internet. If you choose BUCKET_OWNER_FULL_CONTROL, only the owner of the CRL S3 bucket
    /// 			can access the CRL, and your PKI clients may need an alternative method of access. </p>
    /// 		       <p>If no value is specified, the default is <code>PUBLIC_READ</code>.</p>
    /// 		       <p>
    ///             <i>Note:</i> This default can cause CA creation to fail in some
    /// 			circumstances. If you have have enabled the Block Public Access (BPA) feature in your S3
    /// 			account, then you must specify the value of this parameter as
    /// 				<code>BUCKET_OWNER_FULL_CONTROL</code>, and not doing so results in an error. If you
    /// 			have disabled BPA in S3, then you can specify either
    /// 				<code>BUCKET_OWNER_FULL_CONTROL</code> or <code>PUBLIC_READ</code> as the
    /// 			value.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaCreateCa.html#s3-bpa">Blocking public access to the S3
    /// 				bucket</a>.</p>
    public let s3ObjectAcl: S3ObjectAcl?

    public init (
        customCname: String? = nil,
        enabled: Bool = false,
        expirationInDays: Int? = nil,
        s3BucketName: String? = nil,
        s3ObjectAcl: S3ObjectAcl? = nil
    )
    {
        self.customCname = customCname
        self.enabled = enabled
        self.expirationInDays = expirationInDays
        self.s3BucketName = s3BucketName
        self.s3ObjectAcl = s3ObjectAcl
    }
}

extension CsrExtensions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyUsage = "KeyUsage"
        case subjectInformationAccess = "SubjectInformationAccess"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyUsage = keyUsage {
            try encodeContainer.encode(keyUsage, forKey: .keyUsage)
        }
        if let subjectInformationAccess = subjectInformationAccess {
            var subjectInformationAccessContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectInformationAccess)
            for accessdescriptionlist0 in subjectInformationAccess {
                try subjectInformationAccessContainer.encode(accessdescriptionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyUsageDecoded = try containerValues.decodeIfPresent(KeyUsage.self, forKey: .keyUsage)
        keyUsage = keyUsageDecoded
        let subjectInformationAccessContainer = try containerValues.decodeIfPresent([AccessDescription?].self, forKey: .subjectInformationAccess)
        var subjectInformationAccessDecoded0:[AccessDescription]? = nil
        if let subjectInformationAccessContainer = subjectInformationAccessContainer {
            subjectInformationAccessDecoded0 = [AccessDescription]()
            for structure0 in subjectInformationAccessContainer {
                if let structure0 = structure0 {
                    subjectInformationAccessDecoded0?.append(structure0)
                }
            }
        }
        subjectInformationAccess = subjectInformationAccessDecoded0
    }
}

extension CsrExtensions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CsrExtensions(keyUsage: \(String(describing: keyUsage)), subjectInformationAccess: \(String(describing: subjectInformationAccess)))"}
}

/// <p>Describes the certificate extensions to be added to the certificate signing request
/// 			(CSR).</p>
public struct CsrExtensions: Equatable {
    /// <p>Indicates the purpose of the certificate and of the key contained in the
    /// 			certificate.</p>
    public let keyUsage: KeyUsage?
    /// <p>For CA certificates, provides a path to additional information pertaining to the CA,
    /// 			such as revocation and policy. For more information, see <a href="https://tools.ietf.org/html/rfc5280#section-4.2.2.2">Subject Information
    /// 				Access</a> in RFC 5280.</p>
    public let subjectInformationAccess: [AccessDescription]?

    public init (
        keyUsage: KeyUsage? = nil,
        subjectInformationAccess: [AccessDescription]? = nil
    )
    {
        self.keyUsage = keyUsage
        self.subjectInformationAccess = subjectInformationAccess
    }
}

public struct DeleteCertificateAuthorityInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DeleteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCertificateAuthorityOutputError>
}

extension DeleteCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCertificateAuthorityInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), permanentDeletionTimeInDays: \(String(describing: permanentDeletionTimeInDays)))"}
}

extension DeleteCertificateAuthorityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case permanentDeletionTimeInDays = "PermanentDeletionTimeInDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let permanentDeletionTimeInDays = permanentDeletionTimeInDays {
            try encodeContainer.encode(permanentDeletionTimeInDays, forKey: .permanentDeletionTimeInDays)
        }
    }
}

public struct DeleteCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DeleteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCertificateAuthorityOutputError>
}

public struct DeleteCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DeleteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCertificateAuthorityOutputError>
}

public struct DeleteCertificateAuthorityInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a>. This must have the following form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>.
    /// 		</p>
    public let certificateAuthorityArn: String?
    /// <p>The number of days to make a CA restorable after it has been deleted. This can be
    /// 			anywhere from 7 to 30 days, with 30 being the default.</p>
    public let permanentDeletionTimeInDays: Int?

    public init (
        certificateAuthorityArn: String? = nil,
        permanentDeletionTimeInDays: Int? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.permanentDeletionTimeInDays = permanentDeletionTimeInDays
    }
}

struct DeleteCertificateAuthorityInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let permanentDeletionTimeInDays: Int?
}

extension DeleteCertificateAuthorityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case permanentDeletionTimeInDays = "PermanentDeletionTimeInDays"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let permanentDeletionTimeInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .permanentDeletionTimeInDays)
        permanentDeletionTimeInDays = permanentDeletionTimeInDaysDecoded
    }
}

extension DeleteCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCertificateAuthorityOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCertificateAuthorityOutputResponse()"}
}

extension DeleteCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCertificateAuthorityOutputResponse: Equatable {

    public init() {}
}

struct DeleteCertificateAuthorityOutputResponseBody: Equatable {
}

extension DeleteCertificateAuthorityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePermissionInputBodyMiddleware: Middleware {
    public let id: String = "DeletePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionInput>
    public typealias MOutput = OperationOutput<DeletePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionOutputError>
}

extension DeletePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePermissionInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), principal: \(String(describing: principal)), sourceAccount: \(String(describing: sourceAccount)))"}
}

extension DeletePermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case principal = "Principal"
        case sourceAccount = "SourceAccount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let sourceAccount = sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
    }
}

public struct DeletePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionInput>
    public typealias MOutput = OperationOutput<DeletePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionOutputError>
}

public struct DeletePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionInput>
    public typealias MOutput = OperationOutput<DeletePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionOutputError>
}

public struct DeletePermissionInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the private CA that issued the permissions. You
    /// 			can find the CA's ARN by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities</a> action. This must have the following form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>.
    /// 		</p>
    public let certificateAuthorityArn: String?
    /// <p>The AWS service or identity that will have its CA permissions revoked. At this time,
    /// 			the only valid service principal is <code>acm.amazonaws.com</code>
    ///          </p>
    public let principal: String?
    /// <p>The AWS account that calls this action.</p>
    public let sourceAccount: String?

    public init (
        certificateAuthorityArn: String? = nil,
        principal: String? = nil,
        sourceAccount: String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.principal = principal
        self.sourceAccount = sourceAccount
    }
}

struct DeletePermissionInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let principal: String?
    public let sourceAccount: String?
}

extension DeletePermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case principal = "Principal"
        case sourceAccount = "SourceAccount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
    }
}

extension DeletePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePermissionOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePermissionOutputResponse()"}
}

extension DeletePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePermissionOutputResponse: Equatable {

    public init() {}
}

struct DeletePermissionOutputResponseBody: Equatable {
}

extension DeletePermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeletePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

extension DeletePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DeletePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeletePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the private CA that will have its policy deleted.
    /// 			You can find the CA's ARN by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities</a> action. The ARN value must have the form
    /// 				<code>arn:aws:acm-pca:region:account:certificate-authority/01234567-89ab-cdef-0123-0123456789ab</code>.
    /// 		</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeletePolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension DeletePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeletePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LockoutPreventedException" : self = .lockoutPreventedException(try LockoutPreventedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePolicyOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case lockoutPreventedException(LockoutPreventedException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyOutputResponse()"}
}

extension DeletePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeletePolicyOutputResponseBody: Equatable {
}

extension DeletePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeCertificateAuthorityAuditReportInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCertificateAuthorityAuditReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>
    public typealias MOutput = OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateAuthorityAuditReportOutputError>
}

extension DescribeCertificateAuthorityAuditReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificateAuthorityAuditReportInput(auditReportId: \(String(describing: auditReportId)), certificateAuthorityArn: \(String(describing: certificateAuthorityArn)))"}
}

extension DescribeCertificateAuthorityAuditReportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auditReportId = "AuditReportId"
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditReportId = auditReportId {
            try encodeContainer.encode(auditReportId, forKey: .auditReportId)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct DescribeCertificateAuthorityAuditReportInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCertificateAuthorityAuditReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>
    public typealias MOutput = OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateAuthorityAuditReportOutputError>
}

public struct DescribeCertificateAuthorityAuditReportInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCertificateAuthorityAuditReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>
    public typealias MOutput = OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateAuthorityAuditReportOutputError>
}

public struct DescribeCertificateAuthorityAuditReportInput: Equatable {
    /// <p>The report ID returned by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthorityAuditReport.html">CreateCertificateAuthorityAuditReport</a> action.</p>
    public let auditReportId: String?
    /// <p>The Amazon Resource Name (ARN) of the private CA. This must be of the form:</p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>.
    /// 		</p>
    public let certificateAuthorityArn: String?

    public init (
        auditReportId: String? = nil,
        certificateAuthorityArn: String? = nil
    )
    {
        self.auditReportId = auditReportId
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct DescribeCertificateAuthorityAuditReportInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let auditReportId: String?
}

extension DescribeCertificateAuthorityAuditReportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditReportId = "AuditReportId"
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let auditReportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditReportId)
        auditReportId = auditReportIdDecoded
    }
}

extension DescribeCertificateAuthorityAuditReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCertificateAuthorityAuditReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificateAuthorityAuditReportOutputError: Equatable {
    case invalidArgsException(InvalidArgsException)
    case invalidArnException(InvalidArnException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificateAuthorityAuditReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificateAuthorityAuditReportOutputResponse(auditReportStatus: \(String(describing: auditReportStatus)), createdAt: \(String(describing: createdAt)), s3BucketName: \(String(describing: s3BucketName)), s3Key: \(String(describing: s3Key)))"}
}

extension DescribeCertificateAuthorityAuditReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCertificateAuthorityAuditReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.auditReportStatus = output.auditReportStatus
            self.createdAt = output.createdAt
            self.s3BucketName = output.s3BucketName
            self.s3Key = output.s3Key
        } else {
            self.auditReportStatus = nil
            self.createdAt = nil
            self.s3BucketName = nil
            self.s3Key = nil
        }
    }
}

public struct DescribeCertificateAuthorityAuditReportOutputResponse: Equatable {
    /// <p>Specifies whether report creation is in progress, has succeeded, or has failed.</p>
    public let auditReportStatus: AuditReportStatus?
    /// <p>The date and time at which the report was created.</p>
    public let createdAt: Date?
    /// <p>Name of the S3 bucket that contains the report.</p>
    public let s3BucketName: String?
    /// <p>S3 <b>key</b> that uniquely identifies the report file in
    /// 			your S3 bucket.</p>
    public let s3Key: String?

    public init (
        auditReportStatus: AuditReportStatus? = nil,
        createdAt: Date? = nil,
        s3BucketName: String? = nil,
        s3Key: String? = nil
    )
    {
        self.auditReportStatus = auditReportStatus
        self.createdAt = createdAt
        self.s3BucketName = s3BucketName
        self.s3Key = s3Key
    }
}

struct DescribeCertificateAuthorityAuditReportOutputResponseBody: Equatable {
    public let auditReportStatus: AuditReportStatus?
    public let s3BucketName: String?
    public let s3Key: String?
    public let createdAt: Date?
}

extension DescribeCertificateAuthorityAuditReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditReportStatus = "AuditReportStatus"
        case createdAt = "CreatedAt"
        case s3BucketName = "S3BucketName"
        case s3Key = "S3Key"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditReportStatusDecoded = try containerValues.decodeIfPresent(AuditReportStatus.self, forKey: .auditReportStatus)
        auditReportStatus = auditReportStatusDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

public struct DescribeCertificateAuthorityInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DescribeCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateAuthorityOutputError>
}

extension DescribeCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificateAuthorityInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)))"}
}

extension DescribeCertificateAuthorityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct DescribeCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DescribeCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateAuthorityOutputError>
}

public struct DescribeCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DescribeCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateAuthorityOutputError>
}

public struct DescribeCertificateAuthorityInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a>. This must be of the form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>.
    /// 		</p>
    public let certificateAuthorityArn: String?

    public init (
        certificateAuthorityArn: String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct DescribeCertificateAuthorityInputBody: Equatable {
    public let certificateAuthorityArn: String?
}

extension DescribeCertificateAuthorityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension DescribeCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificateAuthorityOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificateAuthorityOutputResponse(certificateAuthority: \(String(describing: certificateAuthority)))"}
}

extension DescribeCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateAuthority = output.certificateAuthority
        } else {
            self.certificateAuthority = nil
        }
    }
}

public struct DescribeCertificateAuthorityOutputResponse: Equatable {
    /// <p>A <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CertificateAuthority.html">CertificateAuthority</a> structure that contains information about your private
    /// 			CA.</p>
    public let certificateAuthority: CertificateAuthority?

    public init (
        certificateAuthority: CertificateAuthority? = nil
    )
    {
        self.certificateAuthority = certificateAuthority
    }
}

struct DescribeCertificateAuthorityOutputResponseBody: Equatable {
    public let certificateAuthority: CertificateAuthority?
}

extension DescribeCertificateAuthorityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthority = "CertificateAuthority"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityDecoded = try containerValues.decodeIfPresent(CertificateAuthority.self, forKey: .certificateAuthority)
        certificateAuthority = certificateAuthorityDecoded
    }
}

extension EdiPartyName: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nameAssigner = "NameAssigner"
        case partyName = "PartyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nameAssigner = nameAssigner {
            try encodeContainer.encode(nameAssigner, forKey: .nameAssigner)
        }
        if let partyName = partyName {
            try encodeContainer.encode(partyName, forKey: .partyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partyName)
        partyName = partyNameDecoded
        let nameAssignerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nameAssigner)
        nameAssigner = nameAssignerDecoded
    }
}

extension EdiPartyName: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EdiPartyName(nameAssigner: \(String(describing: nameAssigner)), partyName: \(String(describing: partyName)))"}
}

/// <p>Describes an Electronic Data Interchange (EDI) entity as described in as defined in
/// 				<a href="https://tools.ietf.org/html/rfc5280">Subject Alternative Name</a> in
/// 			RFC 5280.</p>
public struct EdiPartyName: Equatable {
    /// <p>Specifies the name assigner.</p>
    public let nameAssigner: String?
    /// <p>Specifies the party name.</p>
    public let partyName: String?

    public init (
        nameAssigner: String? = nil,
        partyName: String? = nil
    )
    {
        self.nameAssigner = nameAssigner
        self.partyName = partyName
    }
}

extension ExtendedKeyUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case extendedKeyUsageObjectIdentifier = "ExtendedKeyUsageObjectIdentifier"
        case extendedKeyUsageType = "ExtendedKeyUsageType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let extendedKeyUsageObjectIdentifier = extendedKeyUsageObjectIdentifier {
            try encodeContainer.encode(extendedKeyUsageObjectIdentifier, forKey: .extendedKeyUsageObjectIdentifier)
        }
        if let extendedKeyUsageType = extendedKeyUsageType {
            try encodeContainer.encode(extendedKeyUsageType.rawValue, forKey: .extendedKeyUsageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extendedKeyUsageTypeDecoded = try containerValues.decodeIfPresent(ExtendedKeyUsageType.self, forKey: .extendedKeyUsageType)
        extendedKeyUsageType = extendedKeyUsageTypeDecoded
        let extendedKeyUsageObjectIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extendedKeyUsageObjectIdentifier)
        extendedKeyUsageObjectIdentifier = extendedKeyUsageObjectIdentifierDecoded
    }
}

extension ExtendedKeyUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExtendedKeyUsage(extendedKeyUsageObjectIdentifier: \(String(describing: extendedKeyUsageObjectIdentifier)), extendedKeyUsageType: \(String(describing: extendedKeyUsageType)))"}
}

/// <p>Specifies additional purposes for which the certified public key may be used other
/// 			than basic purposes indicated in the <code>KeyUsage</code> extension.</p>
public struct ExtendedKeyUsage: Equatable {
    /// <p>Specifies a custom <code>ExtendedKeyUsage</code> with an object identifier
    /// 			(OID).</p>
    public let extendedKeyUsageObjectIdentifier: String?
    /// <p>Specifies a standard <code>ExtendedKeyUsage</code> as defined as in <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.12">RFC 5280</a>.</p>
    public let extendedKeyUsageType: ExtendedKeyUsageType?

    public init (
        extendedKeyUsageObjectIdentifier: String? = nil,
        extendedKeyUsageType: ExtendedKeyUsageType? = nil
    )
    {
        self.extendedKeyUsageObjectIdentifier = extendedKeyUsageObjectIdentifier
        self.extendedKeyUsageType = extendedKeyUsageType
    }
}

public enum ExtendedKeyUsageType {
    case certificateTransparency
    case clientAuth
    case codeSigning
    case documentSigning
    case emailProtection
    case ocspSigning
    case serverAuth
    case smartCardLogin
    case timeStamping
    case sdkUnknown(String)
}

extension ExtendedKeyUsageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExtendedKeyUsageType] {
        return [
            .certificateTransparency,
            .clientAuth,
            .codeSigning,
            .documentSigning,
            .emailProtection,
            .ocspSigning,
            .serverAuth,
            .smartCardLogin,
            .timeStamping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .certificateTransparency: return "CERTIFICATE_TRANSPARENCY"
        case .clientAuth: return "CLIENT_AUTH"
        case .codeSigning: return "CODE_SIGNING"
        case .documentSigning: return "DOCUMENT_SIGNING"
        case .emailProtection: return "EMAIL_PROTECTION"
        case .ocspSigning: return "OCSP_SIGNING"
        case .serverAuth: return "SERVER_AUTH"
        case .smartCardLogin: return "SMART_CARD_LOGIN"
        case .timeStamping: return "TIME_STAMPING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExtendedKeyUsageType(rawValue: rawValue) ?? ExtendedKeyUsageType.sdkUnknown(rawValue)
    }
}

extension Extensions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificatePolicies = "CertificatePolicies"
        case extendedKeyUsage = "ExtendedKeyUsage"
        case keyUsage = "KeyUsage"
        case subjectAlternativeNames = "SubjectAlternativeNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificatePolicies = certificatePolicies {
            var certificatePoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificatePolicies)
            for certificatepolicylist0 in certificatePolicies {
                try certificatePoliciesContainer.encode(certificatepolicylist0)
            }
        }
        if let extendedKeyUsage = extendedKeyUsage {
            var extendedKeyUsageContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendedKeyUsage)
            for extendedkeyusagelist0 in extendedKeyUsage {
                try extendedKeyUsageContainer.encode(extendedkeyusagelist0)
            }
        }
        if let keyUsage = keyUsage {
            try encodeContainer.encode(keyUsage, forKey: .keyUsage)
        }
        if let subjectAlternativeNames = subjectAlternativeNames {
            var subjectAlternativeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectAlternativeNames)
            for generalnamelist0 in subjectAlternativeNames {
                try subjectAlternativeNamesContainer.encode(generalnamelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatePoliciesContainer = try containerValues.decodeIfPresent([PolicyInformation?].self, forKey: .certificatePolicies)
        var certificatePoliciesDecoded0:[PolicyInformation]? = nil
        if let certificatePoliciesContainer = certificatePoliciesContainer {
            certificatePoliciesDecoded0 = [PolicyInformation]()
            for structure0 in certificatePoliciesContainer {
                if let structure0 = structure0 {
                    certificatePoliciesDecoded0?.append(structure0)
                }
            }
        }
        certificatePolicies = certificatePoliciesDecoded0
        let extendedKeyUsageContainer = try containerValues.decodeIfPresent([ExtendedKeyUsage?].self, forKey: .extendedKeyUsage)
        var extendedKeyUsageDecoded0:[ExtendedKeyUsage]? = nil
        if let extendedKeyUsageContainer = extendedKeyUsageContainer {
            extendedKeyUsageDecoded0 = [ExtendedKeyUsage]()
            for structure0 in extendedKeyUsageContainer {
                if let structure0 = structure0 {
                    extendedKeyUsageDecoded0?.append(structure0)
                }
            }
        }
        extendedKeyUsage = extendedKeyUsageDecoded0
        let keyUsageDecoded = try containerValues.decodeIfPresent(KeyUsage.self, forKey: .keyUsage)
        keyUsage = keyUsageDecoded
        let subjectAlternativeNamesContainer = try containerValues.decodeIfPresent([GeneralName?].self, forKey: .subjectAlternativeNames)
        var subjectAlternativeNamesDecoded0:[GeneralName]? = nil
        if let subjectAlternativeNamesContainer = subjectAlternativeNamesContainer {
            subjectAlternativeNamesDecoded0 = [GeneralName]()
            for structure0 in subjectAlternativeNamesContainer {
                if let structure0 = structure0 {
                    subjectAlternativeNamesDecoded0?.append(structure0)
                }
            }
        }
        subjectAlternativeNames = subjectAlternativeNamesDecoded0
    }
}

extension Extensions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Extensions(certificatePolicies: \(String(describing: certificatePolicies)), extendedKeyUsage: \(String(describing: extendedKeyUsage)), keyUsage: \(String(describing: keyUsage)), subjectAlternativeNames: \(String(describing: subjectAlternativeNames)))"}
}

/// <p>Contains X.509 extension information for a certificate.</p>
public struct Extensions: Equatable {
    /// <p>Contains a sequence of one or more policy information terms, each of which consists of
    /// 			an object identifier (OID) and optional qualifiers. For more information, see NIST's
    /// 			definition of <a href="https://csrc.nist.gov/glossary/term/Object_Identifier">Object
    /// 				Identifier (OID)</a>.</p>
    /// 		       <p>In an end-entity certificate, these terms indicate the policy under which the
    /// 			certificate was issued and the purposes for which it may be used. In a CA certificate,
    /// 			these terms limit the set of policies for certification paths that include this
    /// 			certificate.</p>
    public let certificatePolicies: [PolicyInformation]?
    /// <p>Specifies additional purposes for which the certified public key may be used other
    /// 			than basic purposes indicated in the <code>KeyUsage</code> extension.</p>
    public let extendedKeyUsage: [ExtendedKeyUsage]?
    /// <p>Defines one or more purposes for which the key contained in the certificate can be
    /// 			used. Default value for each option is false.</p>
    public let keyUsage: KeyUsage?
    /// <p>The subject alternative name extension allows identities to be bound to the subject of
    /// 			the certificate. These identities may be included in addition to or in place of the
    /// 			identity in the subject field of the certificate.</p>
    public let subjectAlternativeNames: [GeneralName]?

    public init (
        certificatePolicies: [PolicyInformation]? = nil,
        extendedKeyUsage: [ExtendedKeyUsage]? = nil,
        keyUsage: KeyUsage? = nil,
        subjectAlternativeNames: [GeneralName]? = nil
    )
    {
        self.certificatePolicies = certificatePolicies
        self.extendedKeyUsage = extendedKeyUsage
        self.keyUsage = keyUsage
        self.subjectAlternativeNames = subjectAlternativeNames
    }
}

public enum FailureReason {
    case other
    case requestTimedOut
    case unsupportedAlgorithm
    case sdkUnknown(String)
}

extension FailureReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FailureReason] {
        return [
            .other,
            .requestTimedOut,
            .unsupportedAlgorithm,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .other: return "OTHER"
        case .requestTimedOut: return "REQUEST_TIMED_OUT"
        case .unsupportedAlgorithm: return "UNSUPPORTED_ALGORITHM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FailureReason(rawValue: rawValue) ?? FailureReason.sdkUnknown(rawValue)
    }
}

extension GeneralName: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryName = "DirectoryName"
        case dnsName = "DnsName"
        case ediPartyName = "EdiPartyName"
        case ipAddress = "IpAddress"
        case otherName = "OtherName"
        case registeredId = "RegisteredId"
        case rfc822Name = "Rfc822Name"
        case uniformResourceIdentifier = "UniformResourceIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let dnsName = dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let ediPartyName = ediPartyName {
            try encodeContainer.encode(ediPartyName, forKey: .ediPartyName)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let otherName = otherName {
            try encodeContainer.encode(otherName, forKey: .otherName)
        }
        if let registeredId = registeredId {
            try encodeContainer.encode(registeredId, forKey: .registeredId)
        }
        if let rfc822Name = rfc822Name {
            try encodeContainer.encode(rfc822Name, forKey: .rfc822Name)
        }
        if let uniformResourceIdentifier = uniformResourceIdentifier {
            try encodeContainer.encode(uniformResourceIdentifier, forKey: .uniformResourceIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otherNameDecoded = try containerValues.decodeIfPresent(OtherName.self, forKey: .otherName)
        otherName = otherNameDecoded
        let rfc822NameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rfc822Name)
        rfc822Name = rfc822NameDecoded
        let dnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let directoryNameDecoded = try containerValues.decodeIfPresent(ASN1Subject.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let ediPartyNameDecoded = try containerValues.decodeIfPresent(EdiPartyName.self, forKey: .ediPartyName)
        ediPartyName = ediPartyNameDecoded
        let uniformResourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uniformResourceIdentifier)
        uniformResourceIdentifier = uniformResourceIdentifierDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let registeredIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registeredId)
        registeredId = registeredIdDecoded
    }
}

extension GeneralName: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeneralName(directoryName: \(String(describing: directoryName)), dnsName: \(String(describing: dnsName)), ediPartyName: \(String(describing: ediPartyName)), ipAddress: \(String(describing: ipAddress)), otherName: \(String(describing: otherName)), registeredId: \(String(describing: registeredId)), rfc822Name: \(String(describing: rfc822Name)), uniformResourceIdentifier: \(String(describing: uniformResourceIdentifier)))"}
}

/// <p>Describes an ASN.1 X.400 <code>GeneralName</code> as defined in <a href="https://tools.ietf.org/html/rfc5280">RFC 5280</a>. Only one of the
/// 			following naming options should be provided. Providing more than one option results in
/// 			an <code>InvalidArgsException</code> error.</p>
public struct GeneralName: Equatable {
    /// <p>Contains information about the certificate subject. The <code>Subject</code> field in
    /// 			the certificate identifies the entity that owns or controls the public key in the
    /// 			certificate. The entity can be a user, computer, device, or service. The <code>Subject
    /// 			</code>must contain an X.500 distinguished name (DN). A DN is a sequence of relative
    /// 			distinguished names (RDNs). The RDNs are separated by commas in the certificate.</p>
    public let directoryName: ASN1Subject?
    /// <p>Represents <code>GeneralName</code> as a DNS name.</p>
    public let dnsName: String?
    /// <p>Represents <code>GeneralName</code> as an <code>EdiPartyName</code> object.</p>
    public let ediPartyName: EdiPartyName?
    /// <p>Represents <code>GeneralName</code> as an IPv4 or IPv6 address.</p>
    public let ipAddress: String?
    /// <p>Represents <code>GeneralName</code> using an <code>OtherName</code> object.</p>
    public let otherName: OtherName?
    /// <p> Represents <code>GeneralName</code> as an object identifier (OID).</p>
    public let registeredId: String?
    /// <p>Represents <code>GeneralName</code> as an <a href="https://tools.ietf.org/html/rfc822">RFC 822</a> email address.</p>
    public let rfc822Name: String?
    /// <p>Represents <code>GeneralName</code> as a URI.</p>
    public let uniformResourceIdentifier: String?

    public init (
        directoryName: ASN1Subject? = nil,
        dnsName: String? = nil,
        ediPartyName: EdiPartyName? = nil,
        ipAddress: String? = nil,
        otherName: OtherName? = nil,
        registeredId: String? = nil,
        rfc822Name: String? = nil,
        uniformResourceIdentifier: String? = nil
    )
    {
        self.directoryName = directoryName
        self.dnsName = dnsName
        self.ediPartyName = ediPartyName
        self.ipAddress = ipAddress
        self.otherName = otherName
        self.registeredId = registeredId
        self.rfc822Name = rfc822Name
        self.uniformResourceIdentifier = uniformResourceIdentifier
    }
}

public struct GetCertificateAuthorityCertificateInputBodyMiddleware: Middleware {
    public let id: String = "GetCertificateAuthorityCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCertificateAuthorityCertificateInput>
    public typealias MOutput = OperationOutput<GetCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCertificateAuthorityCertificateOutputError>
}

extension GetCertificateAuthorityCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCertificateAuthorityCertificateInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)))"}
}

extension GetCertificateAuthorityCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct GetCertificateAuthorityCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "GetCertificateAuthorityCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCertificateAuthorityCertificateInput>
    public typealias MOutput = OperationOutput<GetCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCertificateAuthorityCertificateOutputError>
}

public struct GetCertificateAuthorityCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCertificateAuthorityCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCertificateAuthorityCertificateInput>
    public typealias MOutput = OperationOutput<GetCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCertificateAuthorityCertificateOutputError>
}

public struct GetCertificateAuthorityCertificateInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of your private CA. This is of the form:</p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>.
    /// 		</p>
    public let certificateAuthorityArn: String?

    public init (
        certificateAuthorityArn: String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct GetCertificateAuthorityCertificateInputBody: Equatable {
    public let certificateAuthorityArn: String?
}

extension GetCertificateAuthorityCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension GetCertificateAuthorityCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCertificateAuthorityCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCertificateAuthorityCertificateOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCertificateAuthorityCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCertificateAuthorityCertificateOutputResponse(certificate: \(String(describing: certificate)), certificateChain: \(String(describing: certificateChain)))"}
}

extension GetCertificateAuthorityCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCertificateAuthorityCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificate = output.certificate
            self.certificateChain = output.certificateChain
        } else {
            self.certificate = nil
            self.certificateChain = nil
        }
    }
}

public struct GetCertificateAuthorityCertificateOutputResponse: Equatable {
    /// <p>Base64-encoded certificate authority (CA) certificate.</p>
    public let certificate: String?
    /// <p>Base64-encoded certificate chain that includes any intermediate certificates and
    /// 			chains up to root certificate that you used to sign your private CA certificate. The
    /// 			chain does not include your private CA certificate. If this is a root CA, the value will
    /// 			be null.</p>
    public let certificateChain: String?

    public init (
        certificate: String? = nil,
        certificateChain: String? = nil
    )
    {
        self.certificate = certificate
        self.certificateChain = certificateChain
    }
}

struct GetCertificateAuthorityCertificateOutputResponseBody: Equatable {
    public let certificate: String?
    public let certificateChain: String?
}

extension GetCertificateAuthorityCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case certificateChain = "CertificateChain"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
    }
}

public struct GetCertificateAuthorityCsrInputBodyMiddleware: Middleware {
    public let id: String = "GetCertificateAuthorityCsrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCertificateAuthorityCsrInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCertificateAuthorityCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCertificateAuthorityCsrInput>
    public typealias MOutput = OperationOutput<GetCertificateAuthorityCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCertificateAuthorityCsrOutputError>
}

extension GetCertificateAuthorityCsrInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCertificateAuthorityCsrInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)))"}
}

extension GetCertificateAuthorityCsrInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct GetCertificateAuthorityCsrInputHeadersMiddleware: Middleware {
    public let id: String = "GetCertificateAuthorityCsrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCertificateAuthorityCsrInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCertificateAuthorityCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCertificateAuthorityCsrInput>
    public typealias MOutput = OperationOutput<GetCertificateAuthorityCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCertificateAuthorityCsrOutputError>
}

public struct GetCertificateAuthorityCsrInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCertificateAuthorityCsrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCertificateAuthorityCsrInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCertificateAuthorityCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCertificateAuthorityCsrInput>
    public typealias MOutput = OperationOutput<GetCertificateAuthorityCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCertificateAuthorityCsrOutputError>
}

public struct GetCertificateAuthorityCsrInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that was returned when you called the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a> action. This must be of the form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>
    /// 		       </p>
    public let certificateAuthorityArn: String?

    public init (
        certificateAuthorityArn: String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct GetCertificateAuthorityCsrInputBody: Equatable {
    public let certificateAuthorityArn: String?
}

extension GetCertificateAuthorityCsrInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension GetCertificateAuthorityCsrOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCertificateAuthorityCsrOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestInProgressException" : self = .requestInProgressException(try RequestInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCertificateAuthorityCsrOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case requestInProgressException(RequestInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCertificateAuthorityCsrOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCertificateAuthorityCsrOutputResponse(csr: \(String(describing: csr)))"}
}

extension GetCertificateAuthorityCsrOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCertificateAuthorityCsrOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.csr = output.csr
        } else {
            self.csr = nil
        }
    }
}

public struct GetCertificateAuthorityCsrOutputResponse: Equatable {
    /// <p>The base64 PEM-encoded certificate signing request (CSR) for your private CA
    /// 			certificate.</p>
    public let csr: String?

    public init (
        csr: String? = nil
    )
    {
        self.csr = csr
    }
}

struct GetCertificateAuthorityCsrOutputResponseBody: Equatable {
    public let csr: String?
}

extension GetCertificateAuthorityCsrOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case csr = "Csr"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .csr)
        csr = csrDecoded
    }
}

public struct GetCertificateInputBodyMiddleware: Middleware {
    public let id: String = "GetCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCertificateInput>
    public typealias MOutput = OperationOutput<GetCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCertificateOutputError>
}

extension GetCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCertificateInput(certificateArn: \(String(describing: certificateArn)), certificateAuthorityArn: \(String(describing: certificateAuthorityArn)))"}
}

extension GetCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct GetCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "GetCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCertificateInput>
    public typealias MOutput = OperationOutput<GetCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCertificateOutputError>
}

public struct GetCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCertificateInput>
    public typealias MOutput = OperationOutput<GetCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCertificateOutputError>
}

public struct GetCertificateInput: Equatable {
    /// <p>The ARN of the issued certificate. The ARN contains the certificate serial number and
    /// 			must be in the following form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>/certificate/<i>286535153982981100925020015808220737245</i>
    ///             </code>
    /// 		       </p>
    public let certificateArn: String?
    /// <p>The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a>. This must be of the form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>.
    /// 		</p>
    public let certificateAuthorityArn: String?

    public init (
        certificateArn: String? = nil,
        certificateAuthorityArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct GetCertificateInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let certificateArn: String?
}

extension GetCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension GetCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestInProgressException" : self = .requestInProgressException(try RequestInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCertificateOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case requestInProgressException(RequestInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCertificateOutputResponse(certificate: \(String(describing: certificate)), certificateChain: \(String(describing: certificateChain)))"}
}

extension GetCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificate = output.certificate
            self.certificateChain = output.certificateChain
        } else {
            self.certificate = nil
            self.certificateChain = nil
        }
    }
}

public struct GetCertificateOutputResponse: Equatable {
    /// <p>The base64 PEM-encoded certificate specified by the <code>CertificateArn</code>
    /// 			parameter.</p>
    public let certificate: String?
    /// <p>The base64 PEM-encoded certificate chain that chains up to the root CA certificate
    /// 			that you used to sign your private CA certificate. </p>
    public let certificateChain: String?

    public init (
        certificate: String? = nil,
        certificateChain: String? = nil
    )
    {
        self.certificate = certificate
        self.certificateChain = certificateChain
    }
}

struct GetCertificateOutputResponseBody: Equatable {
    public let certificate: String?
    public let certificateChain: String?
}

extension GetCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case certificateChain = "CertificateChain"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
    }
}

public struct GetPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

extension GetPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension GetPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

public struct GetPolicyInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the private CA that will have its policy
    /// 			retrieved. You can find the CA's ARN by calling the ListCertificateAuthorities action.
    /// 			
    /// 		</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetPolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension GetPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetPolicyOutputResponse: Equatable {
    /// <p>The policy attached to the private CA as a JSON document.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetPolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct ImportCertificateAuthorityCertificateInputBodyMiddleware: Middleware {
    public let id: String = "ImportCertificateAuthorityCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportCertificateAuthorityCertificateInput>
    public typealias MOutput = OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportCertificateAuthorityCertificateOutputError>
}

extension ImportCertificateAuthorityCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportCertificateAuthorityCertificateInput(certificate: \(String(describing: certificate)), certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), certificateChain: \(String(describing: certificateChain)))"}
}

extension ImportCertificateAuthorityCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case certificateChain = "CertificateChain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate.base64EncodedString(), forKey: .certificate)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let certificateChain = certificateChain {
            try encodeContainer.encode(certificateChain.base64EncodedString(), forKey: .certificateChain)
        }
    }
}

public struct ImportCertificateAuthorityCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "ImportCertificateAuthorityCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportCertificateAuthorityCertificateInput>
    public typealias MOutput = OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportCertificateAuthorityCertificateOutputError>
}

public struct ImportCertificateAuthorityCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportCertificateAuthorityCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportCertificateAuthorityCertificateInput>
    public typealias MOutput = OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportCertificateAuthorityCertificateOutputError>
}

public struct ImportCertificateAuthorityCertificateInput: Equatable {
    /// <p>The PEM-encoded certificate for a private CA. This may be a self-signed certificate in
    /// 			the case of a root CA, or it may be signed by another CA that you control.</p>
    public let certificate: Data?
    /// <p>The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a>. This must be of the form: </p>
    /// 		       <p>
    ///             <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>
    ///          </p>
    public let certificateAuthorityArn: String?
    /// <p>A PEM-encoded file that contains all of your certificates, other than the certificate
    /// 			you're importing, chaining up to your root CA. Your ACM Private CA-hosted or on-premises root
    /// 			certificate is the last in the chain, and each certificate in the chain signs the one
    /// 			preceding. </p>
    /// 		       <p>This parameter must be supplied when you import a subordinate CA. When you import a
    /// 			root CA, there is no chain.</p>
    public let certificateChain: Data?

    public init (
        certificate: Data? = nil,
        certificateAuthorityArn: String? = nil,
        certificateChain: Data? = nil
    )
    {
        self.certificate = certificate
        self.certificateAuthorityArn = certificateAuthorityArn
        self.certificateChain = certificateChain
    }
}

struct ImportCertificateAuthorityCertificateInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let certificate: Data?
    public let certificateChain: Data?
}

extension ImportCertificateAuthorityCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case certificateChain = "CertificateChain"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
    }
}

extension ImportCertificateAuthorityCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportCertificateAuthorityCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateMismatchException" : self = .certificateMismatchException(try CertificateMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedCertificateException" : self = .malformedCertificateException(try MalformedCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestInProgressException" : self = .requestInProgressException(try RequestInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportCertificateAuthorityCertificateOutputError: Equatable {
    case certificateMismatchException(CertificateMismatchException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case malformedCertificateException(MalformedCertificateException)
    case requestFailedException(RequestFailedException)
    case requestInProgressException(RequestInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportCertificateAuthorityCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportCertificateAuthorityCertificateOutputResponse()"}
}

extension ImportCertificateAuthorityCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ImportCertificateAuthorityCertificateOutputResponse: Equatable {

    public init() {}
}

struct ImportCertificateAuthorityCertificateOutputResponseBody: Equatable {
}

extension ImportCertificateAuthorityCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension InvalidArgsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgsException(message: \(String(describing: message)))"}
}

extension InvalidArgsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArgsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the specified arguments was not valid.</p>
public struct InvalidArgsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArnException(message: \(String(describing: message)))"}
}

extension InvalidArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
/// 			resource.</p>
public struct InvalidArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The token specified in the <code>NextToken</code> argument is not valid. Use the token
/// 			returned from your previous call to <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities</a>.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPolicyException(message: \(String(describing: message)))"}
}

extension InvalidPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource policy is invalid or is missing a required statement. For general
/// 			information about IAM policy and statement structure, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json">Overview of JSON Policies</a>.</p>
public struct InvalidPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request action cannot be performed or is prohibited.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStateException(message: \(String(describing: message)))"}
}

extension InvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the private CA does not allow this action to occur.</p>
public struct InvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagException(message: \(String(describing: message)))"}
}

extension InvalidTagException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTagExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tag associated with the CA is not valid. The invalid argument is contained in the
/// 			message field.</p>
public struct InvalidTagException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTagExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct IssueCertificateInputBodyMiddleware: Middleware {
    public let id: String = "IssueCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IssueCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<IssueCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IssueCertificateInput>
    public typealias MOutput = OperationOutput<IssueCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IssueCertificateOutputError>
}

extension IssueCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IssueCertificateInput(apiPassthrough: \(String(describing: apiPassthrough)), certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), csr: \(String(describing: csr)), idempotencyToken: \(String(describing: idempotencyToken)), signingAlgorithm: \(String(describing: signingAlgorithm)), templateArn: \(String(describing: templateArn)), validity: \(String(describing: validity)), validityNotBefore: \(String(describing: validityNotBefore)))"}
}

extension IssueCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiPassthrough = "ApiPassthrough"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case csr = "Csr"
        case idempotencyToken = "IdempotencyToken"
        case signingAlgorithm = "SigningAlgorithm"
        case templateArn = "TemplateArn"
        case validity = "Validity"
        case validityNotBefore = "ValidityNotBefore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiPassthrough = apiPassthrough {
            try encodeContainer.encode(apiPassthrough, forKey: .apiPassthrough)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let csr = csr {
            try encodeContainer.encode(csr.base64EncodedString(), forKey: .csr)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let signingAlgorithm = signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm.rawValue, forKey: .signingAlgorithm)
        }
        if let templateArn = templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
        if let validityNotBefore = validityNotBefore {
            try encodeContainer.encode(validityNotBefore, forKey: .validityNotBefore)
        }
    }
}

public struct IssueCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "IssueCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IssueCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<IssueCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IssueCertificateInput>
    public typealias MOutput = OperationOutput<IssueCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IssueCertificateOutputError>
}

public struct IssueCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "IssueCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IssueCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<IssueCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IssueCertificateInput>
    public typealias MOutput = OperationOutput<IssueCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IssueCertificateOutputError>
}

public struct IssueCertificateInput: Equatable {
    /// <p>Specifies X.509 certificate information to be included in the issued certificate. An
    /// 				<code>APIPassthrough</code> or <code>APICSRPassthrough</code> template variant must
    /// 			be selected, or else this parameter is ignored. For more information about using these
    /// 			templates, see <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/UsingTemplates.html">Understanding Certificate Templates</a>.</p>
    /// 		       <p>If conflicting or duplicate certificate information is supplied during certificate
    /// 			issuance, ACM Private CA applies <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/UsingTemplates.html#template-order-of-operations">order of
    /// 				operation rules</a> to determine what information is used.</p>
    public let apiPassthrough: ApiPassthrough?
    /// <p>The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a>. This must be of the form:</p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>
    /// 		       </p>
    public let certificateAuthorityArn: String?
    /// <p>The certificate signing request (CSR) for the certificate you want to issue. As an
    /// 			example, you can use the following OpenSSL command to create the CSR and a 2048 bit RSA
    /// 			private key. </p>
    /// 		       <p>
    /// 			         <code>openssl req -new -newkey rsa:2048 -days 365 -keyout private/test_cert_priv_key.pem
    /// 				-out csr/test_cert_.csr</code>
    /// 		       </p>
    /// 		       <p>If you have a configuration file, you can then use the following OpenSSL command. The
    /// 				<code>usr_cert</code> block in the configuration file contains your X509 version 3
    /// 			extensions. </p>
    /// 		       <p>
    ///             <code>openssl req -new -config openssl_rsa.cnf -extensions usr_cert -newkey rsa:2048
    /// 				-days -365 -keyout private/test_cert_priv_key.pem -out
    /// 			csr/test_cert_.csr</code>
    ///          </p>
    /// 		       <p>Note: A CSR must provide either a <i>subject name</i> or a
    /// 				<i>subject alternative name</i> or the request will be rejected.
    /// 		</p>
    public let csr: Data?
    /// <p>Alphanumeric string that can be used to distinguish between calls to the <b>IssueCertificate</b> action. Idempotency tokens for <b>IssueCertificate</b> time out after one minute. Therefore, if you
    /// 			call <b>IssueCertificate</b> multiple times with the same
    /// 			idempotency token within one minute, ACM Private CA recognizes that you are requesting only one
    /// 			certificate and will issue only one. If you change the idempotency token for each call,
    /// 			PCA recognizes that you are requesting multiple certificates.</p>
    public let idempotencyToken: String?
    /// <p>The name of the algorithm that will be used to sign the certificate to be issued. </p>
    /// 		       <p>This parameter should not be confused with the <code>SigningAlgorithm</code> parameter
    /// 			used to sign a CSR in the <code>CreateCertificateAuthority</code> action.</p>
    public let signingAlgorithm: SigningAlgorithm?
    /// <p>Specifies a custom configuration template to use when issuing a certificate. If this
    /// 			parameter is not provided, ACM Private CA defaults to the <code>EndEntityCertificate/V1</code>
    /// 			template. For CA certificates, you should choose the shortest path length that meets
    /// 			your needs. The path length is indicated by the PathLen<i>N</i> portion of
    /// 			the ARN, where <i>N</i> is the <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaTerms.html#terms-cadepth">CA depth</a>.</p>
    /// 		       <p>Note: The CA depth configured on a subordinate CA certificate must not exceed the
    /// 			limit set by its parents in the CA hierarchy.</p>
    /// 		       <p>For a list of <code>TemplateArn</code> values supported by ACM Private CA, see <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/UsingTemplates.html">Understanding Certificate
    /// 				Templates</a>.</p>
    public let templateArn: String?
    /// <p>Information describing the end of the validity period of the certificate. This
    /// 			parameter sets the “Not After” date for the certificate.</p>
    /// 		       <p>Certificate validity is the period of time during which a certificate is valid.
    /// 			Validity can be expressed as an explicit date and time when the certificate expires, or
    /// 			as a span of time after issuance, stated in days, months, or years. For more
    /// 			information, see <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.5">Validity</a> in RFC 5280. </p>
    /// 		       <p>This value is unaffected when <code>ValidityNotBefore</code> is also specified. For
    /// 			example, if <code>Validity</code> is set to 20 days in the future, the certificate will
    /// 			expire 20 days from issuance time regardless of the <code>ValidityNotBefore</code>
    /// 			value.</p>
    /// 		       <p>The end of the validity period configured on a certificate must not exceed the limit
    /// 			set on its parents in the CA hierarchy.</p>
    public let validity: Validity?
    /// <p>Information describing the start of the validity period of the certificate. This
    /// 			parameter sets the “Not Before" date for the certificate.</p>
    /// 		       <p>By default, when issuing a certificate, ACM Private CA sets the "Not Before" date to the
    /// 			issuance time minus 60 minutes. This compensates for clock inconsistencies across
    /// 			computer systems. The <code>ValidityNotBefore</code> parameter can be used to customize
    /// 			the “Not Before” value. </p>
    /// 		       <p>Unlike the <code>Validity</code> parameter, the <code>ValidityNotBefore</code>
    /// 			parameter is optional.</p>
    /// 		       <p>The <code>ValidityNotBefore</code> value is expressed as an explicit date and time,
    /// 			using the <code>Validity</code> type value <code>ABSOLUTE</code>. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_Validity.html">Validity</a> in this API reference and <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.5">Validity</a> in RFC
    /// 			5280.</p>
    public let validityNotBefore: Validity?

    public init (
        apiPassthrough: ApiPassthrough? = nil,
        certificateAuthorityArn: String? = nil,
        csr: Data? = nil,
        idempotencyToken: String? = nil,
        signingAlgorithm: SigningAlgorithm? = nil,
        templateArn: String? = nil,
        validity: Validity? = nil,
        validityNotBefore: Validity? = nil
    )
    {
        self.apiPassthrough = apiPassthrough
        self.certificateAuthorityArn = certificateAuthorityArn
        self.csr = csr
        self.idempotencyToken = idempotencyToken
        self.signingAlgorithm = signingAlgorithm
        self.templateArn = templateArn
        self.validity = validity
        self.validityNotBefore = validityNotBefore
    }
}

struct IssueCertificateInputBody: Equatable {
    public let apiPassthrough: ApiPassthrough?
    public let certificateAuthorityArn: String?
    public let csr: Data?
    public let signingAlgorithm: SigningAlgorithm?
    public let templateArn: String?
    public let validity: Validity?
    public let validityNotBefore: Validity?
    public let idempotencyToken: String?
}

extension IssueCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiPassthrough = "ApiPassthrough"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case csr = "Csr"
        case idempotencyToken = "IdempotencyToken"
        case signingAlgorithm = "SigningAlgorithm"
        case templateArn = "TemplateArn"
        case validity = "Validity"
        case validityNotBefore = "ValidityNotBefore"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiPassthroughDecoded = try containerValues.decodeIfPresent(ApiPassthrough.self, forKey: .apiPassthrough)
        apiPassthrough = apiPassthroughDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let csrDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .csr)
        csr = csrDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(SigningAlgorithm.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let validityDecoded = try containerValues.decodeIfPresent(Validity.self, forKey: .validity)
        validity = validityDecoded
        let validityNotBeforeDecoded = try containerValues.decodeIfPresent(Validity.self, forKey: .validityNotBefore)
        validityNotBefore = validityNotBeforeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension IssueCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension IssueCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedCSRException" : self = .malformedCSRException(try MalformedCSRException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum IssueCertificateOutputError: Equatable {
    case invalidArgsException(InvalidArgsException)
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case malformedCSRException(MalformedCSRException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension IssueCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IssueCertificateOutputResponse(certificateArn: \(String(describing: certificateArn)))"}
}

extension IssueCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IssueCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateArn = output.certificateArn
        } else {
            self.certificateArn = nil
        }
    }
}

public struct IssueCertificateOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the issued certificate and the certificate serial
    /// 			number. This is of the form:</p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>/certificate/<i>286535153982981100925020015808220737245</i>
    ///             </code>
    /// 		       </p>
    public let certificateArn: String?

    public init (
        certificateArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

struct IssueCertificateOutputResponseBody: Equatable {
    public let certificateArn: String?
}

extension IssueCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

public enum KeyAlgorithm {
    case ecPrime256v1
    case ecSecp384r1
    case rsa2048
    case rsa4096
    case sdkUnknown(String)
}

extension KeyAlgorithm : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KeyAlgorithm] {
        return [
            .ecPrime256v1,
            .ecSecp384r1,
            .rsa2048,
            .rsa4096,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ecPrime256v1: return "EC_prime256v1"
        case .ecSecp384r1: return "EC_secp384r1"
        case .rsa2048: return "RSA_2048"
        case .rsa4096: return "RSA_4096"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KeyAlgorithm(rawValue: rawValue) ?? KeyAlgorithm.sdkUnknown(rawValue)
    }
}

public enum KeyStorageSecurityStandard {
    case fips1402Level2OrHigher
    case fips1402Level3OrHigher
    case sdkUnknown(String)
}

extension KeyStorageSecurityStandard : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KeyStorageSecurityStandard] {
        return [
            .fips1402Level2OrHigher,
            .fips1402Level3OrHigher,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fips1402Level2OrHigher: return "FIPS_140_2_LEVEL_2_OR_HIGHER"
        case .fips1402Level3OrHigher: return "FIPS_140_2_LEVEL_3_OR_HIGHER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KeyStorageSecurityStandard(rawValue: rawValue) ?? KeyStorageSecurityStandard.sdkUnknown(rawValue)
    }
}

extension KeyUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cRLSign = "CRLSign"
        case dataEncipherment = "DataEncipherment"
        case decipherOnly = "DecipherOnly"
        case digitalSignature = "DigitalSignature"
        case encipherOnly = "EncipherOnly"
        case keyAgreement = "KeyAgreement"
        case keyCertSign = "KeyCertSign"
        case keyEncipherment = "KeyEncipherment"
        case nonRepudiation = "NonRepudiation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cRLSign != false {
            try encodeContainer.encode(cRLSign, forKey: .cRLSign)
        }
        if dataEncipherment != false {
            try encodeContainer.encode(dataEncipherment, forKey: .dataEncipherment)
        }
        if decipherOnly != false {
            try encodeContainer.encode(decipherOnly, forKey: .decipherOnly)
        }
        if digitalSignature != false {
            try encodeContainer.encode(digitalSignature, forKey: .digitalSignature)
        }
        if encipherOnly != false {
            try encodeContainer.encode(encipherOnly, forKey: .encipherOnly)
        }
        if keyAgreement != false {
            try encodeContainer.encode(keyAgreement, forKey: .keyAgreement)
        }
        if keyCertSign != false {
            try encodeContainer.encode(keyCertSign, forKey: .keyCertSign)
        }
        if keyEncipherment != false {
            try encodeContainer.encode(keyEncipherment, forKey: .keyEncipherment)
        }
        if nonRepudiation != false {
            try encodeContainer.encode(nonRepudiation, forKey: .nonRepudiation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let digitalSignatureDecoded = try containerValues.decode(Bool.self, forKey: .digitalSignature)
        digitalSignature = digitalSignatureDecoded
        let nonRepudiationDecoded = try containerValues.decode(Bool.self, forKey: .nonRepudiation)
        nonRepudiation = nonRepudiationDecoded
        let keyEnciphermentDecoded = try containerValues.decode(Bool.self, forKey: .keyEncipherment)
        keyEncipherment = keyEnciphermentDecoded
        let dataEnciphermentDecoded = try containerValues.decode(Bool.self, forKey: .dataEncipherment)
        dataEncipherment = dataEnciphermentDecoded
        let keyAgreementDecoded = try containerValues.decode(Bool.self, forKey: .keyAgreement)
        keyAgreement = keyAgreementDecoded
        let keyCertSignDecoded = try containerValues.decode(Bool.self, forKey: .keyCertSign)
        keyCertSign = keyCertSignDecoded
        let cRLSignDecoded = try containerValues.decode(Bool.self, forKey: .cRLSign)
        cRLSign = cRLSignDecoded
        let encipherOnlyDecoded = try containerValues.decode(Bool.self, forKey: .encipherOnly)
        encipherOnly = encipherOnlyDecoded
        let decipherOnlyDecoded = try containerValues.decode(Bool.self, forKey: .decipherOnly)
        decipherOnly = decipherOnlyDecoded
    }
}

extension KeyUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyUsage(cRLSign: \(String(describing: cRLSign)), dataEncipherment: \(String(describing: dataEncipherment)), decipherOnly: \(String(describing: decipherOnly)), digitalSignature: \(String(describing: digitalSignature)), encipherOnly: \(String(describing: encipherOnly)), keyAgreement: \(String(describing: keyAgreement)), keyCertSign: \(String(describing: keyCertSign)), keyEncipherment: \(String(describing: keyEncipherment)), nonRepudiation: \(String(describing: nonRepudiation)))"}
}

/// <p>Defines one or more purposes for which the key contained in the certificate can be
/// 			used. Default value for each option is false.</p>
public struct KeyUsage: Equatable {
    /// <p>Key can be used to sign CRLs.</p>
    public let cRLSign: Bool
    /// <p>Key can be used to decipher data.</p>
    public let dataEncipherment: Bool
    /// <p>Key can be used only to decipher data.</p>
    public let decipherOnly: Bool
    /// <p> Key can be used for digital signing.</p>
    public let digitalSignature: Bool
    /// <p>Key can be used only to encipher data.</p>
    public let encipherOnly: Bool
    /// <p>Key can be used in a key-agreement protocol.</p>
    public let keyAgreement: Bool
    /// <p>Key can be used to sign certificates.</p>
    public let keyCertSign: Bool
    /// <p>Key can be used to encipher data.</p>
    public let keyEncipherment: Bool
    /// <p>Key can be used for non-repudiation.</p>
    public let nonRepudiation: Bool

    public init (
        cRLSign: Bool = false,
        dataEncipherment: Bool = false,
        decipherOnly: Bool = false,
        digitalSignature: Bool = false,
        encipherOnly: Bool = false,
        keyAgreement: Bool = false,
        keyCertSign: Bool = false,
        keyEncipherment: Bool = false,
        nonRepudiation: Bool = false
    )
    {
        self.cRLSign = cRLSign
        self.dataEncipherment = dataEncipherment
        self.decipherOnly = decipherOnly
        self.digitalSignature = digitalSignature
        self.encipherOnly = encipherOnly
        self.keyAgreement = keyAgreement
        self.keyCertSign = keyCertSign
        self.keyEncipherment = keyEncipherment
        self.nonRepudiation = nonRepudiation
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An ACM Private CA quota has been exceeded. See the exception message returned to determine the
/// 			quota that was exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListCertificateAuthoritiesInputBodyMiddleware: Middleware {
    public let id: String = "ListCertificateAuthoritiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCertificateAuthoritiesInput>
    public typealias MOutput = OperationOutput<ListCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCertificateAuthoritiesOutputError>
}

extension ListCertificateAuthoritiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCertificateAuthoritiesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceOwner: \(String(describing: resourceOwner)))"}
}

extension ListCertificateAuthoritiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceOwner = "ResourceOwner"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
    }
}

public struct ListCertificateAuthoritiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCertificateAuthoritiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCertificateAuthoritiesInput>
    public typealias MOutput = OperationOutput<ListCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCertificateAuthoritiesOutputError>
}

public struct ListCertificateAuthoritiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCertificateAuthoritiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCertificateAuthoritiesInput>
    public typealias MOutput = OperationOutput<ListCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCertificateAuthoritiesOutputError>
}

public struct ListCertificateAuthoritiesInput: Equatable {
    /// <p>Use this parameter when paginating results to specify the maximum number of items to
    /// 			return in the response on each page. If additional items exist beyond the number you
    /// 			specify, the <code>NextToken</code> element is sent in the response. Use this
    /// 				<code>NextToken</code> value in a subsequent request to retrieve additional
    /// 			items.</p>
    public let maxResults: Int?
    /// <p>Use this parameter when paginating results in a subsequent request after you receive a
    /// 			response with truncated results. Set it to the value of the <code>NextToken</code>
    /// 			parameter from the response you just received.</p>
    public let nextToken: String?
    /// <p>Use this parameter to filter the returned set of certificate authorities based on
    /// 			their owner. The default is SELF.</p>
    public let resourceOwner: ResourceOwner?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceOwner: ResourceOwner? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceOwner = resourceOwner
    }
}

struct ListCertificateAuthoritiesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let resourceOwner: ResourceOwner?
}

extension ListCertificateAuthoritiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceOwner = "ResourceOwner"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
    }
}

extension ListCertificateAuthoritiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCertificateAuthoritiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCertificateAuthoritiesOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCertificateAuthoritiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCertificateAuthoritiesOutputResponse(certificateAuthorities: \(String(describing: certificateAuthorities)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCertificateAuthoritiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCertificateAuthoritiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateAuthorities = output.certificateAuthorities
            self.nextToken = output.nextToken
        } else {
            self.certificateAuthorities = nil
            self.nextToken = nil
        }
    }
}

public struct ListCertificateAuthoritiesOutputResponse: Equatable {
    /// <p>Summary information about each certificate authority you have created.</p>
    public let certificateAuthorities: [CertificateAuthority]?
    /// <p>When the list is truncated, this value is present and should be used for the
    /// 				<code>NextToken</code> parameter in a subsequent pagination request.</p>
    public let nextToken: String?

    public init (
        certificateAuthorities: [CertificateAuthority]? = nil,
        nextToken: String? = nil
    )
    {
        self.certificateAuthorities = certificateAuthorities
        self.nextToken = nextToken
    }
}

struct ListCertificateAuthoritiesOutputResponseBody: Equatable {
    public let certificateAuthorities: [CertificateAuthority]?
    public let nextToken: String?
}

extension ListCertificateAuthoritiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorities = "CertificateAuthorities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthoritiesContainer = try containerValues.decodeIfPresent([CertificateAuthority?].self, forKey: .certificateAuthorities)
        var certificateAuthoritiesDecoded0:[CertificateAuthority]? = nil
        if let certificateAuthoritiesContainer = certificateAuthoritiesContainer {
            certificateAuthoritiesDecoded0 = [CertificateAuthority]()
            for structure0 in certificateAuthoritiesContainer {
                if let structure0 = structure0 {
                    certificateAuthoritiesDecoded0?.append(structure0)
                }
            }
        }
        certificateAuthorities = certificateAuthoritiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "ListPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionsOutputError>
}

extension ListPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionsInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the private CA to inspect. You can find the ARN by
    /// 			calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities</a> action. This must be of the form:
    /// 				<code>arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012</code>
    /// 			You can get a private CA's ARN by running the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities</a> action.</p>
    public let certificateAuthorityArn: String?
    /// <p>When paginating results, use this parameter to specify the maximum number of items to
    /// 			return in the response. If additional items exist beyond the number you specify, the
    /// 				<b>NextToken</b> element is sent in the response. Use this
    /// 				<b>NextToken</b> value in a subsequent request to retrieve
    /// 			additional items.</p>
    public let maxResults: Int?
    /// <p>When paginating results, use this parameter in a subsequent request after you receive
    /// 			a response with truncated results. Set it to the value of <b>NextToken</b> from the response you just received.</p>
    public let nextToken: String?

    public init (
        certificateAuthorityArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionsInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionsOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionsOutputResponse(nextToken: \(String(describing: nextToken)), permissions: \(String(describing: permissions)))"}
}

extension ListPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionsOutputResponse: Equatable {
    /// <p>When the list is truncated, this value is present and should be used for the <b>NextToken</b> parameter in a subsequent pagination request.
    /// 		</p>
    public let nextToken: String?
    /// <p>Summary information about each permission assigned by the specified private CA,
    /// 			including the action enabled, the policy provided, and the time of creation.</p>
    public let permissions: [Permission]?

    public init (
        nextToken: String? = nil,
        permissions: [Permission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionsOutputResponseBody: Equatable {
    public let permissions: [Permission]?
    public let nextToken: String?
}

extension ListPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case permissions = "Permissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

extension ListTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that was returned when you called the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a> action. This must be of the form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>
    /// 		       </p>
    public let certificateAuthorityArn: String?
    /// <p>Use this parameter when paginating results to specify the maximum number of items to
    /// 			return in the response. If additional items exist beyond the number you specify, the
    /// 				<b>NextToken</b> element is sent in the response. Use this
    /// 				<b>NextToken</b> value in a subsequent request to retrieve
    /// 			additional items.</p>
    public let maxResults: Int?
    /// <p>Use this parameter when paginating results in a subsequent request after you receive a
    /// 			response with truncated results. Set it to the value of <b>NextToken</b> from the response you just received.</p>
    public let nextToken: String?

    public init (
        certificateAuthorityArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Equatable {
    /// <p>When the list is truncated, this value is present and should be used for the <b>NextToken</b> parameter in a subsequent pagination request.
    /// 		</p>
    public let nextToken: String?
    /// <p>The tags associated with your private CA.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LockoutPreventedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LockoutPreventedException(message: \(String(describing: message)))"}
}

extension LockoutPreventedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LockoutPreventedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The current action was prevented because it would lock the caller out from performing
/// 			subsequent actions. Verify that the specified parameters would not result in the caller
/// 			being denied access to the resource. </p>
public struct LockoutPreventedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LockoutPreventedExceptionBody: Equatable {
    public let message: String?
}

extension LockoutPreventedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedCSRException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MalformedCSRException(message: \(String(describing: message)))"}
}

extension MalformedCSRException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MalformedCSRExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate signing request is invalid.</p>
public struct MalformedCSRException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedCSRExceptionBody: Equatable {
    public let message: String?
}

extension MalformedCSRExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedCertificateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MalformedCertificateException(message: \(String(describing: message)))"}
}

extension MalformedCertificateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MalformedCertificateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more fields in the certificate are invalid.</p>
public struct MalformedCertificateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedCertificateExceptionBody: Equatable {
    public let message: String?
}

extension MalformedCertificateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OtherName: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case typeId = "TypeId"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typeId = typeId {
            try encodeContainer.encode(typeId, forKey: .typeId)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeId)
        typeId = typeIdDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension OtherName: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OtherName(typeId: \(String(describing: typeId)), value: \(String(describing: value)))"}
}

/// <p>Defines a custom ASN.1 X.400 <code>GeneralName</code> using an object identifier (OID)
/// 			and value. The OID must satisfy the regular expression shown below. For more
/// 			information, see NIST's definition of <a href="https://csrc.nist.gov/glossary/term/Object_Identifier">Object Identifier
/// 				(OID)</a>.</p>
public struct OtherName: Equatable {
    /// <p>Specifies an OID. </p>
    public let typeId: String?
    /// <p>Specifies an OID value.</p>
    public let value: String?

    public init (
        typeId: String? = nil,
        value: String? = nil
    )
    {
        self.typeId = typeId
        self.value = value
    }
}

extension Permission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case createdAt = "CreatedAt"
        case policy = "Policy"
        case principal = "Principal"
        case sourceAccount = "SourceAccount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0.rawValue)
            }
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let sourceAccount = sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
        let actionsContainer = try containerValues.decodeIfPresent([ActionType?].self, forKey: .actions)
        var actionsDecoded0:[ActionType]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [ActionType]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension Permission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Permission(actions: \(String(describing: actions)), certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), createdAt: \(String(describing: createdAt)), policy: \(String(describing: policy)), principal: \(String(describing: principal)), sourceAccount: \(String(describing: sourceAccount)))"}
}

/// <p>Permissions designate which private CA actions can be performed by an AWS service or
/// 			entity. In order for ACM to automatically renew private certificates, you must give
/// 			the ACM service principal all available permissions (<code>IssueCertificate</code>,
/// 				<code>GetCertificate</code>, and <code>ListPermissions</code>). Permissions can be
/// 			assigned with the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreatePermission.html">CreatePermission</a> action,
/// 			removed with the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_DeletePermission.html">DeletePermission</a> action, and
/// 			listed with the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListPermissions.html">ListPermissions</a> action.</p>
public struct Permission: Equatable {
    /// <p>The private CA actions that can be performed by the designated AWS service.</p>
    public let actions: [ActionType]?
    /// <p>The Amazon Resource Number (ARN) of the private CA from which the permission was
    /// 			issued.</p>
    public let certificateAuthorityArn: String?
    /// <p>The time at which the permission was created.</p>
    public let createdAt: Date?
    /// <p>The name of the policy that is associated with the permission.</p>
    public let policy: String?
    /// <p>The AWS service or entity that holds the permission. At this time, the only valid
    /// 			principal is <code>acm.amazonaws.com</code>.</p>
    public let principal: String?
    /// <p>The ID of the account that assigned the permission.</p>
    public let sourceAccount: String?

    public init (
        actions: [ActionType]? = nil,
        certificateAuthorityArn: String? = nil,
        createdAt: Date? = nil,
        policy: String? = nil,
        principal: String? = nil,
        sourceAccount: String? = nil
    )
    {
        self.actions = actions
        self.certificateAuthorityArn = certificateAuthorityArn
        self.createdAt = createdAt
        self.policy = policy
        self.principal = principal
        self.sourceAccount = sourceAccount
    }
}

extension PermissionAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PermissionAlreadyExistsException(message: \(String(describing: message)))"}
}

extension PermissionAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PermissionAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The designated permission has already been given to the user.</p>
public struct PermissionAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PermissionAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension PermissionAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PolicyInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certPolicyId = "CertPolicyId"
        case policyQualifiers = "PolicyQualifiers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certPolicyId = certPolicyId {
            try encodeContainer.encode(certPolicyId, forKey: .certPolicyId)
        }
        if let policyQualifiers = policyQualifiers {
            var policyQualifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyQualifiers)
            for policyqualifierinfolist0 in policyQualifiers {
                try policyQualifiersContainer.encode(policyqualifierinfolist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certPolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certPolicyId)
        certPolicyId = certPolicyIdDecoded
        let policyQualifiersContainer = try containerValues.decodeIfPresent([PolicyQualifierInfo?].self, forKey: .policyQualifiers)
        var policyQualifiersDecoded0:[PolicyQualifierInfo]? = nil
        if let policyQualifiersContainer = policyQualifiersContainer {
            policyQualifiersDecoded0 = [PolicyQualifierInfo]()
            for structure0 in policyQualifiersContainer {
                if let structure0 = structure0 {
                    policyQualifiersDecoded0?.append(structure0)
                }
            }
        }
        policyQualifiers = policyQualifiersDecoded0
    }
}

extension PolicyInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyInformation(certPolicyId: \(String(describing: certPolicyId)), policyQualifiers: \(String(describing: policyQualifiers)))"}
}

/// <p>Defines the X.509 <code>CertificatePolicies</code> extension.</p>
public struct PolicyInformation: Equatable {
    /// <p>Specifies the object identifier (OID) of the certificate policy under which the
    /// 			certificate was issued. For more information, see NIST's definition of <a href="https://csrc.nist.gov/glossary/term/Object_Identifier">Object Identifier
    /// 				(OID)</a>.</p>
    public let certPolicyId: String?
    /// <p>Modifies the given <code>CertPolicyId</code> with a qualifier. ACM Private CA supports the
    /// 			certification practice statement (CPS) qualifier.</p>
    public let policyQualifiers: [PolicyQualifierInfo]?

    public init (
        certPolicyId: String? = nil,
        policyQualifiers: [PolicyQualifierInfo]? = nil
    )
    {
        self.certPolicyId = certPolicyId
        self.policyQualifiers = policyQualifiers
    }
}

public enum PolicyQualifierId {
    case cps
    case sdkUnknown(String)
}

extension PolicyQualifierId : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyQualifierId] {
        return [
            .cps,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cps: return "CPS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyQualifierId(rawValue: rawValue) ?? PolicyQualifierId.sdkUnknown(rawValue)
    }
}

extension PolicyQualifierInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyQualifierId = "PolicyQualifierId"
        case qualifier = "Qualifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyQualifierId = policyQualifierId {
            try encodeContainer.encode(policyQualifierId.rawValue, forKey: .policyQualifierId)
        }
        if let qualifier = qualifier {
            try encodeContainer.encode(qualifier, forKey: .qualifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyQualifierIdDecoded = try containerValues.decodeIfPresent(PolicyQualifierId.self, forKey: .policyQualifierId)
        policyQualifierId = policyQualifierIdDecoded
        let qualifierDecoded = try containerValues.decodeIfPresent(Qualifier.self, forKey: .qualifier)
        qualifier = qualifierDecoded
    }
}

extension PolicyQualifierInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyQualifierInfo(policyQualifierId: \(String(describing: policyQualifierId)), qualifier: \(String(describing: qualifier)))"}
}

/// <p>Modifies the <code>CertPolicyId</code> of a <code>PolicyInformation</code> object with
/// 			a qualifier. ACM Private CA supports the certification practice statement (CPS) qualifier.</p>
public struct PolicyQualifierInfo: Equatable {
    /// <p>Identifies the qualifier modifying a <code>CertPolicyId</code>.</p>
    public let policyQualifierId: PolicyQualifierId?
    /// <p>Defines the qualifier type. ACM Private CA supports the use of a URI for a CPS qualifier in
    /// 			this field.</p>
    public let qualifier: Qualifier?

    public init (
        policyQualifierId: PolicyQualifierId? = nil,
        qualifier: Qualifier? = nil
    )
    {
        self.policyQualifierId = policyQualifierId
        self.qualifier = qualifier
    }
}

public struct PutPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPolicyInput>
    public typealias MOutput = OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPolicyOutputError>
}

extension PutPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPolicyInput(policy: \(String(describing: policy)), resourceArn: \(String(describing: resourceArn)))"}
}

extension PutPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct PutPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPolicyInput>
    public typealias MOutput = OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPolicyOutputError>
}

public struct PutPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPolicyInput>
    public typealias MOutput = OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPolicyOutputError>
}

public struct PutPolicyInput: Equatable {
    /// <p>The path and file name of a JSON-formatted IAM policy to attach to the specified
    /// 			private CA resource. If this policy does not contain all required statements or if it
    /// 			includes any statement that is not allowed, the <code>PutPolicy</code> action returns an
    /// 				<code>InvalidPolicyException</code>. For information about IAM policy and
    /// 			statement structure, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json">Overview of JSON Policies</a>.</p>
    public let policy: String?
    /// <p>The Amazon Resource Number (ARN) of the private CA to associate with the policy. The
    /// 			ARN of the CA can be found by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities</a> action.</p>
    /// 		       <p></p>
    public let resourceArn: String?

    public init (
        policy: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutPolicyInputBody: Equatable {
    public let resourceArn: String?
    public let policy: String?
}

extension PutPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyException" : self = .invalidPolicyException(try InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LockoutPreventedException" : self = .lockoutPreventedException(try LockoutPreventedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPolicyOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidPolicyException(InvalidPolicyException)
    case invalidStateException(InvalidStateException)
    case lockoutPreventedException(LockoutPreventedException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPolicyOutputResponse()"}
}

extension PutPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutPolicyOutputResponseBody: Equatable {
}

extension PutPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Qualifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cpsUri = "CpsUri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpsUri = cpsUri {
            try encodeContainer.encode(cpsUri, forKey: .cpsUri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpsUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cpsUri)
        cpsUri = cpsUriDecoded
    }
}

extension Qualifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Qualifier(cpsUri: \(String(describing: cpsUri)))"}
}

/// <p>Defines a <code>PolicyInformation</code> qualifier. ACM Private CA supports the <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">certification practice
/// 				statement (CPS) qualifier</a> defined in RFC 5280. </p>
public struct Qualifier: Equatable {
    /// <p>Contains a pointer to a certification practice statement (CPS) published by the
    /// 			CA.</p>
    public let cpsUri: String?

    public init (
        cpsUri: String? = nil
    )
    {
        self.cpsUri = cpsUri
    }
}

extension RequestAlreadyProcessedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestAlreadyProcessedException(message: \(String(describing: message)))"}
}

extension RequestAlreadyProcessedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestAlreadyProcessedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request has already been completed.</p>
public struct RequestAlreadyProcessedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestAlreadyProcessedExceptionBody: Equatable {
    public let message: String?
}

extension RequestAlreadyProcessedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RequestFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestFailedException(message: \(String(describing: message)))"}
}

extension RequestFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has failed for an unspecified reason.</p>
public struct RequestFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestFailedExceptionBody: Equatable {
    public let message: String?
}

extension RequestFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RequestInProgressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestInProgressException(message: \(String(describing: message)))"}
}

extension RequestInProgressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestInProgressExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request is already in progress.</p>
public struct RequestInProgressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestInProgressExceptionBody: Equatable {
    public let message: String?
}

extension RequestInProgressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
/// 			cannot be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceOwner {
    case otherAccounts
    case `self`
    case sdkUnknown(String)
}

extension ResourceOwner : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceOwner] {
        return [
            .otherAccounts,
            .self,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .otherAccounts: return "OTHER_ACCOUNTS"
        case .self: return "SELF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceOwner(rawValue: rawValue) ?? ResourceOwner.sdkUnknown(rawValue)
    }
}

public struct RestoreCertificateAuthorityInputBodyMiddleware: Middleware {
    public let id: String = "RestoreCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<RestoreCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreCertificateAuthorityOutputError>
}

extension RestoreCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreCertificateAuthorityInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)))"}
}

extension RestoreCertificateAuthorityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct RestoreCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<RestoreCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreCertificateAuthorityOutputError>
}

public struct RestoreCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<RestoreCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreCertificateAuthorityOutputError>
}

public struct RestoreCertificateAuthorityInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that was returned when you called the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a> action. This must be of the form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>
    /// 		       </p>
    public let certificateAuthorityArn: String?

    public init (
        certificateAuthorityArn: String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct RestoreCertificateAuthorityInputBody: Equatable {
    public let certificateAuthorityArn: String?
}

extension RestoreCertificateAuthorityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension RestoreCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreCertificateAuthorityOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreCertificateAuthorityOutputResponse()"}
}

extension RestoreCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RestoreCertificateAuthorityOutputResponse: Equatable {

    public init() {}
}

struct RestoreCertificateAuthorityOutputResponseBody: Equatable {
}

extension RestoreCertificateAuthorityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RevocationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crlConfiguration = "CrlConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crlConfiguration = crlConfiguration {
            try encodeContainer.encode(crlConfiguration, forKey: .crlConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlConfigurationDecoded = try containerValues.decodeIfPresent(CrlConfiguration.self, forKey: .crlConfiguration)
        crlConfiguration = crlConfigurationDecoded
    }
}

extension RevocationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevocationConfiguration(crlConfiguration: \(String(describing: crlConfiguration)))"}
}

/// <p>Certificate revocation information used by the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a> and <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_UpdateCertificateAuthority.html">UpdateCertificateAuthority</a> actions. Your private certificate authority (CA)
/// 			can create and maintain a certificate revocation list (CRL). A CRL contains information
/// 			about certificates revoked by your CA. For more information, see <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_RevokeCertificate.html">RevokeCertificate</a>.</p>
public struct RevocationConfiguration: Equatable {
    /// <p>Configuration of the certificate revocation list (CRL), if any, maintained by your
    /// 			private CA.</p>
    public let crlConfiguration: CrlConfiguration?

    public init (
        crlConfiguration: CrlConfiguration? = nil
    )
    {
        self.crlConfiguration = crlConfiguration
    }
}

public enum RevocationReason {
    case affiliationChanged
    case aACompromise
    case certificateAuthorityCompromise
    case cessationOfOperation
    case keyCompromise
    case privilegeWithdrawn
    case superseded
    case unspecified
    case sdkUnknown(String)
}

extension RevocationReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RevocationReason] {
        return [
            .affiliationChanged,
            .aACompromise,
            .certificateAuthorityCompromise,
            .cessationOfOperation,
            .keyCompromise,
            .privilegeWithdrawn,
            .superseded,
            .unspecified,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .affiliationChanged: return "AFFILIATION_CHANGED"
        case .aACompromise: return "A_A_COMPROMISE"
        case .certificateAuthorityCompromise: return "CERTIFICATE_AUTHORITY_COMPROMISE"
        case .cessationOfOperation: return "CESSATION_OF_OPERATION"
        case .keyCompromise: return "KEY_COMPROMISE"
        case .privilegeWithdrawn: return "PRIVILEGE_WITHDRAWN"
        case .superseded: return "SUPERSEDED"
        case .unspecified: return "UNSPECIFIED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RevocationReason(rawValue: rawValue) ?? RevocationReason.sdkUnknown(rawValue)
    }
}

public struct RevokeCertificateInputBodyMiddleware: Middleware {
    public let id: String = "RevokeCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeCertificateInput>
    public typealias MOutput = OperationOutput<RevokeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeCertificateOutputError>
}

extension RevokeCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeCertificateInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), certificateSerial: \(String(describing: certificateSerial)), revocationReason: \(String(describing: revocationReason)))"}
}

extension RevokeCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case certificateSerial = "CertificateSerial"
        case revocationReason = "RevocationReason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let certificateSerial = certificateSerial {
            try encodeContainer.encode(certificateSerial, forKey: .certificateSerial)
        }
        if let revocationReason = revocationReason {
            try encodeContainer.encode(revocationReason.rawValue, forKey: .revocationReason)
        }
    }
}

public struct RevokeCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeCertificateInput>
    public typealias MOutput = OperationOutput<RevokeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeCertificateOutputError>
}

public struct RevokeCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeCertificateInput>
    public typealias MOutput = OperationOutput<RevokeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeCertificateOutputError>
}

public struct RevokeCertificateInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the private CA that issued the certificate to be
    /// 			revoked. This must be of the form:</p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>
    /// 		       </p>
    public let certificateAuthorityArn: String?
    /// <p>Serial number of the certificate to be revoked. This must be in hexadecimal format.
    /// 			You can retrieve the serial number by calling <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_GetCertificate.html">GetCertificate</a> with the Amazon
    /// 			Resource Name (ARN) of the certificate you want and the ARN of your private CA. The
    /// 				<b>GetCertificate</b> action retrieves the certificate in
    /// 			the PEM format. You can use the following OpenSSL command to list the certificate in
    /// 			text format and copy the hexadecimal serial number. </p>
    /// 		       <p>
    ///             <code>openssl x509 -in <i>file_path</i> -text -noout</code>
    ///          </p>
    /// 		       <p>You can also copy the serial number from the console or use the <a href="https://docs.aws.amazon.com/acm/latest/APIReference/API_DescribeCertificate.html">DescribeCertificate</a> action in the <i>AWS Certificate Manager API
    /// 				Reference</i>. </p>
    public let certificateSerial: String?
    /// <p>Specifies why you revoked the certificate.</p>
    public let revocationReason: RevocationReason?

    public init (
        certificateAuthorityArn: String? = nil,
        certificateSerial: String? = nil,
        revocationReason: RevocationReason? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.certificateSerial = certificateSerial
        self.revocationReason = revocationReason
    }
}

struct RevokeCertificateInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let certificateSerial: String?
    public let revocationReason: RevocationReason?
}

extension RevokeCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case certificateSerial = "CertificateSerial"
        case revocationReason = "RevocationReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let certificateSerialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateSerial)
        certificateSerial = certificateSerialDecoded
        let revocationReasonDecoded = try containerValues.decodeIfPresent(RevocationReason.self, forKey: .revocationReason)
        revocationReason = revocationReasonDecoded
    }
}

extension RevokeCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestAlreadyProcessedException" : self = .requestAlreadyProcessedException(try RequestAlreadyProcessedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestInProgressException" : self = .requestInProgressException(try RequestInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeCertificateOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case requestAlreadyProcessedException(RequestAlreadyProcessedException)
    case requestFailedException(RequestFailedException)
    case requestInProgressException(RequestInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeCertificateOutputResponse()"}
}

extension RevokeCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RevokeCertificateOutputResponse: Equatable {

    public init() {}
}

struct RevokeCertificateOutputResponseBody: Equatable {
}

extension RevokeCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum S3ObjectAcl {
    case bucketOwnerFullControl
    case publicRead
    case sdkUnknown(String)
}

extension S3ObjectAcl : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3ObjectAcl] {
        return [
            .bucketOwnerFullControl,
            .publicRead,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bucketOwnerFullControl: return "BUCKET_OWNER_FULL_CONTROL"
        case .publicRead: return "PUBLIC_READ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3ObjectAcl(rawValue: rawValue) ?? S3ObjectAcl.sdkUnknown(rawValue)
    }
}

public enum SigningAlgorithm {
    case sha256withecdsa
    case sha256withrsa
    case sha384withecdsa
    case sha384withrsa
    case sha512withecdsa
    case sha512withrsa
    case sdkUnknown(String)
}

extension SigningAlgorithm : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SigningAlgorithm] {
        return [
            .sha256withecdsa,
            .sha256withrsa,
            .sha384withecdsa,
            .sha384withrsa,
            .sha512withecdsa,
            .sha512withrsa,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sha256withecdsa: return "SHA256WITHECDSA"
        case .sha256withrsa: return "SHA256WITHRSA"
        case .sha384withecdsa: return "SHA384WITHECDSA"
        case .sha384withrsa: return "SHA384WITHRSA"
        case .sha512withecdsa: return "SHA512WITHECDSA"
        case .sha512withrsa: return "SHA512WITHRSA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SigningAlgorithm(rawValue: rawValue) ?? SigningAlgorithm.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Tags are labels that you can use to identify and organize your private CAs. Each tag
/// 			consists of a key and an optional value. You can associate up to 50 tags with a private
/// 			CA. To add one or more tags to a private CA, call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_TagCertificateAuthority.html">TagCertificateAuthority</a>
/// 			action. To remove a tag, call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_UntagCertificateAuthority.html">UntagCertificateAuthority</a> action. </p>
public struct Tag: Equatable {
    /// <p>Key (name) of the tag.</p>
    public let key: String?
    /// <p>Value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagCertificateAuthorityInputBodyMiddleware: Middleware {
    public let id: String = "TagCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<TagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<TagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagCertificateAuthorityOutputError>
}

extension TagCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagCertificateAuthorityInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), tags: \(String(describing: tags)))"}
}

extension TagCertificateAuthorityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "TagCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<TagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<TagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagCertificateAuthorityOutputError>
}

public struct TagCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "TagCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<TagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<TagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagCertificateAuthorityOutputError>
}

public struct TagCertificateAuthorityInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a>. This must be of the form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>
    /// 		       </p>
    public let certificateAuthorityArn: String?
    /// <p>List of tags to be associated with the CA.</p>
    public let tags: [Tag]?

    public init (
        certificateAuthorityArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.tags = tags
    }
}

struct TagCertificateAuthorityInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let tags: [Tag]?
}

extension TagCertificateAuthorityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagCertificateAuthorityOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case invalidTagException(InvalidTagException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagCertificateAuthorityOutputResponse()"}
}

extension TagCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagCertificateAuthorityOutputResponse: Equatable {

    public init() {}
}

struct TagCertificateAuthorityOutputResponseBody: Equatable {
}

extension TagCertificateAuthorityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can associate up to 50 tags with a private CA. Exception information is contained
/// 			in the exception message field.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagCertificateAuthorityInputBodyMiddleware: Middleware {
    public let id: String = "UntagCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<UntagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagCertificateAuthorityOutputError>
}

extension UntagCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagCertificateAuthorityInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), tags: \(String(describing: tags)))"}
}

extension UntagCertificateAuthorityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct UntagCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "UntagCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<UntagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagCertificateAuthorityOutputError>
}

public struct UntagCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<UntagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagCertificateAuthorityOutputError>
}

public struct UntagCertificateAuthorityInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority</a>. This must be of the form: </p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>
    /// 		       </p>
    public let certificateAuthorityArn: String?
    /// <p>List of tags to be removed from the CA.</p>
    public let tags: [Tag]?

    public init (
        certificateAuthorityArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.tags = tags
    }
}

struct UntagCertificateAuthorityInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let tags: [Tag]?
}

extension UntagCertificateAuthorityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UntagCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagCertificateAuthorityOutputError: Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case invalidTagException(InvalidTagException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagCertificateAuthorityOutputResponse()"}
}

extension UntagCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagCertificateAuthorityOutputResponse: Equatable {

    public init() {}
}

struct UntagCertificateAuthorityOutputResponseBody: Equatable {
}

extension UntagCertificateAuthorityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCertificateAuthorityInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<UpdateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCertificateAuthorityOutputError>
}

extension UpdateCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCertificateAuthorityInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), revocationConfiguration: \(String(describing: revocationConfiguration)), status: \(String(describing: status)))"}
}

extension UpdateCertificateAuthorityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case revocationConfiguration = "RevocationConfiguration"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let revocationConfiguration = revocationConfiguration {
            try encodeContainer.encode(revocationConfiguration, forKey: .revocationConfiguration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<UpdateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCertificateAuthorityOutputError>
}

public struct UpdateCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<UpdateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCertificateAuthorityOutputError>
}

public struct UpdateCertificateAuthorityInput: Equatable {
    /// <p>Amazon Resource Name (ARN) of the private CA that issued the certificate to be
    /// 			revoked. This must be of the form:</p>
    /// 		       <p>
    /// 			         <code>arn:aws:acm-pca:<i>region</i>:<i>account</i>:certificate-authority/<i>12345678-1234-1234-1234-123456789012</i>
    ///             </code>
    /// 		       </p>
    public let certificateAuthorityArn: String?
    /// <p>Revocation information for your private CA.</p>
    public let revocationConfiguration: RevocationConfiguration?
    /// <p>Status of your private CA.</p>
    public let status: CertificateAuthorityStatus?

    public init (
        certificateAuthorityArn: String? = nil,
        revocationConfiguration: RevocationConfiguration? = nil,
        status: CertificateAuthorityStatus? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.revocationConfiguration = revocationConfiguration
        self.status = status
    }
}

struct UpdateCertificateAuthorityInputBody: Equatable {
    public let certificateAuthorityArn: String?
    public let revocationConfiguration: RevocationConfiguration?
    public let status: CertificateAuthorityStatus?
}

extension UpdateCertificateAuthorityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case revocationConfiguration = "RevocationConfiguration"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let revocationConfigurationDecoded = try containerValues.decodeIfPresent(RevocationConfiguration.self, forKey: .revocationConfiguration)
        revocationConfiguration = revocationConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CertificateAuthorityStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyException" : self = .invalidPolicyException(try InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCertificateAuthorityOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgsException(InvalidArgsException)
    case invalidArnException(InvalidArnException)
    case invalidPolicyException(InvalidPolicyException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCertificateAuthorityOutputResponse()"}
}

extension UpdateCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCertificateAuthorityOutputResponse: Equatable {

    public init() {}
}

struct UpdateCertificateAuthorityOutputResponseBody: Equatable {
}

extension UpdateCertificateAuthorityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Validity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ValidityPeriodType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Validity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Validity(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Validity specifies the period of time during which a certificate is valid. Validity
/// 			can be expressed as an explicit date and time when the validity of a certificate starts
/// 			or expires, or as a span of time after issuance, stated in days, months, or years. For
/// 			more information, see <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.5">Validity</a> in RFC 5280.</p>
/// 		       <p>ACM Private CA API consumes the <code>Validity</code> data type differently in two distinct
/// 			parameters of the <code>IssueCertificate</code> action. The required parameter
/// 				<code>IssueCertificate</code>:<code>Validity</code> specifies the end of a
/// 			certificate's validity period. The optional parameter
/// 				<code>IssueCertificate</code>:<code>ValidityNotBefore</code> specifies a customized
/// 			starting time for the validity period.</p>
public struct Validity: Equatable {
    /// <p>Determines how <i>ACM Private CA</i> interprets the <code>Value</code>
    /// 			parameter, an integer. Supported validity types include those listed below. Type
    /// 			definitions with values include a sample input value and the resulting output. </p>
    /// 		       <p>
    ///             <code>END_DATE</code>: The specific date and time when the certificate will expire,
    /// 			expressed using UTCTime (YYMMDDHHMMSS) or GeneralizedTime (YYYYMMDDHHMMSS) format. When
    /// 			UTCTime is used, if the year field (YY) is greater than or equal to 50, the year is
    /// 			interpreted as 19YY. If the year field is less than 50, the year is interpreted as
    /// 			20YY.</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Sample input value: 491231235959 (UTCTime format)</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Output expiration date/time: 12/31/2049 23:59:59</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>
    ///             <code>ABSOLUTE</code>: The specific date and time when the validity of a certificate
    /// 			will start or expire, expressed in seconds since the Unix Epoch. </p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Sample input value: 2524608000</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Output expiration date/time: 01/01/2050 00:00:00</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>
    ///             <code>DAYS</code>, <code>MONTHS</code>, <code>YEARS</code>: The relative time from the
    /// 			moment of issuance until the certificate will expire, expressed in days, months, or
    /// 			years. </p>
    /// 		       <p>Example if <code>DAYS</code>, issued on 10/12/2020 at 12:34:54 UTC:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Sample input value: 90</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Output expiration date: 01/10/2020 12:34:54 UTC</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>The minimum validity duration for a certificate using relative time
    /// 			(<code>DAYS</code>) is one day. The minimum validity for a certificate using absolute
    /// 			time (<code>ABSOLUTE</code> or <code>END_DATE</code>) is one second.</p>
    public let type: ValidityPeriodType?
    /// <p>A long integer interpreted according to the value of <code>Type</code>, below.</p>
    public let value: Int?

    public init (
        type: ValidityPeriodType? = nil,
        value: Int? = nil
    )
    {
        self.type = type
        self.value = value
    }
}

public enum ValidityPeriodType {
    case absolute
    case days
    case endDate
    case months
    case years
    case sdkUnknown(String)
}

extension ValidityPeriodType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidityPeriodType] {
        return [
            .absolute,
            .days,
            .endDate,
            .months,
            .years,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .absolute: return "ABSOLUTE"
        case .days: return "DAYS"
        case .endDate: return "END_DATE"
        case .months: return "MONTHS"
        case .years: return "YEARS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidityPeriodType(rawValue: rawValue) ?? ValidityPeriodType.sdkUnknown(rawValue)
    }
}
