//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You do not have sufficient permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension ServiceQuotasClientTypes {

    public enum AppliedLevelEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case all
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [AppliedLevelEnum] {
            return [
                .account,
                .all,
                .resource
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .all: return "ALL"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.
public struct AWSServiceAccessNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AWSServiceAccessNotEnabledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// You can't perform this action because a dependency does not have access.
public struct DependencyAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyAccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The Amazon Web Services account making this call is not a member of an organization.
public struct NoAvailableOrganizationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoAvailableOrganizationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The organization that your Amazon Web Services account belongs to is not in All Features mode.
public struct OrganizationNotInAllFeaturesModeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationNotInAllFeaturesModeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Something went wrong.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The Service Quotas template is not available in this Amazon Web Services Region.
public struct TemplatesNotAvailableInRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TemplatesNotAvailableInRegionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct AssociateServiceQuotaTemplateInput: Swift.Sendable {

    public init() { }
}

public struct AssociateServiceQuotaTemplateOutput: Swift.Sendable {

    public init() { }
}

/// Invalid input was provided.
public struct IllegalArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The resource is in an invalid state.
public struct InvalidResourceStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified resource does not exist.
public struct NoSuchResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchResourceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateSupportCaseInput: Swift.Sendable {
    /// The ID of the pending quota increase request for which you want to open a Support case.
    /// This member is required.
    public var requestId: Swift.String?

    public init(
        requestId: Swift.String? = nil
    ) {
        self.requestId = requestId
    }
}

public struct CreateSupportCaseOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInput: Swift.Sendable {
    /// Specifies the Amazon Web Services Region for which the request was made.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateOutput: Swift.Sendable {

    public init() { }
}

/// The quota request template is not associated with your organization.
public struct ServiceQuotaTemplateNotInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaTemplateNotInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct DisassociateServiceQuotaTemplateInput: Swift.Sendable {

    public init() { }
}

public struct DisassociateServiceQuotaTemplateOutput: Swift.Sendable {

    public init() { }
}

extension ServiceQuotasClientTypes {

    public enum ErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dependencyAccessDeniedError
        case dependencyServiceError
        case dependencyThrottlingError
        case serviceQuotaNotAvailableError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .dependencyAccessDeniedError,
                .dependencyServiceError,
                .dependencyThrottlingError,
                .serviceQuotaNotAvailableError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dependencyAccessDeniedError: return "DEPENDENCY_ACCESS_DENIED_ERROR"
            case .dependencyServiceError: return "DEPENDENCY_SERVICE_ERROR"
            case .dependencyThrottlingError: return "DEPENDENCY_THROTTLING_ERROR"
            case .serviceQuotaNotAvailableError: return "SERVICE_QUOTA_NOT_AVAILABLE_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    /// An error that explains why an action did not succeed.
    public struct ErrorReason: Swift.Sendable {
        /// Service Quotas returns the following error values:
        ///
        /// * DEPENDENCY_ACCESS_DENIED_ERROR - The caller does not have the required permissions to complete the action. To resolve the error, you must have permission to access the Amazon Web Services service or quota.
        ///
        /// * DEPENDENCY_THROTTLING_ERROR - The Amazon Web Services service is throttling Service Quotas.
        ///
        /// * DEPENDENCY_SERVICE_ERROR - The Amazon Web Services service is not available.
        ///
        /// * SERVICE_QUOTA_NOT_AVAILABLE_ERROR - There was an error in Service Quotas.
        public var errorCode: ServiceQuotasClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: ServiceQuotasClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil
        ) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension ServiceQuotasClientTypes {

    /// Information on your Service Quotas for [Service Quotas Automatic Management](https://docs.aws.amazon.com/servicequotas/latest/userguide/automatic-management.html). Automatic Management monitors your Service Quotas utilization and notifies you before you run out of your allocated quotas.
    public struct QuotaInfo: Swift.Sendable {
        /// The Service Quotas code for the Amazon Web Services service monitored with Automatic Management.
        public var quotaCode: Swift.String?
        /// The Service Quotas name for the Amazon Web Services service monitored with Automatic Management.
        public var quotaName: Swift.String?

        public init(
            quotaCode: Swift.String? = nil,
            quotaName: Swift.String? = nil
        ) {
            self.quotaCode = quotaCode
            self.quotaName = quotaName
        }
    }
}

public struct GetAssociationForServiceQuotaTemplateInput: Swift.Sendable {

    public init() { }
}

extension ServiceQuotasClientTypes {

    public enum ServiceQuotaTemplateAssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associated
        case disassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaTemplateAssociationStatus] {
            return [
                .associated,
                .disassociated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .disassociated: return "DISASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAssociationForServiceQuotaTemplateOutput: Swift.Sendable {
    /// The association status. If the status is ASSOCIATED, the quota increase requests in the template are automatically applied to new Amazon Web Services accounts in your organization.
    public var serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus?

    public init(
        serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus? = nil
    ) {
        self.serviceQuotaTemplateAssociationStatus = serviceQuotaTemplateAssociationStatus
    }
}

public struct GetAutoManagementConfigurationInput: Swift.Sendable {

    public init() { }
}

extension ServiceQuotasClientTypes {

    public enum OptInLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case sdkUnknown(Swift.String)

        public static var allCases: [OptInLevel] {
            return [
                .account
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    public enum OptInStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OptInStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    public enum OptInType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notifyandadjust
        case notifyonly
        case sdkUnknown(Swift.String)

        public static var allCases: [OptInType] {
            return [
                .notifyandadjust,
                .notifyonly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notifyandadjust: return "NotifyAndAdjust"
            case .notifyonly: return "NotifyOnly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAutoManagementConfigurationOutput: Swift.Sendable {
    /// List of Amazon Web Services services excluded from Automatic Management. You won't be notified of Service Quotas utilization for Amazon Web Services services added to the Automatic Management exclusion list.
    public var exclusionList: [Swift.String: [ServiceQuotasClientTypes.QuotaInfo]]?
    /// The [User Notifications](https://docs.aws.amazon.com/notifications/latest/userguide/resource-level-permissions.html#rlp-table) Amazon Resource Name (ARN) for Automatic Management notifications.
    public var notificationArn: Swift.String?
    /// Information on the opt-in level for Automatic Management. Only Amazon Web Services account level is supported.
    public var optInLevel: ServiceQuotasClientTypes.OptInLevel?
    /// Status on whether Automatic Management is started or stopped.
    public var optInStatus: ServiceQuotasClientTypes.OptInStatus?
    /// Information on the opt-in type for Automatic Management. There are two modes: Notify only and Notify and Auto-Adjust. Currently, only NotifyOnly is available.
    public var optInType: ServiceQuotasClientTypes.OptInType?

    public init(
        exclusionList: [Swift.String: [ServiceQuotasClientTypes.QuotaInfo]]? = nil,
        notificationArn: Swift.String? = nil,
        optInLevel: ServiceQuotasClientTypes.OptInLevel? = nil,
        optInStatus: ServiceQuotasClientTypes.OptInStatus? = nil,
        optInType: ServiceQuotasClientTypes.OptInType? = nil
    ) {
        self.exclusionList = exclusionList
        self.notificationArn = notificationArn
        self.optInLevel = optInLevel
        self.optInStatus = optInStatus
        self.optInType = optInType
    }
}

public struct GetAWSDefaultServiceQuotaInput: Swift.Sendable {
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

extension ServiceQuotasClientTypes {

    public enum PeriodUnit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case hour
        case microsecond
        case millisecond
        case minute
        case second
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [PeriodUnit] {
            return [
                .day,
                .hour,
                .microsecond,
                .millisecond,
                .minute,
                .second,
                .week
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .microsecond: return "MICROSECOND"
            case .millisecond: return "MILLISECOND"
            case .minute: return "MINUTE"
            case .second: return "SECOND"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    /// Information about the quota period.
    public struct QuotaPeriod: Swift.Sendable {
        /// The time unit.
        public var periodUnit: ServiceQuotasClientTypes.PeriodUnit?
        /// The value associated with the reported PeriodUnit.
        public var periodValue: Swift.Int?

        public init(
            periodUnit: ServiceQuotasClientTypes.PeriodUnit? = nil,
            periodValue: Swift.Int? = nil
        ) {
            self.periodUnit = periodUnit
            self.periodValue = periodValue
        }
    }
}

extension ServiceQuotasClientTypes {

    public enum QuotaContextScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [QuotaContextScope] {
            return [
                .account,
                .resource
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    /// A structure that describes the context for a resource-level quota. For resource-level quotas, such as Instances per OpenSearch Service Domain, you can apply the quota value at the resource-level for each OpenSearch Service Domain in your Amazon Web Services account. Together the attributes of this structure help you understand how the quota is implemented by Amazon Web Services and how you can manage it. For quotas such as Amazon OpenSearch Service Domains which can be managed at the account-level for each Amazon Web Services Region, the QuotaContext field is absent. See the attribute descriptions below to further understand how to use them.
    public struct QuotaContextInfo: Swift.Sendable {
        /// Specifies the resource, or resources, to which the quota applies. The value for this field is either an Amazon Resource Name (ARN) or *. If the value is an ARN, the quota value applies to that resource. If the value is *, then the quota value applies to all resources listed in the ContextScopeType field. The quota value applies to all resources for which you haven’t previously applied a quota value, and any new resources you create in your Amazon Web Services account.
        public var contextId: Swift.String?
        /// Specifies the scope to which the quota value is applied. If the scope is RESOURCE, the quota value is applied to each resource in the Amazon Web Services account. If the scope is ACCOUNT, the quota value is applied to the Amazon Web Services account.
        public var contextScope: ServiceQuotasClientTypes.QuotaContextScope?
        /// Specifies the resource type to which the quota can be applied.
        public var contextScopeType: Swift.String?

        public init(
            contextId: Swift.String? = nil,
            contextScope: ServiceQuotasClientTypes.QuotaContextScope? = nil,
            contextScopeType: Swift.String? = nil
        ) {
            self.contextId = contextId
            self.contextScope = contextScope
            self.contextScopeType = contextScopeType
        }
    }
}

extension ServiceQuotasClientTypes {

    /// Information about the CloudWatch metric that reflects quota usage.
    public struct MetricInfo: Swift.Sendable {
        /// The metric dimension. This is a name/value pair that is part of the identity of a metric.
        public var metricDimensions: [Swift.String: Swift.String]?
        /// The name of the metric.
        public var metricName: Swift.String?
        /// The namespace of the metric.
        public var metricNamespace: Swift.String?
        /// The metric statistic that we recommend you use when determining quota usage.
        public var metricStatisticRecommendation: Swift.String?

        public init(
            metricDimensions: [Swift.String: Swift.String]? = nil,
            metricName: Swift.String? = nil,
            metricNamespace: Swift.String? = nil,
            metricStatisticRecommendation: Swift.String? = nil
        ) {
            self.metricDimensions = metricDimensions
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.metricStatisticRecommendation = metricStatisticRecommendation
        }
    }
}

extension ServiceQuotasClientTypes {

    /// Information about a quota.
    public struct ServiceQuota: Swift.Sendable {
        /// Indicates whether the quota value can be increased.
        public var adjustable: Swift.Bool
        /// The quota description.
        public var description: Swift.String?
        /// The error code and error reason.
        public var errorReason: ServiceQuotasClientTypes.ErrorReason?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// The period of time.
        public var period: ServiceQuotasClientTypes.QuotaPeriod?
        /// Filters the response to return applied quota values for the ACCOUNT, RESOURCE, or ALL levels. ACCOUNT is the default.
        public var quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
        /// The Amazon Resource Name (ARN) of the quota.
        public var quotaArn: Swift.String?
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// The context for this service quota.
        public var quotaContext: ServiceQuotasClientTypes.QuotaContextInfo?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The unit of measurement.
        public var unit: Swift.String?
        /// Information about the measurement.
        public var usageMetric: ServiceQuotasClientTypes.MetricInfo?
        /// The quota value.
        public var value: Swift.Double?

        public init(
            adjustable: Swift.Bool = false,
            description: Swift.String? = nil,
            errorReason: ServiceQuotasClientTypes.ErrorReason? = nil,
            globalQuota: Swift.Bool = false,
            period: ServiceQuotasClientTypes.QuotaPeriod? = nil,
            quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
            quotaArn: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaContext: ServiceQuotasClientTypes.QuotaContextInfo? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            unit: Swift.String? = nil,
            usageMetric: ServiceQuotasClientTypes.MetricInfo? = nil,
            value: Swift.Double? = nil
        ) {
            self.adjustable = adjustable
            self.description = description
            self.errorReason = errorReason
            self.globalQuota = globalQuota
            self.period = period
            self.quotaAppliedAtLevel = quotaAppliedAtLevel
            self.quotaArn = quotaArn
            self.quotaCode = quotaCode
            self.quotaContext = quotaContext
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.unit = unit
            self.usageMetric = usageMetric
            self.value = value
        }
    }
}

public struct GetAWSDefaultServiceQuotaOutput: Swift.Sendable {
    /// Information about the quota.
    public var quota: ServiceQuotasClientTypes.ServiceQuota?

    public init(
        quota: ServiceQuotasClientTypes.ServiceQuota? = nil
    ) {
        self.quota = quota
    }
}

public struct GetQuotaUtilizationReportInput: Swift.Sendable {
    /// The maximum number of results to return per page. The default value is 1,000 and the maximum allowed value is 1,000.
    public var maxResults: Swift.Int?
    /// A token that indicates the next page of results to retrieve. This token is returned in the response when there are more results available. Omit this parameter for the first request.
    public var nextToken: Swift.String?
    /// The unique identifier for the quota utilization report. This identifier is returned by the StartQuotaUtilizationReport operation.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reportId: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reportId = reportId
    }
}

extension ServiceQuotasClientTypes {

    /// Information about a quota's utilization, including the quota code, service information, current usage, and applied limits.
    public struct QuotaUtilizationInfo: Swift.Sendable {
        /// Indicates whether the quota value can be increased.
        public var adjustable: Swift.Bool
        /// The applied value of the quota, which may be higher than the default value if a quota increase has been requested and approved.
        public var appliedValue: Swift.Double?
        /// The default value of the quota.
        public var defaultValue: Swift.Double?
        /// The namespace of the metric used to track quota usage.
        public var namespace: Swift.String?
        /// The quota identifier.
        public var quotaCode: Swift.String?
        /// The quota name.
        public var quotaName: Swift.String?
        /// The service identifier.
        public var serviceCode: Swift.String?
        /// The service name.
        public var serviceName: Swift.String?
        /// The utilization percentage of the quota, calculated as (current usage / applied value) × 100. Values range from 0.0 to 100.0 or higher if usage exceeds the quota limit.
        public var utilization: Swift.Double?

        public init(
            adjustable: Swift.Bool = false,
            appliedValue: Swift.Double? = nil,
            defaultValue: Swift.Double? = nil,
            namespace: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            utilization: Swift.Double? = nil
        ) {
            self.adjustable = adjustable
            self.appliedValue = appliedValue
            self.defaultValue = defaultValue
            self.namespace = namespace
            self.quotaCode = quotaCode
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.utilization = utilization
        }
    }
}

extension ServiceQuotasClientTypes {

    public enum ReportStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQuotaUtilizationReportOutput: Swift.Sendable {
    /// An error code indicating the reason for failure when the report status is FAILED. This field is only present when the status is FAILED.
    public var errorCode: Swift.String?
    /// A detailed error message describing the failure when the report status is FAILED. This field is only present when the status is FAILED.
    public var errorMessage: Swift.String?
    /// The timestamp when the report was generated, in ISO 8601 format.
    public var generatedAt: Foundation.Date?
    /// A token that indicates more results are available. Include this token in the next request to retrieve the next page of results. If this field is not present, you have retrieved all available results.
    public var nextToken: Swift.String?
    /// A list of quota utilization records, sorted by utilization percentage in descending order. Each record includes the quota code, service code, service name, quota name, namespace, utilization percentage, default value, applied value, and whether the quota is adjustable. Up to 1,000 records are returned per page.
    public var quotas: [ServiceQuotasClientTypes.QuotaUtilizationInfo]?
    /// The unique identifier for the quota utilization report.
    public var reportId: Swift.String?
    /// The current status of the report generation. Possible values are:
    ///
    /// * PENDING - The report generation is in progress. Retry this operation after a few seconds.
    ///
    /// * IN_PROGRESS - The report is being processed. Continue polling until the status changes to COMPLETED.
    ///
    /// * COMPLETED - The report is ready and quota utilization data is available in the response.
    ///
    /// * FAILED - The report generation failed. Check the ErrorCode and ErrorMessage fields for details.
    public var status: ServiceQuotasClientTypes.ReportStatus?
    /// The total number of quotas included in the report across all pages.
    public var totalCount: Swift.Int?

    public init(
        errorCode: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        generatedAt: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.QuotaUtilizationInfo]? = nil,
        reportId: Swift.String? = nil,
        status: ServiceQuotasClientTypes.ReportStatus? = nil,
        totalCount: Swift.Int? = nil
    ) {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.generatedAt = generatedAt
        self.nextToken = nextToken
        self.quotas = quotas
        self.reportId = reportId
        self.status = status
        self.totalCount = totalCount
    }
}

public struct GetRequestedServiceQuotaChangeInput: Swift.Sendable {
    /// Specifies the ID of the quota increase request.
    /// This member is required.
    public var requestId: Swift.String?

    public init(
        requestId: Swift.String? = nil
    ) {
        self.requestId = requestId
    }
}

extension ServiceQuotasClientTypes {

    public enum RequestType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automaticmanagement
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestType] {
            return [
                .automaticmanagement
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automaticmanagement: return "AutomaticManagement"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    public enum RequestStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case caseClosed
        case caseOpened
        case denied
        case invalidRequest
        case notApproved
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestStatus] {
            return [
                .approved,
                .caseClosed,
                .caseOpened,
                .denied,
                .invalidRequest,
                .notApproved,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .caseClosed: return "CASE_CLOSED"
            case .caseOpened: return "CASE_OPENED"
            case .denied: return "DENIED"
            case .invalidRequest: return "INVALID_REQUEST"
            case .notApproved: return "NOT_APPROVED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    /// Information about a quota increase request.
    public struct RequestedServiceQuotaChange: Swift.Sendable {
        /// The case ID.
        public var caseId: Swift.String?
        /// The date and time when the quota increase request was received and the case ID was created.
        public var created: Foundation.Date?
        /// The new, increased value for the quota.
        public var desiredValue: Swift.Double?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// The unique identifier.
        public var id: Swift.String?
        /// The date and time of the most recent change.
        public var lastUpdated: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the quota.
        public var quotaArn: Swift.String?
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// The context for this service quota.
        public var quotaContext: ServiceQuotasClientTypes.QuotaContextInfo?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Filters the response to return quota requests for the ACCOUNT, RESOURCE, or ALL levels. ACCOUNT is the default.
        public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
        /// The type of quota increase request. Possible values include:
        ///
        /// * AutomaticManagement - The request was automatically created by Service Quotas Automatic Management when quota utilization approached the limit.
        ///
        ///
        /// If this field is not present, the request was manually created by a user.
        public var requestType: ServiceQuotasClientTypes.RequestType?
        /// The IAM identity of the requester.
        public var requester: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The state of the quota increase request.
        ///
        /// * PENDING: The quota increase request is under review by Amazon Web Services.
        ///
        /// * CASE_OPENED: Service Quotas opened a support case to process the quota increase request. Follow-up on the support case for more information.
        ///
        /// * APPROVED: The quota increase request is approved.
        ///
        /// * DENIED: The quota increase request can't be approved by Service Quotas. Contact Amazon Web Services Support for more details.
        ///
        /// * NOT APPROVED: The quota increase request can't be approved by Service Quotas. Contact Amazon Web Services Support for more details.
        ///
        /// * CASE_CLOSED: The support case associated with this quota increase request was closed. Check the support case correspondence for the outcome of your quota request.
        ///
        /// * INVALID_REQUEST: Service Quotas couldn't process your resource-level quota increase request because the Amazon Resource Name (ARN) specified as part of the ContextId is invalid.
        public var status: ServiceQuotasClientTypes.RequestStatus?
        /// The unit of measurement.
        public var unit: Swift.String?

        public init(
            caseId: Swift.String? = nil,
            created: Foundation.Date? = nil,
            desiredValue: Swift.Double? = nil,
            globalQuota: Swift.Bool = false,
            id: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            quotaArn: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaContext: ServiceQuotasClientTypes.QuotaContextInfo? = nil,
            quotaName: Swift.String? = nil,
            quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
            requestType: ServiceQuotasClientTypes.RequestType? = nil,
            requester: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            status: ServiceQuotasClientTypes.RequestStatus? = nil,
            unit: Swift.String? = nil
        ) {
            self.caseId = caseId
            self.created = created
            self.desiredValue = desiredValue
            self.globalQuota = globalQuota
            self.id = id
            self.lastUpdated = lastUpdated
            self.quotaArn = quotaArn
            self.quotaCode = quotaCode
            self.quotaContext = quotaContext
            self.quotaName = quotaName
            self.quotaRequestedAtLevel = quotaRequestedAtLevel
            self.requestType = requestType
            self.requester = requester
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.status = status
            self.unit = unit
        }
    }
}

public struct GetRequestedServiceQuotaChangeOutput: Swift.Sendable {
    /// Information about the quota increase request.
    public var requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?

    public init(
        requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange? = nil
    ) {
        self.requestedQuota = requestedQuota
    }
}

public struct GetServiceQuotaInput: Swift.Sendable {
    /// Specifies the resource with an Amazon Resource Name (ARN).
    public var contextId: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        contextId: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.contextId = contextId
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

public struct GetServiceQuotaOutput: Swift.Sendable {
    /// Information about the quota.
    public var quota: ServiceQuotasClientTypes.ServiceQuota?

    public init(
        quota: ServiceQuotasClientTypes.ServiceQuota? = nil
    ) {
        self.quota = quota
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInput: Swift.Sendable {
    /// Specifies the Amazon Web Services Region for which you made the request.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

extension ServiceQuotasClientTypes {

    /// Information about a quota increase request.
    public struct ServiceQuotaIncreaseRequestInTemplate: Swift.Sendable {
        /// The Amazon Web Services Region.
        public var awsRegion: Swift.String?
        /// The new, increased value of the quota.
        public var desiredValue: Swift.Double?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The unit of measurement.
        public var unit: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            desiredValue: Swift.Double? = nil,
            globalQuota: Swift.Bool = false,
            quotaCode: Swift.String? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            unit: Swift.String? = nil
        ) {
            self.awsRegion = awsRegion
            self.desiredValue = desiredValue
            self.globalQuota = globalQuota
            self.quotaCode = quotaCode
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.unit = unit
        }
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateOutput: Swift.Sendable {
    /// Information about the quota increase request.
    public var serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?

    public init(
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate? = nil
    ) {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

extension ServiceQuotasClientTypes {

    /// A complex data type that contains a tag key and tag value.
    public struct Tag: Swift.Sendable {
        /// A string that contains a tag key. The string length should be between 1 and 128 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains an optional tag value. The string length should be between 0 and 256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

/// Invalid input was provided.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct ListAWSDefaultServiceQuotasInput: Swift.Sendable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

public struct ListAWSDefaultServiceQuotasOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quotas.
    public var quotas: [ServiceQuotasClientTypes.ServiceQuota]?

    public init(
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.ServiceQuota]? = nil
    ) {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

public struct ListRequestedServiceQuotaChangeHistoryInput: Swift.Sendable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Filters the response to return quota requests for the ACCOUNT, RESOURCE, or ALL levels. ACCOUNT is the default.
    public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    public var serviceCode: Swift.String?
    /// Specifies that you want to filter the results to only the requests with the matching status.
    public var status: ServiceQuotasClientTypes.RequestStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        serviceCode: Swift.String? = nil,
        status: ServiceQuotasClientTypes.RequestStatus? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaRequestedAtLevel = quotaRequestedAtLevel
        self.serviceCode = serviceCode
        self.status = status
    }
}

public struct ListRequestedServiceQuotaChangeHistoryOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?

    public init(
        nextToken: Swift.String? = nil,
        requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
    ) {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInput: Swift.Sendable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Filters the response to return quota requests for the ACCOUNT, RESOURCE, or ALL levels. ACCOUNT is the default.
    public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?
    /// Specifies that you want to filter the results to only the requests with the matching status.
    public var status: ServiceQuotasClientTypes.RequestStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        serviceCode: Swift.String? = nil,
        status: ServiceQuotasClientTypes.RequestStatus? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaCode = quotaCode
        self.quotaRequestedAtLevel = quotaRequestedAtLevel
        self.serviceCode = serviceCode
        self.status = status
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?

    public init(
        nextToken: Swift.String? = nil,
        requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
    ) {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInput: Swift.Sendable {
    /// Specifies the Amazon Web Services Region for which you made the request.
    public var awsRegion: Swift.String?
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.awsRegion = awsRegion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]?

    public init(
        nextToken: Swift.String? = nil,
        serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]? = nil
    ) {
        self.nextToken = nextToken
        self.serviceQuotaIncreaseRequestInTemplateList = serviceQuotaIncreaseRequestInTemplateList
    }
}

public struct ListServiceQuotasInput: Swift.Sendable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Filters the response to return applied quota values for the ACCOUNT, RESOURCE, or ALL levels. ACCOUNT is the default.
    public var quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaAppliedAtLevel = quotaAppliedAtLevel
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

public struct ListServiceQuotasOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quotas.
    public var quotas: [ServiceQuotasClientTypes.ServiceQuota]?

    public init(
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.ServiceQuota]? = nil
    ) {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

public struct ListServicesInput: Swift.Sendable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ServiceQuotasClientTypes {

    /// Information about an Amazon Web Services service.
    public struct ServiceInfo: Swift.Sendable {
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?

        public init(
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil
        ) {
            self.serviceCode = serviceCode
            self.serviceName = serviceName
        }
    }
}

public struct ListServicesOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// The list of the Amazon Web Services service names and service codes.
    public var services: [ServiceQuotasClientTypes.ServiceInfo]?

    public init(
        nextToken: Swift.String? = nil,
        services: [ServiceQuotasClientTypes.ServiceInfo]? = nil
    ) {
        self.nextToken = nextToken
        self.services = services
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the applied quota for which you want to list tags. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    ) {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A complex data type that contains zero or more tag elements.
    public var tags: [ServiceQuotasClientTypes.Tag]?

    public init(
        tags: [ServiceQuotasClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct QuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInput: Swift.Sendable {
    /// Specifies the Amazon Web Services Region to which the template applies.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the new, increased value for the quota.
    /// This member is required.
    public var desiredValue: Swift.Double?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        desiredValue: Swift.Double? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.awsRegion = awsRegion
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateOutput: Swift.Sendable {
    /// Information about the quota increase request.
    public var serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?

    public init(
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate? = nil
    ) {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

public struct RequestServiceQuotaIncreaseInput: Swift.Sendable {
    /// Specifies the resource with an Amazon Resource Name (ARN).
    public var contextId: Swift.String?
    /// Specifies the new, increased value for the quota.
    /// This member is required.
    public var desiredValue: Swift.Double?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?
    /// Specifies if an Amazon Web Services Support case can be opened for the quota increase request. This parameter is optional. By default, this flag is set to True and Amazon Web Services may create a support case for some quota increase requests. You can set this flag to False if you do not want a support case created when you request a quota increase. If you set the flag to False, Amazon Web Services does not open a support case and updates the request status to Not approved.
    public var supportCaseAllowed: Swift.Bool?

    public init(
        contextId: Swift.String? = nil,
        desiredValue: Swift.Double? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil,
        supportCaseAllowed: Swift.Bool? = nil
    ) {
        self.contextId = contextId
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
        self.supportCaseAllowed = supportCaseAllowed
    }
}

public struct RequestServiceQuotaIncreaseOutput: Swift.Sendable {
    /// Information about the quota increase request.
    public var requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?

    public init(
        requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange? = nil
    ) {
        self.requestedQuota = requestedQuota
    }
}

public struct StartAutoManagementInput: Swift.Sendable {
    /// List of Amazon Web Services services excluded from Automatic Management. You won't be notified of Service Quotas utilization for Amazon Web Services services added to the Automatic Management exclusion list.
    public var exclusionList: [Swift.String: [Swift.String]]?
    /// The [User Notifications](https://docs.aws.amazon.com/notifications/latest/userguide/resource-level-permissions.html#rlp-table) Amazon Resource Name (ARN) for Automatic Management notifications.
    public var notificationArn: Swift.String?
    /// Sets the opt-in level for Automatic Management. Only Amazon Web Services account level is supported.
    /// This member is required.
    public var optInLevel: ServiceQuotasClientTypes.OptInLevel?
    /// Sets the opt-in type for Automatic Management. There are two modes: Notify only and Notify and Auto-Adjust. Currently, only NotifyOnly is available.
    /// This member is required.
    public var optInType: ServiceQuotasClientTypes.OptInType?

    public init(
        exclusionList: [Swift.String: [Swift.String]]? = nil,
        notificationArn: Swift.String? = nil,
        optInLevel: ServiceQuotasClientTypes.OptInLevel? = nil,
        optInType: ServiceQuotasClientTypes.OptInType? = nil
    ) {
        self.exclusionList = exclusionList
        self.notificationArn = notificationArn
        self.optInLevel = optInLevel
        self.optInType = optInType
    }
}

public struct StartAutoManagementOutput: Swift.Sendable {

    public init() { }
}

public struct StartQuotaUtilizationReportInput: Swift.Sendable {

    public init() { }
}

public struct StartQuotaUtilizationReportOutput: Swift.Sendable {
    /// An optional message providing additional information about the report generation status. This field may contain details about the report initiation or indicate if an existing recent report is being reused.
    public var message: Swift.String?
    /// A unique identifier for the quota utilization report. Use this identifier with the GetQuotaUtilizationReport operation to retrieve the report results.
    public var reportId: Swift.String?
    /// The current status of the report generation. The status will be PENDING when the report is first initiated.
    public var status: ServiceQuotasClientTypes.ReportStatus?

    public init(
        message: Swift.String? = nil,
        reportId: Swift.String? = nil,
        status: ServiceQuotasClientTypes.ReportStatus? = nil
    ) {
        self.message = message
        self.reportId = reportId
        self.status = status
    }
}

public struct StopAutoManagementInput: Swift.Sendable {

    public init() { }
}

public struct StopAutoManagementOutput: Swift.Sendable {

    public init() { }
}

/// The specified tag is a reserved word and cannot be used.
public struct TagPolicyViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicyViolationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// You've exceeded the number of tags allowed for a resource. For more information, see [Tag restrictions](https://docs.aws.amazon.com/servicequotas/latest/userguide/sq-tagging.html#sq-tagging-restrictions) in the Service Quotas User Guide.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the applied quota. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags that you want to add to the resource.
    /// This member is required.
    public var tags: [ServiceQuotasClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ServiceQuotasClientTypes.Tag]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the applied quota that you want to untag. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAutoManagementInput: Swift.Sendable {
    /// List of Amazon Web Services services you want to exclude from Automatic Management. You won't be notified of Service Quotas utilization for Amazon Web Services services added to the Automatic Management exclusion list.
    public var exclusionList: [Swift.String: [Swift.String]]?
    /// The [User Notifications](https://docs.aws.amazon.com/notifications/latest/userguide/resource-level-permissions.html#rlp-table) Amazon Resource Name (ARN) for Automatic Management notifications you want to update.
    public var notificationArn: Swift.String?
    /// Information on the opt-in type for your Automatic Management configuration. There are two modes: Notify only and Notify and Auto-Adjust. Currently, only NotifyOnly is available.
    public var optInType: ServiceQuotasClientTypes.OptInType?

    public init(
        exclusionList: [Swift.String: [Swift.String]]? = nil,
        notificationArn: Swift.String? = nil,
        optInType: ServiceQuotasClientTypes.OptInType? = nil
    ) {
        self.exclusionList = exclusionList
        self.notificationArn = notificationArn
        self.optInType = optInType
    }
}

public struct UpdateAutoManagementOutput: Swift.Sendable {

    public init() { }
}

extension AssociateServiceQuotaTemplateInput {

    static func urlPathProvider(_ value: AssociateServiceQuotaTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSupportCaseInput {

    static func urlPathProvider(_ value: CreateSupportCaseInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput {

    static func urlPathProvider(_ value: DeleteServiceQuotaIncreaseRequestFromTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateServiceQuotaTemplateInput {

    static func urlPathProvider(_ value: DisassociateServiceQuotaTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension GetAssociationForServiceQuotaTemplateInput {

    static func urlPathProvider(_ value: GetAssociationForServiceQuotaTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension GetAutoManagementConfigurationInput {

    static func urlPathProvider(_ value: GetAutoManagementConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetAWSDefaultServiceQuotaInput {

    static func urlPathProvider(_ value: GetAWSDefaultServiceQuotaInput) -> Swift.String? {
        return "/"
    }
}

extension GetQuotaUtilizationReportInput {

    static func urlPathProvider(_ value: GetQuotaUtilizationReportInput) -> Swift.String? {
        return "/"
    }
}

extension GetRequestedServiceQuotaChangeInput {

    static func urlPathProvider(_ value: GetRequestedServiceQuotaChangeInput) -> Swift.String? {
        return "/"
    }
}

extension GetServiceQuotaInput {

    static func urlPathProvider(_ value: GetServiceQuotaInput) -> Swift.String? {
        return "/"
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput {

    static func urlPathProvider(_ value: GetServiceQuotaIncreaseRequestFromTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension ListAWSDefaultServiceQuotasInput {

    static func urlPathProvider(_ value: ListAWSDefaultServiceQuotasInput) -> Swift.String? {
        return "/"
    }
}

extension ListRequestedServiceQuotaChangeHistoryInput {

    static func urlPathProvider(_ value: ListRequestedServiceQuotaChangeHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput {

    static func urlPathProvider(_ value: ListRequestedServiceQuotaChangeHistoryByQuotaInput) -> Swift.String? {
        return "/"
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput {

    static func urlPathProvider(_ value: ListServiceQuotaIncreaseRequestsInTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension ListServiceQuotasInput {

    static func urlPathProvider(_ value: ListServiceQuotasInput) -> Swift.String? {
        return "/"
    }
}

extension ListServicesInput {

    static func urlPathProvider(_ value: ListServicesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput {

    static func urlPathProvider(_ value: PutServiceQuotaIncreaseRequestIntoTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension RequestServiceQuotaIncreaseInput {

    static func urlPathProvider(_ value: RequestServiceQuotaIncreaseInput) -> Swift.String? {
        return "/"
    }
}

extension StartAutoManagementInput {

    static func urlPathProvider(_ value: StartAutoManagementInput) -> Swift.String? {
        return "/"
    }
}

extension StartQuotaUtilizationReportInput {

    static func urlPathProvider(_ value: StartQuotaUtilizationReportInput) -> Swift.String? {
        return "/"
    }
}

extension StopAutoManagementInput {

    static func urlPathProvider(_ value: StopAutoManagementInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAutoManagementInput {

    static func urlPathProvider(_ value: UpdateAutoManagementInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateServiceQuotaTemplateInput {

    static func write(value: AssociateServiceQuotaTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension CreateSupportCaseInput {

    static func write(value: CreateSupportCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RequestId"].write(value.requestId)
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput {

    static func write(value: DeleteServiceQuotaIncreaseRequestFromTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension DisassociateServiceQuotaTemplateInput {

    static func write(value: DisassociateServiceQuotaTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetAssociationForServiceQuotaTemplateInput {

    static func write(value: GetAssociationForServiceQuotaTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetAutoManagementConfigurationInput {

    static func write(value: GetAutoManagementConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetAWSDefaultServiceQuotaInput {

    static func write(value: GetAWSDefaultServiceQuotaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension GetQuotaUtilizationReportInput {

    static func write(value: GetQuotaUtilizationReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ReportId"].write(value.reportId)
    }
}

extension GetRequestedServiceQuotaChangeInput {

    static func write(value: GetRequestedServiceQuotaChangeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RequestId"].write(value.requestId)
    }
}

extension GetServiceQuotaInput {

    static func write(value: GetServiceQuotaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContextId"].write(value.contextId)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput {

    static func write(value: GetServiceQuotaIncreaseRequestFromTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension ListAWSDefaultServiceQuotasInput {

    static func write(value: ListAWSDefaultServiceQuotasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension ListRequestedServiceQuotaChangeHistoryInput {

    static func write(value: ListRequestedServiceQuotaChangeHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QuotaRequestedAtLevel"].write(value.quotaRequestedAtLevel)
        try writer["ServiceCode"].write(value.serviceCode)
        try writer["Status"].write(value.status)
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput {

    static func write(value: ListRequestedServiceQuotaChangeHistoryByQuotaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["QuotaRequestedAtLevel"].write(value.quotaRequestedAtLevel)
        try writer["ServiceCode"].write(value.serviceCode)
        try writer["Status"].write(value.status)
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput {

    static func write(value: ListServiceQuotaIncreaseRequestsInTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension ListServiceQuotasInput {

    static func write(value: ListServiceQuotasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QuotaAppliedAtLevel"].write(value.quotaAppliedAtLevel)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension ListServicesInput {

    static func write(value: ListServicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput {

    static func write(value: PutServiceQuotaIncreaseRequestIntoTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["DesiredValue"].write(value.desiredValue)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension RequestServiceQuotaIncreaseInput {

    static func write(value: RequestServiceQuotaIncreaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContextId"].write(value.contextId)
        try writer["DesiredValue"].write(value.desiredValue)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
        try writer["SupportCaseAllowed"].write(value.supportCaseAllowed)
    }
}

extension StartAutoManagementInput {

    static func write(value: StartAutoManagementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExclusionList"].writeMap(value.exclusionList, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["NotificationArn"].write(value.notificationArn)
        try writer["OptInLevel"].write(value.optInLevel)
        try writer["OptInType"].write(value.optInType)
    }
}

extension StartQuotaUtilizationReportInput {

    static func write(value: StartQuotaUtilizationReportInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension StopAutoManagementInput {

    static func write(value: StopAutoManagementInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceQuotasClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAutoManagementInput {

    static func write(value: UpdateAutoManagementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExclusionList"].writeMap(value.exclusionList, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["NotificationArn"].write(value.notificationArn)
        try writer["OptInType"].write(value.optInType)
    }
}

extension AssociateServiceQuotaTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateServiceQuotaTemplateOutput {
        return AssociateServiceQuotaTemplateOutput()
    }
}

extension CreateSupportCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSupportCaseOutput {
        return CreateSupportCaseOutput()
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceQuotaIncreaseRequestFromTemplateOutput {
        return DeleteServiceQuotaIncreaseRequestFromTemplateOutput()
    }
}

extension DisassociateServiceQuotaTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateServiceQuotaTemplateOutput {
        return DisassociateServiceQuotaTemplateOutput()
    }
}

extension GetAssociationForServiceQuotaTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssociationForServiceQuotaTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssociationForServiceQuotaTemplateOutput()
        value.serviceQuotaTemplateAssociationStatus = try reader["ServiceQuotaTemplateAssociationStatus"].readIfPresent()
        return value
    }
}

extension GetAutoManagementConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutoManagementConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutoManagementConfigurationOutput()
        value.exclusionList = try reader["ExclusionList"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: ServiceQuotasClientTypes.QuotaInfo.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.notificationArn = try reader["NotificationArn"].readIfPresent()
        value.optInLevel = try reader["OptInLevel"].readIfPresent()
        value.optInStatus = try reader["OptInStatus"].readIfPresent()
        value.optInType = try reader["OptInType"].readIfPresent()
        return value
    }
}

extension GetAWSDefaultServiceQuotaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAWSDefaultServiceQuotaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAWSDefaultServiceQuotaOutput()
        value.quota = try reader["Quota"].readIfPresent(with: ServiceQuotasClientTypes.ServiceQuota.read(from:))
        return value
    }
}

extension GetQuotaUtilizationReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQuotaUtilizationReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQuotaUtilizationReportOutput()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.generatedAt = try reader["GeneratedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.quotas = try reader["Quotas"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.QuotaUtilizationInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reportId = try reader["ReportId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

extension GetRequestedServiceQuotaChangeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRequestedServiceQuotaChangeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRequestedServiceQuotaChangeOutput()
        value.requestedQuota = try reader["RequestedQuota"].readIfPresent(with: ServiceQuotasClientTypes.RequestedServiceQuotaChange.read(from:))
        return value
    }
}

extension GetServiceQuotaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceQuotaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceQuotaOutput()
        value.quota = try reader["Quota"].readIfPresent(with: ServiceQuotasClientTypes.ServiceQuota.read(from:))
        return value
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceQuotaIncreaseRequestFromTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceQuotaIncreaseRequestFromTemplateOutput()
        value.serviceQuotaIncreaseRequestInTemplate = try reader["ServiceQuotaIncreaseRequestInTemplate"].readIfPresent(with: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.read(from:))
        return value
    }
}

extension ListAWSDefaultServiceQuotasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAWSDefaultServiceQuotasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAWSDefaultServiceQuotasOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.quotas = try reader["Quotas"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.ServiceQuota.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRequestedServiceQuotaChangeHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRequestedServiceQuotaChangeHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRequestedServiceQuotaChangeHistoryOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestedQuotas = try reader["RequestedQuotas"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.RequestedServiceQuotaChange.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRequestedServiceQuotaChangeHistoryByQuotaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRequestedServiceQuotaChangeHistoryByQuotaOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestedQuotas = try reader["RequestedQuotas"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.RequestedServiceQuotaChange.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceQuotaIncreaseRequestsInTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceQuotaIncreaseRequestsInTemplateOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceQuotaIncreaseRequestInTemplateList = try reader["ServiceQuotaIncreaseRequestInTemplateList"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServiceQuotasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceQuotasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceQuotasOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.quotas = try reader["Quotas"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.ServiceQuota.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServicesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.ServiceInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutServiceQuotaIncreaseRequestIntoTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutServiceQuotaIncreaseRequestIntoTemplateOutput()
        value.serviceQuotaIncreaseRequestInTemplate = try reader["ServiceQuotaIncreaseRequestInTemplate"].readIfPresent(with: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.read(from:))
        return value
    }
}

extension RequestServiceQuotaIncreaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RequestServiceQuotaIncreaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RequestServiceQuotaIncreaseOutput()
        value.requestedQuota = try reader["RequestedQuota"].readIfPresent(with: ServiceQuotasClientTypes.RequestedServiceQuotaChange.read(from:))
        return value
    }
}

extension StartAutoManagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAutoManagementOutput {
        return StartAutoManagementOutput()
    }
}

extension StartQuotaUtilizationReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartQuotaUtilizationReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartQuotaUtilizationReportOutput()
        value.message = try reader["Message"].readIfPresent()
        value.reportId = try reader["ReportId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension StopAutoManagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopAutoManagementOutput {
        return StopAutoManagementOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAutoManagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAutoManagementOutput {
        return UpdateAutoManagementOutput()
    }
}

enum AssociateServiceQuotaTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesModeException": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSupportCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceQuotaIncreaseRequestFromTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateServiceQuotaTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaTemplateNotInUseException": return try ServiceQuotaTemplateNotInUseException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssociationForServiceQuotaTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaTemplateNotInUseException": return try ServiceQuotaTemplateNotInUseException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutoManagementConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAWSDefaultServiceQuotaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQuotaUtilizationReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRequestedServiceQuotaChangeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceQuotaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceQuotaIncreaseRequestFromTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAWSDefaultServiceQuotasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRequestedServiceQuotaChangeHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRequestedServiceQuotaChangeHistoryByQuotaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceQuotaIncreaseRequestsInTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceQuotasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutServiceQuotaIncreaseRequestIntoTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "QuotaExceededException": return try QuotaExceededException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RequestServiceQuotaIncreaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "QuotaExceededException": return try QuotaExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAutoManagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartQuotaUtilizationReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopAutoManagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TagPolicyViolationException": return try TagPolicyViolationException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAutoManagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AWSServiceAccessNotEnabledException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AWSServiceAccessNotEnabledException {
        let reader = baseError.errorBodyReader
        var value = AWSServiceAccessNotEnabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependencyAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DependencyAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = DependencyAccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoAvailableOrganizationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoAvailableOrganizationException {
        let reader = baseError.errorBodyReader
        var value = NoAvailableOrganizationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OrganizationNotInAllFeaturesModeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OrganizationNotInAllFeaturesModeException {
        let reader = baseError.errorBodyReader
        var value = OrganizationNotInAllFeaturesModeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceException {
        let reader = baseError.errorBodyReader
        var value = ServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TemplatesNotAvailableInRegionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TemplatesNotAvailableInRegionException {
        let reader = baseError.errorBodyReader
        var value = TemplatesNotAvailableInRegionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalArgumentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IllegalArgumentException {
        let reader = baseError.errorBodyReader
        var value = IllegalArgumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResourceStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidResourceStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchResourceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchResourceException {
        let reader = baseError.errorBodyReader
        var value = NoSuchResourceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaTemplateNotInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaTemplateNotInUseException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaTemplateNotInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPaginationTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPaginationTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidPaginationTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> QuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = QuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagPolicyViolationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagPolicyViolationException {
        let reader = baseError.errorBodyReader
        var value = TagPolicyViolationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotasClientTypes.ErrorReason {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.ErrorReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.ErrorReason()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.MetricInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.MetricInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.MetricInfo()
        value.metricNamespace = try reader["MetricNamespace"].readIfPresent()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.metricDimensions = try reader["MetricDimensions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.metricStatisticRecommendation = try reader["MetricStatisticRecommendation"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.QuotaContextInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.QuotaContextInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.QuotaContextInfo()
        value.contextScope = try reader["ContextScope"].readIfPresent()
        value.contextScopeType = try reader["ContextScopeType"].readIfPresent()
        value.contextId = try reader["ContextId"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.QuotaInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.QuotaInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.QuotaInfo()
        value.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.quotaName = try reader["QuotaName"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.QuotaPeriod {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.QuotaPeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.QuotaPeriod()
        value.periodValue = try reader["PeriodValue"].readIfPresent()
        value.periodUnit = try reader["PeriodUnit"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.QuotaUtilizationInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.QuotaUtilizationInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.QuotaUtilizationInfo()
        value.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.quotaName = try reader["QuotaName"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.utilization = try reader["Utilization"].readIfPresent()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.appliedValue = try reader["AppliedValue"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.adjustable = try reader["Adjustable"].readIfPresent() ?? false
        return value
    }
}

extension ServiceQuotasClientTypes.RequestedServiceQuotaChange {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.RequestedServiceQuotaChange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.RequestedServiceQuotaChange()
        value.id = try reader["Id"].readIfPresent()
        value.requestType = try reader["RequestType"].readIfPresent()
        value.caseId = try reader["CaseId"].readIfPresent()
        value.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.quotaName = try reader["QuotaName"].readIfPresent()
        value.desiredValue = try reader["DesiredValue"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.created = try reader["Created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.requester = try reader["Requester"].readIfPresent()
        value.quotaArn = try reader["QuotaArn"].readIfPresent()
        value.globalQuota = try reader["GlobalQuota"].readIfPresent() ?? false
        value.unit = try reader["Unit"].readIfPresent()
        value.quotaRequestedAtLevel = try reader["QuotaRequestedAtLevel"].readIfPresent()
        value.quotaContext = try reader["QuotaContext"].readIfPresent(with: ServiceQuotasClientTypes.QuotaContextInfo.read(from:))
        return value
    }
}

extension ServiceQuotasClientTypes.ServiceInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.ServiceInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.ServiceInfo()
        value.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.ServiceQuota {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.ServiceQuota {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.ServiceQuota()
        value.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.quotaArn = try reader["QuotaArn"].readIfPresent()
        value.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.quotaName = try reader["QuotaName"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        value.adjustable = try reader["Adjustable"].readIfPresent() ?? false
        value.globalQuota = try reader["GlobalQuota"].readIfPresent() ?? false
        value.usageMetric = try reader["UsageMetric"].readIfPresent(with: ServiceQuotasClientTypes.MetricInfo.read(from:))
        value.period = try reader["Period"].readIfPresent(with: ServiceQuotasClientTypes.QuotaPeriod.read(from:))
        value.errorReason = try reader["ErrorReason"].readIfPresent(with: ServiceQuotasClientTypes.ErrorReason.read(from:))
        value.quotaAppliedAtLevel = try reader["QuotaAppliedAtLevel"].readIfPresent()
        value.quotaContext = try reader["QuotaContext"].readIfPresent(with: ServiceQuotasClientTypes.QuotaContextInfo.read(from:))
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate()
        value.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.quotaName = try reader["QuotaName"].readIfPresent()
        value.desiredValue = try reader["DesiredValue"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        value.globalQuota = try reader["GlobalQuota"].readIfPresent() ?? false
        return value
    }
}

extension ServiceQuotasClientTypes.Tag {

    static func write(value: ServiceQuotasClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

public enum ServiceQuotasClientTypes {}
