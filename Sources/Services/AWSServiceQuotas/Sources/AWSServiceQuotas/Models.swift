//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You do not have sufficient permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ServiceQuotasClientTypes {

    public enum AppliedLevelEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case all
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [AppliedLevelEnum] {
            return [
                .account,
                .all,
                .resource
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .all: return "ALL"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.
public struct AWSServiceAccessNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AWSServiceAccessNotEnabledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You can't perform this action because a dependency does not have access.
public struct DependencyAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyAccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Amazon Web Services account making this call is not a member of an organization.
public struct NoAvailableOrganizationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoAvailableOrganizationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The organization that your Amazon Web Services account belongs to is not in All Features mode.
public struct OrganizationNotInAllFeaturesModeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationNotInAllFeaturesModeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Something went wrong.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Service Quotas template is not available in this Amazon Web Services Region.
public struct TemplatesNotAvailableInRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TemplatesNotAvailableInRegionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateServiceQuotaTemplateInput: Swift.Sendable {

    public init() { }
}

public struct AssociateServiceQuotaTemplateOutput: Swift.Sendable {

    public init() { }
}

/// Invalid input was provided.
public struct IllegalArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource does not exist.
public struct NoSuchResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchResourceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInput: Swift.Sendable {
    /// Specifies the Amazon Web Services Region for which the request was made.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateOutput: Swift.Sendable {

    public init() { }
}

/// The quota request template is not associated with your organization.
public struct ServiceQuotaTemplateNotInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaTemplateNotInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DisassociateServiceQuotaTemplateInput: Swift.Sendable {

    public init() { }
}

public struct DisassociateServiceQuotaTemplateOutput: Swift.Sendable {

    public init() { }
}

extension ServiceQuotasClientTypes {

    public enum ErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dependencyAccessDeniedError
        case dependencyServiceError
        case dependencyThrottlingError
        case serviceQuotaNotAvailableError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .dependencyAccessDeniedError,
                .dependencyServiceError,
                .dependencyThrottlingError,
                .serviceQuotaNotAvailableError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dependencyAccessDeniedError: return "DEPENDENCY_ACCESS_DENIED_ERROR"
            case .dependencyServiceError: return "DEPENDENCY_SERVICE_ERROR"
            case .dependencyThrottlingError: return "DEPENDENCY_THROTTLING_ERROR"
            case .serviceQuotaNotAvailableError: return "SERVICE_QUOTA_NOT_AVAILABLE_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    /// An error that explains why an action did not succeed.
    public struct ErrorReason: Swift.Sendable {
        /// Service Quotas returns the following error values:
        ///
        /// * DEPENDENCY_ACCESS_DENIED_ERROR - The caller does not have the required permissions to complete the action. To resolve the error, you must have permission to access the Amazon Web Service or quota.
        ///
        /// * DEPENDENCY_THROTTLING_ERROR - The Amazon Web Service is throttling Service Quotas.
        ///
        /// * DEPENDENCY_SERVICE_ERROR - The Amazon Web Service is not available.
        ///
        /// * SERVICE_QUOTA_NOT_AVAILABLE_ERROR - There was an error in Service Quotas.
        public var errorCode: ServiceQuotasClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: ServiceQuotasClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

public struct GetAssociationForServiceQuotaTemplateInput: Swift.Sendable {

    public init() { }
}

extension ServiceQuotasClientTypes {

    public enum ServiceQuotaTemplateAssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associated
        case disassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaTemplateAssociationStatus] {
            return [
                .associated,
                .disassociated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .disassociated: return "DISASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAssociationForServiceQuotaTemplateOutput: Swift.Sendable {
    /// The association status. If the status is ASSOCIATED, the quota increase requests in the template are automatically applied to new Amazon Web Services accounts in your organization.
    public var serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus?

    public init(
        serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus? = nil
    )
    {
        self.serviceQuotaTemplateAssociationStatus = serviceQuotaTemplateAssociationStatus
    }
}

public struct GetAWSDefaultServiceQuotaInput: Swift.Sendable {
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

extension ServiceQuotasClientTypes {

    public enum PeriodUnit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case hour
        case microsecond
        case millisecond
        case minute
        case second
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [PeriodUnit] {
            return [
                .day,
                .hour,
                .microsecond,
                .millisecond,
                .minute,
                .second,
                .week
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .microsecond: return "MICROSECOND"
            case .millisecond: return "MILLISECOND"
            case .minute: return "MINUTE"
            case .second: return "SECOND"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    /// Information about the quota period.
    public struct QuotaPeriod: Swift.Sendable {
        /// The time unit.
        public var periodUnit: ServiceQuotasClientTypes.PeriodUnit?
        /// The value associated with the reported PeriodUnit.
        public var periodValue: Swift.Int?

        public init(
            periodUnit: ServiceQuotasClientTypes.PeriodUnit? = nil,
            periodValue: Swift.Int? = nil
        )
        {
            self.periodUnit = periodUnit
            self.periodValue = periodValue
        }
    }
}

extension ServiceQuotasClientTypes {

    public enum QuotaContextScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [QuotaContextScope] {
            return [
                .account,
                .resource
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    /// A structure that describes the context for a service quota. The context identifies what the quota applies to.
    public struct QuotaContextInfo: Swift.Sendable {
        /// Specifies the Amazon Web Services account or resource to which the quota applies. The value in this field depends on the context scope associated with the specified service quota.
        public var contextId: Swift.String?
        /// Specifies whether the quota applies to an Amazon Web Services account, or to a resource.
        public var contextScope: ServiceQuotasClientTypes.QuotaContextScope?
        /// When the ContextScope is RESOURCE, then this specifies the resource type of the specified resource.
        public var contextScopeType: Swift.String?

        public init(
            contextId: Swift.String? = nil,
            contextScope: ServiceQuotasClientTypes.QuotaContextScope? = nil,
            contextScopeType: Swift.String? = nil
        )
        {
            self.contextId = contextId
            self.contextScope = contextScope
            self.contextScopeType = contextScopeType
        }
    }
}

extension ServiceQuotasClientTypes {

    /// Information about the CloudWatch metric that reflects quota usage.
    public struct MetricInfo: Swift.Sendable {
        /// The metric dimension. This is a name/value pair that is part of the identity of a metric.
        public var metricDimensions: [Swift.String: Swift.String]?
        /// The name of the metric.
        public var metricName: Swift.String?
        /// The namespace of the metric.
        public var metricNamespace: Swift.String?
        /// The metric statistic that we recommend you use when determining quota usage.
        public var metricStatisticRecommendation: Swift.String?

        public init(
            metricDimensions: [Swift.String: Swift.String]? = nil,
            metricName: Swift.String? = nil,
            metricNamespace: Swift.String? = nil,
            metricStatisticRecommendation: Swift.String? = nil
        )
        {
            self.metricDimensions = metricDimensions
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.metricStatisticRecommendation = metricStatisticRecommendation
        }
    }
}

extension ServiceQuotasClientTypes {

    /// Information about a quota.
    public struct ServiceQuota: Swift.Sendable {
        /// Indicates whether the quota value can be increased.
        public var adjustable: Swift.Bool
        /// The error code and error reason.
        public var errorReason: ServiceQuotasClientTypes.ErrorReason?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// The period of time.
        public var period: ServiceQuotasClientTypes.QuotaPeriod?
        /// Specifies at which level of granularity that the quota value is applied.
        public var quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
        /// The Amazon Resource Name (ARN) of the quota.
        public var quotaArn: Swift.String?
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// The context for this service quota.
        public var quotaContext: ServiceQuotasClientTypes.QuotaContextInfo?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The unit of measurement.
        public var unit: Swift.String?
        /// Information about the measurement.
        public var usageMetric: ServiceQuotasClientTypes.MetricInfo?
        /// The quota value.
        public var value: Swift.Double?

        public init(
            adjustable: Swift.Bool = false,
            errorReason: ServiceQuotasClientTypes.ErrorReason? = nil,
            globalQuota: Swift.Bool = false,
            period: ServiceQuotasClientTypes.QuotaPeriod? = nil,
            quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
            quotaArn: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaContext: ServiceQuotasClientTypes.QuotaContextInfo? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            unit: Swift.String? = nil,
            usageMetric: ServiceQuotasClientTypes.MetricInfo? = nil,
            value: Swift.Double? = nil
        )
        {
            self.adjustable = adjustable
            self.errorReason = errorReason
            self.globalQuota = globalQuota
            self.period = period
            self.quotaAppliedAtLevel = quotaAppliedAtLevel
            self.quotaArn = quotaArn
            self.quotaCode = quotaCode
            self.quotaContext = quotaContext
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.unit = unit
            self.usageMetric = usageMetric
            self.value = value
        }
    }
}

public struct GetAWSDefaultServiceQuotaOutput: Swift.Sendable {
    /// Information about the quota.
    public var quota: ServiceQuotasClientTypes.ServiceQuota?

    public init(
        quota: ServiceQuotasClientTypes.ServiceQuota? = nil
    )
    {
        self.quota = quota
    }
}

public struct GetRequestedServiceQuotaChangeInput: Swift.Sendable {
    /// Specifies the ID of the quota increase request.
    /// This member is required.
    public var requestId: Swift.String?

    public init(
        requestId: Swift.String? = nil
    )
    {
        self.requestId = requestId
    }
}

extension ServiceQuotasClientTypes {

    public enum RequestStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case caseClosed
        case caseOpened
        case denied
        case invalidRequest
        case notApproved
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestStatus] {
            return [
                .approved,
                .caseClosed,
                .caseOpened,
                .denied,
                .invalidRequest,
                .notApproved,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .caseClosed: return "CASE_CLOSED"
            case .caseOpened: return "CASE_OPENED"
            case .denied: return "DENIED"
            case .invalidRequest: return "INVALID_REQUEST"
            case .notApproved: return "NOT_APPROVED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotasClientTypes {

    /// Information about a quota increase request.
    public struct RequestedServiceQuotaChange: Swift.Sendable {
        /// The case ID.
        public var caseId: Swift.String?
        /// The date and time when the quota increase request was received and the case ID was created.
        public var created: Foundation.Date?
        /// The new, increased value for the quota.
        public var desiredValue: Swift.Double?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// The unique identifier.
        public var id: Swift.String?
        /// The date and time of the most recent change.
        public var lastUpdated: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the quota.
        public var quotaArn: Swift.String?
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// The context for this service quota.
        public var quotaContext: ServiceQuotasClientTypes.QuotaContextInfo?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies at which level within the Amazon Web Services account the quota request applies to.
        public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
        /// The IAM identity of the requester.
        public var requester: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The state of the quota increase request.
        public var status: ServiceQuotasClientTypes.RequestStatus?
        /// The unit of measurement.
        public var unit: Swift.String?

        public init(
            caseId: Swift.String? = nil,
            created: Foundation.Date? = nil,
            desiredValue: Swift.Double? = nil,
            globalQuota: Swift.Bool = false,
            id: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            quotaArn: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaContext: ServiceQuotasClientTypes.QuotaContextInfo? = nil,
            quotaName: Swift.String? = nil,
            quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
            requester: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            status: ServiceQuotasClientTypes.RequestStatus? = nil,
            unit: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.created = created
            self.desiredValue = desiredValue
            self.globalQuota = globalQuota
            self.id = id
            self.lastUpdated = lastUpdated
            self.quotaArn = quotaArn
            self.quotaCode = quotaCode
            self.quotaContext = quotaContext
            self.quotaName = quotaName
            self.quotaRequestedAtLevel = quotaRequestedAtLevel
            self.requester = requester
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.status = status
            self.unit = unit
        }
    }
}

public struct GetRequestedServiceQuotaChangeOutput: Swift.Sendable {
    /// Information about the quota increase request.
    public var requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?

    public init(
        requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange? = nil
    )
    {
        self.requestedQuota = requestedQuota
    }
}

public struct GetServiceQuotaInput: Swift.Sendable {
    /// Specifies the Amazon Web Services account or resource to which the quota applies. The value in this field depends on the context scope associated with the specified service quota.
    public var contextId: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        contextId: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.contextId = contextId
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

public struct GetServiceQuotaOutput: Swift.Sendable {
    /// Information about the quota.
    public var quota: ServiceQuotasClientTypes.ServiceQuota?

    public init(
        quota: ServiceQuotasClientTypes.ServiceQuota? = nil
    )
    {
        self.quota = quota
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInput: Swift.Sendable {
    /// Specifies the Amazon Web Services Region for which you made the request.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

extension ServiceQuotasClientTypes {

    /// Information about a quota increase request.
    public struct ServiceQuotaIncreaseRequestInTemplate: Swift.Sendable {
        /// The Amazon Web Services Region.
        public var awsRegion: Swift.String?
        /// The new, increased value of the quota.
        public var desiredValue: Swift.Double?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The unit of measurement.
        public var unit: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            desiredValue: Swift.Double? = nil,
            globalQuota: Swift.Bool = false,
            quotaCode: Swift.String? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.desiredValue = desiredValue
            self.globalQuota = globalQuota
            self.quotaCode = quotaCode
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.unit = unit
        }
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateOutput: Swift.Sendable {
    /// Information about the quota increase request.
    public var serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?

    public init(
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate? = nil
    )
    {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

extension ServiceQuotasClientTypes {

    /// A complex data type that contains a tag key and tag value.
    public struct Tag: Swift.Sendable {
        /// A string that contains a tag key. The string length should be between 1 and 128 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains an optional tag value. The string length should be between 0 and 256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

/// Invalid input was provided.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource is in an invalid state.
public struct InvalidResourceStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListAWSDefaultServiceQuotasInput: Swift.Sendable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

public struct ListAWSDefaultServiceQuotasOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quotas.
    public var quotas: [ServiceQuotasClientTypes.ServiceQuota]?

    public init(
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.ServiceQuota]? = nil
    )
    {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

public struct ListRequestedServiceQuotaChangeHistoryInput: Swift.Sendable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies at which level within the Amazon Web Services account the quota request applies to.
    public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    public var serviceCode: Swift.String?
    /// Specifies that you want to filter the results to only the requests with the matching status.
    public var status: ServiceQuotasClientTypes.RequestStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        serviceCode: Swift.String? = nil,
        status: ServiceQuotasClientTypes.RequestStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaRequestedAtLevel = quotaRequestedAtLevel
        self.serviceCode = serviceCode
        self.status = status
    }
}

public struct ListRequestedServiceQuotaChangeHistoryOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?

    public init(
        nextToken: Swift.String? = nil,
        requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInput: Swift.Sendable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies at which level within the Amazon Web Services account the quota request applies to.
    public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?
    /// Specifies that you want to filter the results to only the requests with the matching status.
    public var status: ServiceQuotasClientTypes.RequestStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        serviceCode: Swift.String? = nil,
        status: ServiceQuotasClientTypes.RequestStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaCode = quotaCode
        self.quotaRequestedAtLevel = quotaRequestedAtLevel
        self.serviceCode = serviceCode
        self.status = status
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?

    public init(
        nextToken: Swift.String? = nil,
        requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInput: Swift.Sendable {
    /// Specifies the Amazon Web Services Region for which you made the request.
    public var awsRegion: Swift.String?
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]?

    public init(
        nextToken: Swift.String? = nil,
        serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceQuotaIncreaseRequestInTemplateList = serviceQuotaIncreaseRequestInTemplateList
    }
}

public struct ListServiceQuotasInput: Swift.Sendable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies at which level of granularity that the quota value is applied.
    public var quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaAppliedAtLevel = quotaAppliedAtLevel
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

public struct ListServiceQuotasOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quotas.
    public var quotas: [ServiceQuotasClientTypes.ServiceQuota]?

    public init(
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.ServiceQuota]? = nil
    )
    {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

public struct ListServicesInput: Swift.Sendable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ServiceQuotasClientTypes {

    /// Information about an Amazon Web Service.
    public struct ServiceInfo: Swift.Sendable {
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?

        public init(
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.serviceCode = serviceCode
            self.serviceName = serviceName
        }
    }
}

public struct ListServicesOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// The list of the Amazon Web Service names and service codes.
    public var services: [ServiceQuotasClientTypes.ServiceInfo]?

    public init(
        nextToken: Swift.String? = nil,
        services: [ServiceQuotasClientTypes.ServiceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the applied quota for which you want to list tags. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A complex data type that contains zero or more tag elements.
    public var tags: [ServiceQuotasClientTypes.Tag]?

    public init(
        tags: [ServiceQuotasClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct QuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInput: Swift.Sendable {
    /// Specifies the Amazon Web Services Region to which the template applies.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the new, increased value for the quota.
    /// This member is required.
    public var desiredValue: Swift.Double?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        desiredValue: Swift.Double? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateOutput: Swift.Sendable {
    /// Information about the quota increase request.
    public var serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?

    public init(
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate? = nil
    )
    {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct RequestServiceQuotaIncreaseInput: Swift.Sendable {
    /// Specifies the Amazon Web Services account or resource to which the quota applies. The value in this field depends on the context scope associated with the specified service quota.
    public var contextId: Swift.String?
    /// Specifies the new, increased value for the quota.
    /// This member is required.
    public var desiredValue: Swift.Double?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        contextId: Swift.String? = nil,
        desiredValue: Swift.Double? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.contextId = contextId
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

public struct RequestServiceQuotaIncreaseOutput: Swift.Sendable {
    /// Information about the quota increase request.
    public var requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?

    public init(
        requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange? = nil
    )
    {
        self.requestedQuota = requestedQuota
    }
}

/// The specified tag is a reserved word and cannot be used.
public struct TagPolicyViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicyViolationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You've exceeded the number of tags allowed for a resource. For more information, see [Tag restrictions](https://docs.aws.amazon.com/servicequotas/latest/userguide/sq-tagging.html#sq-tagging-restrictions) in the Service Quotas User Guide.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the applied quota. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags that you want to add to the resource.
    /// This member is required.
    public var tags: [ServiceQuotasClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ServiceQuotasClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the applied quota that you want to untag. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AssociateServiceQuotaTemplateInput {

    static func urlPathProvider(_ value: AssociateServiceQuotaTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput {

    static func urlPathProvider(_ value: DeleteServiceQuotaIncreaseRequestFromTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateServiceQuotaTemplateInput {

    static func urlPathProvider(_ value: DisassociateServiceQuotaTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension GetAssociationForServiceQuotaTemplateInput {

    static func urlPathProvider(_ value: GetAssociationForServiceQuotaTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension GetAWSDefaultServiceQuotaInput {

    static func urlPathProvider(_ value: GetAWSDefaultServiceQuotaInput) -> Swift.String? {
        return "/"
    }
}

extension GetRequestedServiceQuotaChangeInput {

    static func urlPathProvider(_ value: GetRequestedServiceQuotaChangeInput) -> Swift.String? {
        return "/"
    }
}

extension GetServiceQuotaInput {

    static func urlPathProvider(_ value: GetServiceQuotaInput) -> Swift.String? {
        return "/"
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput {

    static func urlPathProvider(_ value: GetServiceQuotaIncreaseRequestFromTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension ListAWSDefaultServiceQuotasInput {

    static func urlPathProvider(_ value: ListAWSDefaultServiceQuotasInput) -> Swift.String? {
        return "/"
    }
}

extension ListRequestedServiceQuotaChangeHistoryInput {

    static func urlPathProvider(_ value: ListRequestedServiceQuotaChangeHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput {

    static func urlPathProvider(_ value: ListRequestedServiceQuotaChangeHistoryByQuotaInput) -> Swift.String? {
        return "/"
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput {

    static func urlPathProvider(_ value: ListServiceQuotaIncreaseRequestsInTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension ListServiceQuotasInput {

    static func urlPathProvider(_ value: ListServiceQuotasInput) -> Swift.String? {
        return "/"
    }
}

extension ListServicesInput {

    static func urlPathProvider(_ value: ListServicesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput {

    static func urlPathProvider(_ value: PutServiceQuotaIncreaseRequestIntoTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension RequestServiceQuotaIncreaseInput {

    static func urlPathProvider(_ value: RequestServiceQuotaIncreaseInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateServiceQuotaTemplateInput {

    static func write(value: AssociateServiceQuotaTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput {

    static func write(value: DeleteServiceQuotaIncreaseRequestFromTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension DisassociateServiceQuotaTemplateInput {

    static func write(value: DisassociateServiceQuotaTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetAssociationForServiceQuotaTemplateInput {

    static func write(value: GetAssociationForServiceQuotaTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetAWSDefaultServiceQuotaInput {

    static func write(value: GetAWSDefaultServiceQuotaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension GetRequestedServiceQuotaChangeInput {

    static func write(value: GetRequestedServiceQuotaChangeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RequestId"].write(value.requestId)
    }
}

extension GetServiceQuotaInput {

    static func write(value: GetServiceQuotaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContextId"].write(value.contextId)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput {

    static func write(value: GetServiceQuotaIncreaseRequestFromTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension ListAWSDefaultServiceQuotasInput {

    static func write(value: ListAWSDefaultServiceQuotasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension ListRequestedServiceQuotaChangeHistoryInput {

    static func write(value: ListRequestedServiceQuotaChangeHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QuotaRequestedAtLevel"].write(value.quotaRequestedAtLevel)
        try writer["ServiceCode"].write(value.serviceCode)
        try writer["Status"].write(value.status)
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput {

    static func write(value: ListRequestedServiceQuotaChangeHistoryByQuotaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["QuotaRequestedAtLevel"].write(value.quotaRequestedAtLevel)
        try writer["ServiceCode"].write(value.serviceCode)
        try writer["Status"].write(value.status)
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput {

    static func write(value: ListServiceQuotaIncreaseRequestsInTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension ListServiceQuotasInput {

    static func write(value: ListServiceQuotasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QuotaAppliedAtLevel"].write(value.quotaAppliedAtLevel)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension ListServicesInput {

    static func write(value: ListServicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput {

    static func write(value: PutServiceQuotaIncreaseRequestIntoTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["DesiredValue"].write(value.desiredValue)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension RequestServiceQuotaIncreaseInput {

    static func write(value: RequestServiceQuotaIncreaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContextId"].write(value.contextId)
        try writer["DesiredValue"].write(value.desiredValue)
        try writer["QuotaCode"].write(value.quotaCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceQuotasClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateServiceQuotaTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateServiceQuotaTemplateOutput {
        return AssociateServiceQuotaTemplateOutput()
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceQuotaIncreaseRequestFromTemplateOutput {
        return DeleteServiceQuotaIncreaseRequestFromTemplateOutput()
    }
}

extension DisassociateServiceQuotaTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateServiceQuotaTemplateOutput {
        return DisassociateServiceQuotaTemplateOutput()
    }
}

extension GetAssociationForServiceQuotaTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssociationForServiceQuotaTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssociationForServiceQuotaTemplateOutput()
        value.serviceQuotaTemplateAssociationStatus = try reader["ServiceQuotaTemplateAssociationStatus"].readIfPresent()
        return value
    }
}

extension GetAWSDefaultServiceQuotaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAWSDefaultServiceQuotaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAWSDefaultServiceQuotaOutput()
        value.quota = try reader["Quota"].readIfPresent(with: ServiceQuotasClientTypes.ServiceQuota.read(from:))
        return value
    }
}

extension GetRequestedServiceQuotaChangeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRequestedServiceQuotaChangeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRequestedServiceQuotaChangeOutput()
        value.requestedQuota = try reader["RequestedQuota"].readIfPresent(with: ServiceQuotasClientTypes.RequestedServiceQuotaChange.read(from:))
        return value
    }
}

extension GetServiceQuotaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceQuotaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceQuotaOutput()
        value.quota = try reader["Quota"].readIfPresent(with: ServiceQuotasClientTypes.ServiceQuota.read(from:))
        return value
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceQuotaIncreaseRequestFromTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceQuotaIncreaseRequestFromTemplateOutput()
        value.serviceQuotaIncreaseRequestInTemplate = try reader["ServiceQuotaIncreaseRequestInTemplate"].readIfPresent(with: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.read(from:))
        return value
    }
}

extension ListAWSDefaultServiceQuotasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAWSDefaultServiceQuotasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAWSDefaultServiceQuotasOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.quotas = try reader["Quotas"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.ServiceQuota.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRequestedServiceQuotaChangeHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRequestedServiceQuotaChangeHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRequestedServiceQuotaChangeHistoryOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestedQuotas = try reader["RequestedQuotas"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.RequestedServiceQuotaChange.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRequestedServiceQuotaChangeHistoryByQuotaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRequestedServiceQuotaChangeHistoryByQuotaOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestedQuotas = try reader["RequestedQuotas"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.RequestedServiceQuotaChange.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceQuotaIncreaseRequestsInTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceQuotaIncreaseRequestsInTemplateOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceQuotaIncreaseRequestInTemplateList = try reader["ServiceQuotaIncreaseRequestInTemplateList"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServiceQuotasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceQuotasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceQuotasOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.quotas = try reader["Quotas"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.ServiceQuota.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServicesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.ServiceInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceQuotasClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutServiceQuotaIncreaseRequestIntoTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutServiceQuotaIncreaseRequestIntoTemplateOutput()
        value.serviceQuotaIncreaseRequestInTemplate = try reader["ServiceQuotaIncreaseRequestInTemplate"].readIfPresent(with: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.read(from:))
        return value
    }
}

extension RequestServiceQuotaIncreaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RequestServiceQuotaIncreaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RequestServiceQuotaIncreaseOutput()
        value.requestedQuota = try reader["RequestedQuota"].readIfPresent(with: ServiceQuotasClientTypes.RequestedServiceQuotaChange.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum AssociateServiceQuotaTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesModeException": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceQuotaIncreaseRequestFromTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateServiceQuotaTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaTemplateNotInUseException": return try ServiceQuotaTemplateNotInUseException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssociationForServiceQuotaTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "ServiceQuotaTemplateNotInUseException": return try ServiceQuotaTemplateNotInUseException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAWSDefaultServiceQuotaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRequestedServiceQuotaChangeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceQuotaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceQuotaIncreaseRequestFromTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAWSDefaultServiceQuotasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRequestedServiceQuotaChangeHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRequestedServiceQuotaChangeHistoryByQuotaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceQuotaIncreaseRequestsInTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceQuotasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutServiceQuotaIncreaseRequestIntoTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AWSServiceAccessNotEnabledException": return try AWSServiceAccessNotEnabledException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "QuotaExceededException": return try QuotaExceededException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TemplatesNotAvailableInRegionException": return try TemplatesNotAvailableInRegionException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RequestServiceQuotaIncreaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DependencyAccessDeniedException": return try DependencyAccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "QuotaExceededException": return try QuotaExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TagPolicyViolationException": return try TagPolicyViolationException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "NoSuchResourceException": return try NoSuchResourceException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TemplatesNotAvailableInRegionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TemplatesNotAvailableInRegionException {
        let reader = baseError.errorBodyReader
        var value = TemplatesNotAvailableInRegionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoAvailableOrganizationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoAvailableOrganizationException {
        let reader = baseError.errorBodyReader
        var value = NoAvailableOrganizationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceException {
        let reader = baseError.errorBodyReader
        var value = ServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependencyAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DependencyAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = DependencyAccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OrganizationNotInAllFeaturesModeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OrganizationNotInAllFeaturesModeException {
        let reader = baseError.errorBodyReader
        var value = OrganizationNotInAllFeaturesModeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AWSServiceAccessNotEnabledException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AWSServiceAccessNotEnabledException {
        let reader = baseError.errorBodyReader
        var value = AWSServiceAccessNotEnabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalArgumentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IllegalArgumentException {
        let reader = baseError.errorBodyReader
        var value = IllegalArgumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchResourceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchResourceException {
        let reader = baseError.errorBodyReader
        var value = NoSuchResourceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaTemplateNotInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaTemplateNotInUseException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaTemplateNotInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPaginationTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPaginationTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidPaginationTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> QuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = QuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResourceStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidResourceStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagPolicyViolationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagPolicyViolationException {
        let reader = baseError.errorBodyReader
        var value = TagPolicyViolationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotasClientTypes.ServiceQuota {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.ServiceQuota {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.ServiceQuota()
        value.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.quotaArn = try reader["QuotaArn"].readIfPresent()
        value.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.quotaName = try reader["QuotaName"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        value.adjustable = try reader["Adjustable"].readIfPresent() ?? false
        value.globalQuota = try reader["GlobalQuota"].readIfPresent() ?? false
        value.usageMetric = try reader["UsageMetric"].readIfPresent(with: ServiceQuotasClientTypes.MetricInfo.read(from:))
        value.period = try reader["Period"].readIfPresent(with: ServiceQuotasClientTypes.QuotaPeriod.read(from:))
        value.errorReason = try reader["ErrorReason"].readIfPresent(with: ServiceQuotasClientTypes.ErrorReason.read(from:))
        value.quotaAppliedAtLevel = try reader["QuotaAppliedAtLevel"].readIfPresent()
        value.quotaContext = try reader["QuotaContext"].readIfPresent(with: ServiceQuotasClientTypes.QuotaContextInfo.read(from:))
        return value
    }
}

extension ServiceQuotasClientTypes.QuotaContextInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.QuotaContextInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.QuotaContextInfo()
        value.contextScope = try reader["ContextScope"].readIfPresent()
        value.contextScopeType = try reader["ContextScopeType"].readIfPresent()
        value.contextId = try reader["ContextId"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.ErrorReason {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.ErrorReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.ErrorReason()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.QuotaPeriod {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.QuotaPeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.QuotaPeriod()
        value.periodValue = try reader["PeriodValue"].readIfPresent()
        value.periodUnit = try reader["PeriodUnit"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.MetricInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.MetricInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.MetricInfo()
        value.metricNamespace = try reader["MetricNamespace"].readIfPresent()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.metricDimensions = try reader["MetricDimensions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.metricStatisticRecommendation = try reader["MetricStatisticRecommendation"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.RequestedServiceQuotaChange {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.RequestedServiceQuotaChange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.RequestedServiceQuotaChange()
        value.id = try reader["Id"].readIfPresent()
        value.caseId = try reader["CaseId"].readIfPresent()
        value.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.quotaName = try reader["QuotaName"].readIfPresent()
        value.desiredValue = try reader["DesiredValue"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.created = try reader["Created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.requester = try reader["Requester"].readIfPresent()
        value.quotaArn = try reader["QuotaArn"].readIfPresent()
        value.globalQuota = try reader["GlobalQuota"].readIfPresent() ?? false
        value.unit = try reader["Unit"].readIfPresent()
        value.quotaRequestedAtLevel = try reader["QuotaRequestedAtLevel"].readIfPresent()
        value.quotaContext = try reader["QuotaContext"].readIfPresent(with: ServiceQuotasClientTypes.QuotaContextInfo.read(from:))
        return value
    }
}

extension ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate()
        value.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.quotaName = try reader["QuotaName"].readIfPresent()
        value.desiredValue = try reader["DesiredValue"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        value.globalQuota = try reader["GlobalQuota"].readIfPresent() ?? false
        return value
    }
}

extension ServiceQuotasClientTypes.ServiceInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.ServiceInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.ServiceInfo()
        value.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        return value
    }
}

extension ServiceQuotasClientTypes.Tag {

    static func write(value: ServiceQuotasClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotasClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotasClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

public enum ServiceQuotasClientTypes {}
