// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AWSServiceAccessNotEnabledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AWSServiceAccessNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.
public struct AWSServiceAccessNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AWSServiceAccessNotEnabledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AWSServiceAccessNotEnabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AWSServiceAccessNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes {
    public enum AppliedLevelEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case all
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [AppliedLevelEnum] {
            return [
                .account,
                .all,
                .resource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .all: return "ALL"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppliedLevelEnum(rawValue: rawValue) ?? AppliedLevelEnum.sdkUnknown(rawValue)
        }
    }
}

extension AssociateServiceQuotaTemplateInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension AssociateServiceQuotaTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateServiceQuotaTemplateInput: Swift.Equatable {

    public init() { }
}

struct AssociateServiceQuotaTemplateInputBody: Swift.Equatable {
}

extension AssociateServiceQuotaTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateServiceQuotaTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateServiceQuotaTemplateOutput: Swift.Equatable {

    public init() { }
}

enum AssociateServiceQuotaTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotInAllFeaturesModeException": return try await OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInput: Swift.Equatable {
    /// Specifies the Amazon Web Services Region for which the request was made.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct DeleteServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let awsRegion: Swift.String?
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServiceQuotaIncreaseRequestFromTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DependencyAccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DependencyAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You can't perform this action because a dependency does not have access.
public struct DependencyAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyAccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DependencyAccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DependencyAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisassociateServiceQuotaTemplateInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisassociateServiceQuotaTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateServiceQuotaTemplateInput: Swift.Equatable {

    public init() { }
}

struct DisassociateServiceQuotaTemplateInputBody: Swift.Equatable {
}

extension DisassociateServiceQuotaTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateServiceQuotaTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateServiceQuotaTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateServiceQuotaTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaTemplateNotInUseException": return try await ServiceQuotaTemplateNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotasClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dependencyAccessDeniedError
        case dependencyServiceError
        case dependencyThrottlingError
        case serviceQuotaNotAvailableError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .dependencyAccessDeniedError,
                .dependencyServiceError,
                .dependencyThrottlingError,
                .serviceQuotaNotAvailableError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dependencyAccessDeniedError: return "DEPENDENCY_ACCESS_DENIED_ERROR"
            case .dependencyServiceError: return "DEPENDENCY_SERVICE_ERROR"
            case .dependencyThrottlingError: return "DEPENDENCY_THROTTLING_ERROR"
            case .serviceQuotaNotAvailableError: return "SERVICE_QUOTA_NOT_AVAILABLE_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotasClientTypes.ErrorReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// An error that explains why an action did not succeed.
    public struct ErrorReason: Swift.Equatable {
        /// Service Quotas returns the following error values:
        ///
        /// * DEPENDENCY_ACCESS_DENIED_ERROR - The caller does not have the required permissions to complete the action. To resolve the error, you must have permission to access the Amazon Web Service or quota.
        ///
        /// * DEPENDENCY_THROTTLING_ERROR - The Amazon Web Service is throttling Service Quotas.
        ///
        /// * DEPENDENCY_SERVICE_ERROR - The Amazon Web Service is not available.
        ///
        /// * SERVICE_QUOTA_NOT_AVAILABLE_ERROR - There was an error in Service Quotas.
        public var errorCode: ServiceQuotasClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: ServiceQuotasClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension GetAWSDefaultServiceQuotaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension GetAWSDefaultServiceQuotaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAWSDefaultServiceQuotaInput: Swift.Equatable {
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetAWSDefaultServiceQuotaInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension GetAWSDefaultServiceQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension GetAWSDefaultServiceQuotaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAWSDefaultServiceQuotaOutputBody = try responseDecoder.decode(responseBody: data)
            self.quota = output.quota
        } else {
            self.quota = nil
        }
    }
}

public struct GetAWSDefaultServiceQuotaOutput: Swift.Equatable {
    /// Information about the quota.
    public var quota: ServiceQuotasClientTypes.ServiceQuota?

    public init(
        quota: ServiceQuotasClientTypes.ServiceQuota? = nil
    )
    {
        self.quota = quota
    }
}

struct GetAWSDefaultServiceQuotaOutputBody: Swift.Equatable {
    let quota: ServiceQuotasClientTypes.ServiceQuota?
}

extension GetAWSDefaultServiceQuotaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quota = "Quota"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuota.self, forKey: .quota)
        quota = quotaDecoded
    }
}

enum GetAWSDefaultServiceQuotaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssociationForServiceQuotaTemplateInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetAssociationForServiceQuotaTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAssociationForServiceQuotaTemplateInput: Swift.Equatable {

    public init() { }
}

struct GetAssociationForServiceQuotaTemplateInputBody: Swift.Equatable {
}

extension GetAssociationForServiceQuotaTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssociationForServiceQuotaTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssociationForServiceQuotaTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceQuotaTemplateAssociationStatus = output.serviceQuotaTemplateAssociationStatus
        } else {
            self.serviceQuotaTemplateAssociationStatus = nil
        }
    }
}

public struct GetAssociationForServiceQuotaTemplateOutput: Swift.Equatable {
    /// The association status. If the status is ASSOCIATED, the quota increase requests in the template are automatically applied to new Amazon Web Services accounts in your organization.
    public var serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus?

    public init(
        serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus? = nil
    )
    {
        self.serviceQuotaTemplateAssociationStatus = serviceQuotaTemplateAssociationStatus
    }
}

struct GetAssociationForServiceQuotaTemplateOutputBody: Swift.Equatable {
    let serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus?
}

extension GetAssociationForServiceQuotaTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceQuotaTemplateAssociationStatus = "ServiceQuotaTemplateAssociationStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaTemplateAssociationStatusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus.self, forKey: .serviceQuotaTemplateAssociationStatus)
        serviceQuotaTemplateAssociationStatus = serviceQuotaTemplateAssociationStatusDecoded
    }
}

enum GetAssociationForServiceQuotaTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaTemplateNotInUseException": return try await ServiceQuotaTemplateNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRequestedServiceQuotaChangeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }
}

extension GetRequestedServiceQuotaChangeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRequestedServiceQuotaChangeInput: Swift.Equatable {
    /// Specifies the ID of the quota increase request.
    /// This member is required.
    public var requestId: Swift.String?

    public init(
        requestId: Swift.String? = nil
    )
    {
        self.requestId = requestId
    }
}

struct GetRequestedServiceQuotaChangeInputBody: Swift.Equatable {
    let requestId: Swift.String?
}

extension GetRequestedServiceQuotaChangeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GetRequestedServiceQuotaChangeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRequestedServiceQuotaChangeOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestedQuota = output.requestedQuota
        } else {
            self.requestedQuota = nil
        }
    }
}

public struct GetRequestedServiceQuotaChangeOutput: Swift.Equatable {
    /// Information about the quota increase request.
    public var requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?

    public init(
        requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange? = nil
    )
    {
        self.requestedQuota = requestedQuota
    }
}

struct GetRequestedServiceQuotaChangeOutputBody: Swift.Equatable {
    let requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?
}

extension GetRequestedServiceQuotaChangeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestedQuota = "RequestedQuota"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedQuotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestedServiceQuotaChange.self, forKey: .requestedQuota)
        requestedQuota = requestedQuotaDecoded
    }
}

enum GetRequestedServiceQuotaChangeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInput: Swift.Equatable {
    /// Specifies the Amazon Web Services Region for which you made the request.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let awsRegion: Swift.String?
}

extension GetServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceQuotaIncreaseRequestFromTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceQuotaIncreaseRequestInTemplate = output.serviceQuotaIncreaseRequestInTemplate
        } else {
            self.serviceQuotaIncreaseRequestInTemplate = nil
        }
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateOutput: Swift.Equatable {
    /// Information about the quota increase request.
    public var serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?

    public init(
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate? = nil
    )
    {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

struct GetServiceQuotaIncreaseRequestFromTemplateOutputBody: Swift.Equatable {
    let serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceQuotaIncreaseRequestInTemplate = "ServiceQuotaIncreaseRequestInTemplate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.self, forKey: .serviceQuotaIncreaseRequestInTemplate)
        serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplateDecoded
    }
}

enum GetServiceQuotaIncreaseRequestFromTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceQuotaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextId = "ContextId"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextId = self.contextId {
            try encodeContainer.encode(contextId, forKey: .contextId)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension GetServiceQuotaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceQuotaInput: Swift.Equatable {
    /// Specifies the Amazon Web Services account or resource to which the quota applies. The value in this field depends on the context scope associated with the specified service quota.
    public var contextId: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        contextId: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.contextId = contextId
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetServiceQuotaInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let contextId: Swift.String?
}

extension GetServiceQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextId = "ContextId"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let contextIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextId)
        contextId = contextIdDecoded
    }
}

extension GetServiceQuotaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceQuotaOutputBody = try responseDecoder.decode(responseBody: data)
            self.quota = output.quota
        } else {
            self.quota = nil
        }
    }
}

public struct GetServiceQuotaOutput: Swift.Equatable {
    /// Information about the quota.
    public var quota: ServiceQuotasClientTypes.ServiceQuota?

    public init(
        quota: ServiceQuotasClientTypes.ServiceQuota? = nil
    )
    {
        self.quota = quota
    }
}

struct GetServiceQuotaOutputBody: Swift.Equatable {
    let quota: ServiceQuotasClientTypes.ServiceQuota?
}

extension GetServiceQuotaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quota = "Quota"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuota.self, forKey: .quota)
        quota = quotaDecoded
    }
}

enum GetServiceQuotaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IllegalArgumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IllegalArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Invalid input was provided.
public struct IllegalArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalArgumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IllegalArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Invalid input was provided.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is in an invalid state.
public struct InvalidResourceStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAWSDefaultServiceQuotasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension ListAWSDefaultServiceQuotasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAWSDefaultServiceQuotasInput: Swift.Equatable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct ListAWSDefaultServiceQuotasInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAWSDefaultServiceQuotasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAWSDefaultServiceQuotasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAWSDefaultServiceQuotasOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quotas = output.quotas
        } else {
            self.nextToken = nil
            self.quotas = nil
        }
    }
}

public struct ListAWSDefaultServiceQuotasOutput: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quotas.
    public var quotas: [ServiceQuotasClientTypes.ServiceQuota]?

    public init(
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.ServiceQuota]? = nil
    )
    {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

struct ListAWSDefaultServiceQuotasOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let quotas: [ServiceQuotasClientTypes.ServiceQuota]?
}

extension ListAWSDefaultServiceQuotasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case quotas = "Quotas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceQuota?].self, forKey: .quotas)
        var quotasDecoded0:[ServiceQuotasClientTypes.ServiceQuota]? = nil
        if let quotasContainer = quotasContainer {
            quotasDecoded0 = [ServiceQuotasClientTypes.ServiceQuota]()
            for structure0 in quotasContainer {
                if let structure0 = structure0 {
                    quotasDecoded0?.append(structure0)
                }
            }
        }
        quotas = quotasDecoded0
    }
}

enum ListAWSDefaultServiceQuotasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaCode = "QuotaCode"
        case quotaRequestedAtLevel = "QuotaRequestedAtLevel"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaRequestedAtLevel = self.quotaRequestedAtLevel {
            try encodeContainer.encode(quotaRequestedAtLevel.rawValue, forKey: .quotaRequestedAtLevel)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInput: Swift.Equatable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies at which level within the Amazon Web Services account the quota request applies to.
    public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?
    /// Specifies that you want to filter the results to only the requests with the matching status.
    public var status: ServiceQuotasClientTypes.RequestStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        serviceCode: Swift.String? = nil,
        status: ServiceQuotasClientTypes.RequestStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaCode = quotaCode
        self.quotaRequestedAtLevel = quotaRequestedAtLevel
        self.serviceCode = serviceCode
        self.status = status
    }
}

struct ListRequestedServiceQuotaChangeHistoryByQuotaInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let status: ServiceQuotasClientTypes.RequestStatus?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaCode = "QuotaCode"
        case quotaRequestedAtLevel = "QuotaRequestedAtLevel"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let quotaRequestedAtLevelDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.AppliedLevelEnum.self, forKey: .quotaRequestedAtLevel)
        quotaRequestedAtLevel = quotaRequestedAtLevelDecoded
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRequestedServiceQuotaChangeHistoryByQuotaOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestedQuotas = output.requestedQuotas
        } else {
            self.nextToken = nil
            self.requestedQuotas = nil
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaOutput: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?

    public init(
        nextToken: Swift.String? = nil,
        requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

struct ListRequestedServiceQuotaChangeHistoryByQuotaOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestedQuotas = "RequestedQuotas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestedQuotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.RequestedServiceQuotaChange?].self, forKey: .requestedQuotas)
        var requestedQuotasDecoded0:[ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
        if let requestedQuotasContainer = requestedQuotasContainer {
            requestedQuotasDecoded0 = [ServiceQuotasClientTypes.RequestedServiceQuotaChange]()
            for structure0 in requestedQuotasContainer {
                if let structure0 = structure0 {
                    requestedQuotasDecoded0?.append(structure0)
                }
            }
        }
        requestedQuotas = requestedQuotasDecoded0
    }
}

enum ListRequestedServiceQuotaChangeHistoryByQuotaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRequestedServiceQuotaChangeHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaRequestedAtLevel = "QuotaRequestedAtLevel"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let quotaRequestedAtLevel = self.quotaRequestedAtLevel {
            try encodeContainer.encode(quotaRequestedAtLevel.rawValue, forKey: .quotaRequestedAtLevel)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension ListRequestedServiceQuotaChangeHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRequestedServiceQuotaChangeHistoryInput: Swift.Equatable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies at which level within the Amazon Web Services account the quota request applies to.
    public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    public var serviceCode: Swift.String?
    /// Specifies that you want to filter the results to only the requests with the matching status.
    public var status: ServiceQuotasClientTypes.RequestStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        serviceCode: Swift.String? = nil,
        status: ServiceQuotasClientTypes.RequestStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaRequestedAtLevel = quotaRequestedAtLevel
        self.serviceCode = serviceCode
        self.status = status
    }
}

struct ListRequestedServiceQuotaChangeHistoryInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let status: ServiceQuotasClientTypes.RequestStatus?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
}

extension ListRequestedServiceQuotaChangeHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaRequestedAtLevel = "QuotaRequestedAtLevel"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let quotaRequestedAtLevelDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.AppliedLevelEnum.self, forKey: .quotaRequestedAtLevel)
        quotaRequestedAtLevel = quotaRequestedAtLevelDecoded
    }
}

extension ListRequestedServiceQuotaChangeHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRequestedServiceQuotaChangeHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestedQuotas = output.requestedQuotas
        } else {
            self.nextToken = nil
            self.requestedQuotas = nil
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryOutput: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?

    public init(
        nextToken: Swift.String? = nil,
        requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

struct ListRequestedServiceQuotaChangeHistoryOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?
}

extension ListRequestedServiceQuotaChangeHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestedQuotas = "RequestedQuotas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestedQuotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.RequestedServiceQuotaChange?].self, forKey: .requestedQuotas)
        var requestedQuotasDecoded0:[ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
        if let requestedQuotasContainer = requestedQuotasContainer {
            requestedQuotasDecoded0 = [ServiceQuotasClientTypes.RequestedServiceQuotaChange]()
            for structure0 in requestedQuotasContainer {
                if let structure0 = structure0 {
                    requestedQuotasDecoded0?.append(structure0)
                }
            }
        }
        requestedQuotas = requestedQuotasDecoded0
    }
}

enum ListRequestedServiceQuotaChangeHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInput: Swift.Equatable {
    /// Specifies the Amazon Web Services Region for which you made the request.
    public var awsRegion: Swift.String?
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct ListServiceQuotaIncreaseRequestsInTemplateInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let awsRegion: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListServiceQuotaIncreaseRequestsInTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceQuotaIncreaseRequestsInTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceQuotaIncreaseRequestInTemplateList = output.serviceQuotaIncreaseRequestInTemplateList
        } else {
            self.nextToken = nil
            self.serviceQuotaIncreaseRequestInTemplateList = nil
        }
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateOutput: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]?

    public init(
        nextToken: Swift.String? = nil,
        serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceQuotaIncreaseRequestInTemplateList = serviceQuotaIncreaseRequestInTemplateList
    }
}

struct ListServiceQuotaIncreaseRequestsInTemplateOutputBody: Swift.Equatable {
    let serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]?
    let nextToken: Swift.String?
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceQuotaIncreaseRequestInTemplateList = "ServiceQuotaIncreaseRequestInTemplateList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateListContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?].self, forKey: .serviceQuotaIncreaseRequestInTemplateList)
        var serviceQuotaIncreaseRequestInTemplateListDecoded0:[ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]? = nil
        if let serviceQuotaIncreaseRequestInTemplateListContainer = serviceQuotaIncreaseRequestInTemplateListContainer {
            serviceQuotaIncreaseRequestInTemplateListDecoded0 = [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]()
            for structure0 in serviceQuotaIncreaseRequestInTemplateListContainer {
                if let structure0 = structure0 {
                    serviceQuotaIncreaseRequestInTemplateListDecoded0?.append(structure0)
                }
            }
        }
        serviceQuotaIncreaseRequestInTemplateList = serviceQuotaIncreaseRequestInTemplateListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListServiceQuotaIncreaseRequestsInTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceQuotasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaAppliedAtLevel = "QuotaAppliedAtLevel"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let quotaAppliedAtLevel = self.quotaAppliedAtLevel {
            try encodeContainer.encode(quotaAppliedAtLevel.rawValue, forKey: .quotaAppliedAtLevel)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension ListServiceQuotasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceQuotasInput: Swift.Equatable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies at which level of granularity that the quota value is applied.
    public var quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaAppliedAtLevel = quotaAppliedAtLevel
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct ListServiceQuotasInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let quotaCode: Swift.String?
    let quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
}

extension ListServiceQuotasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaAppliedAtLevel = "QuotaAppliedAtLevel"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaAppliedAtLevelDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.AppliedLevelEnum.self, forKey: .quotaAppliedAtLevel)
        quotaAppliedAtLevel = quotaAppliedAtLevelDecoded
    }
}

extension ListServiceQuotasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceQuotasOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quotas = output.quotas
        } else {
            self.nextToken = nil
            self.quotas = nil
        }
    }
}

public struct ListServiceQuotasOutput: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quotas.
    public var quotas: [ServiceQuotasClientTypes.ServiceQuota]?

    public init(
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.ServiceQuota]? = nil
    )
    {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

struct ListServiceQuotasOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let quotas: [ServiceQuotasClientTypes.ServiceQuota]?
}

extension ListServiceQuotasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case quotas = "Quotas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceQuota?].self, forKey: .quotas)
        var quotasDecoded0:[ServiceQuotasClientTypes.ServiceQuota]? = nil
        if let quotasContainer = quotasContainer {
            quotasDecoded0 = [ServiceQuotasClientTypes.ServiceQuota]()
            for structure0 in quotasContainer {
                if let structure0 = structure0 {
                    quotasDecoded0?.append(structure0)
                }
            }
        }
        quotas = quotasDecoded0
    }
}

enum ListServiceQuotasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServicesInput: Swift.Equatable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct ListServicesOutput: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// The list of the Amazon Web Service names and service codes.
    public var services: [ServiceQuotasClientTypes.ServiceInfo]?

    public init(
        nextToken: Swift.String? = nil,
        services: [ServiceQuotasClientTypes.ServiceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct ListServicesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let services: [ServiceQuotasClientTypes.ServiceInfo]?
}

extension ListServicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let servicesContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceInfo?].self, forKey: .services)
        var servicesDecoded0:[ServiceQuotasClientTypes.ServiceInfo]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ServiceQuotasClientTypes.ServiceInfo]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
    }
}

enum ListServicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the applied quota for which you want to list tags. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A complex data type that contains zero or more tag elements.
    public var tags: [ServiceQuotasClientTypes.Tag]?

    public init(
        tags: [ServiceQuotasClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [ServiceQuotasClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceQuotasClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceQuotasClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotasClientTypes.MetricInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDimensions = "MetricDimensions"
        case metricName = "MetricName"
        case metricNamespace = "MetricNamespace"
        case metricStatisticRecommendation = "MetricStatisticRecommendation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDimensions = metricDimensions {
            var metricDimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metricDimensions)
            for (dictKey0, metricDimensionsMapDefinition0) in metricDimensions {
                try metricDimensionsContainer.encode(metricDimensionsMapDefinition0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricNamespace = self.metricNamespace {
            try encodeContainer.encode(metricNamespace, forKey: .metricNamespace)
        }
        if let metricStatisticRecommendation = self.metricStatisticRecommendation {
            try encodeContainer.encode(metricStatisticRecommendation, forKey: .metricStatisticRecommendation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricNamespace)
        metricNamespace = metricNamespaceDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricDimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metricDimensions)
        var metricDimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let metricDimensionsContainer = metricDimensionsContainer {
            metricDimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, metricdimensionvalue0) in metricDimensionsContainer {
                if let metricdimensionvalue0 = metricdimensionvalue0 {
                    metricDimensionsDecoded0?[key0] = metricdimensionvalue0
                }
            }
        }
        metricDimensions = metricDimensionsDecoded0
        let metricStatisticRecommendationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricStatisticRecommendation)
        metricStatisticRecommendation = metricStatisticRecommendationDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about the CloudWatch metric that reflects quota usage.
    public struct MetricInfo: Swift.Equatable {
        /// The metric dimension. This is a name/value pair that is part of the identity of a metric.
        public var metricDimensions: [Swift.String:Swift.String]?
        /// The name of the metric.
        public var metricName: Swift.String?
        /// The namespace of the metric.
        public var metricNamespace: Swift.String?
        /// The metric statistic that we recommend you use when determining quota usage.
        public var metricStatisticRecommendation: Swift.String?

        public init(
            metricDimensions: [Swift.String:Swift.String]? = nil,
            metricName: Swift.String? = nil,
            metricNamespace: Swift.String? = nil,
            metricStatisticRecommendation: Swift.String? = nil
        )
        {
            self.metricDimensions = metricDimensions
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.metricStatisticRecommendation = metricStatisticRecommendation
        }
    }

}

extension NoAvailableOrganizationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoAvailableOrganizationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Web Services account making this call is not a member of an organization.
public struct NoAvailableOrganizationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoAvailableOrganizationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoAvailableOrganizationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoAvailableOrganizationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoSuchResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource does not exist.
public struct NoSuchResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotInAllFeaturesModeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OrganizationNotInAllFeaturesModeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The organization that your Amazon Web Services account belongs to is not in All Features mode.
public struct OrganizationNotInAllFeaturesModeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationNotInAllFeaturesModeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OrganizationNotInAllFeaturesModeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationNotInAllFeaturesModeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes {
    public enum PeriodUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case hour
        case microsecond
        case millisecond
        case minute
        case second
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [PeriodUnit] {
            return [
                .day,
                .hour,
                .microsecond,
                .millisecond,
                .minute,
                .second,
                .week,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .microsecond: return "MICROSECOND"
            case .millisecond: return "MILLISECOND"
            case .minute: return "MINUTE"
            case .second: return "SECOND"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PeriodUnit(rawValue: rawValue) ?? PeriodUnit.sdkUnknown(rawValue)
        }
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let desiredValue = self.desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInput: Swift.Equatable {
    /// Specifies the Amazon Web Services Region to which the template applies.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the new, increased value for the quota.
    /// This member is required.
    public var desiredValue: Swift.Double?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        desiredValue: Swift.Double? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct PutServiceQuotaIncreaseRequestIntoTemplateInputBody: Swift.Equatable {
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
    let awsRegion: Swift.String?
    let desiredValue: Swift.Double?
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutServiceQuotaIncreaseRequestIntoTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceQuotaIncreaseRequestInTemplate = output.serviceQuotaIncreaseRequestInTemplate
        } else {
            self.serviceQuotaIncreaseRequestInTemplate = nil
        }
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateOutput: Swift.Equatable {
    /// Information about the quota increase request.
    public var serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?

    public init(
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate? = nil
    )
    {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

struct PutServiceQuotaIncreaseRequestIntoTemplateOutputBody: Swift.Equatable {
    let serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceQuotaIncreaseRequestInTemplate = "ServiceQuotaIncreaseRequestInTemplate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.self, forKey: .serviceQuotaIncreaseRequestInTemplate)
        serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplateDecoded
    }
}

enum PutServiceQuotaIncreaseRequestIntoTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QuotaExceededException": return try await QuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotasClientTypes.QuotaContextInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextId = "ContextId"
        case contextScope = "ContextScope"
        case contextScopeType = "ContextScopeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextId = self.contextId {
            try encodeContainer.encode(contextId, forKey: .contextId)
        }
        if let contextScope = self.contextScope {
            try encodeContainer.encode(contextScope.rawValue, forKey: .contextScope)
        }
        if let contextScopeType = self.contextScopeType {
            try encodeContainer.encode(contextScopeType, forKey: .contextScopeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contextScopeDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.QuotaContextScope.self, forKey: .contextScope)
        contextScope = contextScopeDecoded
        let contextScopeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextScopeType)
        contextScopeType = contextScopeTypeDecoded
        let contextIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextId)
        contextId = contextIdDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// A structure that describes the context for a service quota. The context identifies what the quota applies to.
    public struct QuotaContextInfo: Swift.Equatable {
        /// Specifies the Amazon Web Services account or resource to which the quota applies. The value in this field depends on the context scope associated with the specified service quota.
        public var contextId: Swift.String?
        /// Specifies whether the quota applies to an Amazon Web Services account, or to a resource.
        public var contextScope: ServiceQuotasClientTypes.QuotaContextScope?
        /// When the ContextScope is RESOURCE, then this specifies the resource type of the specified resource.
        public var contextScopeType: Swift.String?

        public init(
            contextId: Swift.String? = nil,
            contextScope: ServiceQuotasClientTypes.QuotaContextScope? = nil,
            contextScopeType: Swift.String? = nil
        )
        {
            self.contextId = contextId
            self.contextScope = contextScope
            self.contextScopeType = contextScopeType
        }
    }

}

extension ServiceQuotasClientTypes {
    public enum QuotaContextScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [QuotaContextScope] {
            return [
                .account,
                .resource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuotaContextScope(rawValue: rawValue) ?? QuotaContextScope.sdkUnknown(rawValue)
        }
    }
}

extension QuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: QuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct QuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct QuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension QuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes.QuotaPeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case periodUnit = "PeriodUnit"
        case periodValue = "PeriodValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let periodUnit = self.periodUnit {
            try encodeContainer.encode(periodUnit.rawValue, forKey: .periodUnit)
        }
        if let periodValue = self.periodValue {
            try encodeContainer.encode(periodValue, forKey: .periodValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let periodValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodValue)
        periodValue = periodValueDecoded
        let periodUnitDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.PeriodUnit.self, forKey: .periodUnit)
        periodUnit = periodUnitDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about the quota period.
    public struct QuotaPeriod: Swift.Equatable {
        /// The time unit.
        public var periodUnit: ServiceQuotasClientTypes.PeriodUnit?
        /// The value associated with the reported PeriodUnit.
        public var periodValue: Swift.Int?

        public init(
            periodUnit: ServiceQuotasClientTypes.PeriodUnit? = nil,
            periodValue: Swift.Int? = nil
        )
        {
            self.periodUnit = periodUnit
            self.periodValue = periodValue
        }
    }

}

extension RequestServiceQuotaIncreaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextId = "ContextId"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextId = self.contextId {
            try encodeContainer.encode(contextId, forKey: .contextId)
        }
        if let desiredValue = self.desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension RequestServiceQuotaIncreaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RequestServiceQuotaIncreaseInput: Swift.Equatable {
    /// Specifies the Amazon Web Services account or resource to which the quota applies. The value in this field depends on the context scope associated with the specified service quota.
    public var contextId: Swift.String?
    /// Specifies the new, increased value for the quota.
    /// This member is required.
    public var desiredValue: Swift.Double?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        contextId: Swift.String? = nil,
        desiredValue: Swift.Double? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.contextId = contextId
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct RequestServiceQuotaIncreaseInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let desiredValue: Swift.Double?
    let contextId: Swift.String?
}

extension RequestServiceQuotaIncreaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextId = "ContextId"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
        let contextIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextId)
        contextId = contextIdDecoded
    }
}

extension RequestServiceQuotaIncreaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestServiceQuotaIncreaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestedQuota = output.requestedQuota
        } else {
            self.requestedQuota = nil
        }
    }
}

public struct RequestServiceQuotaIncreaseOutput: Swift.Equatable {
    /// Information about the quota increase request.
    public var requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?

    public init(
        requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange? = nil
    )
    {
        self.requestedQuota = requestedQuota
    }
}

struct RequestServiceQuotaIncreaseOutputBody: Swift.Equatable {
    let requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?
}

extension RequestServiceQuotaIncreaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestedQuota = "RequestedQuota"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedQuotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestedServiceQuotaChange.self, forKey: .requestedQuota)
        requestedQuota = requestedQuotaDecoded
    }
}

enum RequestServiceQuotaIncreaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QuotaExceededException": return try await QuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotasClientTypes {
    public enum RequestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case caseClosed
        case caseOpened
        case denied
        case invalidRequest
        case notApproved
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestStatus] {
            return [
                .approved,
                .caseClosed,
                .caseOpened,
                .denied,
                .invalidRequest,
                .notApproved,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .caseClosed: return "CASE_CLOSED"
            case .caseOpened: return "CASE_OPENED"
            case .denied: return "DENIED"
            case .invalidRequest: return "INVALID_REQUEST"
            case .notApproved: return "NOT_APPROVED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestStatus(rawValue: rawValue) ?? RequestStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotasClientTypes.RequestedServiceQuotaChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId = "CaseId"
        case created = "Created"
        case desiredValue = "DesiredValue"
        case globalQuota = "GlobalQuota"
        case id = "Id"
        case lastUpdated = "LastUpdated"
        case quotaArn = "QuotaArn"
        case quotaCode = "QuotaCode"
        case quotaContext = "QuotaContext"
        case quotaName = "QuotaName"
        case quotaRequestedAtLevel = "QuotaRequestedAtLevel"
        case requester = "Requester"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case status = "Status"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = self.caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let desiredValue = self.desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let quotaArn = self.quotaArn {
            try encodeContainer.encode(quotaArn, forKey: .quotaArn)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaContext = self.quotaContext {
            try encodeContainer.encode(quotaContext, forKey: .quotaContext)
        }
        if let quotaName = self.quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let quotaRequestedAtLevel = self.quotaRequestedAtLevel {
            try encodeContainer.encode(quotaRequestedAtLevel.rawValue, forKey: .quotaRequestedAtLevel)
        }
        if let requester = self.requester {
            try encodeContainer.encode(requester, forKey: .requester)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestStatus.self, forKey: .status)
        status = statusDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let requesterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requester)
        requester = requesterDecoded
        let quotaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaArn)
        quotaArn = quotaArnDecoded
        let globalQuotaDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .globalQuota) ?? false
        globalQuota = globalQuotaDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let quotaRequestedAtLevelDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.AppliedLevelEnum.self, forKey: .quotaRequestedAtLevel)
        quotaRequestedAtLevel = quotaRequestedAtLevelDecoded
        let quotaContextDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.QuotaContextInfo.self, forKey: .quotaContext)
        quotaContext = quotaContextDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about a quota increase request.
    public struct RequestedServiceQuotaChange: Swift.Equatable {
        /// The case ID.
        public var caseId: Swift.String?
        /// The date and time when the quota increase request was received and the case ID was created.
        public var created: ClientRuntime.Date?
        /// The new, increased value for the quota.
        public var desiredValue: Swift.Double?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// The unique identifier.
        public var id: Swift.String?
        /// The date and time of the most recent change.
        public var lastUpdated: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the quota.
        public var quotaArn: Swift.String?
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// The context for this service quota.
        public var quotaContext: ServiceQuotasClientTypes.QuotaContextInfo?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies at which level within the Amazon Web Services account the quota request applies to.
        public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
        /// The IAM identity of the requester.
        public var requester: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The state of the quota increase request.
        public var status: ServiceQuotasClientTypes.RequestStatus?
        /// The unit of measurement.
        public var unit: Swift.String?

        public init(
            caseId: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            desiredValue: Swift.Double? = nil,
            globalQuota: Swift.Bool = false,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            quotaArn: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaContext: ServiceQuotasClientTypes.QuotaContextInfo? = nil,
            quotaName: Swift.String? = nil,
            quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
            requester: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            status: ServiceQuotasClientTypes.RequestStatus? = nil,
            unit: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.created = created
            self.desiredValue = desiredValue
            self.globalQuota = globalQuota
            self.id = id
            self.lastUpdated = lastUpdated
            self.quotaArn = quotaArn
            self.quotaCode = quotaCode
            self.quotaContext = quotaContext
            self.quotaName = quotaName
            self.quotaRequestedAtLevel = quotaRequestedAtLevel
            self.requester = requester
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.status = status
            self.unit = unit
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Something went wrong.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes.ServiceInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about an Amazon Web Service.
    public struct ServiceInfo: Swift.Equatable {
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?

        public init(
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.serviceCode = serviceCode
            self.serviceName = serviceName
        }
    }

}

extension ServiceQuotasClientTypes.ServiceQuota: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustable = "Adjustable"
        case errorReason = "ErrorReason"
        case globalQuota = "GlobalQuota"
        case period = "Period"
        case quotaAppliedAtLevel = "QuotaAppliedAtLevel"
        case quotaArn = "QuotaArn"
        case quotaCode = "QuotaCode"
        case quotaContext = "QuotaContext"
        case quotaName = "QuotaName"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case unit = "Unit"
        case usageMetric = "UsageMetric"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if adjustable != false {
            try encodeContainer.encode(adjustable, forKey: .adjustable)
        }
        if let errorReason = self.errorReason {
            try encodeContainer.encode(errorReason, forKey: .errorReason)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let period = self.period {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let quotaAppliedAtLevel = self.quotaAppliedAtLevel {
            try encodeContainer.encode(quotaAppliedAtLevel.rawValue, forKey: .quotaAppliedAtLevel)
        }
        if let quotaArn = self.quotaArn {
            try encodeContainer.encode(quotaArn, forKey: .quotaArn)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaContext = self.quotaContext {
            try encodeContainer.encode(quotaContext, forKey: .quotaContext)
        }
        if let quotaName = self.quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let usageMetric = self.usageMetric {
            try encodeContainer.encode(usageMetric, forKey: .usageMetric)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaArn)
        quotaArn = quotaArnDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let adjustableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .adjustable) ?? false
        adjustable = adjustableDecoded
        let globalQuotaDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .globalQuota) ?? false
        globalQuota = globalQuotaDecoded
        let usageMetricDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.MetricInfo.self, forKey: .usageMetric)
        usageMetric = usageMetricDecoded
        let periodDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.QuotaPeriod.self, forKey: .period)
        period = periodDecoded
        let errorReasonDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ErrorReason.self, forKey: .errorReason)
        errorReason = errorReasonDecoded
        let quotaAppliedAtLevelDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.AppliedLevelEnum.self, forKey: .quotaAppliedAtLevel)
        quotaAppliedAtLevel = quotaAppliedAtLevelDecoded
        let quotaContextDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.QuotaContextInfo.self, forKey: .quotaContext)
        quotaContext = quotaContextDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about a quota.
    public struct ServiceQuota: Swift.Equatable {
        /// Indicates whether the quota value can be increased.
        public var adjustable: Swift.Bool
        /// The error code and error reason.
        public var errorReason: ServiceQuotasClientTypes.ErrorReason?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// The period of time.
        public var period: ServiceQuotasClientTypes.QuotaPeriod?
        /// Specifies at which level of granularity that the quota value is applied.
        public var quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
        /// The Amazon Resource Name (ARN) of the quota.
        public var quotaArn: Swift.String?
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// The context for this service quota.
        public var quotaContext: ServiceQuotasClientTypes.QuotaContextInfo?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The unit of measurement.
        public var unit: Swift.String?
        /// Information about the measurement.
        public var usageMetric: ServiceQuotasClientTypes.MetricInfo?
        /// The quota value.
        public var value: Swift.Double?

        public init(
            adjustable: Swift.Bool = false,
            errorReason: ServiceQuotasClientTypes.ErrorReason? = nil,
            globalQuota: Swift.Bool = false,
            period: ServiceQuotasClientTypes.QuotaPeriod? = nil,
            quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
            quotaArn: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaContext: ServiceQuotasClientTypes.QuotaContextInfo? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            unit: Swift.String? = nil,
            usageMetric: ServiceQuotasClientTypes.MetricInfo? = nil,
            value: Swift.Double? = nil
        )
        {
            self.adjustable = adjustable
            self.errorReason = errorReason
            self.globalQuota = globalQuota
            self.period = period
            self.quotaAppliedAtLevel = quotaAppliedAtLevel
            self.quotaArn = quotaArn
            self.quotaCode = quotaCode
            self.quotaContext = quotaContext
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.unit = unit
            self.usageMetric = usageMetric
            self.value = value
        }
    }

}

extension ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case globalQuota = "GlobalQuota"
        case quotaCode = "QuotaCode"
        case quotaName = "QuotaName"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let desiredValue = self.desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaName = self.quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let globalQuotaDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .globalQuota) ?? false
        globalQuota = globalQuotaDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about a quota increase request.
    public struct ServiceQuotaIncreaseRequestInTemplate: Swift.Equatable {
        /// The Amazon Web Services Region.
        public var awsRegion: Swift.String?
        /// The new, increased value of the quota.
        public var desiredValue: Swift.Double?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The unit of measurement.
        public var unit: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            desiredValue: Swift.Double? = nil,
            globalQuota: Swift.Bool = false,
            quotaCode: Swift.String? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.desiredValue = desiredValue
            self.globalQuota = globalQuota
            self.quotaCode = quotaCode
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.unit = unit
        }
    }

}

extension ServiceQuotasClientTypes {
    public enum ServiceQuotaTemplateAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case disassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaTemplateAssociationStatus] {
            return [
                .associated,
                .disassociated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .disassociated: return "DISASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaTemplateAssociationStatus(rawValue: rawValue) ?? ServiceQuotaTemplateAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaTemplateNotInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaTemplateNotInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The quota request template is not associated with your organization.
public struct ServiceQuotaTemplateNotInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaTemplateNotInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaTemplateNotInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaTemplateNotInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// A complex data type that contains a tag key and tag value.
    public struct Tag: Swift.Equatable {
        /// A string that contains a tag key. The string length should be between 1 and 128 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains an optional tag value. The string length should be between 0 and 256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagPolicyViolationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagPolicyViolationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified tag is a reserved word and cannot be used.
public struct TagPolicyViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicyViolationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagPolicyViolationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagPolicyViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the applied quota. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags that you want to add to the resource.
    /// This member is required.
    public var tags: [ServiceQuotasClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ServiceQuotasClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ServiceQuotasClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceQuotasClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceQuotasClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagPolicyViolationException": return try await TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TemplatesNotAvailableInRegionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TemplatesNotAvailableInRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Service Quotas template is not available in this Amazon Web Services Region.
public struct TemplatesNotAvailableInRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TemplatesNotAvailableInRegionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TemplatesNotAvailableInRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TemplatesNotAvailableInRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've exceeded the number of tags allowed for a resource. For more information, see [Tag restrictions](https://docs.aws.amazon.com/servicequotas/latest/userguide/sq-tagging.html#sq-tagging-restrictions) in the Service Quotas User Guide.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the applied quota that you want to untag. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
