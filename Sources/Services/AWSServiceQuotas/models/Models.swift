// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AWSServiceAccessNotEnabledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AWSServiceAccessNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.
public struct AWSServiceAccessNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AWSServiceAccessNotEnabledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AWSServiceAccessNotEnabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AWSServiceAccessNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes {
    public enum AppliedLevelEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case all
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [AppliedLevelEnum] {
            return [
                .account,
                .all,
                .resource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .all: return "ALL"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppliedLevelEnum(rawValue: rawValue) ?? AppliedLevelEnum.sdkUnknown(rawValue)
        }
    }
}

extension AssociateServiceQuotaTemplateInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension AssociateServiceQuotaTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateServiceQuotaTemplateInput: Swift.Equatable {

    public init() { }
}

struct AssociateServiceQuotaTemplateInputBody: Swift.Equatable {
}

extension AssociateServiceQuotaTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum AssociateServiceQuotaTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotInAllFeaturesModeException": return try await OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateServiceQuotaTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateServiceQuotaTemplateOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInput: Swift.Equatable {
    /// Specifies the Amazon Web Services Region for which the request was made.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct DeleteServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let awsRegion: Swift.String?
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

public enum DeleteServiceQuotaIncreaseRequestFromTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse: Swift.Equatable {

    public init() { }
}

extension DependencyAccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DependencyAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You can't perform this action because a dependency does not have access.
public struct DependencyAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyAccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DependencyAccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DependencyAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisassociateServiceQuotaTemplateInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisassociateServiceQuotaTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateServiceQuotaTemplateInput: Swift.Equatable {

    public init() { }
}

struct DisassociateServiceQuotaTemplateInputBody: Swift.Equatable {
}

extension DisassociateServiceQuotaTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DisassociateServiceQuotaTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaTemplateNotInUseException": return try await ServiceQuotaTemplateNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateServiceQuotaTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateServiceQuotaTemplateOutputResponse: Swift.Equatable {

    public init() { }
}

extension ServiceQuotasClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dependencyAccessDeniedError
        case dependencyServiceError
        case dependencyThrottlingError
        case serviceQuotaNotAvailableError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .dependencyAccessDeniedError,
                .dependencyServiceError,
                .dependencyThrottlingError,
                .serviceQuotaNotAvailableError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dependencyAccessDeniedError: return "DEPENDENCY_ACCESS_DENIED_ERROR"
            case .dependencyServiceError: return "DEPENDENCY_SERVICE_ERROR"
            case .dependencyThrottlingError: return "DEPENDENCY_THROTTLING_ERROR"
            case .serviceQuotaNotAvailableError: return "SERVICE_QUOTA_NOT_AVAILABLE_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotasClientTypes.ErrorReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// An error that explains why an action did not succeed.
    public struct ErrorReason: Swift.Equatable {
        /// Service Quotas returns the following error values:
        ///
        /// * DEPENDENCY_ACCESS_DENIED_ERROR - The caller does not have the required permissions to complete the action. To resolve the error, you must have permission to access the Amazon Web Service or quota.
        ///
        /// * DEPENDENCY_THROTTLING_ERROR - The Amazon Web Service is throttling Service Quotas.
        ///
        /// * DEPENDENCY_SERVICE_ERROR - The Amazon Web Service is not available.
        ///
        /// * SERVICE_QUOTA_NOT_AVAILABLE_ERROR - There was an error in Service Quotas.
        public var errorCode: ServiceQuotasClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: ServiceQuotasClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension GetAWSDefaultServiceQuotaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension GetAWSDefaultServiceQuotaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAWSDefaultServiceQuotaInput: Swift.Equatable {
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetAWSDefaultServiceQuotaInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension GetAWSDefaultServiceQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

public enum GetAWSDefaultServiceQuotaOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAWSDefaultServiceQuotaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAWSDefaultServiceQuotaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.quota = output.quota
        } else {
            self.quota = nil
        }
    }
}

public struct GetAWSDefaultServiceQuotaOutputResponse: Swift.Equatable {
    /// Information about the quota.
    public var quota: ServiceQuotasClientTypes.ServiceQuota?

    public init(
        quota: ServiceQuotasClientTypes.ServiceQuota? = nil
    )
    {
        self.quota = quota
    }
}

struct GetAWSDefaultServiceQuotaOutputResponseBody: Swift.Equatable {
    let quota: ServiceQuotasClientTypes.ServiceQuota?
}

extension GetAWSDefaultServiceQuotaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quota = "Quota"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuota.self, forKey: .quota)
        quota = quotaDecoded
    }
}

extension GetAssociationForServiceQuotaTemplateInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetAssociationForServiceQuotaTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAssociationForServiceQuotaTemplateInput: Swift.Equatable {

    public init() { }
}

struct GetAssociationForServiceQuotaTemplateInputBody: Swift.Equatable {
}

extension GetAssociationForServiceQuotaTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetAssociationForServiceQuotaTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaTemplateNotInUseException": return try await ServiceQuotaTemplateNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssociationForServiceQuotaTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssociationForServiceQuotaTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceQuotaTemplateAssociationStatus = output.serviceQuotaTemplateAssociationStatus
        } else {
            self.serviceQuotaTemplateAssociationStatus = nil
        }
    }
}

public struct GetAssociationForServiceQuotaTemplateOutputResponse: Swift.Equatable {
    /// The association status. If the status is ASSOCIATED, the quota increase requests in the template are automatically applied to new Amazon Web Services accounts in your organization.
    public var serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus?

    public init(
        serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus? = nil
    )
    {
        self.serviceQuotaTemplateAssociationStatus = serviceQuotaTemplateAssociationStatus
    }
}

struct GetAssociationForServiceQuotaTemplateOutputResponseBody: Swift.Equatable {
    let serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus?
}

extension GetAssociationForServiceQuotaTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceQuotaTemplateAssociationStatus = "ServiceQuotaTemplateAssociationStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaTemplateAssociationStatusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus.self, forKey: .serviceQuotaTemplateAssociationStatus)
        serviceQuotaTemplateAssociationStatus = serviceQuotaTemplateAssociationStatusDecoded
    }
}

extension GetRequestedServiceQuotaChangeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }
}

extension GetRequestedServiceQuotaChangeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRequestedServiceQuotaChangeInput: Swift.Equatable {
    /// Specifies the ID of the quota increase request.
    /// This member is required.
    public var requestId: Swift.String?

    public init(
        requestId: Swift.String? = nil
    )
    {
        self.requestId = requestId
    }
}

struct GetRequestedServiceQuotaChangeInputBody: Swift.Equatable {
    let requestId: Swift.String?
}

extension GetRequestedServiceQuotaChangeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public enum GetRequestedServiceQuotaChangeOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRequestedServiceQuotaChangeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRequestedServiceQuotaChangeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestedQuota = output.requestedQuota
        } else {
            self.requestedQuota = nil
        }
    }
}

public struct GetRequestedServiceQuotaChangeOutputResponse: Swift.Equatable {
    /// Information about the quota increase request.
    public var requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?

    public init(
        requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange? = nil
    )
    {
        self.requestedQuota = requestedQuota
    }
}

struct GetRequestedServiceQuotaChangeOutputResponseBody: Swift.Equatable {
    let requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?
}

extension GetRequestedServiceQuotaChangeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestedQuota = "RequestedQuota"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedQuotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestedServiceQuotaChange.self, forKey: .requestedQuota)
        requestedQuota = requestedQuotaDecoded
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInput: Swift.Equatable {
    /// Specifies the Amazon Web Services Region for which you made the request.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let awsRegion: Swift.String?
}

extension GetServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

public enum GetServiceQuotaIncreaseRequestFromTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceQuotaIncreaseRequestFromTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceQuotaIncreaseRequestInTemplate = output.serviceQuotaIncreaseRequestInTemplate
        } else {
            self.serviceQuotaIncreaseRequestInTemplate = nil
        }
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateOutputResponse: Swift.Equatable {
    /// Information about the quota increase request.
    public var serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?

    public init(
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate? = nil
    )
    {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

struct GetServiceQuotaIncreaseRequestFromTemplateOutputResponseBody: Swift.Equatable {
    let serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceQuotaIncreaseRequestInTemplate = "ServiceQuotaIncreaseRequestInTemplate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.self, forKey: .serviceQuotaIncreaseRequestInTemplate)
        serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplateDecoded
    }
}

extension GetServiceQuotaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextId = "ContextId"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextId = self.contextId {
            try encodeContainer.encode(contextId, forKey: .contextId)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension GetServiceQuotaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceQuotaInput: Swift.Equatable {
    /// Specifies the Amazon Web Services account or resource to which the quota applies. The value in this field depends on the context scope associated with the specified service quota.
    public var contextId: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        contextId: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.contextId = contextId
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetServiceQuotaInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let contextId: Swift.String?
}

extension GetServiceQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextId = "ContextId"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let contextIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextId)
        contextId = contextIdDecoded
    }
}

public enum GetServiceQuotaOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceQuotaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceQuotaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.quota = output.quota
        } else {
            self.quota = nil
        }
    }
}

public struct GetServiceQuotaOutputResponse: Swift.Equatable {
    /// Information about the quota.
    public var quota: ServiceQuotasClientTypes.ServiceQuota?

    public init(
        quota: ServiceQuotasClientTypes.ServiceQuota? = nil
    )
    {
        self.quota = quota
    }
}

struct GetServiceQuotaOutputResponseBody: Swift.Equatable {
    let quota: ServiceQuotasClientTypes.ServiceQuota?
}

extension GetServiceQuotaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quota = "Quota"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuota.self, forKey: .quota)
        quota = quotaDecoded
    }
}

extension IllegalArgumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IllegalArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Invalid input was provided.
public struct IllegalArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalArgumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IllegalArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Invalid input was provided.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is in an invalid state.
public struct InvalidResourceStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAWSDefaultServiceQuotasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension ListAWSDefaultServiceQuotasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAWSDefaultServiceQuotasInput: Swift.Equatable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct ListAWSDefaultServiceQuotasInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAWSDefaultServiceQuotasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListAWSDefaultServiceQuotasOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAWSDefaultServiceQuotasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAWSDefaultServiceQuotasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quotas = output.quotas
        } else {
            self.nextToken = nil
            self.quotas = nil
        }
    }
}

public struct ListAWSDefaultServiceQuotasOutputResponse: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quotas.
    public var quotas: [ServiceQuotasClientTypes.ServiceQuota]?

    public init(
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.ServiceQuota]? = nil
    )
    {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

struct ListAWSDefaultServiceQuotasOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let quotas: [ServiceQuotasClientTypes.ServiceQuota]?
}

extension ListAWSDefaultServiceQuotasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case quotas = "Quotas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceQuota?].self, forKey: .quotas)
        var quotasDecoded0:[ServiceQuotasClientTypes.ServiceQuota]? = nil
        if let quotasContainer = quotasContainer {
            quotasDecoded0 = [ServiceQuotasClientTypes.ServiceQuota]()
            for structure0 in quotasContainer {
                if let structure0 = structure0 {
                    quotasDecoded0?.append(structure0)
                }
            }
        }
        quotas = quotasDecoded0
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaCode = "QuotaCode"
        case quotaRequestedAtLevel = "QuotaRequestedAtLevel"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaRequestedAtLevel = self.quotaRequestedAtLevel {
            try encodeContainer.encode(quotaRequestedAtLevel.rawValue, forKey: .quotaRequestedAtLevel)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInput: Swift.Equatable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies at which level within the Amazon Web Services account the quota request applies to.
    public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?
    /// Specifies that you want to filter the results to only the requests with the matching status.
    public var status: ServiceQuotasClientTypes.RequestStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        serviceCode: Swift.String? = nil,
        status: ServiceQuotasClientTypes.RequestStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaCode = quotaCode
        self.quotaRequestedAtLevel = quotaRequestedAtLevel
        self.serviceCode = serviceCode
        self.status = status
    }
}

struct ListRequestedServiceQuotaChangeHistoryByQuotaInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let status: ServiceQuotasClientTypes.RequestStatus?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaCode = "QuotaCode"
        case quotaRequestedAtLevel = "QuotaRequestedAtLevel"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let quotaRequestedAtLevelDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.AppliedLevelEnum.self, forKey: .quotaRequestedAtLevel)
        quotaRequestedAtLevel = quotaRequestedAtLevelDecoded
    }
}

public enum ListRequestedServiceQuotaChangeHistoryByQuotaOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestedQuotas = output.requestedQuotas
        } else {
            self.nextToken = nil
            self.requestedQuotas = nil
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?

    public init(
        nextToken: Swift.String? = nil,
        requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

struct ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestedQuotas = "RequestedQuotas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestedQuotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.RequestedServiceQuotaChange?].self, forKey: .requestedQuotas)
        var requestedQuotasDecoded0:[ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
        if let requestedQuotasContainer = requestedQuotasContainer {
            requestedQuotasDecoded0 = [ServiceQuotasClientTypes.RequestedServiceQuotaChange]()
            for structure0 in requestedQuotasContainer {
                if let structure0 = structure0 {
                    requestedQuotasDecoded0?.append(structure0)
                }
            }
        }
        requestedQuotas = requestedQuotasDecoded0
    }
}

extension ListRequestedServiceQuotaChangeHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaRequestedAtLevel = "QuotaRequestedAtLevel"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let quotaRequestedAtLevel = self.quotaRequestedAtLevel {
            try encodeContainer.encode(quotaRequestedAtLevel.rawValue, forKey: .quotaRequestedAtLevel)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension ListRequestedServiceQuotaChangeHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRequestedServiceQuotaChangeHistoryInput: Swift.Equatable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies at which level within the Amazon Web Services account the quota request applies to.
    public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    public var serviceCode: Swift.String?
    /// Specifies that you want to filter the results to only the requests with the matching status.
    public var status: ServiceQuotasClientTypes.RequestStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        serviceCode: Swift.String? = nil,
        status: ServiceQuotasClientTypes.RequestStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaRequestedAtLevel = quotaRequestedAtLevel
        self.serviceCode = serviceCode
        self.status = status
    }
}

struct ListRequestedServiceQuotaChangeHistoryInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let status: ServiceQuotasClientTypes.RequestStatus?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
}

extension ListRequestedServiceQuotaChangeHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaRequestedAtLevel = "QuotaRequestedAtLevel"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let quotaRequestedAtLevelDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.AppliedLevelEnum.self, forKey: .quotaRequestedAtLevel)
        quotaRequestedAtLevel = quotaRequestedAtLevelDecoded
    }
}

public enum ListRequestedServiceQuotaChangeHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRequestedServiceQuotaChangeHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRequestedServiceQuotaChangeHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestedQuotas = output.requestedQuotas
        } else {
            self.nextToken = nil
            self.requestedQuotas = nil
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryOutputResponse: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?

    public init(
        nextToken: Swift.String? = nil,
        requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

struct ListRequestedServiceQuotaChangeHistoryOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?
}

extension ListRequestedServiceQuotaChangeHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestedQuotas = "RequestedQuotas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestedQuotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.RequestedServiceQuotaChange?].self, forKey: .requestedQuotas)
        var requestedQuotasDecoded0:[ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
        if let requestedQuotasContainer = requestedQuotasContainer {
            requestedQuotasDecoded0 = [ServiceQuotasClientTypes.RequestedServiceQuotaChange]()
            for structure0 in requestedQuotasContainer {
                if let structure0 = structure0 {
                    requestedQuotasDecoded0?.append(structure0)
                }
            }
        }
        requestedQuotas = requestedQuotasDecoded0
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInput: Swift.Equatable {
    /// Specifies the Amazon Web Services Region for which you made the request.
    public var awsRegion: Swift.String?
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct ListServiceQuotaIncreaseRequestsInTemplateInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let awsRegion: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListServiceQuotaIncreaseRequestsInTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListServiceQuotaIncreaseRequestsInTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceQuotaIncreaseRequestsInTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceQuotaIncreaseRequestInTemplateList = output.serviceQuotaIncreaseRequestInTemplateList
        } else {
            self.nextToken = nil
            self.serviceQuotaIncreaseRequestInTemplateList = nil
        }
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateOutputResponse: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quota increase requests.
    public var serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]?

    public init(
        nextToken: Swift.String? = nil,
        serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceQuotaIncreaseRequestInTemplateList = serviceQuotaIncreaseRequestInTemplateList
    }
}

struct ListServiceQuotaIncreaseRequestsInTemplateOutputResponseBody: Swift.Equatable {
    let serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]?
    let nextToken: Swift.String?
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceQuotaIncreaseRequestInTemplateList = "ServiceQuotaIncreaseRequestInTemplateList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateListContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?].self, forKey: .serviceQuotaIncreaseRequestInTemplateList)
        var serviceQuotaIncreaseRequestInTemplateListDecoded0:[ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]? = nil
        if let serviceQuotaIncreaseRequestInTemplateListContainer = serviceQuotaIncreaseRequestInTemplateListContainer {
            serviceQuotaIncreaseRequestInTemplateListDecoded0 = [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]()
            for structure0 in serviceQuotaIncreaseRequestInTemplateListContainer {
                if let structure0 = structure0 {
                    serviceQuotaIncreaseRequestInTemplateListDecoded0?.append(structure0)
                }
            }
        }
        serviceQuotaIncreaseRequestInTemplateList = serviceQuotaIncreaseRequestInTemplateListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServiceQuotasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaAppliedAtLevel = "QuotaAppliedAtLevel"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let quotaAppliedAtLevel = self.quotaAppliedAtLevel {
            try encodeContainer.encode(quotaAppliedAtLevel.rawValue, forKey: .quotaAppliedAtLevel)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension ListServiceQuotasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceQuotasInput: Swift.Equatable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?
    /// Specifies at which level of granularity that the quota value is applied.
    public var quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaAppliedAtLevel = quotaAppliedAtLevel
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct ListServiceQuotasInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let quotaCode: Swift.String?
    let quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
}

extension ListServiceQuotasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaAppliedAtLevel = "QuotaAppliedAtLevel"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaAppliedAtLevelDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.AppliedLevelEnum.self, forKey: .quotaAppliedAtLevel)
        quotaAppliedAtLevel = quotaAppliedAtLevelDecoded
    }
}

public enum ListServiceQuotasOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceQuotasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceQuotasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quotas = output.quotas
        } else {
            self.nextToken = nil
            self.quotas = nil
        }
    }
}

public struct ListServiceQuotasOutputResponse: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// Information about the quotas.
    public var quotas: [ServiceQuotasClientTypes.ServiceQuota]?

    public init(
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.ServiceQuota]? = nil
    )
    {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

struct ListServiceQuotasOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let quotas: [ServiceQuotasClientTypes.ServiceQuota]?
}

extension ListServiceQuotasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case quotas = "Quotas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceQuota?].self, forKey: .quotas)
        var quotasDecoded0:[ServiceQuotasClientTypes.ServiceQuota]? = nil
        if let quotasContainer = quotasContainer {
            quotasDecoded0 = [ServiceQuotasClientTypes.ServiceQuota]()
            for structure0 in quotasContainer {
                if let structure0 = structure0 {
                    quotasDecoded0?.append(structure0)
                }
            }
        }
        quotas = quotasDecoded0
    }
}

extension ListServicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServicesInput: Swift.Equatable {
    /// Specifies the maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies a value for receiving additional results after you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListServicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null.
    public var nextToken: Swift.String?
    /// The list of the Amazon Web Service names and service codes.
    public var services: [ServiceQuotasClientTypes.ServiceInfo]?

    public init(
        nextToken: Swift.String? = nil,
        services: [ServiceQuotasClientTypes.ServiceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let services: [ServiceQuotasClientTypes.ServiceInfo]?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let servicesContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceInfo?].self, forKey: .services)
        var servicesDecoded0:[ServiceQuotasClientTypes.ServiceInfo]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ServiceQuotasClientTypes.ServiceInfo]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the applied quota for which you want to list tags. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

public enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A complex data type that contains zero or more tag elements.
    public var tags: [ServiceQuotasClientTypes.Tag]?

    public init(
        tags: [ServiceQuotasClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ServiceQuotasClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceQuotasClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceQuotasClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ServiceQuotasClientTypes.MetricInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDimensions = "MetricDimensions"
        case metricName = "MetricName"
        case metricNamespace = "MetricNamespace"
        case metricStatisticRecommendation = "MetricStatisticRecommendation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDimensions = metricDimensions {
            var metricDimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metricDimensions)
            for (dictKey0, metricDimensionsMapDefinition0) in metricDimensions {
                try metricDimensionsContainer.encode(metricDimensionsMapDefinition0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricNamespace = self.metricNamespace {
            try encodeContainer.encode(metricNamespace, forKey: .metricNamespace)
        }
        if let metricStatisticRecommendation = self.metricStatisticRecommendation {
            try encodeContainer.encode(metricStatisticRecommendation, forKey: .metricStatisticRecommendation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricNamespace)
        metricNamespace = metricNamespaceDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricDimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metricDimensions)
        var metricDimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let metricDimensionsContainer = metricDimensionsContainer {
            metricDimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, metricdimensionvalue0) in metricDimensionsContainer {
                if let metricdimensionvalue0 = metricdimensionvalue0 {
                    metricDimensionsDecoded0?[key0] = metricdimensionvalue0
                }
            }
        }
        metricDimensions = metricDimensionsDecoded0
        let metricStatisticRecommendationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricStatisticRecommendation)
        metricStatisticRecommendation = metricStatisticRecommendationDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about the CloudWatch metric that reflects quota usage.
    public struct MetricInfo: Swift.Equatable {
        /// The metric dimension. This is a name/value pair that is part of the identity of a metric.
        public var metricDimensions: [Swift.String:Swift.String]?
        /// The name of the metric.
        public var metricName: Swift.String?
        /// The namespace of the metric.
        public var metricNamespace: Swift.String?
        /// The metric statistic that we recommend you use when determining quota usage.
        public var metricStatisticRecommendation: Swift.String?

        public init(
            metricDimensions: [Swift.String:Swift.String]? = nil,
            metricName: Swift.String? = nil,
            metricNamespace: Swift.String? = nil,
            metricStatisticRecommendation: Swift.String? = nil
        )
        {
            self.metricDimensions = metricDimensions
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.metricStatisticRecommendation = metricStatisticRecommendation
        }
    }

}

extension NoAvailableOrganizationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoAvailableOrganizationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Web Services account making this call is not a member of an organization.
public struct NoAvailableOrganizationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoAvailableOrganizationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoAvailableOrganizationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoAvailableOrganizationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoSuchResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource does not exist.
public struct NoSuchResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotInAllFeaturesModeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OrganizationNotInAllFeaturesModeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The organization that your Amazon Web Services account belongs to is not in All Features mode.
public struct OrganizationNotInAllFeaturesModeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationNotInAllFeaturesModeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OrganizationNotInAllFeaturesModeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationNotInAllFeaturesModeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes {
    public enum PeriodUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case hour
        case microsecond
        case millisecond
        case minute
        case second
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [PeriodUnit] {
            return [
                .day,
                .hour,
                .microsecond,
                .millisecond,
                .minute,
                .second,
                .week,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .microsecond: return "MICROSECOND"
            case .millisecond: return "MILLISECOND"
            case .minute: return "MINUTE"
            case .second: return "SECOND"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PeriodUnit(rawValue: rawValue) ?? PeriodUnit.sdkUnknown(rawValue)
        }
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let desiredValue = self.desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInput: Swift.Equatable {
    /// Specifies the Amazon Web Services Region to which the template applies.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// Specifies the new, increased value for the quota.
    /// This member is required.
    public var desiredValue: Swift.Double?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        desiredValue: Swift.Double? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct PutServiceQuotaIncreaseRequestIntoTemplateInputBody: Swift.Equatable {
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
    let awsRegion: Swift.String?
    let desiredValue: Swift.Double?
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
    }
}

public enum PutServiceQuotaIncreaseRequestIntoTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AWSServiceAccessNotEnabledException": return try await AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableOrganizationException": return try await NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QuotaExceededException": return try await QuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemplatesNotAvailableInRegionException": return try await TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutServiceQuotaIncreaseRequestIntoTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceQuotaIncreaseRequestInTemplate = output.serviceQuotaIncreaseRequestInTemplate
        } else {
            self.serviceQuotaIncreaseRequestInTemplate = nil
        }
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse: Swift.Equatable {
    /// Information about the quota increase request.
    public var serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?

    public init(
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate? = nil
    )
    {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

struct PutServiceQuotaIncreaseRequestIntoTemplateOutputResponseBody: Swift.Equatable {
    let serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceQuotaIncreaseRequestInTemplate = "ServiceQuotaIncreaseRequestInTemplate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.self, forKey: .serviceQuotaIncreaseRequestInTemplate)
        serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplateDecoded
    }
}

extension ServiceQuotasClientTypes.QuotaContextInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextId = "ContextId"
        case contextScope = "ContextScope"
        case contextScopeType = "ContextScopeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextId = self.contextId {
            try encodeContainer.encode(contextId, forKey: .contextId)
        }
        if let contextScope = self.contextScope {
            try encodeContainer.encode(contextScope.rawValue, forKey: .contextScope)
        }
        if let contextScopeType = self.contextScopeType {
            try encodeContainer.encode(contextScopeType, forKey: .contextScopeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contextScopeDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.QuotaContextScope.self, forKey: .contextScope)
        contextScope = contextScopeDecoded
        let contextScopeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextScopeType)
        contextScopeType = contextScopeTypeDecoded
        let contextIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextId)
        contextId = contextIdDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// A structure that describes the context for a service quota. The context identifies what the quota applies to.
    public struct QuotaContextInfo: Swift.Equatable {
        /// Specifies the Amazon Web Services account or resource to which the quota applies. The value in this field depends on the context scope associated with the specified service quota.
        public var contextId: Swift.String?
        /// Specifies whether the quota applies to an Amazon Web Services account, or to a resource.
        public var contextScope: ServiceQuotasClientTypes.QuotaContextScope?
        /// When the ContextScope is RESOURCE, then this specifies the resource type of the specified resource.
        public var contextScopeType: Swift.String?

        public init(
            contextId: Swift.String? = nil,
            contextScope: ServiceQuotasClientTypes.QuotaContextScope? = nil,
            contextScopeType: Swift.String? = nil
        )
        {
            self.contextId = contextId
            self.contextScope = contextScope
            self.contextScopeType = contextScopeType
        }
    }

}

extension ServiceQuotasClientTypes {
    public enum QuotaContextScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [QuotaContextScope] {
            return [
                .account,
                .resource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuotaContextScope(rawValue: rawValue) ?? QuotaContextScope.sdkUnknown(rawValue)
        }
    }
}

extension QuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: QuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct QuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct QuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension QuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes.QuotaPeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case periodUnit = "PeriodUnit"
        case periodValue = "PeriodValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let periodUnit = self.periodUnit {
            try encodeContainer.encode(periodUnit.rawValue, forKey: .periodUnit)
        }
        if let periodValue = self.periodValue {
            try encodeContainer.encode(periodValue, forKey: .periodValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let periodValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodValue)
        periodValue = periodValueDecoded
        let periodUnitDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.PeriodUnit.self, forKey: .periodUnit)
        periodUnit = periodUnitDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about the quota period.
    public struct QuotaPeriod: Swift.Equatable {
        /// The time unit.
        public var periodUnit: ServiceQuotasClientTypes.PeriodUnit?
        /// The value associated with the reported PeriodUnit.
        public var periodValue: Swift.Int?

        public init(
            periodUnit: ServiceQuotasClientTypes.PeriodUnit? = nil,
            periodValue: Swift.Int? = nil
        )
        {
            self.periodUnit = periodUnit
            self.periodValue = periodValue
        }
    }

}

extension RequestServiceQuotaIncreaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextId = "ContextId"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextId = self.contextId {
            try encodeContainer.encode(contextId, forKey: .contextId)
        }
        if let desiredValue = self.desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension RequestServiceQuotaIncreaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RequestServiceQuotaIncreaseInput: Swift.Equatable {
    /// Specifies the Amazon Web Services account or resource to which the quota applies. The value in this field depends on the context scope associated with the specified service quota.
    public var contextId: Swift.String?
    /// Specifies the new, increased value for the quota.
    /// This member is required.
    public var desiredValue: Swift.Double?
    /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        contextId: Swift.String? = nil,
        desiredValue: Swift.Double? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.contextId = contextId
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct RequestServiceQuotaIncreaseInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let desiredValue: Swift.Double?
    let contextId: Swift.String?
}

extension RequestServiceQuotaIncreaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextId = "ContextId"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
        let contextIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextId)
        contextId = contextIdDecoded
    }
}

public enum RequestServiceQuotaIncreaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyAccessDeniedException": return try await DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QuotaExceededException": return try await QuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RequestServiceQuotaIncreaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestServiceQuotaIncreaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestedQuota = output.requestedQuota
        } else {
            self.requestedQuota = nil
        }
    }
}

public struct RequestServiceQuotaIncreaseOutputResponse: Swift.Equatable {
    /// Information about the quota increase request.
    public var requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?

    public init(
        requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange? = nil
    )
    {
        self.requestedQuota = requestedQuota
    }
}

struct RequestServiceQuotaIncreaseOutputResponseBody: Swift.Equatable {
    let requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?
}

extension RequestServiceQuotaIncreaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestedQuota = "RequestedQuota"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedQuotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestedServiceQuotaChange.self, forKey: .requestedQuota)
        requestedQuota = requestedQuotaDecoded
    }
}

extension ServiceQuotasClientTypes {
    public enum RequestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case caseClosed
        case caseOpened
        case denied
        case invalidRequest
        case notApproved
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestStatus] {
            return [
                .approved,
                .caseClosed,
                .caseOpened,
                .denied,
                .invalidRequest,
                .notApproved,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .caseClosed: return "CASE_CLOSED"
            case .caseOpened: return "CASE_OPENED"
            case .denied: return "DENIED"
            case .invalidRequest: return "INVALID_REQUEST"
            case .notApproved: return "NOT_APPROVED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestStatus(rawValue: rawValue) ?? RequestStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotasClientTypes.RequestedServiceQuotaChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId = "CaseId"
        case created = "Created"
        case desiredValue = "DesiredValue"
        case globalQuota = "GlobalQuota"
        case id = "Id"
        case lastUpdated = "LastUpdated"
        case quotaArn = "QuotaArn"
        case quotaCode = "QuotaCode"
        case quotaContext = "QuotaContext"
        case quotaName = "QuotaName"
        case quotaRequestedAtLevel = "QuotaRequestedAtLevel"
        case requester = "Requester"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case status = "Status"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = self.caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let desiredValue = self.desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let quotaArn = self.quotaArn {
            try encodeContainer.encode(quotaArn, forKey: .quotaArn)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaContext = self.quotaContext {
            try encodeContainer.encode(quotaContext, forKey: .quotaContext)
        }
        if let quotaName = self.quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let quotaRequestedAtLevel = self.quotaRequestedAtLevel {
            try encodeContainer.encode(quotaRequestedAtLevel.rawValue, forKey: .quotaRequestedAtLevel)
        }
        if let requester = self.requester {
            try encodeContainer.encode(requester, forKey: .requester)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestStatus.self, forKey: .status)
        status = statusDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let requesterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requester)
        requester = requesterDecoded
        let quotaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaArn)
        quotaArn = quotaArnDecoded
        let globalQuotaDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .globalQuota) ?? false
        globalQuota = globalQuotaDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let quotaRequestedAtLevelDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.AppliedLevelEnum.self, forKey: .quotaRequestedAtLevel)
        quotaRequestedAtLevel = quotaRequestedAtLevelDecoded
        let quotaContextDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.QuotaContextInfo.self, forKey: .quotaContext)
        quotaContext = quotaContextDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about a quota increase request.
    public struct RequestedServiceQuotaChange: Swift.Equatable {
        /// The case ID.
        public var caseId: Swift.String?
        /// The date and time when the quota increase request was received and the case ID was created.
        public var created: ClientRuntime.Date?
        /// The new, increased value for the quota.
        public var desiredValue: Swift.Double?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// The unique identifier.
        public var id: Swift.String?
        /// The date and time of the most recent change.
        public var lastUpdated: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the quota.
        public var quotaArn: Swift.String?
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// The context for this service quota.
        public var quotaContext: ServiceQuotasClientTypes.QuotaContextInfo?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies at which level within the Amazon Web Services account the quota request applies to.
        public var quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
        /// The IAM identity of the requester.
        public var requester: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The state of the quota increase request.
        public var status: ServiceQuotasClientTypes.RequestStatus?
        /// The unit of measurement.
        public var unit: Swift.String?

        public init(
            caseId: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            desiredValue: Swift.Double? = nil,
            globalQuota: Swift.Bool = false,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            quotaArn: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaContext: ServiceQuotasClientTypes.QuotaContextInfo? = nil,
            quotaName: Swift.String? = nil,
            quotaRequestedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
            requester: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            status: ServiceQuotasClientTypes.RequestStatus? = nil,
            unit: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.created = created
            self.desiredValue = desiredValue
            self.globalQuota = globalQuota
            self.id = id
            self.lastUpdated = lastUpdated
            self.quotaArn = quotaArn
            self.quotaCode = quotaCode
            self.quotaContext = quotaContext
            self.quotaName = quotaName
            self.quotaRequestedAtLevel = quotaRequestedAtLevel
            self.requester = requester
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.status = status
            self.unit = unit
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Something went wrong.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes.ServiceInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about an Amazon Web Service.
    public struct ServiceInfo: Swift.Equatable {
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?

        public init(
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.serviceCode = serviceCode
            self.serviceName = serviceName
        }
    }

}

extension ServiceQuotasClientTypes.ServiceQuota: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustable = "Adjustable"
        case errorReason = "ErrorReason"
        case globalQuota = "GlobalQuota"
        case period = "Period"
        case quotaAppliedAtLevel = "QuotaAppliedAtLevel"
        case quotaArn = "QuotaArn"
        case quotaCode = "QuotaCode"
        case quotaContext = "QuotaContext"
        case quotaName = "QuotaName"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case unit = "Unit"
        case usageMetric = "UsageMetric"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if adjustable != false {
            try encodeContainer.encode(adjustable, forKey: .adjustable)
        }
        if let errorReason = self.errorReason {
            try encodeContainer.encode(errorReason, forKey: .errorReason)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let period = self.period {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let quotaAppliedAtLevel = self.quotaAppliedAtLevel {
            try encodeContainer.encode(quotaAppliedAtLevel.rawValue, forKey: .quotaAppliedAtLevel)
        }
        if let quotaArn = self.quotaArn {
            try encodeContainer.encode(quotaArn, forKey: .quotaArn)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaContext = self.quotaContext {
            try encodeContainer.encode(quotaContext, forKey: .quotaContext)
        }
        if let quotaName = self.quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let usageMetric = self.usageMetric {
            try encodeContainer.encode(usageMetric, forKey: .usageMetric)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaArn)
        quotaArn = quotaArnDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let adjustableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .adjustable) ?? false
        adjustable = adjustableDecoded
        let globalQuotaDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .globalQuota) ?? false
        globalQuota = globalQuotaDecoded
        let usageMetricDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.MetricInfo.self, forKey: .usageMetric)
        usageMetric = usageMetricDecoded
        let periodDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.QuotaPeriod.self, forKey: .period)
        period = periodDecoded
        let errorReasonDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ErrorReason.self, forKey: .errorReason)
        errorReason = errorReasonDecoded
        let quotaAppliedAtLevelDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.AppliedLevelEnum.self, forKey: .quotaAppliedAtLevel)
        quotaAppliedAtLevel = quotaAppliedAtLevelDecoded
        let quotaContextDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.QuotaContextInfo.self, forKey: .quotaContext)
        quotaContext = quotaContextDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about a quota.
    public struct ServiceQuota: Swift.Equatable {
        /// Indicates whether the quota value can be increased.
        public var adjustable: Swift.Bool
        /// The error code and error reason.
        public var errorReason: ServiceQuotasClientTypes.ErrorReason?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// The period of time.
        public var period: ServiceQuotasClientTypes.QuotaPeriod?
        /// Specifies at which level of granularity that the quota value is applied.
        public var quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum?
        /// The Amazon Resource Name (ARN) of the quota.
        public var quotaArn: Swift.String?
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// The context for this service quota.
        public var quotaContext: ServiceQuotasClientTypes.QuotaContextInfo?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The unit of measurement.
        public var unit: Swift.String?
        /// Information about the measurement.
        public var usageMetric: ServiceQuotasClientTypes.MetricInfo?
        /// The quota value.
        public var value: Swift.Double?

        public init(
            adjustable: Swift.Bool = false,
            errorReason: ServiceQuotasClientTypes.ErrorReason? = nil,
            globalQuota: Swift.Bool = false,
            period: ServiceQuotasClientTypes.QuotaPeriod? = nil,
            quotaAppliedAtLevel: ServiceQuotasClientTypes.AppliedLevelEnum? = nil,
            quotaArn: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaContext: ServiceQuotasClientTypes.QuotaContextInfo? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            unit: Swift.String? = nil,
            usageMetric: ServiceQuotasClientTypes.MetricInfo? = nil,
            value: Swift.Double? = nil
        )
        {
            self.adjustable = adjustable
            self.errorReason = errorReason
            self.globalQuota = globalQuota
            self.period = period
            self.quotaAppliedAtLevel = quotaAppliedAtLevel
            self.quotaArn = quotaArn
            self.quotaCode = quotaCode
            self.quotaContext = quotaContext
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.unit = unit
            self.usageMetric = usageMetric
            self.value = value
        }
    }

}

extension ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case globalQuota = "GlobalQuota"
        case quotaCode = "QuotaCode"
        case quotaName = "QuotaName"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let desiredValue = self.desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let quotaCode = self.quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaName = self.quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let globalQuotaDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .globalQuota) ?? false
        globalQuota = globalQuotaDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// Information about a quota increase request.
    public struct ServiceQuotaIncreaseRequestInTemplate: Swift.Equatable {
        /// The Amazon Web Services Region.
        public var awsRegion: Swift.String?
        /// The new, increased value of the quota.
        public var desiredValue: Swift.Double?
        /// Indicates whether the quota is global.
        public var globalQuota: Swift.Bool
        /// Specifies the quota identifier. To find the quota code for a specific quota, use the [ListServiceQuotas] operation, and look for the QuotaCode response in the output for the quota you want.
        public var quotaCode: Swift.String?
        /// Specifies the quota name.
        public var quotaName: Swift.String?
        /// Specifies the service identifier. To find the service code value for an Amazon Web Services service, use the [ListServices] operation.
        public var serviceCode: Swift.String?
        /// Specifies the service name.
        public var serviceName: Swift.String?
        /// The unit of measurement.
        public var unit: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            desiredValue: Swift.Double? = nil,
            globalQuota: Swift.Bool = false,
            quotaCode: Swift.String? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.desiredValue = desiredValue
            self.globalQuota = globalQuota
            self.quotaCode = quotaCode
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.unit = unit
        }
    }

}

extension ServiceQuotasClientTypes {
    public enum ServiceQuotaTemplateAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case disassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaTemplateAssociationStatus] {
            return [
                .associated,
                .disassociated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .disassociated: return "DISASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaTemplateAssociationStatus(rawValue: rawValue) ?? ServiceQuotaTemplateAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaTemplateNotInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaTemplateNotInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The quota request template is not associated with your organization.
public struct ServiceQuotaTemplateNotInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaTemplateNotInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaTemplateNotInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaTemplateNotInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceQuotasClientTypes {
    /// A complex data type that contains a tag key and tag value.
    public struct Tag: Swift.Equatable {
        /// A string that contains a tag key. The string length should be between 1 and 128 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains an optional tag value. The string length should be between 0 and 256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagPolicyViolationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagPolicyViolationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified tag is a reserved word and cannot be used.
public struct TagPolicyViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicyViolationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagPolicyViolationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagPolicyViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the applied quota. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags that you want to add to the resource.
    /// This member is required.
    public var tags: [ServiceQuotasClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ServiceQuotasClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ServiceQuotasClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceQuotasClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceQuotasClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagPolicyViolationException": return try await TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension TemplatesNotAvailableInRegionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TemplatesNotAvailableInRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Service Quotas template is not available in this Amazon Web Services Region.
public struct TemplatesNotAvailableInRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TemplatesNotAvailableInRegionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TemplatesNotAvailableInRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TemplatesNotAvailableInRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've exceeded the number of tags allowed for a resource. For more information, see [Tag restrictions](https://docs.aws.amazon.com/servicequotas/latest/userguide/sq-tagging.html#sq-tagging-restrictions) in the Service Quotas User Guide.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the applied quota that you want to untag. You can get this information by using the Service Quotas console, or by listing the quotas using the [list-service-quotas](https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html) CLI command or the [ListServiceQuotas](https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html) Amazon Web Services API operation.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

public enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchResourceException": return try await NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() { }
}
