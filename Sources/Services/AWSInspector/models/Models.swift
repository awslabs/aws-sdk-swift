// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension InspectorClientTypes {
    public enum AccessDeniedErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDeniedToAssessmentRun
        case accessDeniedToAssessmentTarget
        case accessDeniedToAssessmentTemplate
        case accessDeniedToFinding
        case accessDeniedToIamRole
        case accessDeniedToResourceGroup
        case accessDeniedToRulesPackage
        case accessDeniedToSnsTopic
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedErrorCode] {
            return [
                .accessDeniedToAssessmentRun,
                .accessDeniedToAssessmentTarget,
                .accessDeniedToAssessmentTemplate,
                .accessDeniedToFinding,
                .accessDeniedToIamRole,
                .accessDeniedToResourceGroup,
                .accessDeniedToRulesPackage,
                .accessDeniedToSnsTopic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDeniedToAssessmentRun: return "ACCESS_DENIED_TO_ASSESSMENT_RUN"
            case .accessDeniedToAssessmentTarget: return "ACCESS_DENIED_TO_ASSESSMENT_TARGET"
            case .accessDeniedToAssessmentTemplate: return "ACCESS_DENIED_TO_ASSESSMENT_TEMPLATE"
            case .accessDeniedToFinding: return "ACCESS_DENIED_TO_FINDING"
            case .accessDeniedToIamRole: return "ACCESS_DENIED_TO_IAM_ROLE"
            case .accessDeniedToResourceGroup: return "ACCESS_DENIED_TO_RESOURCE_GROUP"
            case .accessDeniedToRulesPackage: return "ACCESS_DENIED_TO_RULES_PACKAGE"
            case .accessDeniedToSnsTopic: return "ACCESS_DENIED_TO_SNS_TOPIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessDeniedErrorCode(rawValue: rawValue) ?? AccessDeniedErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.canRetry = output.canRetry
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.canRetry = nil
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have required permissions to access the requested resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Code that indicates the type of error that is generated.
        /// This member is required.
        public internal(set) var errorCode: InspectorClientTypes.AccessDeniedErrorCode? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.AccessDeniedErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let errorCode: InspectorClientTypes.AccessDeniedErrorCode?
    let canRetry: Swift.Bool?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AccessDeniedErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension AddAttributesToFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case findingArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attribute0 in attributes {
                try attributesContainer.encode(attribute0)
            }
        }
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for arn0 in findingArns {
                try findingArnsContainer.encode(arn0)
            }
        }
    }
}

extension AddAttributesToFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddAttributesToFindingsInput: Swift.Equatable {
    /// The array of attributes that you want to assign to specified findings.
    /// This member is required.
    public var attributes: [InspectorClientTypes.Attribute]?
    /// The ARNs that specify the findings that you want to assign attributes to.
    /// This member is required.
    public var findingArns: [Swift.String]?

    public init(
        attributes: [InspectorClientTypes.Attribute]? = nil,
        findingArns: [Swift.String]? = nil
    )
    {
        self.attributes = attributes
        self.findingArns = findingArns
    }
}

struct AddAttributesToFindingsInputBody: Swift.Equatable {
    let findingArns: [Swift.String]?
    let attributes: [InspectorClientTypes.Attribute]?
}

extension AddAttributesToFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case findingArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[Swift.String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [Swift.String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension AddAttributesToFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddAttributesToFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
        } else {
            self.failedItems = nil
        }
    }
}

public struct AddAttributesToFindingsOutput: Swift.Equatable {
    /// Attribute details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init(
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.failedItems = failedItems
    }
}

struct AddAttributesToFindingsOutputBody: Swift.Equatable {
    let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension AddAttributesToFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

enum AddAttributesToFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InspectorClientTypes.AgentAlreadyRunningAssessment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case assessmentRunArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let assessmentRunArn = self.assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

extension InspectorClientTypes {
    /// Used in the exception error that is thrown if you start an assessment run for an assessment target that includes an EC2 instance that is already participating in another started assessment run.
    public struct AgentAlreadyRunningAssessment: Swift.Equatable {
        /// ID of the agent that is running on an EC2 instance that is already participating in another started assessment run.
        /// This member is required.
        public var agentId: Swift.String?
        /// The ARN of the assessment run that has already been started.
        /// This member is required.
        public var assessmentRunArn: Swift.String?

        public init(
            agentId: Swift.String? = nil,
            assessmentRunArn: Swift.String? = nil
        )
        {
            self.agentId = agentId
            self.assessmentRunArn = assessmentRunArn
        }
    }

}

extension InspectorClientTypes.AgentFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentHealthCodes
        case agentHealths
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentHealthCodes = agentHealthCodes {
            var agentHealthCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentHealthCodes)
            for agenthealthcode0 in agentHealthCodes {
                try agentHealthCodesContainer.encode(agenthealthcode0.rawValue)
            }
        }
        if let agentHealths = agentHealths {
            var agentHealthsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentHealths)
            for agenthealth0 in agentHealths {
                try agentHealthsContainer.encode(agenthealth0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentHealthsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AgentHealth?].self, forKey: .agentHealths)
        var agentHealthsDecoded0:[InspectorClientTypes.AgentHealth]? = nil
        if let agentHealthsContainer = agentHealthsContainer {
            agentHealthsDecoded0 = [InspectorClientTypes.AgentHealth]()
            for enum0 in agentHealthsContainer {
                if let enum0 = enum0 {
                    agentHealthsDecoded0?.append(enum0)
                }
            }
        }
        agentHealths = agentHealthsDecoded0
        let agentHealthCodesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AgentHealthCode?].self, forKey: .agentHealthCodes)
        var agentHealthCodesDecoded0:[InspectorClientTypes.AgentHealthCode]? = nil
        if let agentHealthCodesContainer = agentHealthCodesContainer {
            agentHealthCodesDecoded0 = [InspectorClientTypes.AgentHealthCode]()
            for enum0 in agentHealthCodesContainer {
                if let enum0 = enum0 {
                    agentHealthCodesDecoded0?.append(enum0)
                }
            }
        }
        agentHealthCodes = agentHealthCodesDecoded0
    }
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector agent. This data type is used as a request parameter in the [ListAssessmentRunAgents] action.
    public struct AgentFilter: Swift.Equatable {
        /// The detailed health state of the agent. Values can be set to IDLE, RUNNING, SHUTDOWN, UNHEALTHY, THROTTLED, and UNKNOWN.
        /// This member is required.
        public var agentHealthCodes: [InspectorClientTypes.AgentHealthCode]?
        /// The current health state of the agent. Values can be set to HEALTHY or UNHEALTHY.
        /// This member is required.
        public var agentHealths: [InspectorClientTypes.AgentHealth]?

        public init(
            agentHealthCodes: [InspectorClientTypes.AgentHealthCode]? = nil,
            agentHealths: [InspectorClientTypes.AgentHealth]? = nil
        )
        {
            self.agentHealthCodes = agentHealthCodes
            self.agentHealths = agentHealths
        }
    }

}

extension InspectorClientTypes {
    public enum AgentHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentHealth] {
            return [
                .healthy,
                .unhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentHealth(rawValue: rawValue) ?? AgentHealth.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes {
    public enum AgentHealthCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case idle
        case running
        case shutdown
        case throttled
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentHealthCode] {
            return [
                .idle,
                .running,
                .shutdown,
                .throttled,
                .unhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .idle: return "IDLE"
            case .running: return "RUNNING"
            case .shutdown: return "SHUTDOWN"
            case .throttled: return "THROTTLED"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentHealthCode(rawValue: rawValue) ?? AgentHealthCode.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.AgentPreview: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentHealth
        case agentId
        case agentVersion
        case autoScalingGroup
        case hostname
        case ipv4Address
        case kernelVersion
        case operatingSystem
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentHealth = self.agentHealth {
            try encodeContainer.encode(agentHealth.rawValue, forKey: .agentHealth)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let autoScalingGroup = self.autoScalingGroup {
            try encodeContainer.encode(autoScalingGroup, forKey: .autoScalingGroup)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let ipv4Address = self.ipv4Address {
            try encodeContainer.encode(ipv4Address, forKey: .ipv4Address)
        }
        if let kernelVersion = self.kernelVersion {
            try encodeContainer.encode(kernelVersion, forKey: .kernelVersion)
        }
        if let operatingSystem = self.operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let autoScalingGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingGroup)
        autoScalingGroup = autoScalingGroupDecoded
        let agentHealthDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AgentHealth.self, forKey: .agentHealth)
        agentHealth = agentHealthDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let kernelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kernelVersion)
        kernelVersion = kernelVersionDecoded
        let ipv4AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv4Address)
        ipv4Address = ipv4AddressDecoded
    }
}

extension InspectorClientTypes {
    /// Used as a response element in the [PreviewAgents] action.
    public struct AgentPreview: Swift.Equatable {
        /// The health status of the Amazon Inspector Agent.
        public var agentHealth: InspectorClientTypes.AgentHealth?
        /// The ID of the EC2 instance where the agent is installed.
        /// This member is required.
        public var agentId: Swift.String?
        /// The version of the Amazon Inspector Agent.
        public var agentVersion: Swift.String?
        /// The Auto Scaling group for the EC2 instance where the agent is installed.
        public var autoScalingGroup: Swift.String?
        /// The hostname of the EC2 instance on which the Amazon Inspector Agent is installed.
        public var hostname: Swift.String?
        /// The IP address of the EC2 instance on which the Amazon Inspector Agent is installed.
        public var ipv4Address: Swift.String?
        /// The kernel version of the operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.
        public var kernelVersion: Swift.String?
        /// The operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.
        public var operatingSystem: Swift.String?

        public init(
            agentHealth: InspectorClientTypes.AgentHealth? = nil,
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            autoScalingGroup: Swift.String? = nil,
            hostname: Swift.String? = nil,
            ipv4Address: Swift.String? = nil,
            kernelVersion: Swift.String? = nil,
            operatingSystem: Swift.String? = nil
        )
        {
            self.agentHealth = agentHealth
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.autoScalingGroup = autoScalingGroup
            self.hostname = hostname
            self.ipv4Address = ipv4Address
            self.kernelVersion = kernelVersion
            self.operatingSystem = operatingSystem
        }
    }

}

extension AgentsAlreadyRunningAssessmentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AgentsAlreadyRunningAssessmentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.agents = output.agents
            self.properties.agentsTruncated = output.agentsTruncated
            self.properties.canRetry = output.canRetry
            self.properties.message = output.message
        } else {
            self.properties.agents = nil
            self.properties.agentsTruncated = nil
            self.properties.canRetry = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You started an assessment run, but one of the instances is already participating in another assessment run.
public struct AgentsAlreadyRunningAssessmentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        /// This member is required.
        public internal(set) var agents: [InspectorClientTypes.AgentAlreadyRunningAssessment]? = nil
        ///
        /// This member is required.
        public internal(set) var agentsTruncated: Swift.Bool? = nil
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AgentsAlreadyRunningAssessmentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        agents: [InspectorClientTypes.AgentAlreadyRunningAssessment]? = nil,
        agentsTruncated: Swift.Bool? = nil,
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.agents = agents
        self.properties.agentsTruncated = agentsTruncated
        self.properties.canRetry = canRetry
        self.properties.message = message
    }
}

struct AgentsAlreadyRunningAssessmentExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let agents: [InspectorClientTypes.AgentAlreadyRunningAssessment]?
    let agentsTruncated: Swift.Bool?
    let canRetry: Swift.Bool?
}

extension AgentsAlreadyRunningAssessmentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agents
        case agentsTruncated
        case canRetry
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let agentsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AgentAlreadyRunningAssessment?].self, forKey: .agents)
        var agentsDecoded0:[InspectorClientTypes.AgentAlreadyRunningAssessment]? = nil
        if let agentsContainer = agentsContainer {
            agentsDecoded0 = [InspectorClientTypes.AgentAlreadyRunningAssessment]()
            for structure0 in agentsContainer {
                if let structure0 = structure0 {
                    agentsDecoded0?.append(structure0)
                }
            }
        }
        agents = agentsDecoded0
        let agentsTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .agentsTruncated)
        agentsTruncated = agentsTruncatedDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension InspectorClientTypes.AssessmentRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assessmentTemplateArn
        case completedAt
        case createdAt
        case dataCollected
        case durationInSeconds
        case findingCounts
        case name
        case notifications
        case rulesPackageArns
        case startedAt
        case state
        case stateChangedAt
        case stateChanges
        case userAttributesForFindings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assessmentTemplateArn = self.assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
        if let completedAt = self.completedAt {
            try encodeContainer.encodeTimestamp(completedAt, format: .epochSeconds, forKey: .completedAt)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let dataCollected = self.dataCollected {
            try encodeContainer.encode(dataCollected, forKey: .dataCollected)
        }
        if durationInSeconds != 0 {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let findingCounts = findingCounts {
            var findingCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .findingCounts)
            for (dictKey0, assessmentRunFindingCounts0) in findingCounts {
                try findingCountsContainer.encode(assessmentRunFindingCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for assessmentrunnotification0 in notifications {
                try notificationsContainer.encode(assessmentrunnotification0)
            }
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for arn0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(arn0)
            }
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangedAt = self.stateChangedAt {
            try encodeContainer.encodeTimestamp(stateChangedAt, format: .epochSeconds, forKey: .stateChangedAt)
        }
        if let stateChanges = stateChanges {
            var stateChangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stateChanges)
            for assessmentrunstatechange0 in stateChanges {
                try stateChangesContainer.encode(assessmentrunstatechange0)
            }
        }
        if let userAttributesForFindings = userAttributesForFindings {
            var userAttributesForFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributesForFindings)
            for attribute0 in userAttributesForFindings {
                try userAttributesForFindingsContainer.encode(attribute0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentRunState.self, forKey: .state)
        state = stateDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds) ?? 0
        durationInSeconds = durationInSecondsDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let userAttributesForFindingsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .userAttributesForFindings)
        var userAttributesForFindingsDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let userAttributesForFindingsContainer = userAttributesForFindingsContainer {
            userAttributesForFindingsDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in userAttributesForFindingsContainer {
                if let structure0 = structure0 {
                    userAttributesForFindingsDecoded0?.append(structure0)
                }
            }
        }
        userAttributesForFindings = userAttributesForFindingsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedAt)
        completedAt = completedAtDecoded
        let stateChangedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stateChangedAt)
        stateChangedAt = stateChangedAtDecoded
        let dataCollectedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataCollected)
        dataCollected = dataCollectedDecoded
        let stateChangesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentRunStateChange?].self, forKey: .stateChanges)
        var stateChangesDecoded0:[InspectorClientTypes.AssessmentRunStateChange]? = nil
        if let stateChangesContainer = stateChangesContainer {
            stateChangesDecoded0 = [InspectorClientTypes.AssessmentRunStateChange]()
            for structure0 in stateChangesContainer {
                if let structure0 = structure0 {
                    stateChangesDecoded0?.append(structure0)
                }
            }
        }
        stateChanges = stateChangesDecoded0
        let notificationsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentRunNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[InspectorClientTypes.AssessmentRunNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [InspectorClientTypes.AssessmentRunNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let findingCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .findingCounts)
        var findingCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let findingCountsContainer = findingCountsContainer {
            findingCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, findingcount0) in findingCountsContainer {
                if let findingcount0 = findingcount0 {
                    findingCountsDecoded0?[key0] = findingcount0
                }
            }
        }
        findingCounts = findingCountsDecoded0
    }
}

extension InspectorClientTypes {
    /// A snapshot of an Amazon Inspector assessment run that contains the findings of the assessment run . Used as the response element in the [DescribeAssessmentRuns] action.
    public struct AssessmentRun: Swift.Equatable {
        /// The ARN of the assessment run.
        /// This member is required.
        public var arn: Swift.String?
        /// The ARN of the assessment template that is associated with the assessment run.
        /// This member is required.
        public var assessmentTemplateArn: Swift.String?
        /// The assessment run completion time that corresponds to the rules packages evaluation completion time or failure.
        public var completedAt: ClientRuntime.Date?
        /// The time when [StartAssessmentRun] was called.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A Boolean value (true or false) that specifies whether the process of collecting data from the agents is completed.
        /// This member is required.
        public var dataCollected: Swift.Bool?
        /// The duration of the assessment run.
        /// This member is required.
        public var durationInSeconds: Swift.Int
        /// Provides a total count of generated findings per severity.
        /// This member is required.
        public var findingCounts: [Swift.String:Swift.Int]?
        /// The auto-generated name for the assessment run.
        /// This member is required.
        public var name: Swift.String?
        /// A list of notifications for the event subscriptions. A notification about a particular generated finding is added to this list only once.
        /// This member is required.
        public var notifications: [InspectorClientTypes.AssessmentRunNotification]?
        /// The rules packages selected for the assessment run.
        /// This member is required.
        public var rulesPackageArns: [Swift.String]?
        /// The time when [StartAssessmentRun] was called.
        public var startedAt: ClientRuntime.Date?
        /// The state of the assessment run.
        /// This member is required.
        public var state: InspectorClientTypes.AssessmentRunState?
        /// The last time when the assessment run's state changed.
        /// This member is required.
        public var stateChangedAt: ClientRuntime.Date?
        /// A list of the assessment run state changes.
        /// This member is required.
        public var stateChanges: [InspectorClientTypes.AssessmentRunStateChange]?
        /// The user-defined attributes that are assigned to every generated finding.
        /// This member is required.
        public var userAttributesForFindings: [InspectorClientTypes.Attribute]?

        public init(
            arn: Swift.String? = nil,
            assessmentTemplateArn: Swift.String? = nil,
            completedAt: ClientRuntime.Date? = nil,
            createdAt: ClientRuntime.Date? = nil,
            dataCollected: Swift.Bool? = nil,
            durationInSeconds: Swift.Int = 0,
            findingCounts: [Swift.String:Swift.Int]? = nil,
            name: Swift.String? = nil,
            notifications: [InspectorClientTypes.AssessmentRunNotification]? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            startedAt: ClientRuntime.Date? = nil,
            state: InspectorClientTypes.AssessmentRunState? = nil,
            stateChangedAt: ClientRuntime.Date? = nil,
            stateChanges: [InspectorClientTypes.AssessmentRunStateChange]? = nil,
            userAttributesForFindings: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.arn = arn
            self.assessmentTemplateArn = assessmentTemplateArn
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.dataCollected = dataCollected
            self.durationInSeconds = durationInSeconds
            self.findingCounts = findingCounts
            self.name = name
            self.notifications = notifications
            self.rulesPackageArns = rulesPackageArns
            self.startedAt = startedAt
            self.state = state
            self.stateChangedAt = stateChangedAt
            self.stateChanges = stateChanges
            self.userAttributesForFindings = userAttributesForFindings
        }
    }

}

extension InspectorClientTypes.AssessmentRunAgent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentHealth
        case agentHealthCode
        case agentHealthDetails
        case agentId
        case assessmentRunArn
        case autoScalingGroup
        case telemetryMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentHealth = self.agentHealth {
            try encodeContainer.encode(agentHealth.rawValue, forKey: .agentHealth)
        }
        if let agentHealthCode = self.agentHealthCode {
            try encodeContainer.encode(agentHealthCode.rawValue, forKey: .agentHealthCode)
        }
        if let agentHealthDetails = self.agentHealthDetails {
            try encodeContainer.encode(agentHealthDetails, forKey: .agentHealthDetails)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let assessmentRunArn = self.assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let autoScalingGroup = self.autoScalingGroup {
            try encodeContainer.encode(autoScalingGroup, forKey: .autoScalingGroup)
        }
        if let telemetryMetadata = telemetryMetadata {
            var telemetryMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .telemetryMetadata)
            for telemetrymetadata0 in telemetryMetadata {
                try telemetryMetadataContainer.encode(telemetrymetadata0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let agentHealthDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AgentHealth.self, forKey: .agentHealth)
        agentHealth = agentHealthDecoded
        let agentHealthCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AgentHealthCode.self, forKey: .agentHealthCode)
        agentHealthCode = agentHealthCodeDecoded
        let agentHealthDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentHealthDetails)
        agentHealthDetails = agentHealthDetailsDecoded
        let autoScalingGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingGroup)
        autoScalingGroup = autoScalingGroupDecoded
        let telemetryMetadataContainer = try containerValues.decodeIfPresent([InspectorClientTypes.TelemetryMetadata?].self, forKey: .telemetryMetadata)
        var telemetryMetadataDecoded0:[InspectorClientTypes.TelemetryMetadata]? = nil
        if let telemetryMetadataContainer = telemetryMetadataContainer {
            telemetryMetadataDecoded0 = [InspectorClientTypes.TelemetryMetadata]()
            for structure0 in telemetryMetadataContainer {
                if let structure0 = structure0 {
                    telemetryMetadataDecoded0?.append(structure0)
                }
            }
        }
        telemetryMetadata = telemetryMetadataDecoded0
    }
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector agent. This data type is used as a response element in the [ListAssessmentRunAgents] action.
    public struct AssessmentRunAgent: Swift.Equatable {
        /// The current health state of the agent.
        /// This member is required.
        public var agentHealth: InspectorClientTypes.AgentHealth?
        /// The detailed health state of the agent.
        /// This member is required.
        public var agentHealthCode: InspectorClientTypes.AgentHealthCode?
        /// The description for the agent health code.
        public var agentHealthDetails: Swift.String?
        /// The AWS account of the EC2 instance where the agent is installed.
        /// This member is required.
        public var agentId: Swift.String?
        /// The ARN of the assessment run that is associated with the agent.
        /// This member is required.
        public var assessmentRunArn: Swift.String?
        /// The Auto Scaling group of the EC2 instance that is specified by the agent ID.
        public var autoScalingGroup: Swift.String?
        /// The Amazon Inspector application data metrics that are collected by the agent.
        /// This member is required.
        public var telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]?

        public init(
            agentHealth: InspectorClientTypes.AgentHealth? = nil,
            agentHealthCode: InspectorClientTypes.AgentHealthCode? = nil,
            agentHealthDetails: Swift.String? = nil,
            agentId: Swift.String? = nil,
            assessmentRunArn: Swift.String? = nil,
            autoScalingGroup: Swift.String? = nil,
            telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]? = nil
        )
        {
            self.agentHealth = agentHealth
            self.agentHealthCode = agentHealthCode
            self.agentHealthDetails = agentHealthDetails
            self.agentId = agentId
            self.assessmentRunArn = assessmentRunArn
            self.autoScalingGroup = autoScalingGroup
            self.telemetryMetadata = telemetryMetadata
        }
    }

}

extension InspectorClientTypes.AssessmentRunFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTimeRange
        case durationRange
        case namePattern
        case rulesPackageArns
        case startTimeRange
        case stateChangeTimeRange
        case states
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTimeRange = self.completionTimeRange {
            try encodeContainer.encode(completionTimeRange, forKey: .completionTimeRange)
        }
        if let durationRange = self.durationRange {
            try encodeContainer.encode(durationRange, forKey: .durationRange)
        }
        if let namePattern = self.namePattern {
            try encodeContainer.encode(namePattern, forKey: .namePattern)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for arn0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(arn0)
            }
        }
        if let startTimeRange = self.startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let stateChangeTimeRange = self.stateChangeTimeRange {
            try encodeContainer.encode(stateChangeTimeRange, forKey: .stateChangeTimeRange)
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for assessmentrunstate0 in states {
                try statesContainer.encode(assessmentrunstate0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePattern)
        namePattern = namePatternDecoded
        let statesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentRunState?].self, forKey: .states)
        var statesDecoded0:[InspectorClientTypes.AssessmentRunState]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [InspectorClientTypes.AssessmentRunState]()
            for enum0 in statesContainer {
                if let enum0 = enum0 {
                    statesDecoded0?.append(enum0)
                }
            }
        }
        states = statesDecoded0
        let durationRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.DurationRange.self, forKey: .durationRange)
        durationRange = durationRangeDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.TimestampRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let completionTimeRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.TimestampRange.self, forKey: .completionTimeRange)
        completionTimeRange = completionTimeRangeDecoded
        let stateChangeTimeRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.TimestampRange.self, forKey: .stateChangeTimeRange)
        stateChangeTimeRange = stateChangeTimeRangeDecoded
    }
}

extension InspectorClientTypes {
    /// Used as the request parameter in the [ListAssessmentRuns] action.
    public struct AssessmentRunFilter: Swift.Equatable {
        /// For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the completedAt property of the [AssessmentRun] data type.
        public var completionTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the durationInSeconds property of the [AssessmentRun] data type.
        public var durationRange: InspectorClientTypes.DurationRange?
        /// For a record to match a filter, an explicit value or a string containing a wildcard that is specified for this data type property must match the value of the assessmentRunName property of the [AssessmentRun] data type.
        public var namePattern: Swift.String?
        /// For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the rulesPackages property of the [AssessmentRun] data type.
        public var rulesPackageArns: [Swift.String]?
        /// For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the startTime property of the [AssessmentRun] data type.
        public var startTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, the value that is specified for this data type property must match the stateChangedAt property of the [AssessmentRun] data type.
        public var stateChangeTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, one of the values specified for this data type property must be the exact match of the value of the assessmentRunState property of the [AssessmentRun] data type.
        public var states: [InspectorClientTypes.AssessmentRunState]?

        public init(
            completionTimeRange: InspectorClientTypes.TimestampRange? = nil,
            durationRange: InspectorClientTypes.DurationRange? = nil,
            namePattern: Swift.String? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            startTimeRange: InspectorClientTypes.TimestampRange? = nil,
            stateChangeTimeRange: InspectorClientTypes.TimestampRange? = nil,
            states: [InspectorClientTypes.AssessmentRunState]? = nil
        )
        {
            self.completionTimeRange = completionTimeRange
            self.durationRange = durationRange
            self.namePattern = namePattern
            self.rulesPackageArns = rulesPackageArns
            self.startTimeRange = startTimeRange
            self.stateChangeTimeRange = stateChangeTimeRange
            self.states = states
        }
    }

}

extension AssessmentRunInProgressException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssessmentRunInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.assessmentRunArns = output.assessmentRunArns
            self.properties.assessmentRunArnsTruncated = output.assessmentRunArnsTruncated
            self.properties.canRetry = output.canRetry
            self.properties.message = output.message
        } else {
            self.properties.assessmentRunArns = nil
            self.properties.assessmentRunArnsTruncated = nil
            self.properties.canRetry = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot perform a specified action if an assessment run is currently in progress.
public struct AssessmentRunInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The ARNs of the assessment runs that are currently in progress.
        /// This member is required.
        public internal(set) var assessmentRunArns: [Swift.String]? = nil
        /// Boolean value that indicates whether the ARN list of the assessment runs is truncated.
        /// This member is required.
        public internal(set) var assessmentRunArnsTruncated: Swift.Bool? = nil
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AssessmentRunInProgressException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        assessmentRunArns: [Swift.String]? = nil,
        assessmentRunArnsTruncated: Swift.Bool? = nil,
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.assessmentRunArns = assessmentRunArns
        self.properties.assessmentRunArnsTruncated = assessmentRunArnsTruncated
        self.properties.canRetry = canRetry
        self.properties.message = message
    }
}

struct AssessmentRunInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let assessmentRunArns: [Swift.String]?
    let assessmentRunArnsTruncated: Swift.Bool?
    let canRetry: Swift.Bool?
}

extension AssessmentRunInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
        case assessmentRunArnsTruncated
        case canRetry
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[Swift.String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [Swift.String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
        let assessmentRunArnsTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assessmentRunArnsTruncated)
        assessmentRunArnsTruncated = assessmentRunArnsTruncatedDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension InspectorClientTypes.AssessmentRunNotification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date
        case error
        case event
        case message
        case snsPublishStatusCode
        case snsTopicArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .epochSeconds, forKey: .date)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let snsPublishStatusCode = self.snsPublishStatusCode {
            try encodeContainer.encode(snsPublishStatusCode.rawValue, forKey: .snsPublishStatusCode)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .date)
        date = dateDecoded
        let eventDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .error)
        error = errorDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsPublishStatusCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentRunNotificationSnsStatusCode.self, forKey: .snsPublishStatusCode)
        snsPublishStatusCode = snsPublishStatusCodeDecoded
    }
}

extension InspectorClientTypes {
    /// Used as one of the elements of the [AssessmentRun] data type.
    public struct AssessmentRunNotification: Swift.Equatable {
        /// The date of the notification.
        /// This member is required.
        public var date: ClientRuntime.Date?
        /// The Boolean value that specifies whether the notification represents an error.
        /// This member is required.
        public var error: Swift.Bool?
        /// The event for which a notification is sent.
        /// This member is required.
        public var event: InspectorClientTypes.InspectorEvent?
        /// The message included in the notification.
        public var message: Swift.String?
        /// The status code of the SNS notification.
        public var snsPublishStatusCode: InspectorClientTypes.AssessmentRunNotificationSnsStatusCode?
        /// The SNS topic to which the SNS notification is sent.
        public var snsTopicArn: Swift.String?

        public init(
            date: ClientRuntime.Date? = nil,
            error: Swift.Bool? = nil,
            event: InspectorClientTypes.InspectorEvent? = nil,
            message: Swift.String? = nil,
            snsPublishStatusCode: InspectorClientTypes.AssessmentRunNotificationSnsStatusCode? = nil,
            snsTopicArn: Swift.String? = nil
        )
        {
            self.date = date
            self.error = error
            self.event = event
            self.message = message
            self.snsPublishStatusCode = snsPublishStatusCode
            self.snsTopicArn = snsTopicArn
        }
    }

}

extension InspectorClientTypes {
    public enum AssessmentRunNotificationSnsStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalError
        case success
        case topicDoesNotExist
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentRunNotificationSnsStatusCode] {
            return [
                .accessDenied,
                .internalError,
                .success,
                .topicDoesNotExist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalError: return "INTERNAL_ERROR"
            case .success: return "SUCCESS"
            case .topicDoesNotExist: return "TOPIC_DOES_NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentRunNotificationSnsStatusCode(rawValue: rawValue) ?? AssessmentRunNotificationSnsStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes {
    public enum AssessmentRunState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case collectingData
        case completed
        case completedWithErrors
        case created
        case dataCollected
        case error
        case evaluatingRules
        case failed
        case startDataCollectionInProgress
        case startDataCollectionPending
        case startEvaluatingRulesPending
        case stopDataCollectionPending
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentRunState] {
            return [
                .canceled,
                .collectingData,
                .completed,
                .completedWithErrors,
                .created,
                .dataCollected,
                .error,
                .evaluatingRules,
                .failed,
                .startDataCollectionInProgress,
                .startDataCollectionPending,
                .startEvaluatingRulesPending,
                .stopDataCollectionPending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .collectingData: return "COLLECTING_DATA"
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .created: return "CREATED"
            case .dataCollected: return "DATA_COLLECTED"
            case .error: return "ERROR"
            case .evaluatingRules: return "EVALUATING_RULES"
            case .failed: return "FAILED"
            case .startDataCollectionInProgress: return "START_DATA_COLLECTION_IN_PROGRESS"
            case .startDataCollectionPending: return "START_DATA_COLLECTION_PENDING"
            case .startEvaluatingRulesPending: return "START_EVALUATING_RULES_PENDING"
            case .stopDataCollectionPending: return "STOP_DATA_COLLECTION_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentRunState(rawValue: rawValue) ?? AssessmentRunState.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.AssessmentRunStateChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
        case stateChangedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangedAt = self.stateChangedAt {
            try encodeContainer.encodeTimestamp(stateChangedAt, format: .epochSeconds, forKey: .stateChangedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateChangedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stateChangedAt)
        stateChangedAt = stateChangedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentRunState.self, forKey: .state)
        state = stateDecoded
    }
}

extension InspectorClientTypes {
    /// Used as one of the elements of the [AssessmentRun] data type.
    public struct AssessmentRunStateChange: Swift.Equatable {
        /// The assessment run state.
        /// This member is required.
        public var state: InspectorClientTypes.AssessmentRunState?
        /// The last time the assessment run state changed.
        /// This member is required.
        public var stateChangedAt: ClientRuntime.Date?

        public init(
            state: InspectorClientTypes.AssessmentRunState? = nil,
            stateChangedAt: ClientRuntime.Date? = nil
        )
        {
            self.state = state
            self.stateChangedAt = stateChangedAt
        }
    }

}

extension InspectorClientTypes.AssessmentTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case name
        case resourceGroupArn
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceGroupArn = self.resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector application. This data type is used as the response element in the [DescribeAssessmentTargets] action.
    public struct AssessmentTarget: Swift.Equatable {
        /// The ARN that specifies the Amazon Inspector assessment target.
        /// This member is required.
        public var arn: Swift.String?
        /// The time at which the assessment target is created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the Amazon Inspector assessment target.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN that specifies the resource group that is associated with the assessment target.
        public var resourceGroupArn: Swift.String?
        /// The time at which [UpdateAssessmentTarget] is called.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceGroupArn: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.resourceGroupArn = resourceGroupArn
            self.updatedAt = updatedAt
        }
    }

}

extension InspectorClientTypes.AssessmentTargetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetNamePattern
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetNamePattern = self.assessmentTargetNamePattern {
            try encodeContainer.encode(assessmentTargetNamePattern, forKey: .assessmentTargetNamePattern)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetNamePatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetNamePattern)
        assessmentTargetNamePattern = assessmentTargetNamePatternDecoded
    }
}

extension InspectorClientTypes {
    /// Used as the request parameter in the [ListAssessmentTargets] action.
    public struct AssessmentTargetFilter: Swift.Equatable {
        /// For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the assessmentTargetName property of the [AssessmentTarget] data type.
        public var assessmentTargetNamePattern: Swift.String?

        public init(
            assessmentTargetNamePattern: Swift.String? = nil
        )
        {
            self.assessmentTargetNamePattern = assessmentTargetNamePattern
        }
    }

}

extension InspectorClientTypes.AssessmentTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assessmentRunCount
        case assessmentTargetArn
        case createdAt
        case durationInSeconds
        case lastAssessmentRunArn
        case name
        case rulesPackageArns
        case userAttributesForFindings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assessmentRunCount = self.assessmentRunCount {
            try encodeContainer.encode(assessmentRunCount, forKey: .assessmentRunCount)
        }
        if let assessmentTargetArn = self.assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if durationInSeconds != 0 {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let lastAssessmentRunArn = self.lastAssessmentRunArn {
            try encodeContainer.encode(lastAssessmentRunArn, forKey: .lastAssessmentRunArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for arn0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(arn0)
            }
        }
        if let userAttributesForFindings = userAttributesForFindings {
            var userAttributesForFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributesForFindings)
            for attribute0 in userAttributesForFindings {
                try userAttributesForFindingsContainer.encode(attribute0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds) ?? 0
        durationInSeconds = durationInSecondsDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let userAttributesForFindingsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .userAttributesForFindings)
        var userAttributesForFindingsDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let userAttributesForFindingsContainer = userAttributesForFindingsContainer {
            userAttributesForFindingsDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in userAttributesForFindingsContainer {
                if let structure0 = structure0 {
                    userAttributesForFindingsDecoded0?.append(structure0)
                }
            }
        }
        userAttributesForFindings = userAttributesForFindingsDecoded0
        let lastAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAssessmentRunArn)
        lastAssessmentRunArn = lastAssessmentRunArnDecoded
        let assessmentRunCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assessmentRunCount)
        assessmentRunCount = assessmentRunCountDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector assessment template. This data type is used as the response element in the [DescribeAssessmentTemplates] action.
    public struct AssessmentTemplate: Swift.Equatable {
        /// The ARN of the assessment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The number of existing assessment runs associated with this assessment template. This value can be zero or a positive integer.
        /// This member is required.
        public var assessmentRunCount: Swift.Int?
        /// The ARN of the assessment target that corresponds to this assessment template.
        /// This member is required.
        public var assessmentTargetArn: Swift.String?
        /// The time at which the assessment template is created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The duration in seconds specified for this assessment template. The default value is 3600 seconds (one hour). The maximum value is 86400 seconds (one day).
        /// This member is required.
        public var durationInSeconds: Swift.Int
        /// The Amazon Resource Name (ARN) of the most recent assessment run associated with this assessment template. This value exists only when the value of assessmentRunCount is greaterpa than zero.
        public var lastAssessmentRunArn: Swift.String?
        /// The name of the assessment template.
        /// This member is required.
        public var name: Swift.String?
        /// The rules packages that are specified for this assessment template.
        /// This member is required.
        public var rulesPackageArns: [Swift.String]?
        /// The user-defined attributes that are assigned to every generated finding from the assessment run that uses this assessment template.
        /// This member is required.
        public var userAttributesForFindings: [InspectorClientTypes.Attribute]?

        public init(
            arn: Swift.String? = nil,
            assessmentRunCount: Swift.Int? = nil,
            assessmentTargetArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            durationInSeconds: Swift.Int = 0,
            lastAssessmentRunArn: Swift.String? = nil,
            name: Swift.String? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            userAttributesForFindings: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.arn = arn
            self.assessmentRunCount = assessmentRunCount
            self.assessmentTargetArn = assessmentTargetArn
            self.createdAt = createdAt
            self.durationInSeconds = durationInSeconds
            self.lastAssessmentRunArn = lastAssessmentRunArn
            self.name = name
            self.rulesPackageArns = rulesPackageArns
            self.userAttributesForFindings = userAttributesForFindings
        }
    }

}

extension InspectorClientTypes.AssessmentTemplateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationRange
        case namePattern
        case rulesPackageArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationRange = self.durationRange {
            try encodeContainer.encode(durationRange, forKey: .durationRange)
        }
        if let namePattern = self.namePattern {
            try encodeContainer.encode(namePattern, forKey: .namePattern)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for arn0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(arn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePattern)
        namePattern = namePatternDecoded
        let durationRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.DurationRange.self, forKey: .durationRange)
        durationRange = durationRangeDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
    }
}

extension InspectorClientTypes {
    /// Used as the request parameter in the [ListAssessmentTemplates] action.
    public struct AssessmentTemplateFilter: Swift.Equatable {
        /// For a record to match a filter, the value specified for this data type property must inclusively match any value between the specified minimum and maximum values of the durationInSeconds property of the [AssessmentTemplate] data type.
        public var durationRange: InspectorClientTypes.DurationRange?
        /// For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the assessmentTemplateName property of the [AssessmentTemplate] data type.
        public var namePattern: Swift.String?
        /// For a record to match a filter, the values that are specified for this data type property must be contained in the list of values of the rulesPackageArns property of the [AssessmentTemplate] data type.
        public var rulesPackageArns: [Swift.String]?

        public init(
            durationRange: InspectorClientTypes.DurationRange? = nil,
            namePattern: Swift.String? = nil,
            rulesPackageArns: [Swift.String]? = nil
        )
        {
            self.durationRange = durationRange
            self.namePattern = namePattern
            self.rulesPackageArns = rulesPackageArns
        }
    }

}

extension InspectorClientTypes.AssetAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case amiId
        case autoScalingGroup
        case hostname
        case ipv4Addresses
        case networkInterfaces
        case schemaVersion
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let autoScalingGroup = self.autoScalingGroup {
            try encodeContainer.encode(autoScalingGroup, forKey: .autoScalingGroup)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let ipv4Addresses = ipv4Addresses {
            var ipv4AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv4Addresses)
            for ipv4address0 in ipv4Addresses {
                try ipv4AddressesContainer.encode(ipv4address0)
            }
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if schemaVersion != 0 {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .schemaVersion) ?? 0
        schemaVersion = schemaVersionDecoded
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let autoScalingGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingGroup)
        autoScalingGroup = autoScalingGroupDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let ipv4AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipv4Addresses)
        var ipv4AddressesDecoded0:[Swift.String]? = nil
        if let ipv4AddressesContainer = ipv4AddressesContainer {
            ipv4AddressesDecoded0 = [Swift.String]()
            for string0 in ipv4AddressesContainer {
                if let string0 = string0 {
                    ipv4AddressesDecoded0?.append(string0)
                }
            }
        }
        ipv4Addresses = ipv4AddressesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[InspectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [InspectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let networkInterfacesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[InspectorClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [InspectorClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
    }
}

extension InspectorClientTypes {
    /// A collection of attributes of the host from which the finding is generated.
    public struct AssetAttributes: Swift.Equatable {
        /// The ID of the agent that is installed on the EC2 instance where the finding is generated.
        public var agentId: Swift.String?
        /// The ID of the Amazon Machine Image (AMI) that is installed on the EC2 instance where the finding is generated.
        public var amiId: Swift.String?
        /// The Auto Scaling group of the EC2 instance where the finding is generated.
        public var autoScalingGroup: Swift.String?
        /// The hostname of the EC2 instance where the finding is generated.
        public var hostname: Swift.String?
        /// The list of IP v4 addresses of the EC2 instance where the finding is generated.
        public var ipv4Addresses: [Swift.String]?
        /// An array of the network interfaces interacting with the EC2 instance where the finding is generated.
        public var networkInterfaces: [InspectorClientTypes.NetworkInterface]?
        /// The schema version of this data type.
        /// This member is required.
        public var schemaVersion: Swift.Int
        /// The tags related to the EC2 instance where the finding is generated.
        public var tags: [InspectorClientTypes.Tag]?

        public init(
            agentId: Swift.String? = nil,
            amiId: Swift.String? = nil,
            autoScalingGroup: Swift.String? = nil,
            hostname: Swift.String? = nil,
            ipv4Addresses: [Swift.String]? = nil,
            networkInterfaces: [InspectorClientTypes.NetworkInterface]? = nil,
            schemaVersion: Swift.Int = 0,
            tags: [InspectorClientTypes.Tag]? = nil
        )
        {
            self.agentId = agentId
            self.amiId = amiId
            self.autoScalingGroup = autoScalingGroup
            self.hostname = hostname
            self.ipv4Addresses = ipv4Addresses
            self.networkInterfaces = networkInterfaces
            self.schemaVersion = schemaVersion
            self.tags = tags
        }
    }

}

extension InspectorClientTypes {
    public enum AssetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2Instance
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetType] {
            return [
                .ec2Instance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2Instance: return "ec2-instance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetType(rawValue: rawValue) ?? AssetType.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension InspectorClientTypes {
    /// This data type is used as a request parameter in the [AddAttributesToFindings] and [CreateAssessmentTemplate] actions.
    public struct Attribute: Swift.Equatable {
        /// The attribute key.
        /// This member is required.
        public var key: Swift.String?
        /// The value assigned to the attribute key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CreateAssessmentTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetName
        case resourceGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetName = self.assessmentTargetName {
            try encodeContainer.encode(assessmentTargetName, forKey: .assessmentTargetName)
        }
        if let resourceGroupArn = self.resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
    }
}

extension CreateAssessmentTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAssessmentTargetInput: Swift.Equatable {
    /// The user-defined name that identifies the assessment target that you want to create. The name must be unique within the AWS account.
    /// This member is required.
    public var assessmentTargetName: Swift.String?
    /// The ARN that specifies the resource group that is used to create the assessment target. If resourceGroupArn is not specified, all EC2 instances in the current AWS account and region are included in the assessment target.
    public var resourceGroupArn: Swift.String?

    public init(
        assessmentTargetName: Swift.String? = nil,
        resourceGroupArn: Swift.String? = nil
    )
    {
        self.assessmentTargetName = assessmentTargetName
        self.resourceGroupArn = resourceGroupArn
    }
}

struct CreateAssessmentTargetInputBody: Swift.Equatable {
    let assessmentTargetName: Swift.String?
    let resourceGroupArn: Swift.String?
}

extension CreateAssessmentTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetName
        case resourceGroupArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetName)
        assessmentTargetName = assessmentTargetNameDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
    }
}

extension CreateAssessmentTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssessmentTargetOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTargetArn = output.assessmentTargetArn
        } else {
            self.assessmentTargetArn = nil
        }
    }
}

public struct CreateAssessmentTargetOutput: Swift.Equatable {
    /// The ARN that specifies the assessment target that is created.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?

    public init(
        assessmentTargetArn: Swift.String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
    }
}

struct CreateAssessmentTargetOutputBody: Swift.Equatable {
    let assessmentTargetArn: Swift.String?
}

extension CreateAssessmentTargetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
    }
}

enum CreateAssessmentTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCrossAccountRoleException": return try await InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAssessmentTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
        case assessmentTemplateName
        case durationInSeconds
        case rulesPackageArns
        case userAttributesForFindings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArn = self.assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
        if let assessmentTemplateName = self.assessmentTemplateName {
            try encodeContainer.encode(assessmentTemplateName, forKey: .assessmentTemplateName)
        }
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for arn0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(arn0)
            }
        }
        if let userAttributesForFindings = userAttributesForFindings {
            var userAttributesForFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributesForFindings)
            for attribute0 in userAttributesForFindings {
                try userAttributesForFindingsContainer.encode(attribute0)
            }
        }
    }
}

extension CreateAssessmentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAssessmentTemplateInput: Swift.Equatable {
    /// The ARN that specifies the assessment target for which you want to create the assessment template.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?
    /// The user-defined name that identifies the assessment template that you want to create. You can create several assessment templates for an assessment target. The names of the assessment templates that correspond to a particular assessment target must be unique.
    /// This member is required.
    public var assessmentTemplateName: Swift.String?
    /// The duration of the assessment run in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int?
    /// The ARNs that specify the rules packages that you want to attach to the assessment template.
    /// This member is required.
    public var rulesPackageArns: [Swift.String]?
    /// The user-defined attributes that are assigned to every finding that is generated by the assessment run that uses this assessment template. An attribute is a key and value pair (an [Attribute] object). Within an assessment template, each key must be unique.
    public var userAttributesForFindings: [InspectorClientTypes.Attribute]?

    public init(
        assessmentTargetArn: Swift.String? = nil,
        assessmentTemplateName: Swift.String? = nil,
        durationInSeconds: Swift.Int? = nil,
        rulesPackageArns: [Swift.String]? = nil,
        userAttributesForFindings: [InspectorClientTypes.Attribute]? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
        self.assessmentTemplateName = assessmentTemplateName
        self.durationInSeconds = durationInSeconds
        self.rulesPackageArns = rulesPackageArns
        self.userAttributesForFindings = userAttributesForFindings
    }
}

struct CreateAssessmentTemplateInputBody: Swift.Equatable {
    let assessmentTargetArn: Swift.String?
    let assessmentTemplateName: Swift.String?
    let durationInSeconds: Swift.Int?
    let rulesPackageArns: [Swift.String]?
    let userAttributesForFindings: [InspectorClientTypes.Attribute]?
}

extension CreateAssessmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
        case assessmentTemplateName
        case durationInSeconds
        case rulesPackageArns
        case userAttributesForFindings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
        let assessmentTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateName)
        assessmentTemplateName = assessmentTemplateNameDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let userAttributesForFindingsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .userAttributesForFindings)
        var userAttributesForFindingsDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let userAttributesForFindingsContainer = userAttributesForFindingsContainer {
            userAttributesForFindingsDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in userAttributesForFindingsContainer {
                if let structure0 = structure0 {
                    userAttributesForFindingsDecoded0?.append(structure0)
                }
            }
        }
        userAttributesForFindings = userAttributesForFindingsDecoded0
    }
}

extension CreateAssessmentTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssessmentTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTemplateArn = output.assessmentTemplateArn
        } else {
            self.assessmentTemplateArn = nil
        }
    }
}

public struct CreateAssessmentTemplateOutput: Swift.Equatable {
    /// The ARN that specifies the assessment template that is created.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init(
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct CreateAssessmentTemplateOutputBody: Swift.Equatable {
    let assessmentTemplateArn: Swift.String?
}

extension CreateAssessmentTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
    }
}

enum CreateAssessmentTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateExclusionsPreviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArn = self.assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
    }
}

extension CreateExclusionsPreviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateExclusionsPreviewInput: Swift.Equatable {
    /// The ARN that specifies the assessment template for which you want to create an exclusions preview.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init(
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct CreateExclusionsPreviewInputBody: Swift.Equatable {
    let assessmentTemplateArn: Swift.String?
}

extension CreateExclusionsPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
    }
}

extension CreateExclusionsPreviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateExclusionsPreviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.previewToken = output.previewToken
        } else {
            self.previewToken = nil
        }
    }
}

public struct CreateExclusionsPreviewOutput: Swift.Equatable {
    /// Specifies the unique identifier of the requested exclusions preview. You can use the unique identifier to retrieve the exclusions preview when running the GetExclusionsPreview API.
    /// This member is required.
    public var previewToken: Swift.String?

    public init(
        previewToken: Swift.String? = nil
    )
    {
        self.previewToken = previewToken
    }
}

struct CreateExclusionsPreviewOutputBody: Swift.Equatable {
    let previewToken: Swift.String?
}

extension CreateExclusionsPreviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case previewToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previewToken)
        previewToken = previewTokenDecoded
    }
}

enum CreateExclusionsPreviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreviewGenerationInProgressException": return try await PreviewGenerationInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResourceGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupTags = resourceGroupTags {
            var resourceGroupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceGroupTags)
            for resourcegrouptag0 in resourceGroupTags {
                try resourceGroupTagsContainer.encode(resourcegrouptag0)
            }
        }
    }
}

extension CreateResourceGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResourceGroupInput: Swift.Equatable {
    /// A collection of keys and an array of possible values, '[{"key":"key1","values":["Value1","Value2"]},{"key":"Key2","values":["Value3"]}]'. For example,'[{"key":"Name","values":["TestEC2Instance"]}]'.
    /// This member is required.
    public var resourceGroupTags: [InspectorClientTypes.ResourceGroupTag]?

    public init(
        resourceGroupTags: [InspectorClientTypes.ResourceGroupTag]? = nil
    )
    {
        self.resourceGroupTags = resourceGroupTags
    }
}

struct CreateResourceGroupInputBody: Swift.Equatable {
    let resourceGroupTags: [InspectorClientTypes.ResourceGroupTag]?
}

extension CreateResourceGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupTags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupTagsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.ResourceGroupTag?].self, forKey: .resourceGroupTags)
        var resourceGroupTagsDecoded0:[InspectorClientTypes.ResourceGroupTag]? = nil
        if let resourceGroupTagsContainer = resourceGroupTagsContainer {
            resourceGroupTagsDecoded0 = [InspectorClientTypes.ResourceGroupTag]()
            for structure0 in resourceGroupTagsContainer {
                if let structure0 = structure0 {
                    resourceGroupTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceGroupTags = resourceGroupTagsDecoded0
    }
}

extension CreateResourceGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResourceGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceGroupArn = output.resourceGroupArn
        } else {
            self.resourceGroupArn = nil
        }
    }
}

public struct CreateResourceGroupOutput: Swift.Equatable {
    /// The ARN that specifies the resource group that is created.
    /// This member is required.
    public var resourceGroupArn: Swift.String?

    public init(
        resourceGroupArn: Swift.String? = nil
    )
    {
        self.resourceGroupArn = resourceGroupArn
    }
}

struct CreateResourceGroupOutputBody: Swift.Equatable {
    let resourceGroupArn: Swift.String?
}

extension CreateResourceGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
    }
}

enum CreateResourceGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAssessmentRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = self.assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
    }
}

extension DeleteAssessmentRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAssessmentRunInput: Swift.Equatable {
    /// The ARN that specifies the assessment run that you want to delete.
    /// This member is required.
    public var assessmentRunArn: Swift.String?

    public init(
        assessmentRunArn: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

struct DeleteAssessmentRunInputBody: Swift.Equatable {
    let assessmentRunArn: Swift.String?
}

extension DeleteAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

extension DeleteAssessmentRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssessmentRunOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssessmentRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AssessmentRunInProgressException": return try await AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAssessmentTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArn = self.assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
    }
}

extension DeleteAssessmentTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAssessmentTargetInput: Swift.Equatable {
    /// The ARN that specifies the assessment target that you want to delete.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?

    public init(
        assessmentTargetArn: Swift.String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
    }
}

struct DeleteAssessmentTargetInputBody: Swift.Equatable {
    let assessmentTargetArn: Swift.String?
}

extension DeleteAssessmentTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
    }
}

extension DeleteAssessmentTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssessmentTargetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssessmentTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AssessmentRunInProgressException": return try await AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAssessmentTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArn = self.assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
    }
}

extension DeleteAssessmentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAssessmentTemplateInput: Swift.Equatable {
    /// The ARN that specifies the assessment template that you want to delete.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init(
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct DeleteAssessmentTemplateInputBody: Swift.Equatable {
    let assessmentTemplateArn: Swift.String?
}

extension DeleteAssessmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
    }
}

extension DeleteAssessmentTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssessmentTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssessmentTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AssessmentRunInProgressException": return try await AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAssessmentRunsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArns = assessmentRunArns {
            var assessmentRunArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentRunArns)
            for arn0 in assessmentRunArns {
                try assessmentRunArnsContainer.encode(arn0)
            }
        }
    }
}

extension DescribeAssessmentRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAssessmentRunsInput: Swift.Equatable {
    /// The ARN that specifies the assessment run that you want to describe.
    /// This member is required.
    public var assessmentRunArns: [Swift.String]?

    public init(
        assessmentRunArns: [Swift.String]? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
    }
}

struct DescribeAssessmentRunsInputBody: Swift.Equatable {
    let assessmentRunArns: [Swift.String]?
}

extension DescribeAssessmentRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[Swift.String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [Swift.String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
    }
}

extension DescribeAssessmentRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAssessmentRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentRuns = output.assessmentRuns
            self.failedItems = output.failedItems
        } else {
            self.assessmentRuns = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeAssessmentRunsOutput: Swift.Equatable {
    /// Information about the assessment run.
    /// This member is required.
    public var assessmentRuns: [InspectorClientTypes.AssessmentRun]?
    /// Assessment run details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init(
        assessmentRuns: [InspectorClientTypes.AssessmentRun]? = nil,
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.assessmentRuns = assessmentRuns
        self.failedItems = failedItems
    }
}

struct DescribeAssessmentRunsOutputBody: Swift.Equatable {
    let assessmentRuns: [InspectorClientTypes.AssessmentRun]?
    let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeAssessmentRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRuns
        case failedItems
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentRun?].self, forKey: .assessmentRuns)
        var assessmentRunsDecoded0:[InspectorClientTypes.AssessmentRun]? = nil
        if let assessmentRunsContainer = assessmentRunsContainer {
            assessmentRunsDecoded0 = [InspectorClientTypes.AssessmentRun]()
            for structure0 in assessmentRunsContainer {
                if let structure0 = structure0 {
                    assessmentRunsDecoded0?.append(structure0)
                }
            }
        }
        assessmentRuns = assessmentRunsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

enum DescribeAssessmentRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAssessmentTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArns = assessmentTargetArns {
            var assessmentTargetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTargetArns)
            for arn0 in assessmentTargetArns {
                try assessmentTargetArnsContainer.encode(arn0)
            }
        }
    }
}

extension DescribeAssessmentTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAssessmentTargetsInput: Swift.Equatable {
    /// The ARNs that specifies the assessment targets that you want to describe.
    /// This member is required.
    public var assessmentTargetArns: [Swift.String]?

    public init(
        assessmentTargetArns: [Swift.String]? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
    }
}

struct DescribeAssessmentTargetsInputBody: Swift.Equatable {
    let assessmentTargetArns: [Swift.String]?
}

extension DescribeAssessmentTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTargetArns)
        var assessmentTargetArnsDecoded0:[Swift.String]? = nil
        if let assessmentTargetArnsContainer = assessmentTargetArnsContainer {
            assessmentTargetArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTargetArnsContainer {
                if let string0 = string0 {
                    assessmentTargetArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTargetArns = assessmentTargetArnsDecoded0
    }
}

extension DescribeAssessmentTargetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAssessmentTargetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTargets = output.assessmentTargets
            self.failedItems = output.failedItems
        } else {
            self.assessmentTargets = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeAssessmentTargetsOutput: Swift.Equatable {
    /// Information about the assessment targets.
    /// This member is required.
    public var assessmentTargets: [InspectorClientTypes.AssessmentTarget]?
    /// Assessment target details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init(
        assessmentTargets: [InspectorClientTypes.AssessmentTarget]? = nil,
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.assessmentTargets = assessmentTargets
        self.failedItems = failedItems
    }
}

struct DescribeAssessmentTargetsOutputBody: Swift.Equatable {
    let assessmentTargets: [InspectorClientTypes.AssessmentTarget]?
    let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeAssessmentTargetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargets
        case failedItems
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentTarget?].self, forKey: .assessmentTargets)
        var assessmentTargetsDecoded0:[InspectorClientTypes.AssessmentTarget]? = nil
        if let assessmentTargetsContainer = assessmentTargetsContainer {
            assessmentTargetsDecoded0 = [InspectorClientTypes.AssessmentTarget]()
            for structure0 in assessmentTargetsContainer {
                if let structure0 = structure0 {
                    assessmentTargetsDecoded0?.append(structure0)
                }
            }
        }
        assessmentTargets = assessmentTargetsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

enum DescribeAssessmentTargetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAssessmentTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArns = assessmentTemplateArns {
            var assessmentTemplateArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTemplateArns)
            for arn0 in assessmentTemplateArns {
                try assessmentTemplateArnsContainer.encode(arn0)
            }
        }
    }
}

extension DescribeAssessmentTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAssessmentTemplatesInput: Swift.Equatable {
    /// This member is required.
    public var assessmentTemplateArns: [Swift.String]?

    public init(
        assessmentTemplateArns: [Swift.String]? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
    }
}

struct DescribeAssessmentTemplatesInputBody: Swift.Equatable {
    let assessmentTemplateArns: [Swift.String]?
}

extension DescribeAssessmentTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTemplateArns)
        var assessmentTemplateArnsDecoded0:[Swift.String]? = nil
        if let assessmentTemplateArnsContainer = assessmentTemplateArnsContainer {
            assessmentTemplateArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTemplateArnsContainer {
                if let string0 = string0 {
                    assessmentTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTemplateArns = assessmentTemplateArnsDecoded0
    }
}

extension DescribeAssessmentTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAssessmentTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTemplates = output.assessmentTemplates
            self.failedItems = output.failedItems
        } else {
            self.assessmentTemplates = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeAssessmentTemplatesOutput: Swift.Equatable {
    /// Information about the assessment templates.
    /// This member is required.
    public var assessmentTemplates: [InspectorClientTypes.AssessmentTemplate]?
    /// Assessment template details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init(
        assessmentTemplates: [InspectorClientTypes.AssessmentTemplate]? = nil,
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.assessmentTemplates = assessmentTemplates
        self.failedItems = failedItems
    }
}

struct DescribeAssessmentTemplatesOutputBody: Swift.Equatable {
    let assessmentTemplates: [InspectorClientTypes.AssessmentTemplate]?
    let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeAssessmentTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplates
        case failedItems
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplatesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentTemplate?].self, forKey: .assessmentTemplates)
        var assessmentTemplatesDecoded0:[InspectorClientTypes.AssessmentTemplate]? = nil
        if let assessmentTemplatesContainer = assessmentTemplatesContainer {
            assessmentTemplatesDecoded0 = [InspectorClientTypes.AssessmentTemplate]()
            for structure0 in assessmentTemplatesContainer {
                if let structure0 = structure0 {
                    assessmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        assessmentTemplates = assessmentTemplatesDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

enum DescribeAssessmentTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCrossAccountAccessRoleInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeCrossAccountAccessRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCrossAccountAccessRoleInput: Swift.Equatable {

    public init() { }
}

struct DescribeCrossAccountAccessRoleInputBody: Swift.Equatable {
}

extension DescribeCrossAccountAccessRoleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCrossAccountAccessRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCrossAccountAccessRoleOutputBody = try responseDecoder.decode(responseBody: data)
            self.registeredAt = output.registeredAt
            self.roleArn = output.roleArn
            self.valid = output.valid
        } else {
            self.registeredAt = nil
            self.roleArn = nil
            self.valid = nil
        }
    }
}

public struct DescribeCrossAccountAccessRoleOutput: Swift.Equatable {
    /// The date when the cross-account access role was registered.
    /// This member is required.
    public var registeredAt: ClientRuntime.Date?
    /// The ARN that specifies the IAM role that Amazon Inspector uses to access your AWS account.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A Boolean value that specifies whether the IAM role has the necessary policies attached to enable Amazon Inspector to access your AWS account.
    /// This member is required.
    public var valid: Swift.Bool?

    public init(
        registeredAt: ClientRuntime.Date? = nil,
        roleArn: Swift.String? = nil,
        valid: Swift.Bool? = nil
    )
    {
        self.registeredAt = registeredAt
        self.roleArn = roleArn
        self.valid = valid
    }
}

struct DescribeCrossAccountAccessRoleOutputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let valid: Swift.Bool?
    let registeredAt: ClientRuntime.Date?
}

extension DescribeCrossAccountAccessRoleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registeredAt
        case roleArn
        case valid
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let validDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .valid)
        valid = validDecoded
        let registeredAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .registeredAt)
        registeredAt = registeredAtDecoded
    }
}

enum DescribeCrossAccountAccessRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeExclusionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusionArns
        case locale
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusionArns = exclusionArns {
            var exclusionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionArns)
            for arn0 in exclusionArns {
                try exclusionArnsContainer.encode(arn0)
            }
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
    }
}

extension DescribeExclusionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExclusionsInput: Swift.Equatable {
    /// The list of ARNs that specify the exclusions that you want to describe.
    /// This member is required.
    public var exclusionArns: [Swift.String]?
    /// The locale into which you want to translate the exclusion's title, description, and recommendation.
    public var locale: InspectorClientTypes.Locale?

    public init(
        exclusionArns: [Swift.String]? = nil,
        locale: InspectorClientTypes.Locale? = nil
    )
    {
        self.exclusionArns = exclusionArns
        self.locale = locale
    }
}

struct DescribeExclusionsInputBody: Swift.Equatable {
    let exclusionArns: [Swift.String]?
    let locale: InspectorClientTypes.Locale?
}

extension DescribeExclusionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusionArns
        case locale
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exclusionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclusionArns)
        var exclusionArnsDecoded0:[Swift.String]? = nil
        if let exclusionArnsContainer = exclusionArnsContainer {
            exclusionArnsDecoded0 = [Swift.String]()
            for string0 in exclusionArnsContainer {
                if let string0 = string0 {
                    exclusionArnsDecoded0?.append(string0)
                }
            }
        }
        exclusionArns = exclusionArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeExclusionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeExclusionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.exclusions = output.exclusions
            self.failedItems = output.failedItems
        } else {
            self.exclusions = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeExclusionsOutput: Swift.Equatable {
    /// Information about the exclusions.
    /// This member is required.
    public var exclusions: [Swift.String:InspectorClientTypes.Exclusion]?
    /// Exclusion details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init(
        exclusions: [Swift.String:InspectorClientTypes.Exclusion]? = nil,
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.exclusions = exclusions
        self.failedItems = failedItems
    }
}

struct DescribeExclusionsOutputBody: Swift.Equatable {
    let exclusions: [Swift.String:InspectorClientTypes.Exclusion]?
    let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeExclusionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusions
        case failedItems
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exclusionsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.Exclusion?].self, forKey: .exclusions)
        var exclusionsDecoded0: [Swift.String:InspectorClientTypes.Exclusion]? = nil
        if let exclusionsContainer = exclusionsContainer {
            exclusionsDecoded0 = [Swift.String:InspectorClientTypes.Exclusion]()
            for (key0, exclusion0) in exclusionsContainer {
                if let exclusion0 = exclusion0 {
                    exclusionsDecoded0?[key0] = exclusion0
                }
            }
        }
        exclusions = exclusionsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

enum DescribeExclusionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingArns
        case locale
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for arn0 in findingArns {
                try findingArnsContainer.encode(arn0)
            }
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
    }
}

extension DescribeFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFindingsInput: Swift.Equatable {
    /// The ARN that specifies the finding that you want to describe.
    /// This member is required.
    public var findingArns: [Swift.String]?
    /// The locale into which you want to translate a finding description, recommendation, and the short description that identifies the finding.
    public var locale: InspectorClientTypes.Locale?

    public init(
        findingArns: [Swift.String]? = nil,
        locale: InspectorClientTypes.Locale? = nil
    )
    {
        self.findingArns = findingArns
        self.locale = locale
    }
}

struct DescribeFindingsInputBody: Swift.Equatable {
    let findingArns: [Swift.String]?
    let locale: InspectorClientTypes.Locale?
}

extension DescribeFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingArns
        case locale
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[Swift.String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [Swift.String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
            self.findings = output.findings
        } else {
            self.failedItems = nil
            self.findings = nil
        }
    }
}

public struct DescribeFindingsOutput: Swift.Equatable {
    /// Finding details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
    /// Information about the finding.
    /// This member is required.
    public var findings: [InspectorClientTypes.Finding]?

    public init(
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil,
        findings: [InspectorClientTypes.Finding]? = nil
    )
    {
        self.failedItems = failedItems
        self.findings = findings
    }
}

struct DescribeFindingsOutputBody: Swift.Equatable {
    let findings: [InspectorClientTypes.Finding]?
    let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems
        case findings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Finding?].self, forKey: .findings)
        var findingsDecoded0:[InspectorClientTypes.Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [InspectorClientTypes.Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

enum DescribeFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeResourceGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupArns = resourceGroupArns {
            var resourceGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceGroupArns)
            for arn0 in resourceGroupArns {
                try resourceGroupArnsContainer.encode(arn0)
            }
        }
    }
}

extension DescribeResourceGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeResourceGroupsInput: Swift.Equatable {
    /// The ARN that specifies the resource group that you want to describe.
    /// This member is required.
    public var resourceGroupArns: [Swift.String]?

    public init(
        resourceGroupArns: [Swift.String]? = nil
    )
    {
        self.resourceGroupArns = resourceGroupArns
    }
}

struct DescribeResourceGroupsInputBody: Swift.Equatable {
    let resourceGroupArns: [Swift.String]?
}

extension DescribeResourceGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceGroupArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceGroupArns)
        var resourceGroupArnsDecoded0:[Swift.String]? = nil
        if let resourceGroupArnsContainer = resourceGroupArnsContainer {
            resourceGroupArnsDecoded0 = [Swift.String]()
            for string0 in resourceGroupArnsContainer {
                if let string0 = string0 {
                    resourceGroupArnsDecoded0?.append(string0)
                }
            }
        }
        resourceGroupArns = resourceGroupArnsDecoded0
    }
}

extension DescribeResourceGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeResourceGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
            self.resourceGroups = output.resourceGroups
        } else {
            self.failedItems = nil
            self.resourceGroups = nil
        }
    }
}

public struct DescribeResourceGroupsOutput: Swift.Equatable {
    /// Resource group details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
    /// Information about a resource group.
    /// This member is required.
    public var resourceGroups: [InspectorClientTypes.ResourceGroup]?

    public init(
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil,
        resourceGroups: [InspectorClientTypes.ResourceGroup]? = nil
    )
    {
        self.failedItems = failedItems
        self.resourceGroups = resourceGroups
    }
}

struct DescribeResourceGroupsOutputBody: Swift.Equatable {
    let resourceGroups: [InspectorClientTypes.ResourceGroup]?
    let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeResourceGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems
        case resourceGroups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.ResourceGroup?].self, forKey: .resourceGroups)
        var resourceGroupsDecoded0:[InspectorClientTypes.ResourceGroup]? = nil
        if let resourceGroupsContainer = resourceGroupsContainer {
            resourceGroupsDecoded0 = [InspectorClientTypes.ResourceGroup]()
            for structure0 in resourceGroupsContainer {
                if let structure0 = structure0 {
                    resourceGroupsDecoded0?.append(structure0)
                }
            }
        }
        resourceGroups = resourceGroupsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

enum DescribeResourceGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRulesPackagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case rulesPackageArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for arn0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(arn0)
            }
        }
    }
}

extension DescribeRulesPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRulesPackagesInput: Swift.Equatable {
    /// The locale that you want to translate a rules package description into.
    public var locale: InspectorClientTypes.Locale?
    /// The ARN that specifies the rules package that you want to describe.
    /// This member is required.
    public var rulesPackageArns: [Swift.String]?

    public init(
        locale: InspectorClientTypes.Locale? = nil,
        rulesPackageArns: [Swift.String]? = nil
    )
    {
        self.locale = locale
        self.rulesPackageArns = rulesPackageArns
    }
}

struct DescribeRulesPackagesInputBody: Swift.Equatable {
    let rulesPackageArns: [Swift.String]?
    let locale: InspectorClientTypes.Locale?
}

extension DescribeRulesPackagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case rulesPackageArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeRulesPackagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRulesPackagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
            self.rulesPackages = output.rulesPackages
        } else {
            self.failedItems = nil
            self.rulesPackages = nil
        }
    }
}

public struct DescribeRulesPackagesOutput: Swift.Equatable {
    /// Rules package details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
    /// Information about the rules package.
    /// This member is required.
    public var rulesPackages: [InspectorClientTypes.RulesPackage]?

    public init(
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil,
        rulesPackages: [InspectorClientTypes.RulesPackage]? = nil
    )
    {
        self.failedItems = failedItems
        self.rulesPackages = rulesPackages
    }
}

struct DescribeRulesPackagesOutputBody: Swift.Equatable {
    let rulesPackages: [InspectorClientTypes.RulesPackage]?
    let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension DescribeRulesPackagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems
        case rulesPackages
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesPackagesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.RulesPackage?].self, forKey: .rulesPackages)
        var rulesPackagesDecoded0:[InspectorClientTypes.RulesPackage]? = nil
        if let rulesPackagesContainer = rulesPackagesContainer {
            rulesPackagesDecoded0 = [InspectorClientTypes.RulesPackage]()
            for structure0 in rulesPackagesContainer {
                if let structure0 = structure0 {
                    rulesPackagesDecoded0?.append(structure0)
                }
            }
        }
        rulesPackages = rulesPackagesDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

enum DescribeRulesPackagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InspectorClientTypes.DurationRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxSeconds
        case minSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxSeconds != 0 {
            try encodeContainer.encode(maxSeconds, forKey: .maxSeconds)
        }
        if minSeconds != 0 {
            try encodeContainer.encode(minSeconds, forKey: .minSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minSeconds) ?? 0
        minSeconds = minSecondsDecoded
        let maxSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSeconds) ?? 0
        maxSeconds = maxSecondsDecoded
    }
}

extension InspectorClientTypes {
    /// This data type is used in the [AssessmentTemplateFilter] data type.
    public struct DurationRange: Swift.Equatable {
        /// The maximum value of the duration range. Must be less than or equal to 604800 seconds (1 week).
        public var maxSeconds: Swift.Int
        /// The minimum value of the duration range. Must be greater than zero.
        public var minSeconds: Swift.Int

        public init(
            maxSeconds: Swift.Int = 0,
            minSeconds: Swift.Int = 0
        )
        {
            self.maxSeconds = maxSeconds
            self.minSeconds = minSeconds
        }
    }

}

extension InspectorClientTypes.EventSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case subscribedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let subscribedAt = self.subscribedAt {
            try encodeContainer.encodeTimestamp(subscribedAt, format: .epochSeconds, forKey: .subscribedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let subscribedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .subscribedAt)
        subscribedAt = subscribedAtDecoded
    }
}

extension InspectorClientTypes {
    /// This data type is used in the [Subscription] data type.
    public struct EventSubscription: Swift.Equatable {
        /// The event for which Amazon Simple Notification Service (SNS) notifications are sent.
        /// This member is required.
        public var event: InspectorClientTypes.InspectorEvent?
        /// The time at which [SubscribeToEvent] is called.
        /// This member is required.
        public var subscribedAt: ClientRuntime.Date?

        public init(
            event: InspectorClientTypes.InspectorEvent? = nil,
            subscribedAt: ClientRuntime.Date? = nil
        )
        {
            self.event = event
            self.subscribedAt = subscribedAt
        }
    }

}

extension InspectorClientTypes.Exclusion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case attributes
        case description
        case recommendation
        case scopes
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attribute0 in attributes {
                try attributesContainer.encode(attribute0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for scope0 in scopes {
                try scopesContainer.encode(scope0)
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let scopesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Scope?].self, forKey: .scopes)
        var scopesDecoded0:[InspectorClientTypes.Scope]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [InspectorClientTypes.Scope]()
            for structure0 in scopesContainer {
                if let structure0 = structure0 {
                    scopesDecoded0?.append(structure0)
                }
            }
        }
        scopes = scopesDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension InspectorClientTypes {
    /// Contains information about what was excluded from an assessment run.
    public struct Exclusion: Swift.Equatable {
        /// The ARN that specifies the exclusion.
        /// This member is required.
        public var arn: Swift.String?
        /// The system-defined attributes for the exclusion.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// The description of the exclusion.
        /// This member is required.
        public var description: Swift.String?
        /// The recommendation for the exclusion.
        /// This member is required.
        public var recommendation: Swift.String?
        /// The AWS resources for which the exclusion pertains.
        /// This member is required.
        public var scopes: [InspectorClientTypes.Scope]?
        /// The name of the exclusion.
        /// This member is required.
        public var title: Swift.String?

        public init(
            arn: Swift.String? = nil,
            attributes: [InspectorClientTypes.Attribute]? = nil,
            description: Swift.String? = nil,
            recommendation: Swift.String? = nil,
            scopes: [InspectorClientTypes.Scope]? = nil,
            title: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.description = description
            self.recommendation = recommendation
            self.scopes = scopes
            self.title = title
        }
    }

}

extension InspectorClientTypes.ExclusionPreview: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case recommendation
        case scopes
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attribute0 in attributes {
                try attributesContainer.encode(attribute0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for scope0 in scopes {
                try scopesContainer.encode(scope0)
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let scopesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Scope?].self, forKey: .scopes)
        var scopesDecoded0:[InspectorClientTypes.Scope]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [InspectorClientTypes.Scope]()
            for structure0 in scopesContainer {
                if let structure0 = structure0 {
                    scopesDecoded0?.append(structure0)
                }
            }
        }
        scopes = scopesDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension InspectorClientTypes {
    /// Contains information about what is excluded from an assessment run given the current state of the assessment template.
    public struct ExclusionPreview: Swift.Equatable {
        /// The system-defined attributes for the exclusion preview.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// The description of the exclusion preview.
        /// This member is required.
        public var description: Swift.String?
        /// The recommendation for the exclusion preview.
        /// This member is required.
        public var recommendation: Swift.String?
        /// The AWS resources for which the exclusion preview pertains.
        /// This member is required.
        public var scopes: [InspectorClientTypes.Scope]?
        /// The name of the exclusion preview.
        /// This member is required.
        public var title: Swift.String?

        public init(
            attributes: [InspectorClientTypes.Attribute]? = nil,
            description: Swift.String? = nil,
            recommendation: Swift.String? = nil,
            scopes: [InspectorClientTypes.Scope]? = nil,
            title: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.description = description
            self.recommendation = recommendation
            self.scopes = scopes
            self.title = title
        }
    }

}

extension InspectorClientTypes.FailedItemDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case retryable
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let retryable = self.retryable {
            try encodeContainer.encode(retryable, forKey: .retryable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.FailedItemErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retryable)
        retryable = retryableDecoded
    }
}

extension InspectorClientTypes {
    /// Includes details about the failed items.
    public struct FailedItemDetails: Swift.Equatable {
        /// The status code of a failed item.
        /// This member is required.
        public var failureCode: InspectorClientTypes.FailedItemErrorCode?
        /// Indicates whether you can immediately retry a request for this item for a specified resource.
        /// This member is required.
        public var retryable: Swift.Bool?

        public init(
            failureCode: InspectorClientTypes.FailedItemErrorCode? = nil,
            retryable: Swift.Bool? = nil
        )
        {
            self.failureCode = failureCode
            self.retryable = retryable
        }
    }

}

extension InspectorClientTypes {
    public enum FailedItemErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case duplicateArn
        case internalError
        case invalidArn
        case itemDoesNotExist
        case limitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [FailedItemErrorCode] {
            return [
                .accessDenied,
                .duplicateArn,
                .internalError,
                .invalidArn,
                .itemDoesNotExist,
                .limitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .duplicateArn: return "DUPLICATE_ARN"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidArn: return "INVALID_ARN"
            case .itemDoesNotExist: return "ITEM_DOES_NOT_EXIST"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailedItemErrorCode(rawValue: rawValue) ?? FailedItemErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.Finding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetAttributes
        case assetType
        case attributes
        case confidence
        case createdAt
        case description
        case id
        case indicatorOfCompromise
        case numericSeverity
        case recommendation
        case schemaVersion
        case service
        case serviceAttributes
        case severity
        case title
        case updatedAt
        case userAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetAttributes = self.assetAttributes {
            try encodeContainer.encode(assetAttributes, forKey: .assetAttributes)
        }
        if let assetType = self.assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attribute0 in attributes {
                try attributesContainer.encode(attribute0)
            }
        }
        if confidence != 0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indicatorOfCompromise = self.indicatorOfCompromise {
            try encodeContainer.encode(indicatorOfCompromise, forKey: .indicatorOfCompromise)
        }
        if numericSeverity != 0.0 {
            try encodeContainer.encode(numericSeverity, forKey: .numericSeverity)
        }
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if schemaVersion != 0 {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let serviceAttributes = self.serviceAttributes {
            try encodeContainer.encode(serviceAttributes, forKey: .serviceAttributes)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributes)
            for attribute0 in userAttributes {
                try userAttributesContainer.encode(attribute0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .schemaVersion) ?? 0
        schemaVersion = schemaVersionDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let serviceAttributesDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InspectorServiceAttributes.self, forKey: .serviceAttributes)
        serviceAttributes = serviceAttributesDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let assetAttributesDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssetAttributes.self, forKey: .assetAttributes)
        assetAttributes = assetAttributesDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let severityDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.Severity.self, forKey: .severity)
        severity = severityDecoded
        let numericSeverityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .numericSeverity) ?? 0.0
        numericSeverity = numericSeverityDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .confidence) ?? 0
        confidence = confidenceDecoded
        let indicatorOfCompromiseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .indicatorOfCompromise)
        indicatorOfCompromise = indicatorOfCompromiseDecoded
        let attributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let userAttributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector finding. This data type is used as the response element in the [DescribeFindings] action.
    public struct Finding: Swift.Equatable {
        /// The ARN that specifies the finding.
        /// This member is required.
        public var arn: Swift.String?
        /// A collection of attributes of the host from which the finding is generated.
        public var assetAttributes: InspectorClientTypes.AssetAttributes?
        /// The type of the host from which the finding is generated.
        public var assetType: InspectorClientTypes.AssetType?
        /// The system-defined attributes for the finding.
        /// This member is required.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// This data element is currently not used.
        public var confidence: Swift.Int
        /// The time when the finding was generated.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the finding.
        public var description: Swift.String?
        /// The ID of the finding.
        public var id: Swift.String?
        /// This data element is currently not used.
        public var indicatorOfCompromise: Swift.Bool?
        /// The numeric value of the finding severity.
        public var numericSeverity: Swift.Double
        /// The recommendation for the finding.
        public var recommendation: Swift.String?
        /// The schema version of this data type.
        public var schemaVersion: Swift.Int
        /// The data element is set to "Inspector".
        public var service: Swift.String?
        /// This data type is used in the [Finding] data type.
        public var serviceAttributes: InspectorClientTypes.InspectorServiceAttributes?
        /// The finding severity. Values can be set to High, Medium, Low, and Informational.
        public var severity: InspectorClientTypes.Severity?
        /// The name of the finding.
        public var title: Swift.String?
        /// The time when [AddAttributesToFindings] is called.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The user-defined attributes that are assigned to the finding.
        /// This member is required.
        public var userAttributes: [InspectorClientTypes.Attribute]?

        public init(
            arn: Swift.String? = nil,
            assetAttributes: InspectorClientTypes.AssetAttributes? = nil,
            assetType: InspectorClientTypes.AssetType? = nil,
            attributes: [InspectorClientTypes.Attribute]? = nil,
            confidence: Swift.Int = 0,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            indicatorOfCompromise: Swift.Bool? = nil,
            numericSeverity: Swift.Double = 0.0,
            recommendation: Swift.String? = nil,
            schemaVersion: Swift.Int = 0,
            service: Swift.String? = nil,
            serviceAttributes: InspectorClientTypes.InspectorServiceAttributes? = nil,
            severity: InspectorClientTypes.Severity? = nil,
            title: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            userAttributes: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.arn = arn
            self.assetAttributes = assetAttributes
            self.assetType = assetType
            self.attributes = attributes
            self.confidence = confidence
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.indicatorOfCompromise = indicatorOfCompromise
            self.numericSeverity = numericSeverity
            self.recommendation = recommendation
            self.schemaVersion = schemaVersion
            self.service = service
            self.serviceAttributes = serviceAttributes
            self.severity = severity
            self.title = title
            self.updatedAt = updatedAt
            self.userAttributes = userAttributes
        }
    }

}

extension InspectorClientTypes.FindingFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
        case attributes
        case autoScalingGroups
        case creationTimeRange
        case ruleNames
        case rulesPackageArns
        case severities
        case userAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentid0 in agentIds {
                try agentIdsContainer.encode(agentid0)
            }
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attribute0 in attributes {
                try attributesContainer.encode(attribute0)
            }
        }
        if let autoScalingGroups = autoScalingGroups {
            var autoScalingGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoScalingGroups)
            for autoscalinggroup0 in autoScalingGroups {
                try autoScalingGroupsContainer.encode(autoscalinggroup0)
            }
        }
        if let creationTimeRange = self.creationTimeRange {
            try encodeContainer.encode(creationTimeRange, forKey: .creationTimeRange)
        }
        if let ruleNames = ruleNames {
            var ruleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ruleNames)
            for rulename0 in ruleNames {
                try ruleNamesContainer.encode(rulename0)
            }
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for arn0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(arn0)
            }
        }
        if let severities = severities {
            var severitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severities)
            for severity0 in severities {
                try severitiesContainer.encode(severity0.rawValue)
            }
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributes)
            for attribute0 in userAttributes {
                try userAttributesContainer.encode(attribute0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[Swift.String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [Swift.String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
        let autoScalingGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoScalingGroups)
        var autoScalingGroupsDecoded0:[Swift.String]? = nil
        if let autoScalingGroupsContainer = autoScalingGroupsContainer {
            autoScalingGroupsDecoded0 = [Swift.String]()
            for string0 in autoScalingGroupsContainer {
                if let string0 = string0 {
                    autoScalingGroupsDecoded0?.append(string0)
                }
            }
        }
        autoScalingGroups = autoScalingGroupsDecoded0
        let ruleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ruleNames)
        var ruleNamesDecoded0:[Swift.String]? = nil
        if let ruleNamesContainer = ruleNamesContainer {
            ruleNamesDecoded0 = [Swift.String]()
            for string0 in ruleNamesContainer {
                if let string0 = string0 {
                    ruleNamesDecoded0?.append(string0)
                }
            }
        }
        ruleNames = ruleNamesDecoded0
        let severitiesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Severity?].self, forKey: .severities)
        var severitiesDecoded0:[InspectorClientTypes.Severity]? = nil
        if let severitiesContainer = severitiesContainer {
            severitiesDecoded0 = [InspectorClientTypes.Severity]()
            for enum0 in severitiesContainer {
                if let enum0 = enum0 {
                    severitiesDecoded0?.append(enum0)
                }
            }
        }
        severities = severitiesDecoded0
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let userAttributesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Attribute?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[InspectorClientTypes.Attribute]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [InspectorClientTypes.Attribute]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let creationTimeRangeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.TimestampRange.self, forKey: .creationTimeRange)
        creationTimeRange = creationTimeRangeDecoded
    }
}

extension InspectorClientTypes {
    /// This data type is used as a request parameter in the [ListFindings] action.
    public struct FindingFilter: Swift.Equatable {
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the agentId property of the [Finding] data type.
        public var agentIds: [Swift.String]?
        /// For a record to match a filter, the list of values that are specified for this data type property must be contained in the list of values of the attributes property of the [Finding] data type.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the autoScalingGroup property of the [Finding] data type.
        public var autoScalingGroups: [Swift.String]?
        /// The time range during which the finding is generated.
        public var creationTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the ruleName property of the [Finding] data type.
        public var ruleNames: [Swift.String]?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the rulesPackageArn property of the [Finding] data type.
        public var rulesPackageArns: [Swift.String]?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the severity property of the [Finding] data type.
        public var severities: [InspectorClientTypes.Severity]?
        /// For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the userAttributes property of the [Finding] data type.
        public var userAttributes: [InspectorClientTypes.Attribute]?

        public init(
            agentIds: [Swift.String]? = nil,
            attributes: [InspectorClientTypes.Attribute]? = nil,
            autoScalingGroups: [Swift.String]? = nil,
            creationTimeRange: InspectorClientTypes.TimestampRange? = nil,
            ruleNames: [Swift.String]? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            severities: [InspectorClientTypes.Severity]? = nil,
            userAttributes: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.agentIds = agentIds
            self.attributes = attributes
            self.autoScalingGroups = autoScalingGroups
            self.creationTimeRange = creationTimeRange
            self.ruleNames = ruleNames
            self.rulesPackageArns = rulesPackageArns
            self.severities = severities
            self.userAttributes = userAttributes
        }
    }

}

extension GetAssessmentReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case reportFileFormat
        case reportType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = self.assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let reportFileFormat = self.reportFileFormat {
            try encodeContainer.encode(reportFileFormat.rawValue, forKey: .reportFileFormat)
        }
        if let reportType = self.reportType {
            try encodeContainer.encode(reportType.rawValue, forKey: .reportType)
        }
    }
}

extension GetAssessmentReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAssessmentReportInput: Swift.Equatable {
    /// The ARN that specifies the assessment run for which you want to generate a report.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// Specifies the file format (html or pdf) of the assessment report that you want to generate.
    /// This member is required.
    public var reportFileFormat: InspectorClientTypes.ReportFileFormat?
    /// Specifies the type of the assessment report that you want to generate. There are two types of assessment reports: a finding report and a full report. For more information, see [Assessment Reports](https://docs.aws.amazon.com/inspector/latest/userguide/inspector_reports.html).
    /// This member is required.
    public var reportType: InspectorClientTypes.ReportType?

    public init(
        assessmentRunArn: Swift.String? = nil,
        reportFileFormat: InspectorClientTypes.ReportFileFormat? = nil,
        reportType: InspectorClientTypes.ReportType? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.reportFileFormat = reportFileFormat
        self.reportType = reportType
    }
}

struct GetAssessmentReportInputBody: Swift.Equatable {
    let assessmentRunArn: Swift.String?
    let reportFileFormat: InspectorClientTypes.ReportFileFormat?
    let reportType: InspectorClientTypes.ReportType?
}

extension GetAssessmentReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case reportFileFormat
        case reportType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let reportFileFormatDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.ReportFileFormat.self, forKey: .reportFileFormat)
        reportFileFormat = reportFileFormatDecoded
        let reportTypeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.ReportType.self, forKey: .reportType)
        reportType = reportTypeDecoded
    }
}

extension GetAssessmentReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssessmentReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.url = output.url
        } else {
            self.status = nil
            self.url = nil
        }
    }
}

public struct GetAssessmentReportOutput: Swift.Equatable {
    /// Specifies the status of the request to generate an assessment report.
    /// This member is required.
    public var status: InspectorClientTypes.ReportStatus?
    /// Specifies the URL where you can find the generated assessment report. This parameter is only returned if the report is successfully generated.
    public var url: Swift.String?

    public init(
        status: InspectorClientTypes.ReportStatus? = nil,
        url: Swift.String? = nil
    )
    {
        self.status = status
        self.url = url
    }
}

struct GetAssessmentReportOutputBody: Swift.Equatable {
    let status: InspectorClientTypes.ReportStatus?
    let url: Swift.String?
}

extension GetAssessmentReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case url
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.ReportStatus.self, forKey: .status)
        status = statusDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

enum GetAssessmentReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AssessmentRunInProgressException": return try await AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedFeatureException": return try await UnsupportedFeatureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExclusionsPreviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
        case locale
        case maxResults
        case nextToken
        case previewToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArn = self.assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let previewToken = self.previewToken {
            try encodeContainer.encode(previewToken, forKey: .previewToken)
        }
    }
}

extension GetExclusionsPreviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetExclusionsPreviewInput: Swift.Equatable {
    /// The ARN that specifies the assessment template for which the exclusions preview was requested.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?
    /// The locale into which you want to translate the exclusion's title, description, and recommendation.
    public var locale: InspectorClientTypes.Locale?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 100. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the GetExclusionsPreviewRequest action. Subsequent calls to the action fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// The unique identifier associated of the exclusions preview.
    /// This member is required.
    public var previewToken: Swift.String?

    public init(
        assessmentTemplateArn: Swift.String? = nil,
        locale: InspectorClientTypes.Locale? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        previewToken: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.previewToken = previewToken
    }
}

struct GetExclusionsPreviewInputBody: Swift.Equatable {
    let assessmentTemplateArn: Swift.String?
    let previewToken: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let locale: InspectorClientTypes.Locale?
}

extension GetExclusionsPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArn
        case locale
        case maxResults
        case nextToken
        case previewToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
        let previewTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previewToken)
        previewToken = previewTokenDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let localeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension GetExclusionsPreviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExclusionsPreviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.exclusionPreviews = output.exclusionPreviews
            self.nextToken = output.nextToken
            self.previewStatus = output.previewStatus
        } else {
            self.exclusionPreviews = nil
            self.nextToken = nil
            self.previewStatus = nil
        }
    }
}

public struct GetExclusionsPreviewOutput: Swift.Equatable {
    /// Information about the exclusions included in the preview.
    public var exclusionPreviews: [InspectorClientTypes.ExclusionPreview]?
    /// When a response is generated, if there is more data to be listed, this parameters is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?
    /// Specifies the status of the request to generate an exclusions preview.
    /// This member is required.
    public var previewStatus: InspectorClientTypes.PreviewStatus?

    public init(
        exclusionPreviews: [InspectorClientTypes.ExclusionPreview]? = nil,
        nextToken: Swift.String? = nil,
        previewStatus: InspectorClientTypes.PreviewStatus? = nil
    )
    {
        self.exclusionPreviews = exclusionPreviews
        self.nextToken = nextToken
        self.previewStatus = previewStatus
    }
}

struct GetExclusionsPreviewOutputBody: Swift.Equatable {
    let previewStatus: InspectorClientTypes.PreviewStatus?
    let exclusionPreviews: [InspectorClientTypes.ExclusionPreview]?
    let nextToken: Swift.String?
}

extension GetExclusionsPreviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusionPreviews
        case nextToken
        case previewStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewStatusDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.PreviewStatus.self, forKey: .previewStatus)
        previewStatus = previewStatusDecoded
        let exclusionPreviewsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.ExclusionPreview?].self, forKey: .exclusionPreviews)
        var exclusionPreviewsDecoded0:[InspectorClientTypes.ExclusionPreview]? = nil
        if let exclusionPreviewsContainer = exclusionPreviewsContainer {
            exclusionPreviewsDecoded0 = [InspectorClientTypes.ExclusionPreview]()
            for structure0 in exclusionPreviewsContainer {
                if let structure0 = structure0 {
                    exclusionPreviewsDecoded0?.append(structure0)
                }
            }
        }
        exclusionPreviews = exclusionPreviewsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetExclusionsPreviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTelemetryMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = self.assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
    }
}

extension GetTelemetryMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTelemetryMetadataInput: Swift.Equatable {
    /// The ARN that specifies the assessment run that has the telemetry data that you want to obtain.
    /// This member is required.
    public var assessmentRunArn: Swift.String?

    public init(
        assessmentRunArn: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

struct GetTelemetryMetadataInputBody: Swift.Equatable {
    let assessmentRunArn: Swift.String?
}

extension GetTelemetryMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

extension GetTelemetryMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTelemetryMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.telemetryMetadata = output.telemetryMetadata
        } else {
            self.telemetryMetadata = nil
        }
    }
}

public struct GetTelemetryMetadataOutput: Swift.Equatable {
    /// Telemetry details.
    /// This member is required.
    public var telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]?

    public init(
        telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]? = nil
    )
    {
        self.telemetryMetadata = telemetryMetadata
    }
}

struct GetTelemetryMetadataOutputBody: Swift.Equatable {
    let telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]?
}

extension GetTelemetryMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telemetryMetadata
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryMetadataContainer = try containerValues.decodeIfPresent([InspectorClientTypes.TelemetryMetadata?].self, forKey: .telemetryMetadata)
        var telemetryMetadataDecoded0:[InspectorClientTypes.TelemetryMetadata]? = nil
        if let telemetryMetadataContainer = telemetryMetadataContainer {
            telemetryMetadataDecoded0 = [InspectorClientTypes.TelemetryMetadata]()
            for structure0 in telemetryMetadataContainer {
                if let structure0 = structure0 {
                    telemetryMetadataDecoded0?.append(structure0)
                }
            }
        }
        telemetryMetadata = telemetryMetadataDecoded0
    }
}

enum GetTelemetryMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InspectorClientTypes {
    public enum InspectorEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assessmentRunCompleted
        case assessmentRunStarted
        case assessmentRunStateChanged
        case findingReported
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [InspectorEvent] {
            return [
                .assessmentRunCompleted,
                .assessmentRunStarted,
                .assessmentRunStateChanged,
                .findingReported,
                .other,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assessmentRunCompleted: return "ASSESSMENT_RUN_COMPLETED"
            case .assessmentRunStarted: return "ASSESSMENT_RUN_STARTED"
            case .assessmentRunStateChanged: return "ASSESSMENT_RUN_STATE_CHANGED"
            case .findingReported: return "FINDING_REPORTED"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InspectorEvent(rawValue: rawValue) ?? InspectorEvent.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.InspectorServiceAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case rulesPackageArn
        case schemaVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = self.assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let rulesPackageArn = self.rulesPackageArn {
            try encodeContainer.encode(rulesPackageArn, forKey: .rulesPackageArn)
        }
        if schemaVersion != 0 {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .schemaVersion) ?? 0
        schemaVersion = schemaVersionDecoded
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let rulesPackageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rulesPackageArn)
        rulesPackageArn = rulesPackageArnDecoded
    }
}

extension InspectorClientTypes {
    /// This data type is used in the [Finding] data type.
    public struct InspectorServiceAttributes: Swift.Equatable {
        /// The ARN of the assessment run during which the finding is generated.
        public var assessmentRunArn: Swift.String?
        /// The ARN of the rules package that is used to generate the finding.
        public var rulesPackageArn: Swift.String?
        /// The schema version of this data type.
        /// This member is required.
        public var schemaVersion: Swift.Int

        public init(
            assessmentRunArn: Swift.String? = nil,
            rulesPackageArn: Swift.String? = nil,
            schemaVersion: Swift.Int = 0
        )
        {
            self.assessmentRunArn = assessmentRunArn
            self.rulesPackageArn = rulesPackageArn
            self.schemaVersion = schemaVersion
        }
    }

}

extension InternalException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.canRetry = output.canRetry
            self.properties.message = output.message
        } else {
            self.properties.canRetry = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Internal server error.
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let canRetry: Swift.Bool?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension InspectorClientTypes {
    public enum InvalidCrossAccountRoleErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case roleDoesNotExistOrInvalidTrustRelationship
        case roleDoesNotHaveCorrectPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [InvalidCrossAccountRoleErrorCode] {
            return [
                .roleDoesNotExistOrInvalidTrustRelationship,
                .roleDoesNotHaveCorrectPolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .roleDoesNotExistOrInvalidTrustRelationship: return "ROLE_DOES_NOT_EXIST_OR_INVALID_TRUST_RELATIONSHIP"
            case .roleDoesNotHaveCorrectPolicy: return "ROLE_DOES_NOT_HAVE_CORRECT_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvalidCrossAccountRoleErrorCode(rawValue: rawValue) ?? InvalidCrossAccountRoleErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension InvalidCrossAccountRoleException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCrossAccountRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.canRetry = output.canRetry
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.canRetry = nil
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon Inspector cannot assume the cross-account role that it needs to list your EC2 instances during the assessment run.
public struct InvalidCrossAccountRoleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Code that indicates the type of error that is generated.
        /// This member is required.
        public internal(set) var errorCode: InspectorClientTypes.InvalidCrossAccountRoleErrorCode? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCrossAccountRoleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.InvalidCrossAccountRoleErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct InvalidCrossAccountRoleExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let errorCode: InspectorClientTypes.InvalidCrossAccountRoleErrorCode?
    let canRetry: Swift.Bool?
}

extension InvalidCrossAccountRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InvalidCrossAccountRoleErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension InspectorClientTypes {
    public enum InvalidInputErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assessmentTargetNameAlreadyTaken
        case assessmentTemplateNameAlreadyTaken
        case invalidAgentId
        case invalidAssessmentRunArn
        case invalidAssessmentRunCompletionTimeRange
        case invalidAssessmentRunDurationRange
        case invalidAssessmentRunStartTimeRange
        case invalidAssessmentRunState
        case invalidAssessmentRunStateChangeTimeRange
        case invalidAssessmentTargetArn
        case invalidAssessmentTargetName
        case invalidAssessmentTargetNamePattern
        case invalidAssessmentTemplateArn
        case invalidAssessmentTemplateDuration
        case invalidAssessmentTemplateDurationRange
        case invalidAssessmentTemplateName
        case invalidAssessmentTemplateNamePattern
        case invalidAttribute
        case invalidAutoScalingGroup
        case invalidEvent
        case invalidFindingArn
        case invalidIamRoleArn
        case invalidLocale
        case invalidMaxResults
        case invalidNumberOfAgentIds
        case invalidNumberOfAssessmentRunArns
        case invalidNumberOfAssessmentRunStates
        case invalidNumberOfAssessmentTargetArns
        case invalidNumberOfAssessmentTemplateArns
        case invalidNumberOfAttributes
        case invalidNumberOfAutoScalingGroups
        case invalidNumberOfFindingArns
        case invalidNumberOfResourceGroupArns
        case invalidNumberOfResourceGroupTags
        case invalidNumberOfRulesPackageArns
        case invalidNumberOfRuleNames
        case invalidNumberOfSeverities
        case invalidNumberOfTags
        case invalidNumberOfUserAttributes
        case invalidPaginationToken
        case invalidResourceArn
        case invalidResourceGroupArn
        case invalidResourceGroupTagKey
        case invalidResourceGroupTagValue
        case invalidRulesPackageArn
        case invalidRuleName
        case invalidSeverity
        case invalidSnsTopicArn
        case invalidTag
        case invalidTagKey
        case invalidTagValue
        case invalidUserAttribute
        case invalidUserAttributeKey
        case invalidUserAttributeValue
        case sdkUnknown(Swift.String)

        public static var allCases: [InvalidInputErrorCode] {
            return [
                .assessmentTargetNameAlreadyTaken,
                .assessmentTemplateNameAlreadyTaken,
                .invalidAgentId,
                .invalidAssessmentRunArn,
                .invalidAssessmentRunCompletionTimeRange,
                .invalidAssessmentRunDurationRange,
                .invalidAssessmentRunStartTimeRange,
                .invalidAssessmentRunState,
                .invalidAssessmentRunStateChangeTimeRange,
                .invalidAssessmentTargetArn,
                .invalidAssessmentTargetName,
                .invalidAssessmentTargetNamePattern,
                .invalidAssessmentTemplateArn,
                .invalidAssessmentTemplateDuration,
                .invalidAssessmentTemplateDurationRange,
                .invalidAssessmentTemplateName,
                .invalidAssessmentTemplateNamePattern,
                .invalidAttribute,
                .invalidAutoScalingGroup,
                .invalidEvent,
                .invalidFindingArn,
                .invalidIamRoleArn,
                .invalidLocale,
                .invalidMaxResults,
                .invalidNumberOfAgentIds,
                .invalidNumberOfAssessmentRunArns,
                .invalidNumberOfAssessmentRunStates,
                .invalidNumberOfAssessmentTargetArns,
                .invalidNumberOfAssessmentTemplateArns,
                .invalidNumberOfAttributes,
                .invalidNumberOfAutoScalingGroups,
                .invalidNumberOfFindingArns,
                .invalidNumberOfResourceGroupArns,
                .invalidNumberOfResourceGroupTags,
                .invalidNumberOfRulesPackageArns,
                .invalidNumberOfRuleNames,
                .invalidNumberOfSeverities,
                .invalidNumberOfTags,
                .invalidNumberOfUserAttributes,
                .invalidPaginationToken,
                .invalidResourceArn,
                .invalidResourceGroupArn,
                .invalidResourceGroupTagKey,
                .invalidResourceGroupTagValue,
                .invalidRulesPackageArn,
                .invalidRuleName,
                .invalidSeverity,
                .invalidSnsTopicArn,
                .invalidTag,
                .invalidTagKey,
                .invalidTagValue,
                .invalidUserAttribute,
                .invalidUserAttributeKey,
                .invalidUserAttributeValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assessmentTargetNameAlreadyTaken: return "ASSESSMENT_TARGET_NAME_ALREADY_TAKEN"
            case .assessmentTemplateNameAlreadyTaken: return "ASSESSMENT_TEMPLATE_NAME_ALREADY_TAKEN"
            case .invalidAgentId: return "INVALID_AGENT_ID"
            case .invalidAssessmentRunArn: return "INVALID_ASSESSMENT_RUN_ARN"
            case .invalidAssessmentRunCompletionTimeRange: return "INVALID_ASSESSMENT_RUN_COMPLETION_TIME_RANGE"
            case .invalidAssessmentRunDurationRange: return "INVALID_ASSESSMENT_RUN_DURATION_RANGE"
            case .invalidAssessmentRunStartTimeRange: return "INVALID_ASSESSMENT_RUN_START_TIME_RANGE"
            case .invalidAssessmentRunState: return "INVALID_ASSESSMENT_RUN_STATE"
            case .invalidAssessmentRunStateChangeTimeRange: return "INVALID_ASSESSMENT_RUN_STATE_CHANGE_TIME_RANGE"
            case .invalidAssessmentTargetArn: return "INVALID_ASSESSMENT_TARGET_ARN"
            case .invalidAssessmentTargetName: return "INVALID_ASSESSMENT_TARGET_NAME"
            case .invalidAssessmentTargetNamePattern: return "INVALID_ASSESSMENT_TARGET_NAME_PATTERN"
            case .invalidAssessmentTemplateArn: return "INVALID_ASSESSMENT_TEMPLATE_ARN"
            case .invalidAssessmentTemplateDuration: return "INVALID_ASSESSMENT_TEMPLATE_DURATION"
            case .invalidAssessmentTemplateDurationRange: return "INVALID_ASSESSMENT_TEMPLATE_DURATION_RANGE"
            case .invalidAssessmentTemplateName: return "INVALID_ASSESSMENT_TEMPLATE_NAME"
            case .invalidAssessmentTemplateNamePattern: return "INVALID_ASSESSMENT_TEMPLATE_NAME_PATTERN"
            case .invalidAttribute: return "INVALID_ATTRIBUTE"
            case .invalidAutoScalingGroup: return "INVALID_AUTO_SCALING_GROUP"
            case .invalidEvent: return "INVALID_EVENT"
            case .invalidFindingArn: return "INVALID_FINDING_ARN"
            case .invalidIamRoleArn: return "INVALID_IAM_ROLE_ARN"
            case .invalidLocale: return "INVALID_LOCALE"
            case .invalidMaxResults: return "INVALID_MAX_RESULTS"
            case .invalidNumberOfAgentIds: return "INVALID_NUMBER_OF_AGENT_IDS"
            case .invalidNumberOfAssessmentRunArns: return "INVALID_NUMBER_OF_ASSESSMENT_RUN_ARNS"
            case .invalidNumberOfAssessmentRunStates: return "INVALID_NUMBER_OF_ASSESSMENT_RUN_STATES"
            case .invalidNumberOfAssessmentTargetArns: return "INVALID_NUMBER_OF_ASSESSMENT_TARGET_ARNS"
            case .invalidNumberOfAssessmentTemplateArns: return "INVALID_NUMBER_OF_ASSESSMENT_TEMPLATE_ARNS"
            case .invalidNumberOfAttributes: return "INVALID_NUMBER_OF_ATTRIBUTES"
            case .invalidNumberOfAutoScalingGroups: return "INVALID_NUMBER_OF_AUTO_SCALING_GROUPS"
            case .invalidNumberOfFindingArns: return "INVALID_NUMBER_OF_FINDING_ARNS"
            case .invalidNumberOfResourceGroupArns: return "INVALID_NUMBER_OF_RESOURCE_GROUP_ARNS"
            case .invalidNumberOfResourceGroupTags: return "INVALID_NUMBER_OF_RESOURCE_GROUP_TAGS"
            case .invalidNumberOfRulesPackageArns: return "INVALID_NUMBER_OF_RULES_PACKAGE_ARNS"
            case .invalidNumberOfRuleNames: return "INVALID_NUMBER_OF_RULE_NAMES"
            case .invalidNumberOfSeverities: return "INVALID_NUMBER_OF_SEVERITIES"
            case .invalidNumberOfTags: return "INVALID_NUMBER_OF_TAGS"
            case .invalidNumberOfUserAttributes: return "INVALID_NUMBER_OF_USER_ATTRIBUTES"
            case .invalidPaginationToken: return "INVALID_PAGINATION_TOKEN"
            case .invalidResourceArn: return "INVALID_RESOURCE_ARN"
            case .invalidResourceGroupArn: return "INVALID_RESOURCE_GROUP_ARN"
            case .invalidResourceGroupTagKey: return "INVALID_RESOURCE_GROUP_TAG_KEY"
            case .invalidResourceGroupTagValue: return "INVALID_RESOURCE_GROUP_TAG_VALUE"
            case .invalidRulesPackageArn: return "INVALID_RULES_PACKAGE_ARN"
            case .invalidRuleName: return "INVALID_RULE_NAME"
            case .invalidSeverity: return "INVALID_SEVERITY"
            case .invalidSnsTopicArn: return "INVALID_SNS_TOPIC_ARN"
            case .invalidTag: return "INVALID_TAG"
            case .invalidTagKey: return "INVALID_TAG_KEY"
            case .invalidTagValue: return "INVALID_TAG_VALUE"
            case .invalidUserAttribute: return "INVALID_USER_ATTRIBUTE"
            case .invalidUserAttributeKey: return "INVALID_USER_ATTRIBUTE_KEY"
            case .invalidUserAttributeValue: return "INVALID_USER_ATTRIBUTE_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvalidInputErrorCode(rawValue: rawValue) ?? InvalidInputErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension InvalidInputException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.canRetry = output.canRetry
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.canRetry = nil
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because an invalid or out-of-range value was supplied for an input parameter.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Code that indicates the type of error that is generated.
        /// This member is required.
        public internal(set) var errorCode: InspectorClientTypes.InvalidInputErrorCode? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.InvalidInputErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let errorCode: InspectorClientTypes.InvalidInputErrorCode?
    let canRetry: Swift.Bool?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InvalidInputErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension InspectorClientTypes {
    public enum LimitExceededErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assessmentRunLimitExceeded
        case assessmentTargetLimitExceeded
        case assessmentTemplateLimitExceeded
        case eventSubscriptionLimitExceeded
        case resourceGroupLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LimitExceededErrorCode] {
            return [
                .assessmentRunLimitExceeded,
                .assessmentTargetLimitExceeded,
                .assessmentTemplateLimitExceeded,
                .eventSubscriptionLimitExceeded,
                .resourceGroupLimitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assessmentRunLimitExceeded: return "ASSESSMENT_RUN_LIMIT_EXCEEDED"
            case .assessmentTargetLimitExceeded: return "ASSESSMENT_TARGET_LIMIT_EXCEEDED"
            case .assessmentTemplateLimitExceeded: return "ASSESSMENT_TEMPLATE_LIMIT_EXCEEDED"
            case .eventSubscriptionLimitExceeded: return "EVENT_SUBSCRIPTION_LIMIT_EXCEEDED"
            case .resourceGroupLimitExceeded: return "RESOURCE_GROUP_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LimitExceededErrorCode(rawValue: rawValue) ?? LimitExceededErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.canRetry = output.canRetry
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.canRetry = nil
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current AWS account limits. The error code describes the limit exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Code that indicates the type of error that is generated.
        /// This member is required.
        public internal(set) var errorCode: InspectorClientTypes.LimitExceededErrorCode? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.LimitExceededErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let errorCode: InspectorClientTypes.LimitExceededErrorCode?
    let canRetry: Swift.Bool?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.LimitExceededErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension ListAssessmentRunAgentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = self.assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAssessmentRunAgentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssessmentRunAgentsInput: Swift.Equatable {
    /// The ARN that specifies the assessment run whose agents you want to list.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
    public var filter: InspectorClientTypes.AgentFilter?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentRunAgents action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        assessmentRunArn: Swift.String? = nil,
        filter: InspectorClientTypes.AgentFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunAgentsInputBody: Swift.Equatable {
    let assessmentRunArn: Swift.String?
    let filter: InspectorClientTypes.AgentFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAssessmentRunAgentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case filter
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let filterDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AgentFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentRunAgentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssessmentRunAgentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentRunAgents = output.assessmentRunAgents
            self.nextToken = output.nextToken
        } else {
            self.assessmentRunAgents = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentRunAgentsOutput: Swift.Equatable {
    /// A list of ARNs that specifies the agents returned by the action.
    /// This member is required.
    public var assessmentRunAgents: [InspectorClientTypes.AssessmentRunAgent]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        assessmentRunAgents: [InspectorClientTypes.AssessmentRunAgent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunAgents = assessmentRunAgents
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunAgentsOutputBody: Swift.Equatable {
    let assessmentRunAgents: [InspectorClientTypes.AssessmentRunAgent]?
    let nextToken: Swift.String?
}

extension ListAssessmentRunAgentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunAgents
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunAgentsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AssessmentRunAgent?].self, forKey: .assessmentRunAgents)
        var assessmentRunAgentsDecoded0:[InspectorClientTypes.AssessmentRunAgent]? = nil
        if let assessmentRunAgentsContainer = assessmentRunAgentsContainer {
            assessmentRunAgentsDecoded0 = [InspectorClientTypes.AssessmentRunAgent]()
            for structure0 in assessmentRunAgentsContainer {
                if let structure0 = structure0 {
                    assessmentRunAgentsDecoded0?.append(structure0)
                }
            }
        }
        assessmentRunAgents = assessmentRunAgentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssessmentRunAgentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssessmentRunsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArns
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArns = assessmentTemplateArns {
            var assessmentTemplateArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTemplateArns)
            for arn0 in assessmentTemplateArns {
                try assessmentTemplateArnsContainer.encode(arn0)
            }
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAssessmentRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssessmentRunsInput: Swift.Equatable {
    /// The ARNs that specify the assessment templates whose assessment runs you want to list.
    public var assessmentTemplateArns: [Swift.String]?
    /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
    public var filter: InspectorClientTypes.AssessmentRunFilter?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentRuns action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        assessmentTemplateArns: [Swift.String]? = nil,
        filter: InspectorClientTypes.AssessmentRunFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunsInputBody: Swift.Equatable {
    let assessmentTemplateArns: [Swift.String]?
    let filter: InspectorClientTypes.AssessmentRunFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAssessmentRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArns
        case filter
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTemplateArns)
        var assessmentTemplateArnsDecoded0:[Swift.String]? = nil
        if let assessmentTemplateArnsContainer = assessmentTemplateArnsContainer {
            assessmentTemplateArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTemplateArnsContainer {
                if let string0 = string0 {
                    assessmentTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTemplateArns = assessmentTemplateArnsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentRunFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssessmentRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentRunArns = output.assessmentRunArns
            self.nextToken = output.nextToken
        } else {
            self.assessmentRunArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentRunsOutput: Swift.Equatable {
    /// A list of ARNs that specifies the assessment runs that are returned by the action.
    /// This member is required.
    public var assessmentRunArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        assessmentRunArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunsOutputBody: Swift.Equatable {
    let assessmentRunArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAssessmentRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[Swift.String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [Swift.String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssessmentRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssessmentTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAssessmentTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssessmentTargetsInput: Swift.Equatable {
    /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
    public var filter: InspectorClientTypes.AssessmentTargetFilter?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentTargets action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        filter: InspectorClientTypes.AssessmentTargetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentTargetsInputBody: Swift.Equatable {
    let filter: InspectorClientTypes.AssessmentTargetFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAssessmentTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentTargetFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentTargetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssessmentTargetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTargetArns = output.assessmentTargetArns
            self.nextToken = output.nextToken
        } else {
            self.assessmentTargetArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentTargetsOutput: Swift.Equatable {
    /// A list of ARNs that specifies the assessment targets that are returned by the action.
    /// This member is required.
    public var assessmentTargetArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        assessmentTargetArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
        self.nextToken = nextToken
    }
}

struct ListAssessmentTargetsOutputBody: Swift.Equatable {
    let assessmentTargetArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAssessmentTargetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArns
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTargetArns)
        var assessmentTargetArnsDecoded0:[Swift.String]? = nil
        if let assessmentTargetArnsContainer = assessmentTargetArnsContainer {
            assessmentTargetArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTargetArnsContainer {
                if let string0 = string0 {
                    assessmentTargetArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTargetArns = assessmentTargetArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssessmentTargetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssessmentTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArns
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArns = assessmentTargetArns {
            var assessmentTargetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTargetArns)
            for arn0 in assessmentTargetArns {
                try assessmentTargetArnsContainer.encode(arn0)
            }
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAssessmentTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssessmentTemplatesInput: Swift.Equatable {
    /// A list of ARNs that specifies the assessment targets whose assessment templates you want to list.
    public var assessmentTargetArns: [Swift.String]?
    /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
    public var filter: InspectorClientTypes.AssessmentTemplateFilter?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentTemplates action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        assessmentTargetArns: [Swift.String]? = nil,
        filter: InspectorClientTypes.AssessmentTemplateFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentTemplatesInputBody: Swift.Equatable {
    let assessmentTargetArns: [Swift.String]?
    let filter: InspectorClientTypes.AssessmentTemplateFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAssessmentTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArns
        case filter
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTargetArns)
        var assessmentTargetArnsDecoded0:[Swift.String]? = nil
        if let assessmentTargetArnsContainer = assessmentTargetArnsContainer {
            assessmentTargetArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTargetArnsContainer {
                if let string0 = string0 {
                    assessmentTargetArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTargetArns = assessmentTargetArnsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.AssessmentTemplateFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssessmentTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTemplateArns = output.assessmentTemplateArns
            self.nextToken = output.nextToken
        } else {
            self.assessmentTemplateArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentTemplatesOutput: Swift.Equatable {
    /// A list of ARNs that specifies the assessment templates returned by the action.
    /// This member is required.
    public var assessmentTemplateArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        assessmentTemplateArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
        self.nextToken = nextToken
    }
}

struct ListAssessmentTemplatesOutputBody: Swift.Equatable {
    let assessmentTemplateArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAssessmentTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTemplateArns
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentTemplateArns)
        var assessmentTemplateArnsDecoded0:[Swift.String]? = nil
        if let assessmentTemplateArnsContainer = assessmentTemplateArnsContainer {
            assessmentTemplateArnsDecoded0 = [Swift.String]()
            for string0 in assessmentTemplateArnsContainer {
                if let string0 = string0 {
                    assessmentTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTemplateArns = assessmentTemplateArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssessmentTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEventSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListEventSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEventSubscriptionsInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListEventSubscriptions action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// The ARN of the assessment template for which you want to list the existing event subscriptions.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListEventSubscriptionsInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEventSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventSubscriptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventSubscriptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

public struct ListEventSubscriptionsOutput: Swift.Equatable {
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?
    /// Details of the returned event subscriptions.
    /// This member is required.
    public var subscriptions: [InspectorClientTypes.Subscription]?

    public init(
        nextToken: Swift.String? = nil,
        subscriptions: [InspectorClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListEventSubscriptionsOutputBody: Swift.Equatable {
    let subscriptions: [InspectorClientTypes.Subscription]?
    let nextToken: Swift.String?
}

extension ListEventSubscriptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case subscriptions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[InspectorClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [InspectorClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEventSubscriptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExclusionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = self.assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExclusionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExclusionsInput: Swift.Equatable {
    /// The ARN of the assessment run that generated the exclusions that you want to list.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 100. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListExclusionsRequest action. Subsequent calls to the action fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        assessmentRunArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExclusionsInputBody: Swift.Equatable {
    let assessmentRunArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListExclusionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListExclusionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExclusionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.exclusionArns = output.exclusionArns
            self.nextToken = output.nextToken
        } else {
            self.exclusionArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListExclusionsOutput: Swift.Equatable {
    /// A list of exclusions' ARNs returned by the action.
    /// This member is required.
    public var exclusionArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameters is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        exclusionArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exclusionArns = exclusionArns
        self.nextToken = nextToken
    }
}

struct ListExclusionsOutputBody: Swift.Equatable {
    let exclusionArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListExclusionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusionArns
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exclusionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclusionArns)
        var exclusionArnsDecoded0:[Swift.String]? = nil
        if let exclusionArnsContainer = exclusionArnsContainer {
            exclusionArnsDecoded0 = [Swift.String]()
            for string0 in exclusionArnsContainer {
                if let string0 = string0 {
                    exclusionArnsDecoded0?.append(string0)
                }
            }
        }
        exclusionArns = exclusionArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExclusionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArns = assessmentRunArns {
            var assessmentRunArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentRunArns)
            for arn0 in assessmentRunArns {
                try assessmentRunArnsContainer.encode(arn0)
            }
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFindingsInput: Swift.Equatable {
    /// The ARNs of the assessment runs that generate the findings that you want to list.
    public var assessmentRunArns: [Swift.String]?
    /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
    public var filter: InspectorClientTypes.FindingFilter?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListFindings action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        assessmentRunArns: [Swift.String]? = nil,
        filter: InspectorClientTypes.FindingFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFindingsInputBody: Swift.Equatable {
    let assessmentRunArns: [Swift.String]?
    let filter: InspectorClientTypes.FindingFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArns
        case filter
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[Swift.String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [Swift.String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.FindingFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findingArns = output.findingArns
            self.nextToken = output.nextToken
        } else {
            self.findingArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutput: Swift.Equatable {
    /// A list of ARNs that specifies the findings returned by the action.
    /// This member is required.
    public var findingArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        findingArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingArns = findingArns
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputBody: Swift.Equatable {
    let findingArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingArns
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[Swift.String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [Swift.String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRulesPackagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRulesPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRulesPackagesInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListRulesPackages action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRulesPackagesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRulesPackagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRulesPackagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRulesPackagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rulesPackageArns = output.rulesPackageArns
        } else {
            self.nextToken = nil
            self.rulesPackageArns = nil
        }
    }
}

public struct ListRulesPackagesOutput: Swift.Equatable {
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?
    /// The list of ARNs that specifies the rules packages returned by the action.
    /// This member is required.
    public var rulesPackageArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        rulesPackageArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.rulesPackageArns = rulesPackageArns
    }
}

struct ListRulesPackagesOutputBody: Swift.Equatable {
    let rulesPackageArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListRulesPackagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case rulesPackageArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[Swift.String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [Swift.String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRulesPackagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN that specifies the assessment template whose tags you want to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A collection of key and value pairs.
    /// This member is required.
    public var tags: [InspectorClientTypes.Tag]?

    public init(
        tags: [InspectorClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [InspectorClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[InspectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [InspectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InspectorClientTypes {
    public enum Locale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "EN_US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv6Addresses
        case networkInterfaceId
        case privateDnsName
        case privateIpAddress
        case privateIpAddresses
        case publicDnsName
        case publicIp
        case securityGroups
        case subnetId
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv6Addresses = ipv6Addresses {
            var ipv6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Addresses)
            for text0 in ipv6Addresses {
                try ipv6AddressesContainer.encode(text0)
            }
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateDnsName = self.privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for privateip0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(privateip0)
            }
        }
        if let publicDnsName = self.publicDnsName {
            try encodeContainer.encode(publicDnsName, forKey: .publicDnsName)
        }
        if let publicIp = self.publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroup0 in securityGroups {
                try securityGroupsContainer.encode(securitygroup0)
            }
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([InspectorClientTypes.PrivateIp?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[InspectorClientTypes.PrivateIp]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [InspectorClientTypes.PrivateIp]()
            for structure0 in privateIpAddressesContainer {
                if let structure0 = structure0 {
                    privateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let ipv6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipv6Addresses)
        var ipv6AddressesDecoded0:[Swift.String]? = nil
        if let ipv6AddressesContainer = ipv6AddressesContainer {
            ipv6AddressesDecoded0 = [Swift.String]()
            for string0 in ipv6AddressesContainer {
                if let string0 = string0 {
                    ipv6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipv6Addresses = ipv6AddressesDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.SecurityGroup?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[InspectorClientTypes.SecurityGroup]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [InspectorClientTypes.SecurityGroup]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension InspectorClientTypes {
    /// Contains information about the network interfaces interacting with an EC2 instance. This data type is used as one of the elements of the [AssetAttributes] data type.
    public struct NetworkInterface: Swift.Equatable {
        /// The IP addresses associated with the network interface.
        public var ipv6Addresses: [Swift.String]?
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The name of a private DNS associated with the network interface.
        public var privateDnsName: Swift.String?
        /// The private IP address associated with the network interface.
        public var privateIpAddress: Swift.String?
        /// A list of the private IP addresses associated with the network interface. Includes the privateDnsName and privateIpAddress.
        public var privateIpAddresses: [InspectorClientTypes.PrivateIp]?
        /// The name of a public DNS associated with the network interface.
        public var publicDnsName: Swift.String?
        /// The public IP address from which the network interface is reachable.
        public var publicIp: Swift.String?
        /// A list of the security groups associated with the network interface. Includes the groupId and groupName.
        public var securityGroups: [InspectorClientTypes.SecurityGroup]?
        /// The ID of a subnet associated with the network interface.
        public var subnetId: Swift.String?
        /// The ID of a VPC associated with the network interface.
        public var vpcId: Swift.String?

        public init(
            ipv6Addresses: [Swift.String]? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            privateIpAddresses: [InspectorClientTypes.PrivateIp]? = nil,
            publicDnsName: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            securityGroups: [InspectorClientTypes.SecurityGroup]? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension InspectorClientTypes {
    public enum NoSuchEntityErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assessmentRunDoesNotExist
        case assessmentTargetDoesNotExist
        case assessmentTemplateDoesNotExist
        case findingDoesNotExist
        case iamRoleDoesNotExist
        case resourceGroupDoesNotExist
        case rulesPackageDoesNotExist
        case snsTopicDoesNotExist
        case sdkUnknown(Swift.String)

        public static var allCases: [NoSuchEntityErrorCode] {
            return [
                .assessmentRunDoesNotExist,
                .assessmentTargetDoesNotExist,
                .assessmentTemplateDoesNotExist,
                .findingDoesNotExist,
                .iamRoleDoesNotExist,
                .resourceGroupDoesNotExist,
                .rulesPackageDoesNotExist,
                .snsTopicDoesNotExist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assessmentRunDoesNotExist: return "ASSESSMENT_RUN_DOES_NOT_EXIST"
            case .assessmentTargetDoesNotExist: return "ASSESSMENT_TARGET_DOES_NOT_EXIST"
            case .assessmentTemplateDoesNotExist: return "ASSESSMENT_TEMPLATE_DOES_NOT_EXIST"
            case .findingDoesNotExist: return "FINDING_DOES_NOT_EXIST"
            case .iamRoleDoesNotExist: return "IAM_ROLE_DOES_NOT_EXIST"
            case .resourceGroupDoesNotExist: return "RESOURCE_GROUP_DOES_NOT_EXIST"
            case .rulesPackageDoesNotExist: return "RULES_PACKAGE_DOES_NOT_EXIST"
            case .snsTopicDoesNotExist: return "SNS_TOPIC_DOES_NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NoSuchEntityErrorCode(rawValue: rawValue) ?? NoSuchEntityErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension NoSuchEntityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoSuchEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.canRetry = output.canRetry
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.canRetry = nil
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it referenced an entity that does not exist. The error code describes the entity.
public struct NoSuchEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Code that indicates the type of error that is generated.
        /// This member is required.
        public internal(set) var errorCode: InspectorClientTypes.NoSuchEntityErrorCode? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchEntityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.NoSuchEntityErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct NoSuchEntityExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let errorCode: InspectorClientTypes.NoSuchEntityErrorCode?
    let canRetry: Swift.Bool?
}

extension NoSuchEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.NoSuchEntityErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension PreviewAgentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case previewAgentsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let previewAgentsArn = self.previewAgentsArn {
            try encodeContainer.encode(previewAgentsArn, forKey: .previewAgentsArn)
        }
    }
}

extension PreviewAgentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PreviewAgentsInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the PreviewAgents action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// The ARN of the assessment target whose agents you want to preview.
    /// This member is required.
    public var previewAgentsArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        previewAgentsArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.previewAgentsArn = previewAgentsArn
    }
}

struct PreviewAgentsInputBody: Swift.Equatable {
    let previewAgentsArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension PreviewAgentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case previewAgentsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewAgentsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previewAgentsArn)
        previewAgentsArn = previewAgentsArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension PreviewAgentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PreviewAgentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentPreviews = output.agentPreviews
            self.nextToken = output.nextToken
        } else {
            self.agentPreviews = nil
            self.nextToken = nil
        }
    }
}

public struct PreviewAgentsOutput: Swift.Equatable {
    /// The resulting list of agents.
    /// This member is required.
    public var agentPreviews: [InspectorClientTypes.AgentPreview]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        agentPreviews: [InspectorClientTypes.AgentPreview]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentPreviews = agentPreviews
        self.nextToken = nextToken
    }
}

struct PreviewAgentsOutputBody: Swift.Equatable {
    let agentPreviews: [InspectorClientTypes.AgentPreview]?
    let nextToken: Swift.String?
}

extension PreviewAgentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentPreviews
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentPreviewsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.AgentPreview?].self, forKey: .agentPreviews)
        var agentPreviewsDecoded0:[InspectorClientTypes.AgentPreview]? = nil
        if let agentPreviewsContainer = agentPreviewsContainer {
            agentPreviewsDecoded0 = [InspectorClientTypes.AgentPreview]()
            for structure0 in agentPreviewsContainer {
                if let structure0 = structure0 {
                    agentPreviewsDecoded0?.append(structure0)
                }
            }
        }
        agentPreviews = agentPreviewsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum PreviewAgentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCrossAccountRoleException": return try await InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PreviewGenerationInProgressException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PreviewGenerationInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is rejected. The specified assessment template is currently generating an exclusions preview.
public struct PreviewGenerationInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreviewGenerationInProgressException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PreviewGenerationInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PreviewGenerationInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InspectorClientTypes {
    public enum PreviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case workInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [PreviewStatus] {
            return [
                .completed,
                .workInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .workInProgress: return "WORK_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PreviewStatus(rawValue: rawValue) ?? PreviewStatus.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.PrivateIp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privateDnsName
        case privateIpAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateDnsName = self.privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
    }
}

extension InspectorClientTypes {
    /// Contains information about a private IP address associated with a network interface. This data type is used as a response element in the [DescribeFindings] action.
    public struct PrivateIp: Swift.Equatable {
        /// The DNS name of the private IP address.
        public var privateDnsName: Swift.String?
        /// The full IP address of the network inteface.
        public var privateIpAddress: Swift.String?

        public init(
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil
        )
        {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }
    }

}

extension RegisterCrossAccountAccessRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension RegisterCrossAccountAccessRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterCrossAccountAccessRoleInput: Swift.Equatable {
    /// The ARN of the IAM role that grants Amazon Inspector access to AWS Services needed to perform security assessments.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

struct RegisterCrossAccountAccessRoleInputBody: Swift.Equatable {
    let roleArn: Swift.String?
}

extension RegisterCrossAccountAccessRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension RegisterCrossAccountAccessRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RegisterCrossAccountAccessRoleOutput: Swift.Equatable {

    public init() { }
}

enum RegisterCrossAccountAccessRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCrossAccountRoleException": return try await InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveAttributesFromFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeKeys
        case findingArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeKeys = attributeKeys {
            var attributeKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeKeys)
            for attributekey0 in attributeKeys {
                try attributeKeysContainer.encode(attributekey0)
            }
        }
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for arn0 in findingArns {
                try findingArnsContainer.encode(arn0)
            }
        }
    }
}

extension RemoveAttributesFromFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveAttributesFromFindingsInput: Swift.Equatable {
    /// The array of attribute keys that you want to remove from specified findings.
    /// This member is required.
    public var attributeKeys: [Swift.String]?
    /// The ARNs that specify the findings that you want to remove attributes from.
    /// This member is required.
    public var findingArns: [Swift.String]?

    public init(
        attributeKeys: [Swift.String]? = nil,
        findingArns: [Swift.String]? = nil
    )
    {
        self.attributeKeys = attributeKeys
        self.findingArns = findingArns
    }
}

struct RemoveAttributesFromFindingsInputBody: Swift.Equatable {
    let findingArns: [Swift.String]?
    let attributeKeys: [Swift.String]?
}

extension RemoveAttributesFromFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeKeys
        case findingArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[Swift.String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [Swift.String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let attributeKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeKeys)
        var attributeKeysDecoded0:[Swift.String]? = nil
        if let attributeKeysContainer = attributeKeysContainer {
            attributeKeysDecoded0 = [Swift.String]()
            for string0 in attributeKeysContainer {
                if let string0 = string0 {
                    attributeKeysDecoded0?.append(string0)
                }
            }
        }
        attributeKeys = attributeKeysDecoded0
    }
}

extension RemoveAttributesFromFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveAttributesFromFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
        } else {
            self.failedItems = nil
        }
    }
}

public struct RemoveAttributesFromFindingsOutput: Swift.Equatable {
    /// Attributes details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?

    public init(
        failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.failedItems = failedItems
    }
}

struct RemoveAttributesFromFindingsOutputBody: Swift.Equatable {
    let failedItems: [Swift.String:InspectorClientTypes.FailedItemDetails]?
}

extension RemoveAttributesFromFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedItemsContainer = try containerValues.decodeIfPresent([Swift.String: InspectorClientTypes.FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [Swift.String:InspectorClientTypes.FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [Swift.String:InspectorClientTypes.FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

enum RemoveAttributesFromFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InspectorClientTypes {
    public enum ReportFileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case html
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFileFormat] {
            return [
                .html,
                .pdf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .html: return "HTML"
            case .pdf: return "PDF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFileFormat(rawValue: rawValue) ?? ReportFileFormat.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes {
    public enum ReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case workInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportStatus] {
            return [
                .completed,
                .failed,
                .workInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .workInProgress: return "WORK_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportStatus(rawValue: rawValue) ?? ReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes {
    public enum ReportType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case finding
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportType] {
            return [
                .finding,
                .full,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .finding: return "FINDING"
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportType(rawValue: rawValue) ?? ReportType.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.ResourceGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for resourcegrouptag0 in tags {
                try tagsContainer.encode(resourcegrouptag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.ResourceGroupTag?].self, forKey: .tags)
        var tagsDecoded0:[InspectorClientTypes.ResourceGroupTag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [InspectorClientTypes.ResourceGroupTag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension InspectorClientTypes {
    /// Contains information about a resource group. The resource group defines a set of tags that, when queried, identify the AWS resources that make up the assessment target. This data type is used as the response element in the [DescribeResourceGroups] action.
    public struct ResourceGroup: Swift.Equatable {
        /// The ARN of the resource group.
        /// This member is required.
        public var arn: Swift.String?
        /// The time at which resource group is created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The tags (key and value pairs) of the resource group. This data type property is used in the [CreateResourceGroup] action.
        /// This member is required.
        public var tags: [InspectorClientTypes.ResourceGroupTag]?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            tags: [InspectorClientTypes.ResourceGroupTag]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.tags = tags
        }
    }

}

extension InspectorClientTypes.ResourceGroupTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension InspectorClientTypes {
    /// This data type is used as one of the elements of the [ResourceGroup] data type.
    public struct ResourceGroupTag: Swift.Equatable {
        /// A tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The value assigned to a tag key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension InspectorClientTypes.RulesPackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case name
        case provider
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension InspectorClientTypes {
    /// Contains information about an Amazon Inspector rules package. This data type is used as the response element in the [DescribeRulesPackages] action.
    public struct RulesPackage: Swift.Equatable {
        /// The ARN of the rules package.
        /// This member is required.
        public var arn: Swift.String?
        /// The description of the rules package.
        public var description: Swift.String?
        /// The name of the rules package.
        /// This member is required.
        public var name: Swift.String?
        /// The provider of the rules package.
        /// This member is required.
        public var provider: Swift.String?
        /// The version ID of the rules package.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
            self.provider = provider
            self.version = version
        }
    }

}

extension InspectorClientTypes.Scope: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.ScopeType.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension InspectorClientTypes {
    /// This data type contains key-value pairs that identify various Amazon resources.
    public struct Scope: Swift.Equatable {
        /// The type of the scope.
        public var key: InspectorClientTypes.ScopeType?
        /// The resource identifier for the specified scope type.
        public var value: Swift.String?

        public init(
            key: InspectorClientTypes.ScopeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension InspectorClientTypes {
    public enum ScopeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instanceId
        case rulesPackageArn
        case sdkUnknown(Swift.String)

        public static var allCases: [ScopeType] {
            return [
                .instanceId,
                .rulesPackageArn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instanceId: return "INSTANCE_ID"
            case .rulesPackageArn: return "RULES_PACKAGE_ARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScopeType(rawValue: rawValue) ?? ScopeType.sdkUnknown(rawValue)
        }
    }
}

extension InspectorClientTypes.SecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId
        case groupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension InspectorClientTypes {
    /// Contains information about a security group associated with a network interface. This data type is used as one of the elements of the [NetworkInterface] data type.
    public struct SecurityGroup: Swift.Equatable {
        /// The ID of the security group.
        public var groupId: Swift.String?
        /// The name of the security group.
        public var groupName: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension ServiceTemporarilyUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceTemporarilyUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.canRetry = output.canRetry
            self.properties.message = output.message
        } else {
            self.properties.canRetry = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The serice is temporary unavailable.
public struct ServiceTemporarilyUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can wait and then retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceTemporarilyUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.message = message
    }
}

struct ServiceTemporarilyUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let canRetry: Swift.Bool?
}

extension ServiceTemporarilyUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension SetTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension SetTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetTagsForResourceInput: Swift.Equatable {
    /// The ARN of the assessment template that you want to set tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of key and value pairs that you want to set to the assessment template.
    public var tags: [InspectorClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [InspectorClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct SetTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [InspectorClientTypes.Tag]?
}

extension SetTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[InspectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [InspectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SetTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetTagsForResourceOutput: Swift.Equatable {

    public init() { }
}

enum SetTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InspectorClientTypes {
    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case informational
        case low
        case medium
        case undefined
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .high,
                .informational,
                .low,
                .medium,
                .undefined,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .informational: return "Informational"
            case .low: return "Low"
            case .medium: return "Medium"
            case .undefined: return "Undefined"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Severity(rawValue: rawValue) ?? Severity.sdkUnknown(rawValue)
        }
    }
}

extension StartAssessmentRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunName
        case assessmentTemplateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunName = self.assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let assessmentTemplateArn = self.assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
    }
}

extension StartAssessmentRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartAssessmentRunInput: Swift.Equatable {
    /// You can specify the name for the assessment run. The name must be unique for the assessment template whose ARN is used to start the assessment run.
    public var assessmentRunName: Swift.String?
    /// The ARN of the assessment template of the assessment run that you want to start.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init(
        assessmentRunName: Swift.String? = nil,
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentRunName = assessmentRunName
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct StartAssessmentRunInputBody: Swift.Equatable {
    let assessmentTemplateArn: Swift.String?
    let assessmentRunName: Swift.String?
}

extension StartAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunName
        case assessmentTemplateArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
    }
}

extension StartAssessmentRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartAssessmentRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentRunArn = output.assessmentRunArn
        } else {
            self.assessmentRunArn = nil
        }
    }
}

public struct StartAssessmentRunOutput: Swift.Equatable {
    /// The ARN of the assessment run that has been started.
    /// This member is required.
    public var assessmentRunArn: Swift.String?

    public init(
        assessmentRunArn: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

struct StartAssessmentRunOutputBody: Swift.Equatable {
    let assessmentRunArn: Swift.String?
}

extension StartAssessmentRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

enum StartAssessmentRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AgentsAlreadyRunningAssessmentException": return try await AgentsAlreadyRunningAssessmentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCrossAccountRoleException": return try await InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InspectorClientTypes {
    public enum StopAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case skipEvaluation
        case startEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [StopAction] {
            return [
                .skipEvaluation,
                .startEvaluation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .skipEvaluation: return "SKIP_EVALUATION"
            case .startEvaluation: return "START_EVALUATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StopAction(rawValue: rawValue) ?? StopAction.sdkUnknown(rawValue)
        }
    }
}

extension StopAssessmentRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case stopAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = self.assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let stopAction = self.stopAction {
            try encodeContainer.encode(stopAction.rawValue, forKey: .stopAction)
        }
    }
}

extension StopAssessmentRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopAssessmentRunInput: Swift.Equatable {
    /// The ARN of the assessment run that you want to stop.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// An input option that can be set to either START_EVALUATION or SKIP_EVALUATION. START_EVALUATION (the default value), stops the AWS agent from collecting data and begins the results evaluation and the findings generation process. SKIP_EVALUATION cancels the assessment run immediately, after which no findings are generated.
    public var stopAction: InspectorClientTypes.StopAction?

    public init(
        assessmentRunArn: Swift.String? = nil,
        stopAction: InspectorClientTypes.StopAction? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.stopAction = stopAction
    }
}

struct StopAssessmentRunInputBody: Swift.Equatable {
    let assessmentRunArn: Swift.String?
    let stopAction: InspectorClientTypes.StopAction?
}

extension StopAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunArn
        case stopAction
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let stopActionDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.StopAction.self, forKey: .stopAction)
        stopAction = stopActionDecoded
    }
}

extension StopAssessmentRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopAssessmentRunOutput: Swift.Equatable {

    public init() { }
}

enum StopAssessmentRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SubscribeToEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }
}

extension SubscribeToEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SubscribeToEventInput: Swift.Equatable {
    /// The event for which you want to receive SNS notifications.
    /// This member is required.
    public var event: InspectorClientTypes.InspectorEvent?
    /// The ARN of the assessment template that is used during the event for which you want to receive SNS notifications.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ARN of the SNS topic to which the SNS notifications are sent.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        event: InspectorClientTypes.InspectorEvent? = nil,
        resourceArn: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.event = event
        self.resourceArn = resourceArn
        self.topicArn = topicArn
    }
}

struct SubscribeToEventInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let event: InspectorClientTypes.InspectorEvent?
    let topicArn: Swift.String?
}

extension SubscribeToEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let eventDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SubscribeToEventOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SubscribeToEventOutput: Swift.Equatable {

    public init() { }
}

enum SubscribeToEventOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InspectorClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscriptions
        case resourceArn
        case topicArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSubscriptions = eventSubscriptions {
            var eventSubscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSubscriptions)
            for eventsubscription0 in eventSubscriptions {
                try eventSubscriptionsContainer.encode(eventsubscription0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let eventSubscriptionsContainer = try containerValues.decodeIfPresent([InspectorClientTypes.EventSubscription?].self, forKey: .eventSubscriptions)
        var eventSubscriptionsDecoded0:[InspectorClientTypes.EventSubscription]? = nil
        if let eventSubscriptionsContainer = eventSubscriptionsContainer {
            eventSubscriptionsDecoded0 = [InspectorClientTypes.EventSubscription]()
            for structure0 in eventSubscriptionsContainer {
                if let structure0 = structure0 {
                    eventSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        eventSubscriptions = eventSubscriptionsDecoded0
    }
}

extension InspectorClientTypes {
    /// This data type is used as a response element in the [ListEventSubscriptions] action.
    public struct Subscription: Swift.Equatable {
        /// The list of existing event subscriptions.
        /// This member is required.
        public var eventSubscriptions: [InspectorClientTypes.EventSubscription]?
        /// The ARN of the assessment template that is used during the event for which the SNS notification is sent.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The ARN of the Amazon Simple Notification Service (SNS) topic to which the SNS notifications are sent.
        /// This member is required.
        public var topicArn: Swift.String?

        public init(
            eventSubscriptions: [InspectorClientTypes.EventSubscription]? = nil,
            resourceArn: Swift.String? = nil,
            topicArn: Swift.String? = nil
        )
        {
            self.eventSubscriptions = eventSubscriptions
            self.resourceArn = resourceArn
            self.topicArn = topicArn
        }
    }

}

extension InspectorClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension InspectorClientTypes {
    /// A key and value pair. This data type is used as a request parameter in the [SetTagsForResource] action and a response element in the [ListTagsForResource] action.
    public struct Tag: Swift.Equatable {
        /// A tag key.
        /// This member is required.
        public var key: Swift.String?
        /// A value assigned to a tag key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension InspectorClientTypes.TelemetryMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case dataSize
        case messageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let dataSize = self.dataSize {
            try encodeContainer.encode(dataSize, forKey: .dataSize)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType, forKey: .messageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let dataSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataSize)
        dataSize = dataSizeDecoded
    }
}

extension InspectorClientTypes {
    /// The metadata about the Amazon Inspector application data metrics collected by the agent. This data type is used as the response element in the [GetTelemetryMetadata] action.
    public struct TelemetryMetadata: Swift.Equatable {
        /// The count of messages that the agent sends to the Amazon Inspector service.
        /// This member is required.
        public var count: Swift.Int?
        /// The data size of messages that the agent sends to the Amazon Inspector service.
        public var dataSize: Swift.Int?
        /// A specific type of behavioral data that is collected by the agent.
        /// This member is required.
        public var messageType: Swift.String?

        public init(
            count: Swift.Int? = nil,
            dataSize: Swift.Int? = nil,
            messageType: Swift.String? = nil
        )
        {
            self.count = count
            self.dataSize = dataSize
            self.messageType = messageType
        }
    }

}

extension InspectorClientTypes.TimestampRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginDate
        case endDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginDate = self.beginDate {
            try encodeContainer.encodeTimestamp(beginDate, format: .epochSeconds, forKey: .beginDate)
        }
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .epochSeconds, forKey: .endDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .beginDate)
        beginDate = beginDateDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDate)
        endDate = endDateDecoded
    }
}

extension InspectorClientTypes {
    /// This data type is used in the [AssessmentRunFilter] data type.
    public struct TimestampRange: Swift.Equatable {
        /// The minimum value of the timestamp range.
        public var beginDate: ClientRuntime.Date?
        /// The maximum value of the timestamp range.
        public var endDate: ClientRuntime.Date?

        public init(
            beginDate: ClientRuntime.Date? = nil,
            endDate: ClientRuntime.Date? = nil
        )
        {
            self.beginDate = beginDate
            self.endDate = endDate
        }
    }

}

extension UnsubscribeFromEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }
}

extension UnsubscribeFromEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UnsubscribeFromEventInput: Swift.Equatable {
    /// The event for which you want to stop receiving SNS notifications.
    /// This member is required.
    public var event: InspectorClientTypes.InspectorEvent?
    /// The ARN of the assessment template that is used during the event for which you want to stop receiving SNS notifications.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ARN of the SNS topic to which SNS notifications are sent.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        event: InspectorClientTypes.InspectorEvent? = nil,
        resourceArn: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.event = event
        self.resourceArn = resourceArn
        self.topicArn = topicArn
    }
}

struct UnsubscribeFromEventInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let event: InspectorClientTypes.InspectorEvent?
    let topicArn: Swift.String?
}

extension UnsubscribeFromEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let eventDecoded = try containerValues.decodeIfPresent(InspectorClientTypes.InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension UnsubscribeFromEventOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UnsubscribeFromEventOutput: Swift.Equatable {

    public init() { }
}

enum UnsubscribeFromEventOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UnsupportedFeatureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedFeatureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.canRetry = output.canRetry
            self.properties.message = output.message
        } else {
            self.properties.canRetry = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Used by the [GetAssessmentReport] API. The request was rejected because you tried to generate a report for an assessment run that existed before reporting was supported in Amazon Inspector. You can only generate reports for assessment runs that took place or will take place after generating reports in Amazon Inspector became available.
public struct UnsupportedFeatureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedFeatureException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.message = message
    }
}

struct UnsupportedFeatureExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let canRetry: Swift.Bool?
}

extension UnsupportedFeatureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canRetry
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension UpdateAssessmentTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
        case assessmentTargetName
        case resourceGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArn = self.assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
        if let assessmentTargetName = self.assessmentTargetName {
            try encodeContainer.encode(assessmentTargetName, forKey: .assessmentTargetName)
        }
        if let resourceGroupArn = self.resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
    }
}

extension UpdateAssessmentTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAssessmentTargetInput: Swift.Equatable {
    /// The ARN of the assessment target that you want to update.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?
    /// The name of the assessment target that you want to update.
    /// This member is required.
    public var assessmentTargetName: Swift.String?
    /// The ARN of the resource group that is used to specify the new resource group to associate with the assessment target.
    public var resourceGroupArn: Swift.String?

    public init(
        assessmentTargetArn: Swift.String? = nil,
        assessmentTargetName: Swift.String? = nil,
        resourceGroupArn: Swift.String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
        self.assessmentTargetName = assessmentTargetName
        self.resourceGroupArn = resourceGroupArn
    }
}

struct UpdateAssessmentTargetInputBody: Swift.Equatable {
    let assessmentTargetArn: Swift.String?
    let assessmentTargetName: Swift.String?
    let resourceGroupArn: Swift.String?
}

extension UpdateAssessmentTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargetArn
        case assessmentTargetName
        case resourceGroupArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
        let assessmentTargetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentTargetName)
        assessmentTargetName = assessmentTargetNameDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
    }
}

extension UpdateAssessmentTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAssessmentTargetOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAssessmentTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoSuchEntityException": return try await NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceTemporarilyUnavailableException": return try await ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
