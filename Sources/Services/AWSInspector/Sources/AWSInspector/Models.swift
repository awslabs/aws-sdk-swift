//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteAssessmentRunOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAssessmentTargetOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAssessmentTemplateOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeCrossAccountAccessRoleInput: Swift.Sendable {

    public init() { }
}

public struct RegisterCrossAccountAccessRoleOutput: Swift.Sendable {

    public init() { }
}

public struct SetTagsForResourceOutput: Swift.Sendable {

    public init() { }
}

public struct StopAssessmentRunOutput: Swift.Sendable {

    public init() { }
}

public struct SubscribeToEventOutput: Swift.Sendable {

    public init() { }
}

public struct UnsubscribeFromEventOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAssessmentTargetOutput: Swift.Sendable {

    public init() { }
}

extension InspectorClientTypes {

    public enum AccessDeniedErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDeniedToAssessmentRun
        case accessDeniedToAssessmentTarget
        case accessDeniedToAssessmentTemplate
        case accessDeniedToFinding
        case accessDeniedToIamRole
        case accessDeniedToResourceGroup
        case accessDeniedToRulesPackage
        case accessDeniedToSnsTopic
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedErrorCode] {
            return [
                .accessDeniedToAssessmentRun,
                .accessDeniedToAssessmentTarget,
                .accessDeniedToAssessmentTemplate,
                .accessDeniedToFinding,
                .accessDeniedToIamRole,
                .accessDeniedToResourceGroup,
                .accessDeniedToRulesPackage,
                .accessDeniedToSnsTopic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDeniedToAssessmentRun: return "ACCESS_DENIED_TO_ASSESSMENT_RUN"
            case .accessDeniedToAssessmentTarget: return "ACCESS_DENIED_TO_ASSESSMENT_TARGET"
            case .accessDeniedToAssessmentTemplate: return "ACCESS_DENIED_TO_ASSESSMENT_TEMPLATE"
            case .accessDeniedToFinding: return "ACCESS_DENIED_TO_FINDING"
            case .accessDeniedToIamRole: return "ACCESS_DENIED_TO_IAM_ROLE"
            case .accessDeniedToResourceGroup: return "ACCESS_DENIED_TO_RESOURCE_GROUP"
            case .accessDeniedToRulesPackage: return "ACCESS_DENIED_TO_RULES_PACKAGE"
            case .accessDeniedToSnsTopic: return "ACCESS_DENIED_TO_SNS_TOPIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// You do not have required permissions to access the requested resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Code that indicates the type of error that is generated.
        /// This member is required.
        public internal(set) var errorCode: InspectorClientTypes.AccessDeniedErrorCode? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.AccessDeniedErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

/// Internal server error.
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.message = message
    }
}

extension InspectorClientTypes {

    public enum InvalidInputErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assessmentTargetNameAlreadyTaken
        case assessmentTemplateNameAlreadyTaken
        case invalidAgentId
        case invalidAssessmentRunArn
        case invalidAssessmentRunCompletionTimeRange
        case invalidAssessmentRunDurationRange
        case invalidAssessmentRunStartTimeRange
        case invalidAssessmentRunState
        case invalidAssessmentRunStateChangeTimeRange
        case invalidAssessmentTargetArn
        case invalidAssessmentTargetName
        case invalidAssessmentTargetNamePattern
        case invalidAssessmentTemplateArn
        case invalidAssessmentTemplateDuration
        case invalidAssessmentTemplateDurationRange
        case invalidAssessmentTemplateName
        case invalidAssessmentTemplateNamePattern
        case invalidAttribute
        case invalidAutoScalingGroup
        case invalidEvent
        case invalidFindingArn
        case invalidIamRoleArn
        case invalidLocale
        case invalidMaxResults
        case invalidNumberOfAgentIds
        case invalidNumberOfAssessmentRunArns
        case invalidNumberOfAssessmentRunStates
        case invalidNumberOfAssessmentTargetArns
        case invalidNumberOfAssessmentTemplateArns
        case invalidNumberOfAttributes
        case invalidNumberOfAutoScalingGroups
        case invalidNumberOfFindingArns
        case invalidNumberOfResourceGroupArns
        case invalidNumberOfResourceGroupTags
        case invalidNumberOfRulesPackageArns
        case invalidNumberOfRuleNames
        case invalidNumberOfSeverities
        case invalidNumberOfTags
        case invalidNumberOfUserAttributes
        case invalidPaginationToken
        case invalidResourceArn
        case invalidResourceGroupArn
        case invalidResourceGroupTagKey
        case invalidResourceGroupTagValue
        case invalidRulesPackageArn
        case invalidRuleName
        case invalidSeverity
        case invalidSnsTopicArn
        case invalidTag
        case invalidTagKey
        case invalidTagValue
        case invalidUserAttribute
        case invalidUserAttributeKey
        case invalidUserAttributeValue
        case sdkUnknown(Swift.String)

        public static var allCases: [InvalidInputErrorCode] {
            return [
                .assessmentTargetNameAlreadyTaken,
                .assessmentTemplateNameAlreadyTaken,
                .invalidAgentId,
                .invalidAssessmentRunArn,
                .invalidAssessmentRunCompletionTimeRange,
                .invalidAssessmentRunDurationRange,
                .invalidAssessmentRunStartTimeRange,
                .invalidAssessmentRunState,
                .invalidAssessmentRunStateChangeTimeRange,
                .invalidAssessmentTargetArn,
                .invalidAssessmentTargetName,
                .invalidAssessmentTargetNamePattern,
                .invalidAssessmentTemplateArn,
                .invalidAssessmentTemplateDuration,
                .invalidAssessmentTemplateDurationRange,
                .invalidAssessmentTemplateName,
                .invalidAssessmentTemplateNamePattern,
                .invalidAttribute,
                .invalidAutoScalingGroup,
                .invalidEvent,
                .invalidFindingArn,
                .invalidIamRoleArn,
                .invalidLocale,
                .invalidMaxResults,
                .invalidNumberOfAgentIds,
                .invalidNumberOfAssessmentRunArns,
                .invalidNumberOfAssessmentRunStates,
                .invalidNumberOfAssessmentTargetArns,
                .invalidNumberOfAssessmentTemplateArns,
                .invalidNumberOfAttributes,
                .invalidNumberOfAutoScalingGroups,
                .invalidNumberOfFindingArns,
                .invalidNumberOfResourceGroupArns,
                .invalidNumberOfResourceGroupTags,
                .invalidNumberOfRulesPackageArns,
                .invalidNumberOfRuleNames,
                .invalidNumberOfSeverities,
                .invalidNumberOfTags,
                .invalidNumberOfUserAttributes,
                .invalidPaginationToken,
                .invalidResourceArn,
                .invalidResourceGroupArn,
                .invalidResourceGroupTagKey,
                .invalidResourceGroupTagValue,
                .invalidRulesPackageArn,
                .invalidRuleName,
                .invalidSeverity,
                .invalidSnsTopicArn,
                .invalidTag,
                .invalidTagKey,
                .invalidTagValue,
                .invalidUserAttribute,
                .invalidUserAttributeKey,
                .invalidUserAttributeValue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assessmentTargetNameAlreadyTaken: return "ASSESSMENT_TARGET_NAME_ALREADY_TAKEN"
            case .assessmentTemplateNameAlreadyTaken: return "ASSESSMENT_TEMPLATE_NAME_ALREADY_TAKEN"
            case .invalidAgentId: return "INVALID_AGENT_ID"
            case .invalidAssessmentRunArn: return "INVALID_ASSESSMENT_RUN_ARN"
            case .invalidAssessmentRunCompletionTimeRange: return "INVALID_ASSESSMENT_RUN_COMPLETION_TIME_RANGE"
            case .invalidAssessmentRunDurationRange: return "INVALID_ASSESSMENT_RUN_DURATION_RANGE"
            case .invalidAssessmentRunStartTimeRange: return "INVALID_ASSESSMENT_RUN_START_TIME_RANGE"
            case .invalidAssessmentRunState: return "INVALID_ASSESSMENT_RUN_STATE"
            case .invalidAssessmentRunStateChangeTimeRange: return "INVALID_ASSESSMENT_RUN_STATE_CHANGE_TIME_RANGE"
            case .invalidAssessmentTargetArn: return "INVALID_ASSESSMENT_TARGET_ARN"
            case .invalidAssessmentTargetName: return "INVALID_ASSESSMENT_TARGET_NAME"
            case .invalidAssessmentTargetNamePattern: return "INVALID_ASSESSMENT_TARGET_NAME_PATTERN"
            case .invalidAssessmentTemplateArn: return "INVALID_ASSESSMENT_TEMPLATE_ARN"
            case .invalidAssessmentTemplateDuration: return "INVALID_ASSESSMENT_TEMPLATE_DURATION"
            case .invalidAssessmentTemplateDurationRange: return "INVALID_ASSESSMENT_TEMPLATE_DURATION_RANGE"
            case .invalidAssessmentTemplateName: return "INVALID_ASSESSMENT_TEMPLATE_NAME"
            case .invalidAssessmentTemplateNamePattern: return "INVALID_ASSESSMENT_TEMPLATE_NAME_PATTERN"
            case .invalidAttribute: return "INVALID_ATTRIBUTE"
            case .invalidAutoScalingGroup: return "INVALID_AUTO_SCALING_GROUP"
            case .invalidEvent: return "INVALID_EVENT"
            case .invalidFindingArn: return "INVALID_FINDING_ARN"
            case .invalidIamRoleArn: return "INVALID_IAM_ROLE_ARN"
            case .invalidLocale: return "INVALID_LOCALE"
            case .invalidMaxResults: return "INVALID_MAX_RESULTS"
            case .invalidNumberOfAgentIds: return "INVALID_NUMBER_OF_AGENT_IDS"
            case .invalidNumberOfAssessmentRunArns: return "INVALID_NUMBER_OF_ASSESSMENT_RUN_ARNS"
            case .invalidNumberOfAssessmentRunStates: return "INVALID_NUMBER_OF_ASSESSMENT_RUN_STATES"
            case .invalidNumberOfAssessmentTargetArns: return "INVALID_NUMBER_OF_ASSESSMENT_TARGET_ARNS"
            case .invalidNumberOfAssessmentTemplateArns: return "INVALID_NUMBER_OF_ASSESSMENT_TEMPLATE_ARNS"
            case .invalidNumberOfAttributes: return "INVALID_NUMBER_OF_ATTRIBUTES"
            case .invalidNumberOfAutoScalingGroups: return "INVALID_NUMBER_OF_AUTO_SCALING_GROUPS"
            case .invalidNumberOfFindingArns: return "INVALID_NUMBER_OF_FINDING_ARNS"
            case .invalidNumberOfResourceGroupArns: return "INVALID_NUMBER_OF_RESOURCE_GROUP_ARNS"
            case .invalidNumberOfResourceGroupTags: return "INVALID_NUMBER_OF_RESOURCE_GROUP_TAGS"
            case .invalidNumberOfRulesPackageArns: return "INVALID_NUMBER_OF_RULES_PACKAGE_ARNS"
            case .invalidNumberOfRuleNames: return "INVALID_NUMBER_OF_RULE_NAMES"
            case .invalidNumberOfSeverities: return "INVALID_NUMBER_OF_SEVERITIES"
            case .invalidNumberOfTags: return "INVALID_NUMBER_OF_TAGS"
            case .invalidNumberOfUserAttributes: return "INVALID_NUMBER_OF_USER_ATTRIBUTES"
            case .invalidPaginationToken: return "INVALID_PAGINATION_TOKEN"
            case .invalidResourceArn: return "INVALID_RESOURCE_ARN"
            case .invalidResourceGroupArn: return "INVALID_RESOURCE_GROUP_ARN"
            case .invalidResourceGroupTagKey: return "INVALID_RESOURCE_GROUP_TAG_KEY"
            case .invalidResourceGroupTagValue: return "INVALID_RESOURCE_GROUP_TAG_VALUE"
            case .invalidRulesPackageArn: return "INVALID_RULES_PACKAGE_ARN"
            case .invalidRuleName: return "INVALID_RULE_NAME"
            case .invalidSeverity: return "INVALID_SEVERITY"
            case .invalidSnsTopicArn: return "INVALID_SNS_TOPIC_ARN"
            case .invalidTag: return "INVALID_TAG"
            case .invalidTagKey: return "INVALID_TAG_KEY"
            case .invalidTagValue: return "INVALID_TAG_VALUE"
            case .invalidUserAttribute: return "INVALID_USER_ATTRIBUTE"
            case .invalidUserAttributeKey: return "INVALID_USER_ATTRIBUTE_KEY"
            case .invalidUserAttributeValue: return "INVALID_USER_ATTRIBUTE_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request was rejected because an invalid or out-of-range value was supplied for an input parameter.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Code that indicates the type of error that is generated.
        /// This member is required.
        public internal(set) var errorCode: InspectorClientTypes.InvalidInputErrorCode? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.InvalidInputErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension InspectorClientTypes {

    public enum NoSuchEntityErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assessmentRunDoesNotExist
        case assessmentTargetDoesNotExist
        case assessmentTemplateDoesNotExist
        case findingDoesNotExist
        case iamRoleDoesNotExist
        case resourceGroupDoesNotExist
        case rulesPackageDoesNotExist
        case snsTopicDoesNotExist
        case sdkUnknown(Swift.String)

        public static var allCases: [NoSuchEntityErrorCode] {
            return [
                .assessmentRunDoesNotExist,
                .assessmentTargetDoesNotExist,
                .assessmentTemplateDoesNotExist,
                .findingDoesNotExist,
                .iamRoleDoesNotExist,
                .resourceGroupDoesNotExist,
                .rulesPackageDoesNotExist,
                .snsTopicDoesNotExist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assessmentRunDoesNotExist: return "ASSESSMENT_RUN_DOES_NOT_EXIST"
            case .assessmentTargetDoesNotExist: return "ASSESSMENT_TARGET_DOES_NOT_EXIST"
            case .assessmentTemplateDoesNotExist: return "ASSESSMENT_TEMPLATE_DOES_NOT_EXIST"
            case .findingDoesNotExist: return "FINDING_DOES_NOT_EXIST"
            case .iamRoleDoesNotExist: return "IAM_ROLE_DOES_NOT_EXIST"
            case .resourceGroupDoesNotExist: return "RESOURCE_GROUP_DOES_NOT_EXIST"
            case .rulesPackageDoesNotExist: return "RULES_PACKAGE_DOES_NOT_EXIST"
            case .snsTopicDoesNotExist: return "SNS_TOPIC_DOES_NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request was rejected because it referenced an entity that does not exist. The error code describes the entity.
public struct NoSuchEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Code that indicates the type of error that is generated.
        /// This member is required.
        public internal(set) var errorCode: InspectorClientTypes.NoSuchEntityErrorCode? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchEntityException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.NoSuchEntityErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

/// The serice is temporary unavailable.
public struct ServiceTemporarilyUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can wait and then retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceTemporarilyUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.message = message
    }
}

extension InspectorClientTypes {

    /// This data type is used as a request parameter in the [AddAttributesToFindings] and [CreateAssessmentTemplate] actions.
    public struct Attribute: Swift.Sendable {
        /// The attribute key.
        /// This member is required.
        public var key: Swift.String?
        /// The value assigned to the attribute key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct AddAttributesToFindingsInput: Swift.Sendable {
    /// The array of attributes that you want to assign to specified findings.
    /// This member is required.
    public var attributes: [InspectorClientTypes.Attribute]?
    /// The ARNs that specify the findings that you want to assign attributes to.
    /// This member is required.
    public var findingArns: [Swift.String]?

    public init(
        attributes: [InspectorClientTypes.Attribute]? = nil,
        findingArns: [Swift.String]? = nil
    )
    {
        self.attributes = attributes
        self.findingArns = findingArns
    }
}

extension InspectorClientTypes {

    public enum FailedItemErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case duplicateArn
        case internalError
        case invalidArn
        case itemDoesNotExist
        case limitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [FailedItemErrorCode] {
            return [
                .accessDenied,
                .duplicateArn,
                .internalError,
                .invalidArn,
                .itemDoesNotExist,
                .limitExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .duplicateArn: return "DUPLICATE_ARN"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidArn: return "INVALID_ARN"
            case .itemDoesNotExist: return "ITEM_DOES_NOT_EXIST"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InspectorClientTypes {

    /// Includes details about the failed items.
    public struct FailedItemDetails: Swift.Sendable {
        /// The status code of a failed item.
        /// This member is required.
        public var failureCode: InspectorClientTypes.FailedItemErrorCode?
        /// Indicates whether you can immediately retry a request for this item for a specified resource.
        /// This member is required.
        public var retryable: Swift.Bool?

        public init(
            failureCode: InspectorClientTypes.FailedItemErrorCode? = nil,
            retryable: Swift.Bool? = nil
        )
        {
            self.failureCode = failureCode
            self.retryable = retryable
        }
    }
}

public struct AddAttributesToFindingsOutput: Swift.Sendable {
    /// Attribute details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]?

    public init(
        failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.failedItems = failedItems
    }
}

extension InspectorClientTypes {

    /// Used in the exception error that is thrown if you start an assessment run for an assessment target that includes an EC2 instance that is already participating in another started assessment run.
    public struct AgentAlreadyRunningAssessment: Swift.Sendable {
        /// ID of the agent that is running on an EC2 instance that is already participating in another started assessment run.
        /// This member is required.
        public var agentId: Swift.String?
        /// The ARN of the assessment run that has already been started.
        /// This member is required.
        public var assessmentRunArn: Swift.String?

        public init(
            agentId: Swift.String? = nil,
            assessmentRunArn: Swift.String? = nil
        )
        {
            self.agentId = agentId
            self.assessmentRunArn = assessmentRunArn
        }
    }
}

extension InspectorClientTypes {

    public enum AgentHealthCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case idle
        case running
        case shutdown
        case throttled
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentHealthCode] {
            return [
                .idle,
                .running,
                .shutdown,
                .throttled,
                .unhealthy,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .idle: return "IDLE"
            case .running: return "RUNNING"
            case .shutdown: return "SHUTDOWN"
            case .throttled: return "THROTTLED"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InspectorClientTypes {

    public enum AgentHealth: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentHealth] {
            return [
                .healthy,
                .unhealthy,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InspectorClientTypes {

    /// Contains information about an Amazon Inspector agent. This data type is used as a request parameter in the [ListAssessmentRunAgents] action.
    public struct AgentFilter: Swift.Sendable {
        /// The detailed health state of the agent. Values can be set to IDLE, RUNNING, SHUTDOWN, UNHEALTHY, THROTTLED, and UNKNOWN.
        /// This member is required.
        public var agentHealthCodes: [InspectorClientTypes.AgentHealthCode]?
        /// The current health state of the agent. Values can be set to HEALTHY or UNHEALTHY.
        /// This member is required.
        public var agentHealths: [InspectorClientTypes.AgentHealth]?

        public init(
            agentHealthCodes: [InspectorClientTypes.AgentHealthCode]? = nil,
            agentHealths: [InspectorClientTypes.AgentHealth]? = nil
        )
        {
            self.agentHealthCodes = agentHealthCodes
            self.agentHealths = agentHealths
        }
    }
}

extension InspectorClientTypes {

    /// Used as a response element in the [PreviewAgents] action.
    public struct AgentPreview: Swift.Sendable {
        /// The health status of the Amazon Inspector Agent.
        public var agentHealth: InspectorClientTypes.AgentHealth?
        /// The ID of the EC2 instance where the agent is installed.
        /// This member is required.
        public var agentId: Swift.String?
        /// The version of the Amazon Inspector Agent.
        public var agentVersion: Swift.String?
        /// The Auto Scaling group for the EC2 instance where the agent is installed.
        public var autoScalingGroup: Swift.String?
        /// The hostname of the EC2 instance on which the Amazon Inspector Agent is installed.
        public var hostname: Swift.String?
        /// The IP address of the EC2 instance on which the Amazon Inspector Agent is installed.
        public var ipv4Address: Swift.String?
        /// The kernel version of the operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.
        public var kernelVersion: Swift.String?
        /// The operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.
        public var operatingSystem: Swift.String?

        public init(
            agentHealth: InspectorClientTypes.AgentHealth? = nil,
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            autoScalingGroup: Swift.String? = nil,
            hostname: Swift.String? = nil,
            ipv4Address: Swift.String? = nil,
            kernelVersion: Swift.String? = nil,
            operatingSystem: Swift.String? = nil
        )
        {
            self.agentHealth = agentHealth
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.autoScalingGroup = autoScalingGroup
            self.hostname = hostname
            self.ipv4Address = ipv4Address
            self.kernelVersion = kernelVersion
            self.operatingSystem = operatingSystem
        }
    }
}

/// You started an assessment run, but one of the instances is already participating in another assessment run.
public struct AgentsAlreadyRunningAssessmentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        /// This member is required.
        public internal(set) var agents: [InspectorClientTypes.AgentAlreadyRunningAssessment]? = nil
        ///
        /// This member is required.
        public internal(set) var agentsTruncated: Swift.Bool? = nil
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AgentsAlreadyRunningAssessmentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        agents: [InspectorClientTypes.AgentAlreadyRunningAssessment]? = nil,
        agentsTruncated: Swift.Bool? = nil,
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.agents = agents
        self.properties.agentsTruncated = agentsTruncated
        self.properties.canRetry = canRetry
        self.properties.message = message
    }
}

extension InspectorClientTypes {

    public enum Severity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case informational
        case low
        case medium
        case undefined
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .high,
                .informational,
                .low,
                .medium,
                .undefined
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .informational: return "Informational"
            case .low: return "Low"
            case .medium: return "Medium"
            case .undefined: return "Undefined"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InspectorClientTypes {

    public enum InspectorEvent: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assessmentRunCompleted
        case assessmentRunStarted
        case assessmentRunStateChanged
        case findingReported
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [InspectorEvent] {
            return [
                .assessmentRunCompleted,
                .assessmentRunStarted,
                .assessmentRunStateChanged,
                .findingReported,
                .other
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assessmentRunCompleted: return "ASSESSMENT_RUN_COMPLETED"
            case .assessmentRunStarted: return "ASSESSMENT_RUN_STARTED"
            case .assessmentRunStateChanged: return "ASSESSMENT_RUN_STATE_CHANGED"
            case .findingReported: return "FINDING_REPORTED"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InspectorClientTypes {

    public enum AssessmentRunNotificationSnsStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case internalError
        case success
        case topicDoesNotExist
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentRunNotificationSnsStatusCode] {
            return [
                .accessDenied,
                .internalError,
                .success,
                .topicDoesNotExist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalError: return "INTERNAL_ERROR"
            case .success: return "SUCCESS"
            case .topicDoesNotExist: return "TOPIC_DOES_NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InspectorClientTypes {

    /// Used as one of the elements of the [AssessmentRun] data type.
    public struct AssessmentRunNotification: Swift.Sendable {
        /// The date of the notification.
        /// This member is required.
        public var date: Foundation.Date?
        /// The Boolean value that specifies whether the notification represents an error.
        /// This member is required.
        public var error: Swift.Bool?
        /// The event for which a notification is sent.
        /// This member is required.
        public var event: InspectorClientTypes.InspectorEvent?
        /// The message included in the notification.
        public var message: Swift.String?
        /// The status code of the SNS notification.
        public var snsPublishStatusCode: InspectorClientTypes.AssessmentRunNotificationSnsStatusCode?
        /// The SNS topic to which the SNS notification is sent.
        public var snsTopicArn: Swift.String?

        public init(
            date: Foundation.Date? = nil,
            error: Swift.Bool? = nil,
            event: InspectorClientTypes.InspectorEvent? = nil,
            message: Swift.String? = nil,
            snsPublishStatusCode: InspectorClientTypes.AssessmentRunNotificationSnsStatusCode? = nil,
            snsTopicArn: Swift.String? = nil
        )
        {
            self.date = date
            self.error = error
            self.event = event
            self.message = message
            self.snsPublishStatusCode = snsPublishStatusCode
            self.snsTopicArn = snsTopicArn
        }
    }
}

extension InspectorClientTypes {

    public enum AssessmentRunState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case collectingData
        case completed
        case completedWithErrors
        case created
        case dataCollected
        case error
        case evaluatingRules
        case failed
        case startDataCollectionInProgress
        case startDataCollectionPending
        case startEvaluatingRulesPending
        case stopDataCollectionPending
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentRunState] {
            return [
                .canceled,
                .collectingData,
                .completed,
                .completedWithErrors,
                .created,
                .dataCollected,
                .error,
                .evaluatingRules,
                .failed,
                .startDataCollectionInProgress,
                .startDataCollectionPending,
                .startEvaluatingRulesPending,
                .stopDataCollectionPending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .collectingData: return "COLLECTING_DATA"
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .created: return "CREATED"
            case .dataCollected: return "DATA_COLLECTED"
            case .error: return "ERROR"
            case .evaluatingRules: return "EVALUATING_RULES"
            case .failed: return "FAILED"
            case .startDataCollectionInProgress: return "START_DATA_COLLECTION_IN_PROGRESS"
            case .startDataCollectionPending: return "START_DATA_COLLECTION_PENDING"
            case .startEvaluatingRulesPending: return "START_EVALUATING_RULES_PENDING"
            case .stopDataCollectionPending: return "STOP_DATA_COLLECTION_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InspectorClientTypes {

    /// Used as one of the elements of the [AssessmentRun] data type.
    public struct AssessmentRunStateChange: Swift.Sendable {
        /// The assessment run state.
        /// This member is required.
        public var state: InspectorClientTypes.AssessmentRunState?
        /// The last time the assessment run state changed.
        /// This member is required.
        public var stateChangedAt: Foundation.Date?

        public init(
            state: InspectorClientTypes.AssessmentRunState? = nil,
            stateChangedAt: Foundation.Date? = nil
        )
        {
            self.state = state
            self.stateChangedAt = stateChangedAt
        }
    }
}

extension InspectorClientTypes {

    /// A snapshot of an Amazon Inspector assessment run that contains the findings of the assessment run . Used as the response element in the [DescribeAssessmentRuns] action.
    public struct AssessmentRun: Swift.Sendable {
        /// The ARN of the assessment run.
        /// This member is required.
        public var arn: Swift.String?
        /// The ARN of the assessment template that is associated with the assessment run.
        /// This member is required.
        public var assessmentTemplateArn: Swift.String?
        /// The assessment run completion time that corresponds to the rules packages evaluation completion time or failure.
        public var completedAt: Foundation.Date?
        /// The time when [StartAssessmentRun] was called.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A Boolean value (true or false) that specifies whether the process of collecting data from the agents is completed.
        /// This member is required.
        public var dataCollected: Swift.Bool?
        /// The duration of the assessment run.
        /// This member is required.
        public var durationInSeconds: Swift.Int?
        /// Provides a total count of generated findings per severity.
        /// This member is required.
        public var findingCounts: [Swift.String: Swift.Int]?
        /// The auto-generated name for the assessment run.
        /// This member is required.
        public var name: Swift.String?
        /// A list of notifications for the event subscriptions. A notification about a particular generated finding is added to this list only once.
        /// This member is required.
        public var notifications: [InspectorClientTypes.AssessmentRunNotification]?
        /// The rules packages selected for the assessment run.
        /// This member is required.
        public var rulesPackageArns: [Swift.String]?
        /// The time when [StartAssessmentRun] was called.
        public var startedAt: Foundation.Date?
        /// The state of the assessment run.
        /// This member is required.
        public var state: InspectorClientTypes.AssessmentRunState?
        /// The last time when the assessment run's state changed.
        /// This member is required.
        public var stateChangedAt: Foundation.Date?
        /// A list of the assessment run state changes.
        /// This member is required.
        public var stateChanges: [InspectorClientTypes.AssessmentRunStateChange]?
        /// The user-defined attributes that are assigned to every generated finding.
        /// This member is required.
        public var userAttributesForFindings: [InspectorClientTypes.Attribute]?

        public init(
            arn: Swift.String? = nil,
            assessmentTemplateArn: Swift.String? = nil,
            completedAt: Foundation.Date? = nil,
            createdAt: Foundation.Date? = nil,
            dataCollected: Swift.Bool? = nil,
            durationInSeconds: Swift.Int? = nil,
            findingCounts: [Swift.String: Swift.Int]? = nil,
            name: Swift.String? = nil,
            notifications: [InspectorClientTypes.AssessmentRunNotification]? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            startedAt: Foundation.Date? = nil,
            state: InspectorClientTypes.AssessmentRunState? = nil,
            stateChangedAt: Foundation.Date? = nil,
            stateChanges: [InspectorClientTypes.AssessmentRunStateChange]? = nil,
            userAttributesForFindings: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.arn = arn
            self.assessmentTemplateArn = assessmentTemplateArn
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.dataCollected = dataCollected
            self.durationInSeconds = durationInSeconds
            self.findingCounts = findingCounts
            self.name = name
            self.notifications = notifications
            self.rulesPackageArns = rulesPackageArns
            self.startedAt = startedAt
            self.state = state
            self.stateChangedAt = stateChangedAt
            self.stateChanges = stateChanges
            self.userAttributesForFindings = userAttributesForFindings
        }
    }
}

extension InspectorClientTypes {

    /// The metadata about the Amazon Inspector application data metrics collected by the agent. This data type is used as the response element in the [GetTelemetryMetadata] action.
    public struct TelemetryMetadata: Swift.Sendable {
        /// The count of messages that the agent sends to the Amazon Inspector service.
        /// This member is required.
        public var count: Swift.Int?
        /// The data size of messages that the agent sends to the Amazon Inspector service.
        public var dataSize: Swift.Int?
        /// A specific type of behavioral data that is collected by the agent.
        /// This member is required.
        public var messageType: Swift.String?

        public init(
            count: Swift.Int? = nil,
            dataSize: Swift.Int? = nil,
            messageType: Swift.String? = nil
        )
        {
            self.count = count
            self.dataSize = dataSize
            self.messageType = messageType
        }
    }
}

extension InspectorClientTypes {

    /// Contains information about an Amazon Inspector agent. This data type is used as a response element in the [ListAssessmentRunAgents] action.
    public struct AssessmentRunAgent: Swift.Sendable {
        /// The current health state of the agent.
        /// This member is required.
        public var agentHealth: InspectorClientTypes.AgentHealth?
        /// The detailed health state of the agent.
        /// This member is required.
        public var agentHealthCode: InspectorClientTypes.AgentHealthCode?
        /// The description for the agent health code.
        public var agentHealthDetails: Swift.String?
        /// The AWS account of the EC2 instance where the agent is installed.
        /// This member is required.
        public var agentId: Swift.String?
        /// The ARN of the assessment run that is associated with the agent.
        /// This member is required.
        public var assessmentRunArn: Swift.String?
        /// The Auto Scaling group of the EC2 instance that is specified by the agent ID.
        public var autoScalingGroup: Swift.String?
        /// The Amazon Inspector application data metrics that are collected by the agent.
        /// This member is required.
        public var telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]?

        public init(
            agentHealth: InspectorClientTypes.AgentHealth? = nil,
            agentHealthCode: InspectorClientTypes.AgentHealthCode? = nil,
            agentHealthDetails: Swift.String? = nil,
            agentId: Swift.String? = nil,
            assessmentRunArn: Swift.String? = nil,
            autoScalingGroup: Swift.String? = nil,
            telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]? = nil
        )
        {
            self.agentHealth = agentHealth
            self.agentHealthCode = agentHealthCode
            self.agentHealthDetails = agentHealthDetails
            self.agentId = agentId
            self.assessmentRunArn = assessmentRunArn
            self.autoScalingGroup = autoScalingGroup
            self.telemetryMetadata = telemetryMetadata
        }
    }
}

extension InspectorClientTypes {

    /// This data type is used in the [AssessmentRunFilter] data type.
    public struct TimestampRange: Swift.Sendable {
        /// The minimum value of the timestamp range.
        public var beginDate: Foundation.Date?
        /// The maximum value of the timestamp range.
        public var endDate: Foundation.Date?

        public init(
            beginDate: Foundation.Date? = nil,
            endDate: Foundation.Date? = nil
        )
        {
            self.beginDate = beginDate
            self.endDate = endDate
        }
    }
}

extension InspectorClientTypes {

    /// This data type is used in the [AssessmentTemplateFilter] data type.
    public struct DurationRange: Swift.Sendable {
        /// The maximum value of the duration range. Must be less than or equal to 604800 seconds (1 week).
        public var maxSeconds: Swift.Int?
        /// The minimum value of the duration range. Must be greater than zero.
        public var minSeconds: Swift.Int?

        public init(
            maxSeconds: Swift.Int? = nil,
            minSeconds: Swift.Int? = nil
        )
        {
            self.maxSeconds = maxSeconds
            self.minSeconds = minSeconds
        }
    }
}

extension InspectorClientTypes {

    /// Used as the request parameter in the [ListAssessmentRuns] action.
    public struct AssessmentRunFilter: Swift.Sendable {
        /// For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the completedAt property of the [AssessmentRun] data type.
        public var completionTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the durationInSeconds property of the [AssessmentRun] data type.
        public var durationRange: InspectorClientTypes.DurationRange?
        /// For a record to match a filter, an explicit value or a string containing a wildcard that is specified for this data type property must match the value of the assessmentRunName property of the [AssessmentRun] data type.
        public var namePattern: Swift.String?
        /// For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the rulesPackages property of the [AssessmentRun] data type.
        public var rulesPackageArns: [Swift.String]?
        /// For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the startTime property of the [AssessmentRun] data type.
        public var startTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, the value that is specified for this data type property must match the stateChangedAt property of the [AssessmentRun] data type.
        public var stateChangeTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, one of the values specified for this data type property must be the exact match of the value of the assessmentRunState property of the [AssessmentRun] data type.
        public var states: [InspectorClientTypes.AssessmentRunState]?

        public init(
            completionTimeRange: InspectorClientTypes.TimestampRange? = nil,
            durationRange: InspectorClientTypes.DurationRange? = nil,
            namePattern: Swift.String? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            startTimeRange: InspectorClientTypes.TimestampRange? = nil,
            stateChangeTimeRange: InspectorClientTypes.TimestampRange? = nil,
            states: [InspectorClientTypes.AssessmentRunState]? = nil
        )
        {
            self.completionTimeRange = completionTimeRange
            self.durationRange = durationRange
            self.namePattern = namePattern
            self.rulesPackageArns = rulesPackageArns
            self.startTimeRange = startTimeRange
            self.stateChangeTimeRange = stateChangeTimeRange
            self.states = states
        }
    }
}

/// You cannot perform a specified action if an assessment run is currently in progress.
public struct AssessmentRunInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The ARNs of the assessment runs that are currently in progress.
        /// This member is required.
        public internal(set) var assessmentRunArns: [Swift.String]? = nil
        /// Boolean value that indicates whether the ARN list of the assessment runs is truncated.
        /// This member is required.
        public internal(set) var assessmentRunArnsTruncated: Swift.Bool? = nil
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AssessmentRunInProgressException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        assessmentRunArns: [Swift.String]? = nil,
        assessmentRunArnsTruncated: Swift.Bool? = nil,
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.assessmentRunArns = assessmentRunArns
        self.properties.assessmentRunArnsTruncated = assessmentRunArnsTruncated
        self.properties.canRetry = canRetry
        self.properties.message = message
    }
}

extension InspectorClientTypes {

    /// Contains information about an Amazon Inspector application. This data type is used as the response element in the [DescribeAssessmentTargets] action.
    public struct AssessmentTarget: Swift.Sendable {
        /// The ARN that specifies the Amazon Inspector assessment target.
        /// This member is required.
        public var arn: Swift.String?
        /// The time at which the assessment target is created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The name of the Amazon Inspector assessment target.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN that specifies the resource group that is associated with the assessment target.
        public var resourceGroupArn: Swift.String?
        /// The time at which [UpdateAssessmentTarget] is called.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            resourceGroupArn: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.resourceGroupArn = resourceGroupArn
            self.updatedAt = updatedAt
        }
    }
}

extension InspectorClientTypes {

    /// Used as the request parameter in the [ListAssessmentTargets] action.
    public struct AssessmentTargetFilter: Swift.Sendable {
        /// For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the assessmentTargetName property of the [AssessmentTarget] data type.
        public var assessmentTargetNamePattern: Swift.String?

        public init(
            assessmentTargetNamePattern: Swift.String? = nil
        )
        {
            self.assessmentTargetNamePattern = assessmentTargetNamePattern
        }
    }
}

extension InspectorClientTypes {

    /// Contains information about an Amazon Inspector assessment template. This data type is used as the response element in the [DescribeAssessmentTemplates] action.
    public struct AssessmentTemplate: Swift.Sendable {
        /// The ARN of the assessment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The number of existing assessment runs associated with this assessment template. This value can be zero or a positive integer.
        /// This member is required.
        public var assessmentRunCount: Swift.Int?
        /// The ARN of the assessment target that corresponds to this assessment template.
        /// This member is required.
        public var assessmentTargetArn: Swift.String?
        /// The time at which the assessment template is created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The duration in seconds specified for this assessment template. The default value is 3600 seconds (one hour). The maximum value is 86400 seconds (one day).
        /// This member is required.
        public var durationInSeconds: Swift.Int?
        /// The Amazon Resource Name (ARN) of the most recent assessment run associated with this assessment template. This value exists only when the value of assessmentRunCount is greaterpa than zero.
        public var lastAssessmentRunArn: Swift.String?
        /// The name of the assessment template.
        /// This member is required.
        public var name: Swift.String?
        /// The rules packages that are specified for this assessment template.
        /// This member is required.
        public var rulesPackageArns: [Swift.String]?
        /// The user-defined attributes that are assigned to every generated finding from the assessment run that uses this assessment template.
        /// This member is required.
        public var userAttributesForFindings: [InspectorClientTypes.Attribute]?

        public init(
            arn: Swift.String? = nil,
            assessmentRunCount: Swift.Int? = nil,
            assessmentTargetArn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            durationInSeconds: Swift.Int? = nil,
            lastAssessmentRunArn: Swift.String? = nil,
            name: Swift.String? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            userAttributesForFindings: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.arn = arn
            self.assessmentRunCount = assessmentRunCount
            self.assessmentTargetArn = assessmentTargetArn
            self.createdAt = createdAt
            self.durationInSeconds = durationInSeconds
            self.lastAssessmentRunArn = lastAssessmentRunArn
            self.name = name
            self.rulesPackageArns = rulesPackageArns
            self.userAttributesForFindings = userAttributesForFindings
        }
    }
}

extension InspectorClientTypes {

    /// Used as the request parameter in the [ListAssessmentTemplates] action.
    public struct AssessmentTemplateFilter: Swift.Sendable {
        /// For a record to match a filter, the value specified for this data type property must inclusively match any value between the specified minimum and maximum values of the durationInSeconds property of the [AssessmentTemplate] data type.
        public var durationRange: InspectorClientTypes.DurationRange?
        /// For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the assessmentTemplateName property of the [AssessmentTemplate] data type.
        public var namePattern: Swift.String?
        /// For a record to match a filter, the values that are specified for this data type property must be contained in the list of values of the rulesPackageArns property of the [AssessmentTemplate] data type.
        public var rulesPackageArns: [Swift.String]?

        public init(
            durationRange: InspectorClientTypes.DurationRange? = nil,
            namePattern: Swift.String? = nil,
            rulesPackageArns: [Swift.String]? = nil
        )
        {
            self.durationRange = durationRange
            self.namePattern = namePattern
            self.rulesPackageArns = rulesPackageArns
        }
    }
}

extension InspectorClientTypes {

    /// Contains information about a private IP address associated with a network interface. This data type is used as a response element in the [DescribeFindings] action.
    public struct PrivateIp: Swift.Sendable {
        /// The DNS name of the private IP address.
        public var privateDnsName: Swift.String?
        /// The full IP address of the network inteface.
        public var privateIpAddress: Swift.String?

        public init(
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil
        )
        {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }
    }
}

extension InspectorClientTypes {

    /// Contains information about a security group associated with a network interface. This data type is used as one of the elements of the [NetworkInterface] data type.
    public struct SecurityGroup: Swift.Sendable {
        /// The ID of the security group.
        public var groupId: Swift.String?
        /// The name of the security group.
        public var groupName: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }
}

extension InspectorClientTypes {

    /// Contains information about the network interfaces interacting with an EC2 instance. This data type is used as one of the elements of the [AssetAttributes] data type.
    public struct NetworkInterface: Swift.Sendable {
        /// The IP addresses associated with the network interface.
        public var ipv6Addresses: [Swift.String]?
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The name of a private DNS associated with the network interface.
        public var privateDnsName: Swift.String?
        /// The private IP address associated with the network interface.
        public var privateIpAddress: Swift.String?
        /// A list of the private IP addresses associated with the network interface. Includes the privateDnsName and privateIpAddress.
        public var privateIpAddresses: [InspectorClientTypes.PrivateIp]?
        /// The name of a public DNS associated with the network interface.
        public var publicDnsName: Swift.String?
        /// The public IP address from which the network interface is reachable.
        public var publicIp: Swift.String?
        /// A list of the security groups associated with the network interface. Includes the groupId and groupName.
        public var securityGroups: [InspectorClientTypes.SecurityGroup]?
        /// The ID of a subnet associated with the network interface.
        public var subnetId: Swift.String?
        /// The ID of a VPC associated with the network interface.
        public var vpcId: Swift.String?

        public init(
            ipv6Addresses: [Swift.String]? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            privateIpAddresses: [InspectorClientTypes.PrivateIp]? = nil,
            publicDnsName: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            securityGroups: [InspectorClientTypes.SecurityGroup]? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }
}

extension InspectorClientTypes {

    /// A key and value pair. This data type is used as a request parameter in the [SetTagsForResource] action and a response element in the [ListTagsForResource] action.
    public struct Tag: Swift.Sendable {
        /// A tag key.
        /// This member is required.
        public var key: Swift.String?
        /// A value assigned to a tag key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension InspectorClientTypes {

    /// A collection of attributes of the host from which the finding is generated.
    public struct AssetAttributes: Swift.Sendable {
        /// The ID of the agent that is installed on the EC2 instance where the finding is generated.
        public var agentId: Swift.String?
        /// The ID of the Amazon Machine Image (AMI) that is installed on the EC2 instance where the finding is generated.
        public var amiId: Swift.String?
        /// The Auto Scaling group of the EC2 instance where the finding is generated.
        public var autoScalingGroup: Swift.String?
        /// The hostname of the EC2 instance where the finding is generated.
        public var hostname: Swift.String?
        /// The list of IP v4 addresses of the EC2 instance where the finding is generated.
        public var ipv4Addresses: [Swift.String]?
        /// An array of the network interfaces interacting with the EC2 instance where the finding is generated.
        public var networkInterfaces: [InspectorClientTypes.NetworkInterface]?
        /// The schema version of this data type.
        /// This member is required.
        public var schemaVersion: Swift.Int
        /// The tags related to the EC2 instance where the finding is generated.
        public var tags: [InspectorClientTypes.Tag]?

        public init(
            agentId: Swift.String? = nil,
            amiId: Swift.String? = nil,
            autoScalingGroup: Swift.String? = nil,
            hostname: Swift.String? = nil,
            ipv4Addresses: [Swift.String]? = nil,
            networkInterfaces: [InspectorClientTypes.NetworkInterface]? = nil,
            schemaVersion: Swift.Int = 0,
            tags: [InspectorClientTypes.Tag]? = nil
        )
        {
            self.agentId = agentId
            self.amiId = amiId
            self.autoScalingGroup = autoScalingGroup
            self.hostname = hostname
            self.ipv4Addresses = ipv4Addresses
            self.networkInterfaces = networkInterfaces
            self.schemaVersion = schemaVersion
            self.tags = tags
        }
    }
}

extension InspectorClientTypes {

    public enum AssetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ec2Instance
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetType] {
            return [
                .ec2Instance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ec2Instance: return "ec2-instance"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InspectorClientTypes {

    public enum InvalidCrossAccountRoleErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case roleDoesNotExistOrInvalidTrustRelationship
        case roleDoesNotHaveCorrectPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [InvalidCrossAccountRoleErrorCode] {
            return [
                .roleDoesNotExistOrInvalidTrustRelationship,
                .roleDoesNotHaveCorrectPolicy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .roleDoesNotExistOrInvalidTrustRelationship: return "ROLE_DOES_NOT_EXIST_OR_INVALID_TRUST_RELATIONSHIP"
            case .roleDoesNotHaveCorrectPolicy: return "ROLE_DOES_NOT_HAVE_CORRECT_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Amazon Inspector cannot assume the cross-account role that it needs to list your EC2 instances during the assessment run.
public struct InvalidCrossAccountRoleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Code that indicates the type of error that is generated.
        /// This member is required.
        public internal(set) var errorCode: InspectorClientTypes.InvalidCrossAccountRoleErrorCode? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCrossAccountRoleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.InvalidCrossAccountRoleErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension InspectorClientTypes {

    public enum LimitExceededErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assessmentRunLimitExceeded
        case assessmentTargetLimitExceeded
        case assessmentTemplateLimitExceeded
        case eventSubscriptionLimitExceeded
        case resourceGroupLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LimitExceededErrorCode] {
            return [
                .assessmentRunLimitExceeded,
                .assessmentTargetLimitExceeded,
                .assessmentTemplateLimitExceeded,
                .eventSubscriptionLimitExceeded,
                .resourceGroupLimitExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assessmentRunLimitExceeded: return "ASSESSMENT_RUN_LIMIT_EXCEEDED"
            case .assessmentTargetLimitExceeded: return "ASSESSMENT_TARGET_LIMIT_EXCEEDED"
            case .assessmentTemplateLimitExceeded: return "ASSESSMENT_TEMPLATE_LIMIT_EXCEEDED"
            case .eventSubscriptionLimitExceeded: return "EVENT_SUBSCRIPTION_LIMIT_EXCEEDED"
            case .resourceGroupLimitExceeded: return "RESOURCE_GROUP_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request was rejected because it attempted to create resources beyond the current AWS account limits. The error code describes the limit exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You can immediately retry your request.
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// Code that indicates the type of error that is generated.
        /// This member is required.
        public internal(set) var errorCode: InspectorClientTypes.LimitExceededErrorCode? = nil
        /// Details of the exception error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        errorCode: InspectorClientTypes.LimitExceededErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

public struct CreateAssessmentTargetInput: Swift.Sendable {
    /// The user-defined name that identifies the assessment target that you want to create. The name must be unique within the AWS account.
    /// This member is required.
    public var assessmentTargetName: Swift.String?
    /// The ARN that specifies the resource group that is used to create the assessment target. If resourceGroupArn is not specified, all EC2 instances in the current AWS account and region are included in the assessment target.
    public var resourceGroupArn: Swift.String?

    public init(
        assessmentTargetName: Swift.String? = nil,
        resourceGroupArn: Swift.String? = nil
    )
    {
        self.assessmentTargetName = assessmentTargetName
        self.resourceGroupArn = resourceGroupArn
    }
}

public struct CreateAssessmentTargetOutput: Swift.Sendable {
    /// The ARN that specifies the assessment target that is created.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?

    public init(
        assessmentTargetArn: Swift.String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
    }
}

public struct CreateAssessmentTemplateInput: Swift.Sendable {
    /// The ARN that specifies the assessment target for which you want to create the assessment template.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?
    /// The user-defined name that identifies the assessment template that you want to create. You can create several assessment templates for an assessment target. The names of the assessment templates that correspond to a particular assessment target must be unique.
    /// This member is required.
    public var assessmentTemplateName: Swift.String?
    /// The duration of the assessment run in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int?
    /// The ARNs that specify the rules packages that you want to attach to the assessment template.
    /// This member is required.
    public var rulesPackageArns: [Swift.String]?
    /// The user-defined attributes that are assigned to every finding that is generated by the assessment run that uses this assessment template. An attribute is a key and value pair (an [Attribute] object). Within an assessment template, each key must be unique.
    public var userAttributesForFindings: [InspectorClientTypes.Attribute]?

    public init(
        assessmentTargetArn: Swift.String? = nil,
        assessmentTemplateName: Swift.String? = nil,
        durationInSeconds: Swift.Int? = nil,
        rulesPackageArns: [Swift.String]? = nil,
        userAttributesForFindings: [InspectorClientTypes.Attribute]? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
        self.assessmentTemplateName = assessmentTemplateName
        self.durationInSeconds = durationInSeconds
        self.rulesPackageArns = rulesPackageArns
        self.userAttributesForFindings = userAttributesForFindings
    }
}

public struct CreateAssessmentTemplateOutput: Swift.Sendable {
    /// The ARN that specifies the assessment template that is created.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init(
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

/// The request is rejected. The specified assessment template is currently generating an exclusions preview.
public struct PreviewGenerationInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreviewGenerationInProgressException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateExclusionsPreviewInput: Swift.Sendable {
    /// The ARN that specifies the assessment template for which you want to create an exclusions preview.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init(
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

public struct CreateExclusionsPreviewOutput: Swift.Sendable {
    /// Specifies the unique identifier of the requested exclusions preview. You can use the unique identifier to retrieve the exclusions preview when running the GetExclusionsPreview API.
    /// This member is required.
    public var previewToken: Swift.String?

    public init(
        previewToken: Swift.String? = nil
    )
    {
        self.previewToken = previewToken
    }
}

extension InspectorClientTypes {

    /// This data type is used as one of the elements of the [ResourceGroup] data type.
    public struct ResourceGroupTag: Swift.Sendable {
        /// A tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The value assigned to a tag key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateResourceGroupInput: Swift.Sendable {
    /// A collection of keys and an array of possible values, '[{"key":"key1","values":["Value1","Value2"]},{"key":"Key2","values":["Value3"]}]'. For example,'[{"key":"Name","values":["TestEC2Instance"]}]'.
    /// This member is required.
    public var resourceGroupTags: [InspectorClientTypes.ResourceGroupTag]?

    public init(
        resourceGroupTags: [InspectorClientTypes.ResourceGroupTag]? = nil
    )
    {
        self.resourceGroupTags = resourceGroupTags
    }
}

public struct CreateResourceGroupOutput: Swift.Sendable {
    /// The ARN that specifies the resource group that is created.
    /// This member is required.
    public var resourceGroupArn: Swift.String?

    public init(
        resourceGroupArn: Swift.String? = nil
    )
    {
        self.resourceGroupArn = resourceGroupArn
    }
}

public struct DeleteAssessmentRunInput: Swift.Sendable {
    /// The ARN that specifies the assessment run that you want to delete.
    /// This member is required.
    public var assessmentRunArn: Swift.String?

    public init(
        assessmentRunArn: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

public struct DeleteAssessmentTargetInput: Swift.Sendable {
    /// The ARN that specifies the assessment target that you want to delete.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?

    public init(
        assessmentTargetArn: Swift.String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
    }
}

public struct DeleteAssessmentTemplateInput: Swift.Sendable {
    /// The ARN that specifies the assessment template that you want to delete.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init(
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

public struct DescribeAssessmentRunsInput: Swift.Sendable {
    /// The ARN that specifies the assessment run that you want to describe.
    /// This member is required.
    public var assessmentRunArns: [Swift.String]?

    public init(
        assessmentRunArns: [Swift.String]? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
    }
}

public struct DescribeAssessmentRunsOutput: Swift.Sendable {
    /// Information about the assessment run.
    /// This member is required.
    public var assessmentRuns: [InspectorClientTypes.AssessmentRun]?
    /// Assessment run details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]?

    public init(
        assessmentRuns: [InspectorClientTypes.AssessmentRun]? = nil,
        failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.assessmentRuns = assessmentRuns
        self.failedItems = failedItems
    }
}

public struct DescribeAssessmentTargetsInput: Swift.Sendable {
    /// The ARNs that specifies the assessment targets that you want to describe.
    /// This member is required.
    public var assessmentTargetArns: [Swift.String]?

    public init(
        assessmentTargetArns: [Swift.String]? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
    }
}

public struct DescribeAssessmentTargetsOutput: Swift.Sendable {
    /// Information about the assessment targets.
    /// This member is required.
    public var assessmentTargets: [InspectorClientTypes.AssessmentTarget]?
    /// Assessment target details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]?

    public init(
        assessmentTargets: [InspectorClientTypes.AssessmentTarget]? = nil,
        failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.assessmentTargets = assessmentTargets
        self.failedItems = failedItems
    }
}

public struct DescribeAssessmentTemplatesInput: Swift.Sendable {
    /// This member is required.
    public var assessmentTemplateArns: [Swift.String]?

    public init(
        assessmentTemplateArns: [Swift.String]? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
    }
}

public struct DescribeAssessmentTemplatesOutput: Swift.Sendable {
    /// Information about the assessment templates.
    /// This member is required.
    public var assessmentTemplates: [InspectorClientTypes.AssessmentTemplate]?
    /// Assessment template details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]?

    public init(
        assessmentTemplates: [InspectorClientTypes.AssessmentTemplate]? = nil,
        failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.assessmentTemplates = assessmentTemplates
        self.failedItems = failedItems
    }
}

public struct DescribeCrossAccountAccessRoleOutput: Swift.Sendable {
    /// The date when the cross-account access role was registered.
    /// This member is required.
    public var registeredAt: Foundation.Date?
    /// The ARN that specifies the IAM role that Amazon Inspector uses to access your AWS account.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A Boolean value that specifies whether the IAM role has the necessary policies attached to enable Amazon Inspector to access your AWS account.
    /// This member is required.
    public var valid: Swift.Bool?

    public init(
        registeredAt: Foundation.Date? = nil,
        roleArn: Swift.String? = nil,
        valid: Swift.Bool? = nil
    )
    {
        self.registeredAt = registeredAt
        self.roleArn = roleArn
        self.valid = valid
    }
}

extension InspectorClientTypes {

    public enum Locale: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .enUs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "EN_US"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeExclusionsInput: Swift.Sendable {
    /// The list of ARNs that specify the exclusions that you want to describe.
    /// This member is required.
    public var exclusionArns: [Swift.String]?
    /// The locale into which you want to translate the exclusion's title, description, and recommendation.
    public var locale: InspectorClientTypes.Locale?

    public init(
        exclusionArns: [Swift.String]? = nil,
        locale: InspectorClientTypes.Locale? = nil
    )
    {
        self.exclusionArns = exclusionArns
        self.locale = locale
    }
}

extension InspectorClientTypes {

    public enum ScopeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case instanceId
        case rulesPackageArn
        case sdkUnknown(Swift.String)

        public static var allCases: [ScopeType] {
            return [
                .instanceId,
                .rulesPackageArn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .instanceId: return "INSTANCE_ID"
            case .rulesPackageArn: return "RULES_PACKAGE_ARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InspectorClientTypes {

    /// This data type contains key-value pairs that identify various Amazon resources.
    public struct Scope: Swift.Sendable {
        /// The type of the scope.
        public var key: InspectorClientTypes.ScopeType?
        /// The resource identifier for the specified scope type.
        public var value: Swift.String?

        public init(
            key: InspectorClientTypes.ScopeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension InspectorClientTypes {

    /// Contains information about what was excluded from an assessment run.
    public struct Exclusion: Swift.Sendable {
        /// The ARN that specifies the exclusion.
        /// This member is required.
        public var arn: Swift.String?
        /// The system-defined attributes for the exclusion.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// The description of the exclusion.
        /// This member is required.
        public var description: Swift.String?
        /// The recommendation for the exclusion.
        /// This member is required.
        public var recommendation: Swift.String?
        /// The AWS resources for which the exclusion pertains.
        /// This member is required.
        public var scopes: [InspectorClientTypes.Scope]?
        /// The name of the exclusion.
        /// This member is required.
        public var title: Swift.String?

        public init(
            arn: Swift.String? = nil,
            attributes: [InspectorClientTypes.Attribute]? = nil,
            description: Swift.String? = nil,
            recommendation: Swift.String? = nil,
            scopes: [InspectorClientTypes.Scope]? = nil,
            title: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.description = description
            self.recommendation = recommendation
            self.scopes = scopes
            self.title = title
        }
    }
}

public struct DescribeExclusionsOutput: Swift.Sendable {
    /// Information about the exclusions.
    /// This member is required.
    public var exclusions: [Swift.String: InspectorClientTypes.Exclusion]?
    /// Exclusion details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]?

    public init(
        exclusions: [Swift.String: InspectorClientTypes.Exclusion]? = nil,
        failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.exclusions = exclusions
        self.failedItems = failedItems
    }
}

public struct DescribeFindingsInput: Swift.Sendable {
    /// The ARN that specifies the finding that you want to describe.
    /// This member is required.
    public var findingArns: [Swift.String]?
    /// The locale into which you want to translate a finding description, recommendation, and the short description that identifies the finding.
    public var locale: InspectorClientTypes.Locale?

    public init(
        findingArns: [Swift.String]? = nil,
        locale: InspectorClientTypes.Locale? = nil
    )
    {
        self.findingArns = findingArns
        self.locale = locale
    }
}

extension InspectorClientTypes {

    /// This data type is used in the [Finding] data type.
    public struct InspectorServiceAttributes: Swift.Sendable {
        /// The ARN of the assessment run during which the finding is generated.
        public var assessmentRunArn: Swift.String?
        /// The ARN of the rules package that is used to generate the finding.
        public var rulesPackageArn: Swift.String?
        /// The schema version of this data type.
        /// This member is required.
        public var schemaVersion: Swift.Int

        public init(
            assessmentRunArn: Swift.String? = nil,
            rulesPackageArn: Swift.String? = nil,
            schemaVersion: Swift.Int = 0
        )
        {
            self.assessmentRunArn = assessmentRunArn
            self.rulesPackageArn = rulesPackageArn
            self.schemaVersion = schemaVersion
        }
    }
}

extension InspectorClientTypes {

    /// Contains information about an Amazon Inspector finding. This data type is used as the response element in the [DescribeFindings] action.
    public struct Finding: Swift.Sendable {
        /// The ARN that specifies the finding.
        /// This member is required.
        public var arn: Swift.String?
        /// A collection of attributes of the host from which the finding is generated.
        public var assetAttributes: InspectorClientTypes.AssetAttributes?
        /// The type of the host from which the finding is generated.
        public var assetType: InspectorClientTypes.AssetType?
        /// The system-defined attributes for the finding.
        /// This member is required.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// This data element is currently not used.
        public var confidence: Swift.Int
        /// The time when the finding was generated.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the finding.
        public var description: Swift.String?
        /// The ID of the finding.
        public var id: Swift.String?
        /// This data element is currently not used.
        public var indicatorOfCompromise: Swift.Bool?
        /// The numeric value of the finding severity.
        public var numericSeverity: Swift.Double
        /// The recommendation for the finding.
        public var recommendation: Swift.String?
        /// The schema version of this data type.
        public var schemaVersion: Swift.Int
        /// The data element is set to "Inspector".
        public var service: Swift.String?
        /// This data type is used in the [Finding] data type.
        public var serviceAttributes: InspectorClientTypes.InspectorServiceAttributes?
        /// The finding severity. Values can be set to High, Medium, Low, and Informational.
        public var severity: InspectorClientTypes.Severity?
        /// The name of the finding.
        public var title: Swift.String?
        /// The time when [AddAttributesToFindings] is called.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The user-defined attributes that are assigned to the finding.
        /// This member is required.
        public var userAttributes: [InspectorClientTypes.Attribute]?

        public init(
            arn: Swift.String? = nil,
            assetAttributes: InspectorClientTypes.AssetAttributes? = nil,
            assetType: InspectorClientTypes.AssetType? = nil,
            attributes: [InspectorClientTypes.Attribute]? = nil,
            confidence: Swift.Int = 0,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            indicatorOfCompromise: Swift.Bool? = nil,
            numericSeverity: Swift.Double = 0.0,
            recommendation: Swift.String? = nil,
            schemaVersion: Swift.Int = 0,
            service: Swift.String? = nil,
            serviceAttributes: InspectorClientTypes.InspectorServiceAttributes? = nil,
            severity: InspectorClientTypes.Severity? = nil,
            title: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            userAttributes: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.arn = arn
            self.assetAttributes = assetAttributes
            self.assetType = assetType
            self.attributes = attributes
            self.confidence = confidence
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.indicatorOfCompromise = indicatorOfCompromise
            self.numericSeverity = numericSeverity
            self.recommendation = recommendation
            self.schemaVersion = schemaVersion
            self.service = service
            self.serviceAttributes = serviceAttributes
            self.severity = severity
            self.title = title
            self.updatedAt = updatedAt
            self.userAttributes = userAttributes
        }
    }
}

public struct DescribeFindingsOutput: Swift.Sendable {
    /// Finding details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]?
    /// Information about the finding.
    /// This member is required.
    public var findings: [InspectorClientTypes.Finding]?

    public init(
        failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]? = nil,
        findings: [InspectorClientTypes.Finding]? = nil
    )
    {
        self.failedItems = failedItems
        self.findings = findings
    }
}

public struct DescribeResourceGroupsInput: Swift.Sendable {
    /// The ARN that specifies the resource group that you want to describe.
    /// This member is required.
    public var resourceGroupArns: [Swift.String]?

    public init(
        resourceGroupArns: [Swift.String]? = nil
    )
    {
        self.resourceGroupArns = resourceGroupArns
    }
}

extension InspectorClientTypes {

    /// Contains information about a resource group. The resource group defines a set of tags that, when queried, identify the AWS resources that make up the assessment target. This data type is used as the response element in the [DescribeResourceGroups] action.
    public struct ResourceGroup: Swift.Sendable {
        /// The ARN of the resource group.
        /// This member is required.
        public var arn: Swift.String?
        /// The time at which resource group is created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The tags (key and value pairs) of the resource group. This data type property is used in the [CreateResourceGroup] action.
        /// This member is required.
        public var tags: [InspectorClientTypes.ResourceGroupTag]?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            tags: [InspectorClientTypes.ResourceGroupTag]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.tags = tags
        }
    }
}

public struct DescribeResourceGroupsOutput: Swift.Sendable {
    /// Resource group details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]?
    /// Information about a resource group.
    /// This member is required.
    public var resourceGroups: [InspectorClientTypes.ResourceGroup]?

    public init(
        failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]? = nil,
        resourceGroups: [InspectorClientTypes.ResourceGroup]? = nil
    )
    {
        self.failedItems = failedItems
        self.resourceGroups = resourceGroups
    }
}

public struct DescribeRulesPackagesInput: Swift.Sendable {
    /// The locale that you want to translate a rules package description into.
    public var locale: InspectorClientTypes.Locale?
    /// The ARN that specifies the rules package that you want to describe.
    /// This member is required.
    public var rulesPackageArns: [Swift.String]?

    public init(
        locale: InspectorClientTypes.Locale? = nil,
        rulesPackageArns: [Swift.String]? = nil
    )
    {
        self.locale = locale
        self.rulesPackageArns = rulesPackageArns
    }
}

extension InspectorClientTypes {

    /// Contains information about an Amazon Inspector rules package. This data type is used as the response element in the [DescribeRulesPackages] action.
    public struct RulesPackage: Swift.Sendable {
        /// The ARN of the rules package.
        /// This member is required.
        public var arn: Swift.String?
        /// The description of the rules package.
        public var description: Swift.String?
        /// The name of the rules package.
        /// This member is required.
        public var name: Swift.String?
        /// The provider of the rules package.
        /// This member is required.
        public var provider: Swift.String?
        /// The version ID of the rules package.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
            self.provider = provider
            self.version = version
        }
    }
}

public struct DescribeRulesPackagesOutput: Swift.Sendable {
    /// Rules package details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]?
    /// Information about the rules package.
    /// This member is required.
    public var rulesPackages: [InspectorClientTypes.RulesPackage]?

    public init(
        failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]? = nil,
        rulesPackages: [InspectorClientTypes.RulesPackage]? = nil
    )
    {
        self.failedItems = failedItems
        self.rulesPackages = rulesPackages
    }
}

extension InspectorClientTypes {

    /// This data type is used in the [Subscription] data type.
    public struct EventSubscription: Swift.Sendable {
        /// The event for which Amazon Simple Notification Service (SNS) notifications are sent.
        /// This member is required.
        public var event: InspectorClientTypes.InspectorEvent?
        /// The time at which [SubscribeToEvent] is called.
        /// This member is required.
        public var subscribedAt: Foundation.Date?

        public init(
            event: InspectorClientTypes.InspectorEvent? = nil,
            subscribedAt: Foundation.Date? = nil
        )
        {
            self.event = event
            self.subscribedAt = subscribedAt
        }
    }
}

extension InspectorClientTypes {

    /// Contains information about what is excluded from an assessment run given the current state of the assessment template.
    public struct ExclusionPreview: Swift.Sendable {
        /// The system-defined attributes for the exclusion preview.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// The description of the exclusion preview.
        /// This member is required.
        public var description: Swift.String?
        /// The recommendation for the exclusion preview.
        /// This member is required.
        public var recommendation: Swift.String?
        /// The AWS resources for which the exclusion preview pertains.
        /// This member is required.
        public var scopes: [InspectorClientTypes.Scope]?
        /// The name of the exclusion preview.
        /// This member is required.
        public var title: Swift.String?

        public init(
            attributes: [InspectorClientTypes.Attribute]? = nil,
            description: Swift.String? = nil,
            recommendation: Swift.String? = nil,
            scopes: [InspectorClientTypes.Scope]? = nil,
            title: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.description = description
            self.recommendation = recommendation
            self.scopes = scopes
            self.title = title
        }
    }
}

extension InspectorClientTypes {

    /// This data type is used as a request parameter in the [ListFindings] action.
    public struct FindingFilter: Swift.Sendable {
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the agentId property of the [Finding] data type.
        public var agentIds: [Swift.String]?
        /// For a record to match a filter, the list of values that are specified for this data type property must be contained in the list of values of the attributes property of the [Finding] data type.
        public var attributes: [InspectorClientTypes.Attribute]?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the autoScalingGroup property of the [Finding] data type.
        public var autoScalingGroups: [Swift.String]?
        /// The time range during which the finding is generated.
        public var creationTimeRange: InspectorClientTypes.TimestampRange?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the ruleName property of the [Finding] data type.
        public var ruleNames: [Swift.String]?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the rulesPackageArn property of the [Finding] data type.
        public var rulesPackageArns: [Swift.String]?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the severity property of the [Finding] data type.
        public var severities: [InspectorClientTypes.Severity]?
        /// For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the userAttributes property of the [Finding] data type.
        public var userAttributes: [InspectorClientTypes.Attribute]?

        public init(
            agentIds: [Swift.String]? = nil,
            attributes: [InspectorClientTypes.Attribute]? = nil,
            autoScalingGroups: [Swift.String]? = nil,
            creationTimeRange: InspectorClientTypes.TimestampRange? = nil,
            ruleNames: [Swift.String]? = nil,
            rulesPackageArns: [Swift.String]? = nil,
            severities: [InspectorClientTypes.Severity]? = nil,
            userAttributes: [InspectorClientTypes.Attribute]? = nil
        )
        {
            self.agentIds = agentIds
            self.attributes = attributes
            self.autoScalingGroups = autoScalingGroups
            self.creationTimeRange = creationTimeRange
            self.ruleNames = ruleNames
            self.rulesPackageArns = rulesPackageArns
            self.severities = severities
            self.userAttributes = userAttributes
        }
    }
}

/// Used by the [GetAssessmentReport] API. The request was rejected because you tried to generate a report for an assessment run that existed before reporting was supported in Amazon Inspector. You can only generate reports for assessment runs that took place or will take place after generating reports in Amazon Inspector became available.
public struct UnsupportedFeatureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var canRetry: Swift.Bool? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedFeatureException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        canRetry: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.canRetry = canRetry
        self.properties.message = message
    }
}

extension InspectorClientTypes {

    public enum ReportFileFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case html
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFileFormat] {
            return [
                .html,
                .pdf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .html: return "HTML"
            case .pdf: return "PDF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InspectorClientTypes {

    public enum ReportType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case finding
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportType] {
            return [
                .finding,
                .full
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .finding: return "FINDING"
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAssessmentReportInput: Swift.Sendable {
    /// The ARN that specifies the assessment run for which you want to generate a report.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// Specifies the file format (html or pdf) of the assessment report that you want to generate.
    /// This member is required.
    public var reportFileFormat: InspectorClientTypes.ReportFileFormat?
    /// Specifies the type of the assessment report that you want to generate. There are two types of assessment reports: a finding report and a full report. For more information, see [Assessment Reports](https://docs.aws.amazon.com/inspector/latest/userguide/inspector_reports.html).
    /// This member is required.
    public var reportType: InspectorClientTypes.ReportType?

    public init(
        assessmentRunArn: Swift.String? = nil,
        reportFileFormat: InspectorClientTypes.ReportFileFormat? = nil,
        reportType: InspectorClientTypes.ReportType? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.reportFileFormat = reportFileFormat
        self.reportType = reportType
    }
}

extension InspectorClientTypes {

    public enum ReportStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case workInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportStatus] {
            return [
                .completed,
                .failed,
                .workInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .workInProgress: return "WORK_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAssessmentReportOutput: Swift.Sendable {
    /// Specifies the status of the request to generate an assessment report.
    /// This member is required.
    public var status: InspectorClientTypes.ReportStatus?
    /// Specifies the URL where you can find the generated assessment report. This parameter is only returned if the report is successfully generated.
    public var url: Swift.String?

    public init(
        status: InspectorClientTypes.ReportStatus? = nil,
        url: Swift.String? = nil
    )
    {
        self.status = status
        self.url = url
    }
}

public struct GetExclusionsPreviewInput: Swift.Sendable {
    /// The ARN that specifies the assessment template for which the exclusions preview was requested.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?
    /// The locale into which you want to translate the exclusion's title, description, and recommendation.
    public var locale: InspectorClientTypes.Locale?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 100. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the GetExclusionsPreviewRequest action. Subsequent calls to the action fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// The unique identifier associated of the exclusions preview.
    /// This member is required.
    public var previewToken: Swift.String?

    public init(
        assessmentTemplateArn: Swift.String? = nil,
        locale: InspectorClientTypes.Locale? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        previewToken: Swift.String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.previewToken = previewToken
    }
}

extension InspectorClientTypes {

    public enum PreviewStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case workInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [PreviewStatus] {
            return [
                .completed,
                .workInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .workInProgress: return "WORK_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetExclusionsPreviewOutput: Swift.Sendable {
    /// Information about the exclusions included in the preview.
    public var exclusionPreviews: [InspectorClientTypes.ExclusionPreview]?
    /// When a response is generated, if there is more data to be listed, this parameters is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?
    /// Specifies the status of the request to generate an exclusions preview.
    /// This member is required.
    public var previewStatus: InspectorClientTypes.PreviewStatus?

    public init(
        exclusionPreviews: [InspectorClientTypes.ExclusionPreview]? = nil,
        nextToken: Swift.String? = nil,
        previewStatus: InspectorClientTypes.PreviewStatus? = nil
    )
    {
        self.exclusionPreviews = exclusionPreviews
        self.nextToken = nextToken
        self.previewStatus = previewStatus
    }
}

public struct GetTelemetryMetadataInput: Swift.Sendable {
    /// The ARN that specifies the assessment run that has the telemetry data that you want to obtain.
    /// This member is required.
    public var assessmentRunArn: Swift.String?

    public init(
        assessmentRunArn: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

public struct GetTelemetryMetadataOutput: Swift.Sendable {
    /// Telemetry details.
    /// This member is required.
    public var telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]?

    public init(
        telemetryMetadata: [InspectorClientTypes.TelemetryMetadata]? = nil
    )
    {
        self.telemetryMetadata = telemetryMetadata
    }
}

public struct ListAssessmentRunAgentsInput: Swift.Sendable {
    /// The ARN that specifies the assessment run whose agents you want to list.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
    public var filter: InspectorClientTypes.AgentFilter?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentRunAgents action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        assessmentRunArn: Swift.String? = nil,
        filter: InspectorClientTypes.AgentFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssessmentRunAgentsOutput: Swift.Sendable {
    /// A list of ARNs that specifies the agents returned by the action.
    /// This member is required.
    public var assessmentRunAgents: [InspectorClientTypes.AssessmentRunAgent]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        assessmentRunAgents: [InspectorClientTypes.AssessmentRunAgent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunAgents = assessmentRunAgents
        self.nextToken = nextToken
    }
}

public struct ListAssessmentRunsInput: Swift.Sendable {
    /// The ARNs that specify the assessment templates whose assessment runs you want to list.
    public var assessmentTemplateArns: [Swift.String]?
    /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
    public var filter: InspectorClientTypes.AssessmentRunFilter?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentRuns action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        assessmentTemplateArns: [Swift.String]? = nil,
        filter: InspectorClientTypes.AssessmentRunFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssessmentRunsOutput: Swift.Sendable {
    /// A list of ARNs that specifies the assessment runs that are returned by the action.
    /// This member is required.
    public var assessmentRunArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        assessmentRunArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
        self.nextToken = nextToken
    }
}

public struct ListAssessmentTargetsInput: Swift.Sendable {
    /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
    public var filter: InspectorClientTypes.AssessmentTargetFilter?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentTargets action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        filter: InspectorClientTypes.AssessmentTargetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssessmentTargetsOutput: Swift.Sendable {
    /// A list of ARNs that specifies the assessment targets that are returned by the action.
    /// This member is required.
    public var assessmentTargetArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        assessmentTargetArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
        self.nextToken = nextToken
    }
}

public struct ListAssessmentTemplatesInput: Swift.Sendable {
    /// A list of ARNs that specifies the assessment targets whose assessment templates you want to list.
    public var assessmentTargetArns: [Swift.String]?
    /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
    public var filter: InspectorClientTypes.AssessmentTemplateFilter?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentTemplates action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        assessmentTargetArns: [Swift.String]? = nil,
        filter: InspectorClientTypes.AssessmentTemplateFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssessmentTemplatesOutput: Swift.Sendable {
    /// A list of ARNs that specifies the assessment templates returned by the action.
    /// This member is required.
    public var assessmentTemplateArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        assessmentTemplateArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
        self.nextToken = nextToken
    }
}

public struct ListEventSubscriptionsInput: Swift.Sendable {
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListEventSubscriptions action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// The ARN of the assessment template for which you want to list the existing event subscriptions.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension InspectorClientTypes {

    /// This data type is used as a response element in the [ListEventSubscriptions] action.
    public struct Subscription: Swift.Sendable {
        /// The list of existing event subscriptions.
        /// This member is required.
        public var eventSubscriptions: [InspectorClientTypes.EventSubscription]?
        /// The ARN of the assessment template that is used during the event for which the SNS notification is sent.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The ARN of the Amazon Simple Notification Service (SNS) topic to which the SNS notifications are sent.
        /// This member is required.
        public var topicArn: Swift.String?

        public init(
            eventSubscriptions: [InspectorClientTypes.EventSubscription]? = nil,
            resourceArn: Swift.String? = nil,
            topicArn: Swift.String? = nil
        )
        {
            self.eventSubscriptions = eventSubscriptions
            self.resourceArn = resourceArn
            self.topicArn = topicArn
        }
    }
}

public struct ListEventSubscriptionsOutput: Swift.Sendable {
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?
    /// Details of the returned event subscriptions.
    /// This member is required.
    public var subscriptions: [InspectorClientTypes.Subscription]?

    public init(
        nextToken: Swift.String? = nil,
        subscriptions: [InspectorClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

public struct ListExclusionsInput: Swift.Sendable {
    /// The ARN of the assessment run that generated the exclusions that you want to list.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 100. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListExclusionsRequest action. Subsequent calls to the action fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        assessmentRunArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListExclusionsOutput: Swift.Sendable {
    /// A list of exclusions' ARNs returned by the action.
    /// This member is required.
    public var exclusionArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameters is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        exclusionArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exclusionArns = exclusionArns
        self.nextToken = nextToken
    }
}

public struct ListFindingsInput: Swift.Sendable {
    /// The ARNs of the assessment runs that generate the findings that you want to list.
    public var assessmentRunArns: [Swift.String]?
    /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
    public var filter: InspectorClientTypes.FindingFilter?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListFindings action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        assessmentRunArns: [Swift.String]? = nil,
        filter: InspectorClientTypes.FindingFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFindingsOutput: Swift.Sendable {
    /// A list of ARNs that specifies the findings returned by the action.
    /// This member is required.
    public var findingArns: [Swift.String]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        findingArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingArns = findingArns
        self.nextToken = nextToken
    }
}

public struct ListRulesPackagesInput: Swift.Sendable {
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListRulesPackages action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListRulesPackagesOutput: Swift.Sendable {
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?
    /// The list of ARNs that specifies the rules packages returned by the action.
    /// This member is required.
    public var rulesPackageArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        rulesPackageArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.rulesPackageArns = rulesPackageArns
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN that specifies the assessment template whose tags you want to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A collection of key and value pairs.
    /// This member is required.
    public var tags: [InspectorClientTypes.Tag]?

    public init(
        tags: [InspectorClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PreviewAgentsInput: Swift.Sendable {
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the PreviewAgents action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// The ARN of the assessment target whose agents you want to preview.
    /// This member is required.
    public var previewAgentsArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        previewAgentsArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.previewAgentsArn = previewAgentsArn
    }
}

public struct PreviewAgentsOutput: Swift.Sendable {
    /// The resulting list of agents.
    /// This member is required.
    public var agentPreviews: [InspectorClientTypes.AgentPreview]?
    /// When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        agentPreviews: [InspectorClientTypes.AgentPreview]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentPreviews = agentPreviews
        self.nextToken = nextToken
    }
}

public struct RegisterCrossAccountAccessRoleInput: Swift.Sendable {
    /// The ARN of the IAM role that grants Amazon Inspector access to AWS Services needed to perform security assessments.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

public struct RemoveAttributesFromFindingsInput: Swift.Sendable {
    /// The array of attribute keys that you want to remove from specified findings.
    /// This member is required.
    public var attributeKeys: [Swift.String]?
    /// The ARNs that specify the findings that you want to remove attributes from.
    /// This member is required.
    public var findingArns: [Swift.String]?

    public init(
        attributeKeys: [Swift.String]? = nil,
        findingArns: [Swift.String]? = nil
    )
    {
        self.attributeKeys = attributeKeys
        self.findingArns = findingArns
    }
}

public struct RemoveAttributesFromFindingsOutput: Swift.Sendable {
    /// Attributes details that cannot be described. An error code is provided for each failed item.
    /// This member is required.
    public var failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]?

    public init(
        failedItems: [Swift.String: InspectorClientTypes.FailedItemDetails]? = nil
    )
    {
        self.failedItems = failedItems
    }
}

public struct SetTagsForResourceInput: Swift.Sendable {
    /// The ARN of the assessment template that you want to set tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of key and value pairs that you want to set to the assessment template.
    public var tags: [InspectorClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [InspectorClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct StartAssessmentRunInput: Swift.Sendable {
    /// You can specify the name for the assessment run. The name must be unique for the assessment template whose ARN is used to start the assessment run.
    public var assessmentRunName: Swift.String?
    /// The ARN of the assessment template of the assessment run that you want to start.
    /// This member is required.
    public var assessmentTemplateArn: Swift.String?

    public init(
        assessmentRunName: Swift.String? = nil,
        assessmentTemplateArn: Swift.String? = nil
    )
    {
        self.assessmentRunName = assessmentRunName
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

public struct StartAssessmentRunOutput: Swift.Sendable {
    /// The ARN of the assessment run that has been started.
    /// This member is required.
    public var assessmentRunArn: Swift.String?

    public init(
        assessmentRunArn: Swift.String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

extension InspectorClientTypes {

    public enum StopAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case skipEvaluation
        case startEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [StopAction] {
            return [
                .skipEvaluation,
                .startEvaluation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .skipEvaluation: return "SKIP_EVALUATION"
            case .startEvaluation: return "START_EVALUATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StopAssessmentRunInput: Swift.Sendable {
    /// The ARN of the assessment run that you want to stop.
    /// This member is required.
    public var assessmentRunArn: Swift.String?
    /// An input option that can be set to either START_EVALUATION or SKIP_EVALUATION. START_EVALUATION (the default value), stops the AWS agent from collecting data and begins the results evaluation and the findings generation process. SKIP_EVALUATION cancels the assessment run immediately, after which no findings are generated.
    public var stopAction: InspectorClientTypes.StopAction?

    public init(
        assessmentRunArn: Swift.String? = nil,
        stopAction: InspectorClientTypes.StopAction? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.stopAction = stopAction
    }
}

public struct SubscribeToEventInput: Swift.Sendable {
    /// The event for which you want to receive SNS notifications.
    /// This member is required.
    public var event: InspectorClientTypes.InspectorEvent?
    /// The ARN of the assessment template that is used during the event for which you want to receive SNS notifications.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ARN of the SNS topic to which the SNS notifications are sent.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        event: InspectorClientTypes.InspectorEvent? = nil,
        resourceArn: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.event = event
        self.resourceArn = resourceArn
        self.topicArn = topicArn
    }
}

public struct UnsubscribeFromEventInput: Swift.Sendable {
    /// The event for which you want to stop receiving SNS notifications.
    /// This member is required.
    public var event: InspectorClientTypes.InspectorEvent?
    /// The ARN of the assessment template that is used during the event for which you want to stop receiving SNS notifications.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ARN of the SNS topic to which SNS notifications are sent.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        event: InspectorClientTypes.InspectorEvent? = nil,
        resourceArn: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.event = event
        self.resourceArn = resourceArn
        self.topicArn = topicArn
    }
}

public struct UpdateAssessmentTargetInput: Swift.Sendable {
    /// The ARN of the assessment target that you want to update.
    /// This member is required.
    public var assessmentTargetArn: Swift.String?
    /// The name of the assessment target that you want to update.
    /// This member is required.
    public var assessmentTargetName: Swift.String?
    /// The ARN of the resource group that is used to specify the new resource group to associate with the assessment target.
    public var resourceGroupArn: Swift.String?

    public init(
        assessmentTargetArn: Swift.String? = nil,
        assessmentTargetName: Swift.String? = nil,
        resourceGroupArn: Swift.String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
        self.assessmentTargetName = assessmentTargetName
        self.resourceGroupArn = resourceGroupArn
    }
}

extension AddAttributesToFindingsInput {

    static func urlPathProvider(_ value: AddAttributesToFindingsInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAssessmentTargetInput {

    static func urlPathProvider(_ value: CreateAssessmentTargetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAssessmentTemplateInput {

    static func urlPathProvider(_ value: CreateAssessmentTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension CreateExclusionsPreviewInput {

    static func urlPathProvider(_ value: CreateExclusionsPreviewInput) -> Swift.String? {
        return "/"
    }
}

extension CreateResourceGroupInput {

    static func urlPathProvider(_ value: CreateResourceGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAssessmentRunInput {

    static func urlPathProvider(_ value: DeleteAssessmentRunInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAssessmentTargetInput {

    static func urlPathProvider(_ value: DeleteAssessmentTargetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAssessmentTemplateInput {

    static func urlPathProvider(_ value: DeleteAssessmentTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAssessmentRunsInput {

    static func urlPathProvider(_ value: DescribeAssessmentRunsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAssessmentTargetsInput {

    static func urlPathProvider(_ value: DescribeAssessmentTargetsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAssessmentTemplatesInput {

    static func urlPathProvider(_ value: DescribeAssessmentTemplatesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCrossAccountAccessRoleInput {

    static func urlPathProvider(_ value: DescribeCrossAccountAccessRoleInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeExclusionsInput {

    static func urlPathProvider(_ value: DescribeExclusionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFindingsInput {

    static func urlPathProvider(_ value: DescribeFindingsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeResourceGroupsInput {

    static func urlPathProvider(_ value: DescribeResourceGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRulesPackagesInput {

    static func urlPathProvider(_ value: DescribeRulesPackagesInput) -> Swift.String? {
        return "/"
    }
}

extension GetAssessmentReportInput {

    static func urlPathProvider(_ value: GetAssessmentReportInput) -> Swift.String? {
        return "/"
    }
}

extension GetExclusionsPreviewInput {

    static func urlPathProvider(_ value: GetExclusionsPreviewInput) -> Swift.String? {
        return "/"
    }
}

extension GetTelemetryMetadataInput {

    static func urlPathProvider(_ value: GetTelemetryMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension ListAssessmentRunAgentsInput {

    static func urlPathProvider(_ value: ListAssessmentRunAgentsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAssessmentRunsInput {

    static func urlPathProvider(_ value: ListAssessmentRunsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAssessmentTargetsInput {

    static func urlPathProvider(_ value: ListAssessmentTargetsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAssessmentTemplatesInput {

    static func urlPathProvider(_ value: ListAssessmentTemplatesInput) -> Swift.String? {
        return "/"
    }
}

extension ListEventSubscriptionsInput {

    static func urlPathProvider(_ value: ListEventSubscriptionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListExclusionsInput {

    static func urlPathProvider(_ value: ListExclusionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFindingsInput {

    static func urlPathProvider(_ value: ListFindingsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRulesPackagesInput {

    static func urlPathProvider(_ value: ListRulesPackagesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PreviewAgentsInput {

    static func urlPathProvider(_ value: PreviewAgentsInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterCrossAccountAccessRoleInput {

    static func urlPathProvider(_ value: RegisterCrossAccountAccessRoleInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveAttributesFromFindingsInput {

    static func urlPathProvider(_ value: RemoveAttributesFromFindingsInput) -> Swift.String? {
        return "/"
    }
}

extension SetTagsForResourceInput {

    static func urlPathProvider(_ value: SetTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension StartAssessmentRunInput {

    static func urlPathProvider(_ value: StartAssessmentRunInput) -> Swift.String? {
        return "/"
    }
}

extension StopAssessmentRunInput {

    static func urlPathProvider(_ value: StopAssessmentRunInput) -> Swift.String? {
        return "/"
    }
}

extension SubscribeToEventInput {

    static func urlPathProvider(_ value: SubscribeToEventInput) -> Swift.String? {
        return "/"
    }
}

extension UnsubscribeFromEventInput {

    static func urlPathProvider(_ value: UnsubscribeFromEventInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAssessmentTargetInput {

    static func urlPathProvider(_ value: UpdateAssessmentTargetInput) -> Swift.String? {
        return "/"
    }
}

extension AddAttributesToFindingsInput {

    static func write(value: AddAttributesToFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeList(value.attributes, memberWritingClosure: InspectorClientTypes.Attribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["findingArns"].writeList(value.findingArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAssessmentTargetInput {

    static func write(value: CreateAssessmentTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTargetName"].write(value.assessmentTargetName)
        try writer["resourceGroupArn"].write(value.resourceGroupArn)
    }
}

extension CreateAssessmentTemplateInput {

    static func write(value: CreateAssessmentTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTargetArn"].write(value.assessmentTargetArn)
        try writer["assessmentTemplateName"].write(value.assessmentTemplateName)
        try writer["durationInSeconds"].write(value.durationInSeconds)
        try writer["rulesPackageArns"].writeList(value.rulesPackageArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["userAttributesForFindings"].writeList(value.userAttributesForFindings, memberWritingClosure: InspectorClientTypes.Attribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateExclusionsPreviewInput {

    static func write(value: CreateExclusionsPreviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTemplateArn"].write(value.assessmentTemplateArn)
    }
}

extension CreateResourceGroupInput {

    static func write(value: CreateResourceGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceGroupTags"].writeList(value.resourceGroupTags, memberWritingClosure: InspectorClientTypes.ResourceGroupTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteAssessmentRunInput {

    static func write(value: DeleteAssessmentRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentRunArn"].write(value.assessmentRunArn)
    }
}

extension DeleteAssessmentTargetInput {

    static func write(value: DeleteAssessmentTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTargetArn"].write(value.assessmentTargetArn)
    }
}

extension DeleteAssessmentTemplateInput {

    static func write(value: DeleteAssessmentTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTemplateArn"].write(value.assessmentTemplateArn)
    }
}

extension DescribeAssessmentRunsInput {

    static func write(value: DescribeAssessmentRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentRunArns"].writeList(value.assessmentRunArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeAssessmentTargetsInput {

    static func write(value: DescribeAssessmentTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTargetArns"].writeList(value.assessmentTargetArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeAssessmentTemplatesInput {

    static func write(value: DescribeAssessmentTemplatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTemplateArns"].writeList(value.assessmentTemplateArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeCrossAccountAccessRoleInput {

    static func write(value: DescribeCrossAccountAccessRoleInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeExclusionsInput {

    static func write(value: DescribeExclusionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exclusionArns"].writeList(value.exclusionArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["locale"].write(value.locale)
    }
}

extension DescribeFindingsInput {

    static func write(value: DescribeFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["findingArns"].writeList(value.findingArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["locale"].write(value.locale)
    }
}

extension DescribeResourceGroupsInput {

    static func write(value: DescribeResourceGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceGroupArns"].writeList(value.resourceGroupArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeRulesPackagesInput {

    static func write(value: DescribeRulesPackagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["locale"].write(value.locale)
        try writer["rulesPackageArns"].writeList(value.rulesPackageArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetAssessmentReportInput {

    static func write(value: GetAssessmentReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentRunArn"].write(value.assessmentRunArn)
        try writer["reportFileFormat"].write(value.reportFileFormat)
        try writer["reportType"].write(value.reportType)
    }
}

extension GetExclusionsPreviewInput {

    static func write(value: GetExclusionsPreviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTemplateArn"].write(value.assessmentTemplateArn)
        try writer["locale"].write(value.locale)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["previewToken"].write(value.previewToken)
    }
}

extension GetTelemetryMetadataInput {

    static func write(value: GetTelemetryMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentRunArn"].write(value.assessmentRunArn)
    }
}

extension ListAssessmentRunAgentsInput {

    static func write(value: ListAssessmentRunAgentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentRunArn"].write(value.assessmentRunArn)
        try writer["filter"].write(value.filter, with: InspectorClientTypes.AgentFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAssessmentRunsInput {

    static func write(value: ListAssessmentRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTemplateArns"].writeList(value.assessmentTemplateArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filter"].write(value.filter, with: InspectorClientTypes.AssessmentRunFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAssessmentTargetsInput {

    static func write(value: ListAssessmentTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: InspectorClientTypes.AssessmentTargetFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAssessmentTemplatesInput {

    static func write(value: ListAssessmentTemplatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTargetArns"].writeList(value.assessmentTargetArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filter"].write(value.filter, with: InspectorClientTypes.AssessmentTemplateFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListEventSubscriptionsInput {

    static func write(value: ListEventSubscriptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension ListExclusionsInput {

    static func write(value: ListExclusionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentRunArn"].write(value.assessmentRunArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListFindingsInput {

    static func write(value: ListFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentRunArns"].writeList(value.assessmentRunArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filter"].write(value.filter, with: InspectorClientTypes.FindingFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRulesPackagesInput {

    static func write(value: ListRulesPackagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension PreviewAgentsInput {

    static func write(value: PreviewAgentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["previewAgentsArn"].write(value.previewAgentsArn)
    }
}

extension RegisterCrossAccountAccessRoleInput {

    static func write(value: RegisterCrossAccountAccessRoleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
    }
}

extension RemoveAttributesFromFindingsInput {

    static func write(value: RemoveAttributesFromFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeKeys"].writeList(value.attributeKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["findingArns"].writeList(value.findingArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SetTagsForResourceInput {

    static func write(value: SetTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: InspectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartAssessmentRunInput {

    static func write(value: StartAssessmentRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentRunName"].write(value.assessmentRunName)
        try writer["assessmentTemplateArn"].write(value.assessmentTemplateArn)
    }
}

extension StopAssessmentRunInput {

    static func write(value: StopAssessmentRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentRunArn"].write(value.assessmentRunArn)
        try writer["stopAction"].write(value.stopAction)
    }
}

extension SubscribeToEventInput {

    static func write(value: SubscribeToEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["event"].write(value.event)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["topicArn"].write(value.topicArn)
    }
}

extension UnsubscribeFromEventInput {

    static func write(value: UnsubscribeFromEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["event"].write(value.event)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["topicArn"].write(value.topicArn)
    }
}

extension UpdateAssessmentTargetInput {

    static func write(value: UpdateAssessmentTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTargetArn"].write(value.assessmentTargetArn)
        try writer["assessmentTargetName"].write(value.assessmentTargetName)
        try writer["resourceGroupArn"].write(value.resourceGroupArn)
    }
}

extension AddAttributesToFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddAttributesToFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddAttributesToFindingsOutput()
        value.failedItems = try reader["failedItems"].readMapIfPresent(valueReadingClosure: InspectorClientTypes.FailedItemDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension CreateAssessmentTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssessmentTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssessmentTargetOutput()
        value.assessmentTargetArn = try reader["assessmentTargetArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAssessmentTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssessmentTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssessmentTemplateOutput()
        value.assessmentTemplateArn = try reader["assessmentTemplateArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateExclusionsPreviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateExclusionsPreviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateExclusionsPreviewOutput()
        value.previewToken = try reader["previewToken"].readIfPresent() ?? ""
        return value
    }
}

extension CreateResourceGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResourceGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceGroupOutput()
        value.resourceGroupArn = try reader["resourceGroupArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAssessmentRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssessmentRunOutput {
        return DeleteAssessmentRunOutput()
    }
}

extension DeleteAssessmentTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssessmentTargetOutput {
        return DeleteAssessmentTargetOutput()
    }
}

extension DeleteAssessmentTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssessmentTemplateOutput {
        return DeleteAssessmentTemplateOutput()
    }
}

extension DescribeAssessmentRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssessmentRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssessmentRunsOutput()
        value.assessmentRuns = try reader["assessmentRuns"].readListIfPresent(memberReadingClosure: InspectorClientTypes.AssessmentRun.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.failedItems = try reader["failedItems"].readMapIfPresent(valueReadingClosure: InspectorClientTypes.FailedItemDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension DescribeAssessmentTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssessmentTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssessmentTargetsOutput()
        value.assessmentTargets = try reader["assessmentTargets"].readListIfPresent(memberReadingClosure: InspectorClientTypes.AssessmentTarget.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.failedItems = try reader["failedItems"].readMapIfPresent(valueReadingClosure: InspectorClientTypes.FailedItemDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension DescribeAssessmentTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssessmentTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssessmentTemplatesOutput()
        value.assessmentTemplates = try reader["assessmentTemplates"].readListIfPresent(memberReadingClosure: InspectorClientTypes.AssessmentTemplate.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.failedItems = try reader["failedItems"].readMapIfPresent(valueReadingClosure: InspectorClientTypes.FailedItemDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension DescribeCrossAccountAccessRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCrossAccountAccessRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCrossAccountAccessRoleOutput()
        value.registeredAt = try reader["registeredAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.valid = try reader["valid"].readIfPresent() ?? false
        return value
    }
}

extension DescribeExclusionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeExclusionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeExclusionsOutput()
        value.exclusions = try reader["exclusions"].readMapIfPresent(valueReadingClosure: InspectorClientTypes.Exclusion.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.failedItems = try reader["failedItems"].readMapIfPresent(valueReadingClosure: InspectorClientTypes.FailedItemDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension DescribeFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFindingsOutput()
        value.failedItems = try reader["failedItems"].readMapIfPresent(valueReadingClosure: InspectorClientTypes.FailedItemDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Finding.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeResourceGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeResourceGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeResourceGroupsOutput()
        value.failedItems = try reader["failedItems"].readMapIfPresent(valueReadingClosure: InspectorClientTypes.FailedItemDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.resourceGroups = try reader["resourceGroups"].readListIfPresent(memberReadingClosure: InspectorClientTypes.ResourceGroup.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeRulesPackagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRulesPackagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRulesPackagesOutput()
        value.failedItems = try reader["failedItems"].readMapIfPresent(valueReadingClosure: InspectorClientTypes.FailedItemDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.rulesPackages = try reader["rulesPackages"].readListIfPresent(memberReadingClosure: InspectorClientTypes.RulesPackage.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetAssessmentReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssessmentReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssessmentReportOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension GetExclusionsPreviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExclusionsPreviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExclusionsPreviewOutput()
        value.exclusionPreviews = try reader["exclusionPreviews"].readListIfPresent(memberReadingClosure: InspectorClientTypes.ExclusionPreview.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.previewStatus = try reader["previewStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetTelemetryMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTelemetryMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTelemetryMetadataOutput()
        value.telemetryMetadata = try reader["telemetryMetadata"].readListIfPresent(memberReadingClosure: InspectorClientTypes.TelemetryMetadata.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListAssessmentRunAgentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssessmentRunAgentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssessmentRunAgentsOutput()
        value.assessmentRunAgents = try reader["assessmentRunAgents"].readListIfPresent(memberReadingClosure: InspectorClientTypes.AssessmentRunAgent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssessmentRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssessmentRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssessmentRunsOutput()
        value.assessmentRunArns = try reader["assessmentRunArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssessmentTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssessmentTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssessmentTargetsOutput()
        value.assessmentTargetArns = try reader["assessmentTargetArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssessmentTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssessmentTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssessmentTemplatesOutput()
        value.assessmentTemplateArns = try reader["assessmentTemplateArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEventSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventSubscriptionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.subscriptions = try reader["subscriptions"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Subscription.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListExclusionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExclusionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExclusionsOutput()
        value.exclusionArns = try reader["exclusionArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFindingsOutput()
        value.findingArns = try reader["findingArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRulesPackagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRulesPackagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRulesPackagesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.rulesPackageArns = try reader["rulesPackageArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PreviewAgentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PreviewAgentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PreviewAgentsOutput()
        value.agentPreviews = try reader["agentPreviews"].readListIfPresent(memberReadingClosure: InspectorClientTypes.AgentPreview.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension RegisterCrossAccountAccessRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterCrossAccountAccessRoleOutput {
        return RegisterCrossAccountAccessRoleOutput()
    }
}

extension RemoveAttributesFromFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveAttributesFromFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveAttributesFromFindingsOutput()
        value.failedItems = try reader["failedItems"].readMapIfPresent(valueReadingClosure: InspectorClientTypes.FailedItemDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension SetTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetTagsForResourceOutput {
        return SetTagsForResourceOutput()
    }
}

extension StartAssessmentRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAssessmentRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAssessmentRunOutput()
        value.assessmentRunArn = try reader["assessmentRunArn"].readIfPresent() ?? ""
        return value
    }
}

extension StopAssessmentRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopAssessmentRunOutput {
        return StopAssessmentRunOutput()
    }
}

extension SubscribeToEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SubscribeToEventOutput {
        return SubscribeToEventOutput()
    }
}

extension UnsubscribeFromEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnsubscribeFromEventOutput {
        return UnsubscribeFromEventOutput()
    }
}

extension UpdateAssessmentTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssessmentTargetOutput {
        return UpdateAssessmentTargetOutput()
    }
}

enum AddAttributesToFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssessmentTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidCrossAccountRoleException": return try InvalidCrossAccountRoleException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssessmentTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateExclusionsPreviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "PreviewGenerationInProgressException": return try PreviewGenerationInProgressException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResourceGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssessmentRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AssessmentRunInProgressException": return try AssessmentRunInProgressException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssessmentTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AssessmentRunInProgressException": return try AssessmentRunInProgressException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssessmentTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AssessmentRunInProgressException": return try AssessmentRunInProgressException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssessmentRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssessmentTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssessmentTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCrossAccountAccessRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeExclusionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeResourceGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRulesPackagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssessmentReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AssessmentRunInProgressException": return try AssessmentRunInProgressException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            case "UnsupportedFeatureException": return try UnsupportedFeatureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExclusionsPreviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTelemetryMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssessmentRunAgentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssessmentRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssessmentTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssessmentTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExclusionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRulesPackagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PreviewAgentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidCrossAccountRoleException": return try InvalidCrossAccountRoleException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterCrossAccountAccessRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidCrossAccountRoleException": return try InvalidCrossAccountRoleException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveAttributesFromFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAssessmentRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AgentsAlreadyRunningAssessmentException": return try AgentsAlreadyRunningAssessmentException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidCrossAccountRoleException": return try InvalidCrossAccountRoleException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopAssessmentRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SubscribeToEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnsubscribeFromEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssessmentTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "NoSuchEntityException": return try NoSuchEntityException.makeError(baseError: baseError)
            case "ServiceTemporarilyUnavailableException": return try ServiceTemporarilyUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalException {
        let reader = baseError.errorBodyReader
        var value = InternalException()
        value.properties.canRetry = try reader["canRetry"].readIfPresent() ?? false
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.canRetry = try reader["canRetry"].readIfPresent() ?? false
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInputException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInputException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputException()
        value.properties.canRetry = try reader["canRetry"].readIfPresent() ?? false
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchEntityException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchEntityException {
        let reader = baseError.errorBodyReader
        var value = NoSuchEntityException()
        value.properties.canRetry = try reader["canRetry"].readIfPresent() ?? false
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceTemporarilyUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceTemporarilyUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceTemporarilyUnavailableException()
        value.properties.canRetry = try reader["canRetry"].readIfPresent() ?? false
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCrossAccountRoleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCrossAccountRoleException {
        let reader = baseError.errorBodyReader
        var value = InvalidCrossAccountRoleException()
        value.properties.canRetry = try reader["canRetry"].readIfPresent() ?? false
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.canRetry = try reader["canRetry"].readIfPresent() ?? false
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreviewGenerationInProgressException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PreviewGenerationInProgressException {
        let reader = baseError.errorBodyReader
        var value = PreviewGenerationInProgressException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AssessmentRunInProgressException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AssessmentRunInProgressException {
        let reader = baseError.errorBodyReader
        var value = AssessmentRunInProgressException()
        value.properties.assessmentRunArns = try reader["assessmentRunArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.properties.assessmentRunArnsTruncated = try reader["assessmentRunArnsTruncated"].readIfPresent() ?? false
        value.properties.canRetry = try reader["canRetry"].readIfPresent() ?? false
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedFeatureException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedFeatureException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedFeatureException()
        value.properties.canRetry = try reader["canRetry"].readIfPresent() ?? false
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AgentsAlreadyRunningAssessmentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AgentsAlreadyRunningAssessmentException {
        let reader = baseError.errorBodyReader
        var value = AgentsAlreadyRunningAssessmentException()
        value.properties.agents = try reader["agents"].readListIfPresent(memberReadingClosure: InspectorClientTypes.AgentAlreadyRunningAssessment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.properties.agentsTruncated = try reader["agentsTruncated"].readIfPresent() ?? false
        value.properties.canRetry = try reader["canRetry"].readIfPresent() ?? false
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InspectorClientTypes.FailedItemDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.FailedItemDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.FailedItemDetails()
        value.failureCode = try reader["failureCode"].readIfPresent() ?? .sdkUnknown("")
        value.retryable = try reader["retryable"].readIfPresent() ?? false
        return value
    }
}

extension InspectorClientTypes.AssessmentRun {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.AssessmentRun {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.AssessmentRun()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.assessmentTemplateArn = try reader["assessmentTemplateArn"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.durationInSeconds = try reader["durationInSeconds"].readIfPresent() ?? 0
        value.rulesPackageArns = try reader["rulesPackageArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.userAttributesForFindings = try reader["userAttributesForFindings"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Attribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedAt = try reader["completedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stateChangedAt = try reader["stateChangedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dataCollected = try reader["dataCollected"].readIfPresent() ?? false
        value.stateChanges = try reader["stateChanges"].readListIfPresent(memberReadingClosure: InspectorClientTypes.AssessmentRunStateChange.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.notifications = try reader["notifications"].readListIfPresent(memberReadingClosure: InspectorClientTypes.AssessmentRunNotification.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.findingCounts = try reader["findingCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension InspectorClientTypes.AssessmentRunNotification {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.AssessmentRunNotification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.AssessmentRunNotification()
        value.date = try reader["date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.event = try reader["event"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent()
        value.error = try reader["error"].readIfPresent() ?? false
        value.snsTopicArn = try reader["snsTopicArn"].readIfPresent()
        value.snsPublishStatusCode = try reader["snsPublishStatusCode"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.AssessmentRunStateChange {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.AssessmentRunStateChange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.AssessmentRunStateChange()
        value.stateChangedAt = try reader["stateChangedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension InspectorClientTypes.Attribute {

    static func write(value: InspectorClientTypes.Attribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.Attribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.Attribute()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.AssessmentTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.AssessmentTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.AssessmentTarget()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.resourceGroupArn = try reader["resourceGroupArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension InspectorClientTypes.AssessmentTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.AssessmentTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.AssessmentTemplate()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.assessmentTargetArn = try reader["assessmentTargetArn"].readIfPresent() ?? ""
        value.durationInSeconds = try reader["durationInSeconds"].readIfPresent() ?? 0
        value.rulesPackageArns = try reader["rulesPackageArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.userAttributesForFindings = try reader["userAttributesForFindings"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Attribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.lastAssessmentRunArn = try reader["lastAssessmentRunArn"].readIfPresent()
        value.assessmentRunCount = try reader["assessmentRunCount"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension InspectorClientTypes.Exclusion {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.Exclusion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.Exclusion()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.recommendation = try reader["recommendation"].readIfPresent() ?? ""
        value.scopes = try reader["scopes"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Scope.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.attributes = try reader["attributes"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Attribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InspectorClientTypes.Scope {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.Scope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.Scope()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.Finding {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.Finding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.Finding()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.schemaVersion = try reader["schemaVersion"].readIfPresent() ?? 0
        value.service = try reader["service"].readIfPresent()
        value.serviceAttributes = try reader["serviceAttributes"].readIfPresent(with: InspectorClientTypes.InspectorServiceAttributes.read(from:))
        value.assetType = try reader["assetType"].readIfPresent()
        value.assetAttributes = try reader["assetAttributes"].readIfPresent(with: InspectorClientTypes.AssetAttributes.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.title = try reader["title"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.recommendation = try reader["recommendation"].readIfPresent()
        value.severity = try reader["severity"].readIfPresent()
        value.numericSeverity = try reader["numericSeverity"].readIfPresent() ?? 0
        value.confidence = try reader["confidence"].readIfPresent() ?? 0
        value.indicatorOfCompromise = try reader["indicatorOfCompromise"].readIfPresent()
        value.attributes = try reader["attributes"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Attribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.userAttributes = try reader["userAttributes"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Attribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension InspectorClientTypes.AssetAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.AssetAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.AssetAttributes()
        value.schemaVersion = try reader["schemaVersion"].readIfPresent() ?? 0
        value.agentId = try reader["agentId"].readIfPresent()
        value.autoScalingGroup = try reader["autoScalingGroup"].readIfPresent()
        value.amiId = try reader["amiId"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent()
        value.ipv4Addresses = try reader["ipv4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkInterfaces = try reader["networkInterfaces"].readListIfPresent(memberReadingClosure: InspectorClientTypes.NetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InspectorClientTypes.NetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.NetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.NetworkInterface()
        value.networkInterfaceId = try reader["networkInterfaceId"].readIfPresent()
        value.subnetId = try reader["subnetId"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.privateDnsName = try reader["privateDnsName"].readIfPresent()
        value.privateIpAddress = try reader["privateIpAddress"].readIfPresent()
        value.privateIpAddresses = try reader["privateIpAddresses"].readListIfPresent(memberReadingClosure: InspectorClientTypes.PrivateIp.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.publicDnsName = try reader["publicDnsName"].readIfPresent()
        value.publicIp = try reader["publicIp"].readIfPresent()
        value.ipv6Addresses = try reader["ipv6Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: InspectorClientTypes.SecurityGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InspectorClientTypes.SecurityGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.SecurityGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.SecurityGroup()
        value.groupName = try reader["groupName"].readIfPresent()
        value.groupId = try reader["groupId"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.PrivateIp {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.PrivateIp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.PrivateIp()
        value.privateDnsName = try reader["privateDnsName"].readIfPresent()
        value.privateIpAddress = try reader["privateIpAddress"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.Tag {

    static func write(value: InspectorClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.InspectorServiceAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.InspectorServiceAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.InspectorServiceAttributes()
        value.schemaVersion = try reader["schemaVersion"].readIfPresent() ?? 0
        value.assessmentRunArn = try reader["assessmentRunArn"].readIfPresent()
        value.rulesPackageArn = try reader["rulesPackageArn"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.ResourceGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.ResourceGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.ResourceGroup()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: InspectorClientTypes.ResourceGroupTag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension InspectorClientTypes.ResourceGroupTag {

    static func write(value: InspectorClientTypes.ResourceGroupTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.ResourceGroupTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.ResourceGroupTag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.RulesPackage {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.RulesPackage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.RulesPackage()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        value.provider = try reader["provider"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.ExclusionPreview {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.ExclusionPreview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.ExclusionPreview()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.recommendation = try reader["recommendation"].readIfPresent() ?? ""
        value.scopes = try reader["scopes"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Scope.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.attributes = try reader["attributes"].readListIfPresent(memberReadingClosure: InspectorClientTypes.Attribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InspectorClientTypes.TelemetryMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.TelemetryMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.TelemetryMetadata()
        value.messageType = try reader["messageType"].readIfPresent() ?? ""
        value.count = try reader["count"].readIfPresent() ?? 0
        value.dataSize = try reader["dataSize"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.AssessmentRunAgent {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.AssessmentRunAgent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.AssessmentRunAgent()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.assessmentRunArn = try reader["assessmentRunArn"].readIfPresent() ?? ""
        value.agentHealth = try reader["agentHealth"].readIfPresent() ?? .sdkUnknown("")
        value.agentHealthCode = try reader["agentHealthCode"].readIfPresent() ?? .sdkUnknown("")
        value.agentHealthDetails = try reader["agentHealthDetails"].readIfPresent()
        value.autoScalingGroup = try reader["autoScalingGroup"].readIfPresent()
        value.telemetryMetadata = try reader["telemetryMetadata"].readListIfPresent(memberReadingClosure: InspectorClientTypes.TelemetryMetadata.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension InspectorClientTypes.Subscription {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.Subscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.Subscription()
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.topicArn = try reader["topicArn"].readIfPresent() ?? ""
        value.eventSubscriptions = try reader["eventSubscriptions"].readListIfPresent(memberReadingClosure: InspectorClientTypes.EventSubscription.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension InspectorClientTypes.EventSubscription {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.EventSubscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.EventSubscription()
        value.event = try reader["event"].readIfPresent() ?? .sdkUnknown("")
        value.subscribedAt = try reader["subscribedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension InspectorClientTypes.AgentPreview {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.AgentPreview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.AgentPreview()
        value.hostname = try reader["hostname"].readIfPresent()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.autoScalingGroup = try reader["autoScalingGroup"].readIfPresent()
        value.agentHealth = try reader["agentHealth"].readIfPresent()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        value.operatingSystem = try reader["operatingSystem"].readIfPresent()
        value.kernelVersion = try reader["kernelVersion"].readIfPresent()
        value.ipv4Address = try reader["ipv4Address"].readIfPresent()
        return value
    }
}

extension InspectorClientTypes.AgentAlreadyRunningAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> InspectorClientTypes.AgentAlreadyRunningAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InspectorClientTypes.AgentAlreadyRunningAssessment()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.assessmentRunArn = try reader["assessmentRunArn"].readIfPresent() ?? ""
        return value
    }
}

extension InspectorClientTypes.AgentFilter {

    static func write(value: InspectorClientTypes.AgentFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentHealthCodes"].writeList(value.agentHealthCodes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<InspectorClientTypes.AgentHealthCode>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["agentHealths"].writeList(value.agentHealths, memberWritingClosure: SmithyReadWrite.WritingClosureBox<InspectorClientTypes.AgentHealth>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension InspectorClientTypes.AssessmentRunFilter {

    static func write(value: InspectorClientTypes.AssessmentRunFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["completionTimeRange"].write(value.completionTimeRange, with: InspectorClientTypes.TimestampRange.write(value:to:))
        try writer["durationRange"].write(value.durationRange, with: InspectorClientTypes.DurationRange.write(value:to:))
        try writer["namePattern"].write(value.namePattern)
        try writer["rulesPackageArns"].writeList(value.rulesPackageArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["startTimeRange"].write(value.startTimeRange, with: InspectorClientTypes.TimestampRange.write(value:to:))
        try writer["stateChangeTimeRange"].write(value.stateChangeTimeRange, with: InspectorClientTypes.TimestampRange.write(value:to:))
        try writer["states"].writeList(value.states, memberWritingClosure: SmithyReadWrite.WritingClosureBox<InspectorClientTypes.AssessmentRunState>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension InspectorClientTypes.TimestampRange {

    static func write(value: InspectorClientTypes.TimestampRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["beginDate"].writeTimestamp(value.beginDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["endDate"].writeTimestamp(value.endDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension InspectorClientTypes.DurationRange {

    static func write(value: InspectorClientTypes.DurationRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxSeconds"].write(value.maxSeconds)
        try writer["minSeconds"].write(value.minSeconds)
    }
}

extension InspectorClientTypes.AssessmentTargetFilter {

    static func write(value: InspectorClientTypes.AssessmentTargetFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentTargetNamePattern"].write(value.assessmentTargetNamePattern)
    }
}

extension InspectorClientTypes.AssessmentTemplateFilter {

    static func write(value: InspectorClientTypes.AssessmentTemplateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["durationRange"].write(value.durationRange, with: InspectorClientTypes.DurationRange.write(value:to:))
        try writer["namePattern"].write(value.namePattern)
        try writer["rulesPackageArns"].writeList(value.rulesPackageArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension InspectorClientTypes.FindingFilter {

    static func write(value: InspectorClientTypes.FindingFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentIds"].writeList(value.agentIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["attributes"].writeList(value.attributes, memberWritingClosure: InspectorClientTypes.Attribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["autoScalingGroups"].writeList(value.autoScalingGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["creationTimeRange"].write(value.creationTimeRange, with: InspectorClientTypes.TimestampRange.write(value:to:))
        try writer["ruleNames"].writeList(value.ruleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["rulesPackageArns"].writeList(value.rulesPackageArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["severities"].writeList(value.severities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<InspectorClientTypes.Severity>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["userAttributes"].writeList(value.userAttributes, memberWritingClosure: InspectorClientTypes.Attribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum InspectorClientTypes {}
