// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BatchMeterUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productCode = "ProductCode"
        case usageRecords = "UsageRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let usageRecords = usageRecords {
            var usageRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageRecords)
            for usagerecord0 in usageRecords {
                try usageRecordsContainer.encode(usagerecord0)
            }
        }
    }
}

extension BatchMeterUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A BatchMeterUsageRequest contains UsageRecords, which indicate quantities of usage within your application.
public struct BatchMeterUsageInput: Swift.Equatable {
    /// Product code is used to uniquely identify a product in AWS Marketplace. The product code should be the same as the one used during the publishing of a new product.
    /// This member is required.
    public var productCode: Swift.String?
    /// The set of UsageRecords to submit. BatchMeterUsage accepts up to 25 UsageRecords at a time.
    /// This member is required.
    public var usageRecords: [MarketplaceMeteringClientTypes.UsageRecord]?

    public init (
        productCode: Swift.String? = nil,
        usageRecords: [MarketplaceMeteringClientTypes.UsageRecord]? = nil
    )
    {
        self.productCode = productCode
        self.usageRecords = usageRecords
    }
}

struct BatchMeterUsageInputBody: Swift.Equatable {
    let usageRecords: [MarketplaceMeteringClientTypes.UsageRecord]?
    let productCode: Swift.String?
}

extension BatchMeterUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productCode = "ProductCode"
        case usageRecords = "UsageRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageRecordsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.UsageRecord?].self, forKey: .usageRecords)
        var usageRecordsDecoded0:[MarketplaceMeteringClientTypes.UsageRecord]? = nil
        if let usageRecordsContainer = usageRecordsContainer {
            usageRecordsDecoded0 = [MarketplaceMeteringClientTypes.UsageRecord]()
            for structure0 in usageRecordsContainer {
                if let structure0 = structure0 {
                    usageRecordsDecoded0?.append(structure0)
                }
            }
        }
        usageRecords = usageRecordsDecoded0
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
    }
}

extension BatchMeterUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchMeterUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledApiException" : self = .disabledApiException(try DisabledApiException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCustomerIdentifierException" : self = .invalidCustomerIdentifierException(try InvalidCustomerIdentifierException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProductCodeException" : self = .invalidProductCodeException(try InvalidProductCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUsageAllocationsException" : self = .invalidUsageAllocationsException(try InvalidUsageAllocationsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUsageDimensionException" : self = .invalidUsageDimensionException(try InvalidUsageDimensionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TimestampOutOfBoundsException" : self = .timestampOutOfBoundsException(try TimestampOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchMeterUsageOutputError: Swift.Error, Swift.Equatable {
    case disabledApiException(DisabledApiException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidCustomerIdentifierException(InvalidCustomerIdentifierException)
    case invalidProductCodeException(InvalidProductCodeException)
    case invalidTagException(InvalidTagException)
    case invalidUsageAllocationsException(InvalidUsageAllocationsException)
    case invalidUsageDimensionException(InvalidUsageDimensionException)
    case throttlingException(ThrottlingException)
    case timestampOutOfBoundsException(TimestampOutOfBoundsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchMeterUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchMeterUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
            self.unprocessedRecords = output.unprocessedRecords
        } else {
            self.results = nil
            self.unprocessedRecords = nil
        }
    }
}

/// Contains the UsageRecords processed by BatchMeterUsage and any records that have failed due to transient error.
public struct BatchMeterUsageOutputResponse: Swift.Equatable {
    /// Contains all UsageRecords processed by BatchMeterUsage. These records were either honored by AWS Marketplace Metering Service or were invalid. Invalid records should be fixed before being resubmitted.
    public var results: [MarketplaceMeteringClientTypes.UsageRecordResult]?
    /// Contains all UsageRecords that were not processed by BatchMeterUsage. This is a list of UsageRecords. You can retry the failed request by making another BatchMeterUsage call with this list as input in the BatchMeterUsageRequest.
    public var unprocessedRecords: [MarketplaceMeteringClientTypes.UsageRecord]?

    public init (
        results: [MarketplaceMeteringClientTypes.UsageRecordResult]? = nil,
        unprocessedRecords: [MarketplaceMeteringClientTypes.UsageRecord]? = nil
    )
    {
        self.results = results
        self.unprocessedRecords = unprocessedRecords
    }
}

struct BatchMeterUsageOutputResponseBody: Swift.Equatable {
    let results: [MarketplaceMeteringClientTypes.UsageRecordResult]?
    let unprocessedRecords: [MarketplaceMeteringClientTypes.UsageRecord]?
}

extension BatchMeterUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case unprocessedRecords = "UnprocessedRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.UsageRecordResult?].self, forKey: .results)
        var resultsDecoded0:[MarketplaceMeteringClientTypes.UsageRecordResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [MarketplaceMeteringClientTypes.UsageRecordResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let unprocessedRecordsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.UsageRecord?].self, forKey: .unprocessedRecords)
        var unprocessedRecordsDecoded0:[MarketplaceMeteringClientTypes.UsageRecord]? = nil
        if let unprocessedRecordsContainer = unprocessedRecordsContainer {
            unprocessedRecordsDecoded0 = [MarketplaceMeteringClientTypes.UsageRecord]()
            for structure0 in unprocessedRecordsContainer {
                if let structure0 = structure0 {
                    unprocessedRecordsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedRecords = unprocessedRecordsDecoded0
    }
}

extension CustomerNotEntitledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CustomerNotEntitledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception thrown when the customer does not have a valid subscription for the product.
public struct CustomerNotEntitledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomerNotEntitledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomerNotEntitledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisabledApiException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisabledApiExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The API is disabled in the Region.
public struct DisabledApiException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DisabledApiExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DisabledApiExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DuplicateRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A metering record has already been emitted by the same EC2 instance, ECS task, or EKS pod for the given {usageDimension, timestamp} with a different usageQuantity.
public struct DuplicateRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExpiredTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExpiredTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The submitted registration token has expired. This can happen if the buyer's browser takes too long to redirect to your page, the buyer has resubmitted the registration token, or your application has held on to the registration token for too long. Your SaaS registration website should redeem this token as soon as it is submitted by the buyer's browser.
public struct ExpiredTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExpiredTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error has occurred. Retry your request. If the problem persists, post a message with details on the AWS forums.
public struct InternalServiceErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCustomerIdentifierException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidCustomerIdentifierExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have metered usage for a CustomerIdentifier that does not exist.
public struct InvalidCustomerIdentifierException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCustomerIdentifierExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCustomerIdentifierExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointRegionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidEndpointRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The endpoint being called is in a AWS Region different from your EC2 instance, ECS task, or EKS pod. The Region of the Metering Service endpoint and the AWS Region of the resource must match.
public struct InvalidEndpointRegionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEndpointRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidProductCodeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidProductCodeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The product code passed does not match the product code used for publishing the product.
public struct InvalidProductCodeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidProductCodeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidProductCodeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPublicKeyVersionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidPublicKeyVersionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Public Key version is invalid.
public struct InvalidPublicKeyVersionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPublicKeyVersionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPublicKeyVersionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRegionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// RegisterUsage must be called in the same AWS Region the ECS task was launched in. This prevents a container from hardcoding a Region (e.g. withRegion(“us-east-1”) when calling RegisterUsage.
public struct InvalidRegionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTagExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The tag is invalid, or the number of tags is greater than 5.
public struct InvalidTagException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Registration token is invalid.
public struct InvalidTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUsageAllocationsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidUsageAllocationsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The usage allocation objects are invalid, or the number of allocations is greater than 500 for a single usage record.
public struct InvalidUsageAllocationsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUsageAllocationsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidUsageAllocationsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUsageDimensionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidUsageDimensionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The usage dimension does not match one of the UsageDimensions associated with products.
public struct InvalidUsageDimensionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUsageDimensionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidUsageDimensionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MeterUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case productCode = "ProductCode"
        case timestamp = "Timestamp"
        case usageAllocations = "UsageAllocations"
        case usageDimension = "UsageDimension"
        case usageQuantity = "UsageQuantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let usageAllocations = usageAllocations {
            var usageAllocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageAllocations)
            for usageallocation0 in usageAllocations {
                try usageAllocationsContainer.encode(usageallocation0)
            }
        }
        if let usageDimension = self.usageDimension {
            try encodeContainer.encode(usageDimension, forKey: .usageDimension)
        }
        if let usageQuantity = self.usageQuantity {
            try encodeContainer.encode(usageQuantity, forKey: .usageQuantity)
        }
    }
}

extension MeterUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MeterUsageInput: Swift.Equatable {
    /// Checks whether you have the permissions required for the action, but does not make the request. If you have the permissions, the request returns DryRunOperation; otherwise, it returns UnauthorizedException. Defaults to false if not specified.
    public var dryRun: Swift.Bool?
    /// Product code is used to uniquely identify a product in AWS Marketplace. The product code should be the same as the one used during the publishing of a new product.
    /// This member is required.
    public var productCode: Swift.String?
    /// Timestamp, in UTC, for which the usage is being reported. Your application can meter usage for up to one hour in the past. Make sure the timestamp value is not before the start of the software usage.
    /// This member is required.
    public var timestamp: ClientRuntime.Date?
    /// The set of UsageAllocations to submit. The sum of all UsageAllocation quantities must equal the UsageQuantity of the MeterUsage request, and each UsageAllocation must have a unique set of tags (include no tags).
    public var usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]?
    /// It will be one of the fcp dimension name provided during the publishing of the product.
    /// This member is required.
    public var usageDimension: Swift.String?
    /// Consumption value for the hour. Defaults to 0 if not specified.
    public var usageQuantity: Swift.Int?

    public init (
        dryRun: Swift.Bool? = nil,
        productCode: Swift.String? = nil,
        timestamp: ClientRuntime.Date? = nil,
        usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]? = nil,
        usageDimension: Swift.String? = nil,
        usageQuantity: Swift.Int? = nil
    )
    {
        self.dryRun = dryRun
        self.productCode = productCode
        self.timestamp = timestamp
        self.usageAllocations = usageAllocations
        self.usageDimension = usageDimension
        self.usageQuantity = usageQuantity
    }
}

struct MeterUsageInputBody: Swift.Equatable {
    let productCode: Swift.String?
    let timestamp: ClientRuntime.Date?
    let usageDimension: Swift.String?
    let usageQuantity: Swift.Int?
    let dryRun: Swift.Bool?
    let usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]?
}

extension MeterUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case productCode = "ProductCode"
        case timestamp = "Timestamp"
        case usageAllocations = "UsageAllocations"
        case usageDimension = "UsageDimension"
        case usageQuantity = "UsageQuantity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let usageDimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageDimension)
        usageDimension = usageDimensionDecoded
        let usageQuantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .usageQuantity)
        usageQuantity = usageQuantityDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let usageAllocationsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.UsageAllocation?].self, forKey: .usageAllocations)
        var usageAllocationsDecoded0:[MarketplaceMeteringClientTypes.UsageAllocation]? = nil
        if let usageAllocationsContainer = usageAllocationsContainer {
            usageAllocationsDecoded0 = [MarketplaceMeteringClientTypes.UsageAllocation]()
            for structure0 in usageAllocationsContainer {
                if let structure0 = structure0 {
                    usageAllocationsDecoded0?.append(structure0)
                }
            }
        }
        usageAllocations = usageAllocationsDecoded0
    }
}

extension MeterUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MeterUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomerNotEntitledException" : self = .customerNotEntitledException(try CustomerNotEntitledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRequestException" : self = .duplicateRequestException(try DuplicateRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointRegionException" : self = .invalidEndpointRegionException(try InvalidEndpointRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProductCodeException" : self = .invalidProductCodeException(try InvalidProductCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUsageAllocationsException" : self = .invalidUsageAllocationsException(try InvalidUsageAllocationsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUsageDimensionException" : self = .invalidUsageDimensionException(try InvalidUsageDimensionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TimestampOutOfBoundsException" : self = .timestampOutOfBoundsException(try TimestampOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum MeterUsageOutputError: Swift.Error, Swift.Equatable {
    case customerNotEntitledException(CustomerNotEntitledException)
    case duplicateRequestException(DuplicateRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidEndpointRegionException(InvalidEndpointRegionException)
    case invalidProductCodeException(InvalidProductCodeException)
    case invalidTagException(InvalidTagException)
    case invalidUsageAllocationsException(InvalidUsageAllocationsException)
    case invalidUsageDimensionException(InvalidUsageDimensionException)
    case throttlingException(ThrottlingException)
    case timestampOutOfBoundsException(TimestampOutOfBoundsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MeterUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MeterUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.meteringRecordId = output.meteringRecordId
        } else {
            self.meteringRecordId = nil
        }
    }
}

public struct MeterUsageOutputResponse: Swift.Equatable {
    /// Metering record id.
    public var meteringRecordId: Swift.String?

    public init (
        meteringRecordId: Swift.String? = nil
    )
    {
        self.meteringRecordId = meteringRecordId
    }
}

struct MeterUsageOutputResponseBody: Swift.Equatable {
    let meteringRecordId: Swift.String?
}

extension MeterUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meteringRecordId = "MeteringRecordId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meteringRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meteringRecordId)
        meteringRecordId = meteringRecordIdDecoded
    }
}

extension PlatformNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PlatformNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AWS Marketplace does not support metering usage from the underlying platform. Currently, Amazon ECS, Amazon EKS, and AWS Fargate are supported.
public struct PlatformNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PlatformNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PlatformNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RegisterUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nonce = "Nonce"
        case productCode = "ProductCode"
        case publicKeyVersion = "PublicKeyVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nonce = self.nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let publicKeyVersion = self.publicKeyVersion {
            try encodeContainer.encode(publicKeyVersion, forKey: .publicKeyVersion)
        }
    }
}

extension RegisterUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterUsageInput: Swift.Equatable {
    /// (Optional) To scope down the registration to a specific running software instance and guard against replay attacks.
    public var nonce: Swift.String?
    /// Product code is used to uniquely identify a product in AWS Marketplace. The product code should be the same as the one used during the publishing of a new product.
    /// This member is required.
    public var productCode: Swift.String?
    /// Public Key Version provided by AWS Marketplace
    /// This member is required.
    public var publicKeyVersion: Swift.Int?

    public init (
        nonce: Swift.String? = nil,
        productCode: Swift.String? = nil,
        publicKeyVersion: Swift.Int? = nil
    )
    {
        self.nonce = nonce
        self.productCode = productCode
        self.publicKeyVersion = publicKeyVersion
    }
}

struct RegisterUsageInputBody: Swift.Equatable {
    let productCode: Swift.String?
    let publicKeyVersion: Swift.Int?
    let nonce: Swift.String?
}

extension RegisterUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nonce = "Nonce"
        case productCode = "ProductCode"
        case publicKeyVersion = "PublicKeyVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let publicKeyVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .publicKeyVersion)
        publicKeyVersion = publicKeyVersionDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nonce)
        nonce = nonceDecoded
    }
}

extension RegisterUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomerNotEntitledException" : self = .customerNotEntitledException(try CustomerNotEntitledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledApiException" : self = .disabledApiException(try DisabledApiException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProductCodeException" : self = .invalidProductCodeException(try InvalidProductCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPublicKeyVersionException" : self = .invalidPublicKeyVersionException(try InvalidPublicKeyVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRegionException" : self = .invalidRegionException(try InvalidRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PlatformNotSupportedException" : self = .platformNotSupportedException(try PlatformNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterUsageOutputError: Swift.Error, Swift.Equatable {
    case customerNotEntitledException(CustomerNotEntitledException)
    case disabledApiException(DisabledApiException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidProductCodeException(InvalidProductCodeException)
    case invalidPublicKeyVersionException(InvalidPublicKeyVersionException)
    case invalidRegionException(InvalidRegionException)
    case platformNotSupportedException(PlatformNotSupportedException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.publicKeyRotationTimestamp = output.publicKeyRotationTimestamp
            self.signature = output.signature
        } else {
            self.publicKeyRotationTimestamp = nil
            self.signature = nil
        }
    }
}

public struct RegisterUsageOutputResponse: Swift.Equatable {
    /// (Optional) Only included when public key version has expired
    public var publicKeyRotationTimestamp: ClientRuntime.Date?
    /// JWT Token
    public var signature: Swift.String?

    public init (
        publicKeyRotationTimestamp: ClientRuntime.Date? = nil,
        signature: Swift.String? = nil
    )
    {
        self.publicKeyRotationTimestamp = publicKeyRotationTimestamp
        self.signature = signature
    }
}

struct RegisterUsageOutputResponseBody: Swift.Equatable {
    let publicKeyRotationTimestamp: ClientRuntime.Date?
    let signature: Swift.String?
}

extension RegisterUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyRotationTimestamp = "PublicKeyRotationTimestamp"
        case signature = "Signature"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyRotationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .publicKeyRotationTimestamp)
        publicKeyRotationTimestamp = publicKeyRotationTimestampDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

extension ResolveCustomerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationToken = "RegistrationToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationToken = self.registrationToken {
            try encodeContainer.encode(registrationToken, forKey: .registrationToken)
        }
    }
}

extension ResolveCustomerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains input to the ResolveCustomer operation.
public struct ResolveCustomerInput: Swift.Equatable {
    /// When a buyer visits your website during the registration process, the buyer submits a registration token through the browser. The registration token is resolved to obtain a CustomerIdentifier along with the CustomerAWSAccountId and ProductCode.
    /// This member is required.
    public var registrationToken: Swift.String?

    public init (
        registrationToken: Swift.String? = nil
    )
    {
        self.registrationToken = registrationToken
    }
}

struct ResolveCustomerInputBody: Swift.Equatable {
    let registrationToken: Swift.String?
}

extension ResolveCustomerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationToken = "RegistrationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationToken)
        registrationToken = registrationTokenDecoded
    }
}

extension ResolveCustomerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveCustomerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledApiException" : self = .disabledApiException(try DisabledApiException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResolveCustomerOutputError: Swift.Error, Swift.Equatable {
    case disabledApiException(DisabledApiException)
    case expiredTokenException(ExpiredTokenException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidTokenException(InvalidTokenException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveCustomerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResolveCustomerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customerAWSAccountId = output.customerAWSAccountId
            self.customerIdentifier = output.customerIdentifier
            self.productCode = output.productCode
        } else {
            self.customerAWSAccountId = nil
            self.customerIdentifier = nil
            self.productCode = nil
        }
    }
}

/// The result of the ResolveCustomer operation. Contains the CustomerIdentifier along with the CustomerAWSAccountId and ProductCode.
public struct ResolveCustomerOutputResponse: Swift.Equatable {
    /// The CustomerAWSAccountId provides the AWS account ID associated with the CustomerIdentifier for the individual customer.
    public var customerAWSAccountId: Swift.String?
    /// The CustomerIdentifier is used to identify an individual customer in your application. Calls to BatchMeterUsage require CustomerIdentifiers for each UsageRecord.
    public var customerIdentifier: Swift.String?
    /// The product code is returned to confirm that the buyer is registering for your product. Subsequent BatchMeterUsage calls should be made using this product code.
    public var productCode: Swift.String?

    public init (
        customerAWSAccountId: Swift.String? = nil,
        customerIdentifier: Swift.String? = nil,
        productCode: Swift.String? = nil
    )
    {
        self.customerAWSAccountId = customerAWSAccountId
        self.customerIdentifier = customerIdentifier
        self.productCode = productCode
    }
}

struct ResolveCustomerOutputResponseBody: Swift.Equatable {
    let customerIdentifier: Swift.String?
    let productCode: Swift.String?
    let customerAWSAccountId: Swift.String?
}

extension ResolveCustomerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerAWSAccountId = "CustomerAWSAccountId"
        case customerIdentifier = "CustomerIdentifier"
        case productCode = "ProductCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerIdentifier)
        customerIdentifier = customerIdentifierDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let customerAWSAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAWSAccountId)
        customerAWSAccountId = customerAWSAccountIdDecoded
    }
}

extension MarketplaceMeteringClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MarketplaceMeteringClientTypes {
    /// Metadata assigned to an allocation. Each tag is made up of a key and a value.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that makes up a tag. A key is a label that acts like a category for the specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// One part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key). The value can be empty or null.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The calls to the API are throttled.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestampOutOfBoundsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TimestampOutOfBoundsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The timestamp value passed in the UsageRecord is out of allowed range. For BatchMeterUsage, if any of the records are outside of the allowed range, the entire batch is not processed. You must remove invalid records and try again.
public struct TimestampOutOfBoundsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TimestampOutOfBoundsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TimestampOutOfBoundsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MarketplaceMeteringClientTypes.UsageAllocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedUsageQuantity = "AllocatedUsageQuantity"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedUsageQuantity = self.allocatedUsageQuantity {
            try encodeContainer.encode(allocatedUsageQuantity, forKey: .allocatedUsageQuantity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedUsageQuantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedUsageQuantity)
        allocatedUsageQuantity = allocatedUsageQuantityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MarketplaceMeteringClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MarketplaceMeteringClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MarketplaceMeteringClientTypes {
    /// Usage allocations allow you to split usage into buckets by tags. Each UsageAllocation indicates the usage quantity for a specific set of tags.
    public struct UsageAllocation: Swift.Equatable {
        /// The total quantity allocated to this bucket of usage.
        /// This member is required.
        public var allocatedUsageQuantity: Swift.Int?
        /// The set of tags that define the bucket of usage. For the bucket of items with no tags, this parameter can be left out.
        public var tags: [MarketplaceMeteringClientTypes.Tag]?

        public init (
            allocatedUsageQuantity: Swift.Int? = nil,
            tags: [MarketplaceMeteringClientTypes.Tag]? = nil
        )
        {
            self.allocatedUsageQuantity = allocatedUsageQuantity
            self.tags = tags
        }
    }

}

extension MarketplaceMeteringClientTypes.UsageRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerIdentifier = "CustomerIdentifier"
        case dimension = "Dimension"
        case quantity = "Quantity"
        case timestamp = "Timestamp"
        case usageAllocations = "UsageAllocations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerIdentifier = self.customerIdentifier {
            try encodeContainer.encode(customerIdentifier, forKey: .customerIdentifier)
        }
        if let dimension = self.dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let quantity = self.quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let usageAllocations = usageAllocations {
            var usageAllocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageAllocations)
            for usageallocation0 in usageAllocations {
                try usageAllocationsContainer.encode(usageallocation0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let customerIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerIdentifier)
        customerIdentifier = customerIdentifierDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let usageAllocationsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.UsageAllocation?].self, forKey: .usageAllocations)
        var usageAllocationsDecoded0:[MarketplaceMeteringClientTypes.UsageAllocation]? = nil
        if let usageAllocationsContainer = usageAllocationsContainer {
            usageAllocationsDecoded0 = [MarketplaceMeteringClientTypes.UsageAllocation]()
            for structure0 in usageAllocationsContainer {
                if let structure0 = structure0 {
                    usageAllocationsDecoded0?.append(structure0)
                }
            }
        }
        usageAllocations = usageAllocationsDecoded0
    }
}

extension MarketplaceMeteringClientTypes {
    /// A UsageRecord indicates a quantity of usage for a given product, customer, dimension and time. Multiple requests with the same UsageRecords as input will be de-duplicated to prevent double charges.
    public struct UsageRecord: Swift.Equatable {
        /// The CustomerIdentifier is obtained through the ResolveCustomer operation and represents an individual buyer in your application.
        /// This member is required.
        public var customerIdentifier: Swift.String?
        /// During the process of registering a product on AWS Marketplace, dimensions are specified. These represent different units of value in your application.
        /// This member is required.
        public var dimension: Swift.String?
        /// The quantity of usage consumed by the customer for the given dimension and time. Defaults to 0 if not specified.
        public var quantity: Swift.Int?
        /// Timestamp, in UTC, for which the usage is being reported. Your application can meter usage for up to one hour in the past. Make sure the timestamp value is not before the start of the software usage.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The set of UsageAllocations to submit. The sum of all UsageAllocation quantities must equal the Quantity of the UsageRecord.
        public var usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]?

        public init (
            customerIdentifier: Swift.String? = nil,
            dimension: Swift.String? = nil,
            quantity: Swift.Int? = nil,
            timestamp: ClientRuntime.Date? = nil,
            usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]? = nil
        )
        {
            self.customerIdentifier = customerIdentifier
            self.dimension = dimension
            self.quantity = quantity
            self.timestamp = timestamp
            self.usageAllocations = usageAllocations
        }
    }

}

extension MarketplaceMeteringClientTypes.UsageRecordResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meteringRecordId = "MeteringRecordId"
        case status = "Status"
        case usageRecord = "UsageRecord"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meteringRecordId = self.meteringRecordId {
            try encodeContainer.encode(meteringRecordId, forKey: .meteringRecordId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let usageRecord = self.usageRecord {
            try encodeContainer.encode(usageRecord, forKey: .usageRecord)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageRecordDecoded = try containerValues.decodeIfPresent(MarketplaceMeteringClientTypes.UsageRecord.self, forKey: .usageRecord)
        usageRecord = usageRecordDecoded
        let meteringRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meteringRecordId)
        meteringRecordId = meteringRecordIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MarketplaceMeteringClientTypes.UsageRecordResultStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension MarketplaceMeteringClientTypes {
    /// A UsageRecordResult indicates the status of a given UsageRecord processed by BatchMeterUsage.
    public struct UsageRecordResult: Swift.Equatable {
        /// The MeteringRecordId is a unique identifier for this metering event.
        public var meteringRecordId: Swift.String?
        /// The UsageRecordResultStatus indicates the status of an individual UsageRecord processed by BatchMeterUsage.
        ///
        /// * Success- The UsageRecord was accepted and honored by BatchMeterUsage.
        ///
        /// * CustomerNotSubscribed- The CustomerIdentifier specified is not able to use your product. The UsageRecord was not honored. There are three causes for this result:
        ///
        /// * The customer identifier is invalid.
        ///
        /// * The customer identifier provided in the metering record does not have an active agreement or subscription with this product. Future UsageRecords for this customer will fail until the customer subscribes to your product.
        ///
        /// * The customer's AWS account was suspended.
        ///
        ///
        ///
        ///
        /// * DuplicateRecord- Indicates that the UsageRecord was invalid and not honored. A previously metered UsageRecord had the same customer, dimension, and time, but a different quantity.
        public var status: MarketplaceMeteringClientTypes.UsageRecordResultStatus?
        /// The UsageRecord that was part of the BatchMeterUsage request.
        public var usageRecord: MarketplaceMeteringClientTypes.UsageRecord?

        public init (
            meteringRecordId: Swift.String? = nil,
            status: MarketplaceMeteringClientTypes.UsageRecordResultStatus? = nil,
            usageRecord: MarketplaceMeteringClientTypes.UsageRecord? = nil
        )
        {
            self.meteringRecordId = meteringRecordId
            self.status = status
            self.usageRecord = usageRecord
        }
    }

}

extension MarketplaceMeteringClientTypes {
    public enum UsageRecordResultStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerNotSubscribed
        case duplicateRecord
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageRecordResultStatus] {
            return [
                .customerNotSubscribed,
                .duplicateRecord,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerNotSubscribed: return "CustomerNotSubscribed"
            case .duplicateRecord: return "DuplicateRecord"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageRecordResultStatus(rawValue: rawValue) ?? UsageRecordResultStatus.sdkUnknown(rawValue)
        }
    }
}
