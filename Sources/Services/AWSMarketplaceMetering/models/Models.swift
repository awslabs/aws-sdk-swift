// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BatchMeterUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productCode = "ProductCode"
        case usageRecords = "UsageRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let usageRecords = usageRecords {
            var usageRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageRecords)
            for usagerecord0 in usageRecords {
                try usageRecordsContainer.encode(usagerecord0)
            }
        }
    }
}

extension BatchMeterUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A BatchMeterUsageRequest contains UsageRecords, which indicate quantities of usage within your application.
public struct BatchMeterUsageInput: Swift.Equatable {
    /// Product code is used to uniquely identify a product in AWS Marketplace. The product code should be the same as the one used during the publishing of a new product.
    /// This member is required.
    public var productCode: Swift.String?
    /// The set of UsageRecords to submit. BatchMeterUsage accepts up to 25 UsageRecords at a time.
    /// This member is required.
    public var usageRecords: [MarketplaceMeteringClientTypes.UsageRecord]?

    public init(
        productCode: Swift.String? = nil,
        usageRecords: [MarketplaceMeteringClientTypes.UsageRecord]? = nil
    )
    {
        self.productCode = productCode
        self.usageRecords = usageRecords
    }
}

struct BatchMeterUsageInputBody: Swift.Equatable {
    let usageRecords: [MarketplaceMeteringClientTypes.UsageRecord]?
    let productCode: Swift.String?
}

extension BatchMeterUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productCode = "ProductCode"
        case usageRecords = "UsageRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageRecordsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.UsageRecord?].self, forKey: .usageRecords)
        var usageRecordsDecoded0:[MarketplaceMeteringClientTypes.UsageRecord]? = nil
        if let usageRecordsContainer = usageRecordsContainer {
            usageRecordsDecoded0 = [MarketplaceMeteringClientTypes.UsageRecord]()
            for structure0 in usageRecordsContainer {
                if let structure0 = structure0 {
                    usageRecordsDecoded0?.append(structure0)
                }
            }
        }
        usageRecords = usageRecordsDecoded0
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
    }
}

extension BatchMeterUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchMeterUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
            self.unprocessedRecords = output.unprocessedRecords
        } else {
            self.results = nil
            self.unprocessedRecords = nil
        }
    }
}

/// Contains the UsageRecords processed by BatchMeterUsage and any records that have failed due to transient error.
public struct BatchMeterUsageOutput: Swift.Equatable {
    /// Contains all UsageRecords processed by BatchMeterUsage. These records were either honored by AWS Marketplace Metering Service or were invalid. Invalid records should be fixed before being resubmitted.
    public var results: [MarketplaceMeteringClientTypes.UsageRecordResult]?
    /// Contains all UsageRecords that were not processed by BatchMeterUsage. This is a list of UsageRecords. You can retry the failed request by making another BatchMeterUsage call with this list as input in the BatchMeterUsageRequest.
    public var unprocessedRecords: [MarketplaceMeteringClientTypes.UsageRecord]?

    public init(
        results: [MarketplaceMeteringClientTypes.UsageRecordResult]? = nil,
        unprocessedRecords: [MarketplaceMeteringClientTypes.UsageRecord]? = nil
    )
    {
        self.results = results
        self.unprocessedRecords = unprocessedRecords
    }
}

struct BatchMeterUsageOutputBody: Swift.Equatable {
    let results: [MarketplaceMeteringClientTypes.UsageRecordResult]?
    let unprocessedRecords: [MarketplaceMeteringClientTypes.UsageRecord]?
}

extension BatchMeterUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case unprocessedRecords = "UnprocessedRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.UsageRecordResult?].self, forKey: .results)
        var resultsDecoded0:[MarketplaceMeteringClientTypes.UsageRecordResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [MarketplaceMeteringClientTypes.UsageRecordResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let unprocessedRecordsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.UsageRecord?].self, forKey: .unprocessedRecords)
        var unprocessedRecordsDecoded0:[MarketplaceMeteringClientTypes.UsageRecord]? = nil
        if let unprocessedRecordsContainer = unprocessedRecordsContainer {
            unprocessedRecordsDecoded0 = [MarketplaceMeteringClientTypes.UsageRecord]()
            for structure0 in unprocessedRecordsContainer {
                if let structure0 = structure0 {
                    unprocessedRecordsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedRecords = unprocessedRecordsDecoded0
    }
}

enum BatchMeterUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DisabledApiException": return try await DisabledApiException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCustomerIdentifierException": return try await InvalidCustomerIdentifierException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidProductCodeException": return try await InvalidProductCodeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagException": return try await InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidUsageAllocationsException": return try await InvalidUsageAllocationsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidUsageDimensionException": return try await InvalidUsageDimensionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimestampOutOfBoundsException": return try await TimestampOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CustomerNotEntitledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CustomerNotEntitledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception thrown when the customer does not have a valid subscription for the product.
public struct CustomerNotEntitledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CustomerNotEntitledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CustomerNotEntitledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomerNotEntitledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisabledApiException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisabledApiExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The API is disabled in the Region.
public struct DisabledApiException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DisabledApiException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DisabledApiExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DisabledApiExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DuplicateRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A metering record has already been emitted by the same EC2 instance, ECS task, or EKS pod for the given {usageDimension, timestamp} with a different usageQuantity.
public struct DuplicateRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DuplicateRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExpiredTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExpiredTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The submitted registration token has expired. This can happen if the buyer's browser takes too long to redirect to your page, the buyer has resubmitted the registration token, or your application has held on to the registration token for too long. Your SaaS registration website should redeem this token as soon as it is submitted by the buyer's browser.
public struct ExpiredTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ExpiredTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExpiredTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error has occurred. Retry your request. If the problem persists, post a message with details on the AWS forums.
public struct InternalServiceErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCustomerIdentifierException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCustomerIdentifierExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have metered usage for a CustomerIdentifier that does not exist.
public struct InvalidCustomerIdentifierException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCustomerIdentifierException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCustomerIdentifierExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCustomerIdentifierExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointRegionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidEndpointRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The endpoint being called is in a AWS Region different from your EC2 instance, ECS task, or EKS pod. The Region of the Metering Service endpoint and the AWS Region of the resource must match.
public struct InvalidEndpointRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEndpointRegionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidEndpointRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEndpointRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidProductCodeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidProductCodeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The product code passed does not match the product code used for publishing the product.
public struct InvalidProductCodeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidProductCodeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidProductCodeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidProductCodeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPublicKeyVersionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPublicKeyVersionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Public Key version is invalid.
public struct InvalidPublicKeyVersionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPublicKeyVersionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPublicKeyVersionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPublicKeyVersionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRegionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// RegisterUsage must be called in the same AWS Region the ECS task was launched in. This prevents a container from hardcoding a Region (e.g. withRegion(“us-east-1”) when calling RegisterUsage.
public struct InvalidRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRegionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTagExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The tag is invalid, or the number of tags is greater than 5.
public struct InvalidTagException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTagExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Registration token is invalid.
public struct InvalidTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUsageAllocationsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidUsageAllocationsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The usage allocation objects are invalid, or the number of allocations is greater than 500 for a single usage record.
public struct InvalidUsageAllocationsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUsageAllocationsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidUsageAllocationsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidUsageAllocationsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUsageDimensionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidUsageDimensionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The usage dimension does not match one of the UsageDimensions associated with products.
public struct InvalidUsageDimensionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUsageDimensionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidUsageDimensionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidUsageDimensionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MeterUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case productCode = "ProductCode"
        case timestamp = "Timestamp"
        case usageAllocations = "UsageAllocations"
        case usageDimension = "UsageDimension"
        case usageQuantity = "UsageQuantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let usageAllocations = usageAllocations {
            var usageAllocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageAllocations)
            for usageallocation0 in usageAllocations {
                try usageAllocationsContainer.encode(usageallocation0)
            }
        }
        if let usageDimension = self.usageDimension {
            try encodeContainer.encode(usageDimension, forKey: .usageDimension)
        }
        if let usageQuantity = self.usageQuantity {
            try encodeContainer.encode(usageQuantity, forKey: .usageQuantity)
        }
    }
}

extension MeterUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MeterUsageInput: Swift.Equatable {
    /// Checks whether you have the permissions required for the action, but does not make the request. If you have the permissions, the request returns DryRunOperation; otherwise, it returns UnauthorizedException. Defaults to false if not specified.
    public var dryRun: Swift.Bool?
    /// Product code is used to uniquely identify a product in AWS Marketplace. The product code should be the same as the one used during the publishing of a new product.
    /// This member is required.
    public var productCode: Swift.String?
    /// Timestamp, in UTC, for which the usage is being reported. Your application can meter usage for up to one hour in the past. Make sure the timestamp value is not before the start of the software usage.
    /// This member is required.
    public var timestamp: ClientRuntime.Date?
    /// The set of UsageAllocations to submit. The sum of all UsageAllocation quantities must equal the UsageQuantity of the MeterUsage request, and each UsageAllocation must have a unique set of tags (include no tags).
    public var usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]?
    /// It will be one of the fcp dimension name provided during the publishing of the product.
    /// This member is required.
    public var usageDimension: Swift.String?
    /// Consumption value for the hour. Defaults to 0 if not specified.
    public var usageQuantity: Swift.Int?

    public init(
        dryRun: Swift.Bool? = nil,
        productCode: Swift.String? = nil,
        timestamp: ClientRuntime.Date? = nil,
        usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]? = nil,
        usageDimension: Swift.String? = nil,
        usageQuantity: Swift.Int? = nil
    )
    {
        self.dryRun = dryRun
        self.productCode = productCode
        self.timestamp = timestamp
        self.usageAllocations = usageAllocations
        self.usageDimension = usageDimension
        self.usageQuantity = usageQuantity
    }
}

struct MeterUsageInputBody: Swift.Equatable {
    let productCode: Swift.String?
    let timestamp: ClientRuntime.Date?
    let usageDimension: Swift.String?
    let usageQuantity: Swift.Int?
    let dryRun: Swift.Bool?
    let usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]?
}

extension MeterUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case productCode = "ProductCode"
        case timestamp = "Timestamp"
        case usageAllocations = "UsageAllocations"
        case usageDimension = "UsageDimension"
        case usageQuantity = "UsageQuantity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let usageDimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageDimension)
        usageDimension = usageDimensionDecoded
        let usageQuantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .usageQuantity)
        usageQuantity = usageQuantityDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let usageAllocationsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.UsageAllocation?].self, forKey: .usageAllocations)
        var usageAllocationsDecoded0:[MarketplaceMeteringClientTypes.UsageAllocation]? = nil
        if let usageAllocationsContainer = usageAllocationsContainer {
            usageAllocationsDecoded0 = [MarketplaceMeteringClientTypes.UsageAllocation]()
            for structure0 in usageAllocationsContainer {
                if let structure0 = structure0 {
                    usageAllocationsDecoded0?.append(structure0)
                }
            }
        }
        usageAllocations = usageAllocationsDecoded0
    }
}

extension MeterUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MeterUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.meteringRecordId = output.meteringRecordId
        } else {
            self.meteringRecordId = nil
        }
    }
}

public struct MeterUsageOutput: Swift.Equatable {
    /// Metering record id.
    public var meteringRecordId: Swift.String?

    public init(
        meteringRecordId: Swift.String? = nil
    )
    {
        self.meteringRecordId = meteringRecordId
    }
}

struct MeterUsageOutputBody: Swift.Equatable {
    let meteringRecordId: Swift.String?
}

extension MeterUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meteringRecordId = "MeteringRecordId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meteringRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meteringRecordId)
        meteringRecordId = meteringRecordIdDecoded
    }
}

enum MeterUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CustomerNotEntitledException": return try await CustomerNotEntitledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateRequestException": return try await DuplicateRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEndpointRegionException": return try await InvalidEndpointRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidProductCodeException": return try await InvalidProductCodeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagException": return try await InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidUsageAllocationsException": return try await InvalidUsageAllocationsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidUsageDimensionException": return try await InvalidUsageDimensionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TimestampOutOfBoundsException": return try await TimestampOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PlatformNotSupportedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PlatformNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// AWS Marketplace does not support metering usage from the underlying platform. Currently, Amazon ECS, Amazon EKS, and AWS Fargate are supported.
public struct PlatformNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PlatformNotSupportedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PlatformNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PlatformNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RegisterUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nonce = "Nonce"
        case productCode = "ProductCode"
        case publicKeyVersion = "PublicKeyVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nonce = self.nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let publicKeyVersion = self.publicKeyVersion {
            try encodeContainer.encode(publicKeyVersion, forKey: .publicKeyVersion)
        }
    }
}

extension RegisterUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterUsageInput: Swift.Equatable {
    /// (Optional) To scope down the registration to a specific running software instance and guard against replay attacks.
    public var nonce: Swift.String?
    /// Product code is used to uniquely identify a product in AWS Marketplace. The product code should be the same as the one used during the publishing of a new product.
    /// This member is required.
    public var productCode: Swift.String?
    /// Public Key Version provided by AWS Marketplace
    /// This member is required.
    public var publicKeyVersion: Swift.Int?

    public init(
        nonce: Swift.String? = nil,
        productCode: Swift.String? = nil,
        publicKeyVersion: Swift.Int? = nil
    )
    {
        self.nonce = nonce
        self.productCode = productCode
        self.publicKeyVersion = publicKeyVersion
    }
}

struct RegisterUsageInputBody: Swift.Equatable {
    let productCode: Swift.String?
    let publicKeyVersion: Swift.Int?
    let nonce: Swift.String?
}

extension RegisterUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nonce = "Nonce"
        case productCode = "ProductCode"
        case publicKeyVersion = "PublicKeyVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let publicKeyVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .publicKeyVersion)
        publicKeyVersion = publicKeyVersionDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nonce)
        nonce = nonceDecoded
    }
}

extension RegisterUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.publicKeyRotationTimestamp = output.publicKeyRotationTimestamp
            self.signature = output.signature
        } else {
            self.publicKeyRotationTimestamp = nil
            self.signature = nil
        }
    }
}

public struct RegisterUsageOutput: Swift.Equatable {
    /// (Optional) Only included when public key version has expired
    public var publicKeyRotationTimestamp: ClientRuntime.Date?
    /// JWT Token
    public var signature: Swift.String?

    public init(
        publicKeyRotationTimestamp: ClientRuntime.Date? = nil,
        signature: Swift.String? = nil
    )
    {
        self.publicKeyRotationTimestamp = publicKeyRotationTimestamp
        self.signature = signature
    }
}

struct RegisterUsageOutputBody: Swift.Equatable {
    let publicKeyRotationTimestamp: ClientRuntime.Date?
    let signature: Swift.String?
}

extension RegisterUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyRotationTimestamp = "PublicKeyRotationTimestamp"
        case signature = "Signature"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyRotationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .publicKeyRotationTimestamp)
        publicKeyRotationTimestamp = publicKeyRotationTimestampDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

enum RegisterUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CustomerNotEntitledException": return try await CustomerNotEntitledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DisabledApiException": return try await DisabledApiException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidProductCodeException": return try await InvalidProductCodeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPublicKeyVersionException": return try await InvalidPublicKeyVersionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRegionException": return try await InvalidRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PlatformNotSupportedException": return try await PlatformNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResolveCustomerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationToken = "RegistrationToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationToken = self.registrationToken {
            try encodeContainer.encode(registrationToken, forKey: .registrationToken)
        }
    }
}

extension ResolveCustomerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains input to the ResolveCustomer operation.
public struct ResolveCustomerInput: Swift.Equatable {
    /// When a buyer visits your website during the registration process, the buyer submits a registration token through the browser. The registration token is resolved to obtain a CustomerIdentifier along with the CustomerAWSAccountId and ProductCode.
    /// This member is required.
    public var registrationToken: Swift.String?

    public init(
        registrationToken: Swift.String? = nil
    )
    {
        self.registrationToken = registrationToken
    }
}

struct ResolveCustomerInputBody: Swift.Equatable {
    let registrationToken: Swift.String?
}

extension ResolveCustomerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationToken = "RegistrationToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationToken)
        registrationToken = registrationTokenDecoded
    }
}

extension ResolveCustomerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResolveCustomerOutputBody = try responseDecoder.decode(responseBody: data)
            self.customerAWSAccountId = output.customerAWSAccountId
            self.customerIdentifier = output.customerIdentifier
            self.productCode = output.productCode
        } else {
            self.customerAWSAccountId = nil
            self.customerIdentifier = nil
            self.productCode = nil
        }
    }
}

/// The result of the ResolveCustomer operation. Contains the CustomerIdentifier along with the CustomerAWSAccountId and ProductCode.
public struct ResolveCustomerOutput: Swift.Equatable {
    /// The CustomerAWSAccountId provides the AWS account ID associated with the CustomerIdentifier for the individual customer.
    public var customerAWSAccountId: Swift.String?
    /// The CustomerIdentifier is used to identify an individual customer in your application. Calls to BatchMeterUsage require CustomerIdentifiers for each UsageRecord.
    public var customerIdentifier: Swift.String?
    /// The product code is returned to confirm that the buyer is registering for your product. Subsequent BatchMeterUsage calls should be made using this product code.
    public var productCode: Swift.String?

    public init(
        customerAWSAccountId: Swift.String? = nil,
        customerIdentifier: Swift.String? = nil,
        productCode: Swift.String? = nil
    )
    {
        self.customerAWSAccountId = customerAWSAccountId
        self.customerIdentifier = customerIdentifier
        self.productCode = productCode
    }
}

struct ResolveCustomerOutputBody: Swift.Equatable {
    let customerIdentifier: Swift.String?
    let productCode: Swift.String?
    let customerAWSAccountId: Swift.String?
}

extension ResolveCustomerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerAWSAccountId = "CustomerAWSAccountId"
        case customerIdentifier = "CustomerIdentifier"
        case productCode = "ProductCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerIdentifier)
        customerIdentifier = customerIdentifierDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let customerAWSAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAWSAccountId)
        customerAWSAccountId = customerAWSAccountIdDecoded
    }
}

enum ResolveCustomerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DisabledApiException": return try await DisabledApiException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredTokenException": return try await ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTokenException": return try await InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarketplaceMeteringClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MarketplaceMeteringClientTypes {
    /// Metadata assigned to an allocation. Each tag is made up of a key and a value.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that makes up a tag. A key is a label that acts like a category for the specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// One part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key). The value can be empty or null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The calls to the API are throttled.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestampOutOfBoundsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TimestampOutOfBoundsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The timestamp value passed in the UsageRecord is out of allowed range. For BatchMeterUsage, if any of the records are outside of the allowed range, the entire batch is not processed. You must remove invalid records and try again.
public struct TimestampOutOfBoundsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TimestampOutOfBoundsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TimestampOutOfBoundsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TimestampOutOfBoundsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MarketplaceMeteringClientTypes.UsageAllocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedUsageQuantity = "AllocatedUsageQuantity"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedUsageQuantity = self.allocatedUsageQuantity {
            try encodeContainer.encode(allocatedUsageQuantity, forKey: .allocatedUsageQuantity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedUsageQuantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedUsageQuantity)
        allocatedUsageQuantity = allocatedUsageQuantityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MarketplaceMeteringClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MarketplaceMeteringClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MarketplaceMeteringClientTypes {
    /// Usage allocations allow you to split usage into buckets by tags. Each UsageAllocation indicates the usage quantity for a specific set of tags.
    public struct UsageAllocation: Swift.Equatable {
        /// The total quantity allocated to this bucket of usage.
        /// This member is required.
        public var allocatedUsageQuantity: Swift.Int?
        /// The set of tags that define the bucket of usage. For the bucket of items with no tags, this parameter can be left out.
        public var tags: [MarketplaceMeteringClientTypes.Tag]?

        public init(
            allocatedUsageQuantity: Swift.Int? = nil,
            tags: [MarketplaceMeteringClientTypes.Tag]? = nil
        )
        {
            self.allocatedUsageQuantity = allocatedUsageQuantity
            self.tags = tags
        }
    }

}

extension MarketplaceMeteringClientTypes.UsageRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerIdentifier = "CustomerIdentifier"
        case dimension = "Dimension"
        case quantity = "Quantity"
        case timestamp = "Timestamp"
        case usageAllocations = "UsageAllocations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerIdentifier = self.customerIdentifier {
            try encodeContainer.encode(customerIdentifier, forKey: .customerIdentifier)
        }
        if let dimension = self.dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let quantity = self.quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let usageAllocations = usageAllocations {
            var usageAllocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageAllocations)
            for usageallocation0 in usageAllocations {
                try usageAllocationsContainer.encode(usageallocation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let customerIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerIdentifier)
        customerIdentifier = customerIdentifierDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let usageAllocationsContainer = try containerValues.decodeIfPresent([MarketplaceMeteringClientTypes.UsageAllocation?].self, forKey: .usageAllocations)
        var usageAllocationsDecoded0:[MarketplaceMeteringClientTypes.UsageAllocation]? = nil
        if let usageAllocationsContainer = usageAllocationsContainer {
            usageAllocationsDecoded0 = [MarketplaceMeteringClientTypes.UsageAllocation]()
            for structure0 in usageAllocationsContainer {
                if let structure0 = structure0 {
                    usageAllocationsDecoded0?.append(structure0)
                }
            }
        }
        usageAllocations = usageAllocationsDecoded0
    }
}

extension MarketplaceMeteringClientTypes {
    /// A UsageRecord indicates a quantity of usage for a given product, customer, dimension and time. Multiple requests with the same UsageRecords as input will be de-duplicated to prevent double charges.
    public struct UsageRecord: Swift.Equatable {
        /// The CustomerIdentifier is obtained through the ResolveCustomer operation and represents an individual buyer in your application.
        /// This member is required.
        public var customerIdentifier: Swift.String?
        /// During the process of registering a product on AWS Marketplace, dimensions are specified. These represent different units of value in your application.
        /// This member is required.
        public var dimension: Swift.String?
        /// The quantity of usage consumed by the customer for the given dimension and time. Defaults to 0 if not specified.
        public var quantity: Swift.Int?
        /// Timestamp, in UTC, for which the usage is being reported. Your application can meter usage for up to one hour in the past. Make sure the timestamp value is not before the start of the software usage.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The set of UsageAllocations to submit. The sum of all UsageAllocation quantities must equal the Quantity of the UsageRecord.
        public var usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]?

        public init(
            customerIdentifier: Swift.String? = nil,
            dimension: Swift.String? = nil,
            quantity: Swift.Int? = nil,
            timestamp: ClientRuntime.Date? = nil,
            usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]? = nil
        )
        {
            self.customerIdentifier = customerIdentifier
            self.dimension = dimension
            self.quantity = quantity
            self.timestamp = timestamp
            self.usageAllocations = usageAllocations
        }
    }

}

extension MarketplaceMeteringClientTypes.UsageRecordResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meteringRecordId = "MeteringRecordId"
        case status = "Status"
        case usageRecord = "UsageRecord"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meteringRecordId = self.meteringRecordId {
            try encodeContainer.encode(meteringRecordId, forKey: .meteringRecordId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let usageRecord = self.usageRecord {
            try encodeContainer.encode(usageRecord, forKey: .usageRecord)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageRecordDecoded = try containerValues.decodeIfPresent(MarketplaceMeteringClientTypes.UsageRecord.self, forKey: .usageRecord)
        usageRecord = usageRecordDecoded
        let meteringRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meteringRecordId)
        meteringRecordId = meteringRecordIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MarketplaceMeteringClientTypes.UsageRecordResultStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension MarketplaceMeteringClientTypes {
    /// A UsageRecordResult indicates the status of a given UsageRecord processed by BatchMeterUsage.
    public struct UsageRecordResult: Swift.Equatable {
        /// The MeteringRecordId is a unique identifier for this metering event.
        public var meteringRecordId: Swift.String?
        /// The UsageRecordResultStatus indicates the status of an individual UsageRecord processed by BatchMeterUsage.
        ///
        /// * Success- The UsageRecord was accepted and honored by BatchMeterUsage.
        ///
        /// * CustomerNotSubscribed- The CustomerIdentifier specified is not able to use your product. The UsageRecord was not honored. There are three causes for this result:
        ///
        /// * The customer identifier is invalid.
        ///
        /// * The customer identifier provided in the metering record does not have an active agreement or subscription with this product. Future UsageRecords for this customer will fail until the customer subscribes to your product.
        ///
        /// * The customer's AWS account was suspended.
        ///
        ///
        ///
        ///
        /// * DuplicateRecord- Indicates that the UsageRecord was invalid and not honored. A previously metered UsageRecord had the same customer, dimension, and time, but a different quantity.
        public var status: MarketplaceMeteringClientTypes.UsageRecordResultStatus?
        /// The UsageRecord that was part of the BatchMeterUsage request.
        public var usageRecord: MarketplaceMeteringClientTypes.UsageRecord?

        public init(
            meteringRecordId: Swift.String? = nil,
            status: MarketplaceMeteringClientTypes.UsageRecordResultStatus? = nil,
            usageRecord: MarketplaceMeteringClientTypes.UsageRecord? = nil
        )
        {
            self.meteringRecordId = meteringRecordId
            self.status = status
            self.usageRecord = usageRecord
        }
    }

}

extension MarketplaceMeteringClientTypes {
    public enum UsageRecordResultStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerNotSubscribed
        case duplicateRecord
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageRecordResultStatus] {
            return [
                .customerNotSubscribed,
                .duplicateRecord,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerNotSubscribed: return "CustomerNotSubscribed"
            case .duplicateRecord: return "DuplicateRecord"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageRecordResultStatus(rawValue: rawValue) ?? UsageRecordResultStatus.sdkUnknown(rawValue)
        }
    }
}
