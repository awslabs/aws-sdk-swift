//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The API is disabled in the Region.
public struct DisabledApiException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DisabledApiException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal error has occurred. Retry your request. If the problem persists, post a message with details on the AWS forums.
public struct InternalServiceErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have metered usage for a CustomerIdentifier that does not exist.
public struct InvalidCustomerIdentifierException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCustomerIdentifierException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The product code passed does not match the product code used for publishing the product.
public struct InvalidProductCodeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidProductCodeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The tag is invalid, or the number of tags is greater than 5.
public struct InvalidTagException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The usage allocation objects are invalid, or the number of allocations is greater than 500 for a single usage record.
public struct InvalidUsageAllocationsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUsageAllocationsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The usage dimension does not match one of the UsageDimensions associated with products.
public struct InvalidUsageDimensionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUsageDimensionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The calls to the API are throttled.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The timestamp value passed in the UsageRecord is out of allowed range. For BatchMeterUsage, if any of the records are outside of the allowed range, the entire batch is not processed. You must remove invalid records and try again.
public struct TimestampOutOfBoundsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TimestampOutOfBoundsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MarketplaceMeteringClientTypes {

    /// Metadata assigned to an allocation. Each tag is made up of a key and a value.
    public struct Tag: Swift.Sendable {
        /// One part of a key-value pair that makes up a tag. A key is a label that acts like a category for the specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// One part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key). The value can be empty or null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension MarketplaceMeteringClientTypes {

    /// Usage allocations allow you to split usage into buckets by tags. Each UsageAllocation indicates the usage quantity for a specific set of tags.
    public struct UsageAllocation: Swift.Sendable {
        /// The total quantity allocated to this bucket of usage.
        /// This member is required.
        public var allocatedUsageQuantity: Swift.Int?
        /// The set of tags that define the bucket of usage. For the bucket of items with no tags, this parameter can be left out.
        public var tags: [MarketplaceMeteringClientTypes.Tag]?

        public init(
            allocatedUsageQuantity: Swift.Int? = nil,
            tags: [MarketplaceMeteringClientTypes.Tag]? = nil
        )
        {
            self.allocatedUsageQuantity = allocatedUsageQuantity
            self.tags = tags
        }
    }
}

extension MarketplaceMeteringClientTypes {

    /// A UsageRecord indicates a quantity of usage for a given product, customer, dimension and time. Multiple requests with the same UsageRecords as input will be de-duplicated to prevent double charges.
    public struct UsageRecord: Swift.Sendable {
        /// The CustomerIdentifier is obtained through the ResolveCustomer operation and represents an individual buyer in your application.
        /// This member is required.
        public var customerIdentifier: Swift.String?
        /// During the process of registering a product on AWS Marketplace, dimensions are specified. These represent different units of value in your application.
        /// This member is required.
        public var dimension: Swift.String?
        /// The quantity of usage consumed by the customer for the given dimension and time. Defaults to 0 if not specified.
        public var quantity: Swift.Int?
        /// Timestamp, in UTC, for which the usage is being reported. Your application can meter usage for up to one hour in the past. Make sure the timestamp value is not before the start of the software usage.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// The set of UsageAllocations to submit. The sum of all UsageAllocation quantities must equal the Quantity of the UsageRecord.
        public var usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]?

        public init(
            customerIdentifier: Swift.String? = nil,
            dimension: Swift.String? = nil,
            quantity: Swift.Int? = nil,
            timestamp: Foundation.Date? = nil,
            usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]? = nil
        )
        {
            self.customerIdentifier = customerIdentifier
            self.dimension = dimension
            self.quantity = quantity
            self.timestamp = timestamp
            self.usageAllocations = usageAllocations
        }
    }
}

/// A BatchMeterUsageRequest contains UsageRecords, which indicate quantities of usage within your application.
public struct BatchMeterUsageInput: Swift.Sendable {
    /// Product code is used to uniquely identify a product in AWS Marketplace. The product code should be the same as the one used during the publishing of a new product.
    /// This member is required.
    public var productCode: Swift.String?
    /// The set of UsageRecords to submit. BatchMeterUsage accepts up to 25 UsageRecords at a time.
    /// This member is required.
    public var usageRecords: [MarketplaceMeteringClientTypes.UsageRecord]?

    public init(
        productCode: Swift.String? = nil,
        usageRecords: [MarketplaceMeteringClientTypes.UsageRecord]? = nil
    )
    {
        self.productCode = productCode
        self.usageRecords = usageRecords
    }
}

extension MarketplaceMeteringClientTypes {

    public enum UsageRecordResultStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customerNotSubscribed
        case duplicateRecord
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageRecordResultStatus] {
            return [
                .customerNotSubscribed,
                .duplicateRecord,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customerNotSubscribed: return "CustomerNotSubscribed"
            case .duplicateRecord: return "DuplicateRecord"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceMeteringClientTypes {

    /// A UsageRecordResult indicates the status of a given UsageRecord processed by BatchMeterUsage.
    public struct UsageRecordResult: Swift.Sendable {
        /// The MeteringRecordId is a unique identifier for this metering event.
        public var meteringRecordId: Swift.String?
        /// The UsageRecordResultStatus indicates the status of an individual UsageRecord processed by BatchMeterUsage.
        ///
        /// * Success- The UsageRecord was accepted and honored by BatchMeterUsage.
        ///
        /// * CustomerNotSubscribed- The CustomerIdentifier specified is not able to use your product. The UsageRecord was not honored. There are three causes for this result:
        ///
        /// * The customer identifier is invalid.
        ///
        /// * The customer identifier provided in the metering record does not have an active agreement or subscription with this product. Future UsageRecords for this customer will fail until the customer subscribes to your product.
        ///
        /// * The customer's AWS account was suspended.
        ///
        ///
        ///
        ///
        /// * DuplicateRecord- Indicates that the UsageRecord was invalid and not honored. A previously metered UsageRecord had the same customer, dimension, and time, but a different quantity.
        public var status: MarketplaceMeteringClientTypes.UsageRecordResultStatus?
        /// The UsageRecord that was part of the BatchMeterUsage request.
        public var usageRecord: MarketplaceMeteringClientTypes.UsageRecord?

        public init(
            meteringRecordId: Swift.String? = nil,
            status: MarketplaceMeteringClientTypes.UsageRecordResultStatus? = nil,
            usageRecord: MarketplaceMeteringClientTypes.UsageRecord? = nil
        )
        {
            self.meteringRecordId = meteringRecordId
            self.status = status
            self.usageRecord = usageRecord
        }
    }
}

/// Contains the UsageRecords processed by BatchMeterUsage and any records that have failed due to transient error.
public struct BatchMeterUsageOutput: Swift.Sendable {
    /// Contains all UsageRecords processed by BatchMeterUsage. These records were either honored by AWS Marketplace Metering Service or were invalid. Invalid records should be fixed before being resubmitted.
    public var results: [MarketplaceMeteringClientTypes.UsageRecordResult]?
    /// Contains all UsageRecords that were not processed by BatchMeterUsage. This is a list of UsageRecords. You can retry the failed request by making another BatchMeterUsage call with this list as input in the BatchMeterUsageRequest.
    public var unprocessedRecords: [MarketplaceMeteringClientTypes.UsageRecord]?

    public init(
        results: [MarketplaceMeteringClientTypes.UsageRecordResult]? = nil,
        unprocessedRecords: [MarketplaceMeteringClientTypes.UsageRecord]? = nil
    )
    {
        self.results = results
        self.unprocessedRecords = unprocessedRecords
    }
}

/// Exception thrown when the customer does not have a valid subscription for the product.
public struct CustomerNotEntitledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CustomerNotEntitledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A metering record has already been emitted by the same EC2 instance, ECS task, or EKS pod for the given {usageDimension, timestamp} with a different usageQuantity.
public struct DuplicateRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The endpoint being called is in a AWS Region different from your EC2 instance, ECS task, or EKS pod. The Region of the Metering Service endpoint and the AWS Region of the resource must match.
public struct InvalidEndpointRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEndpointRegionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct MeterUsageInput: Swift.Sendable {
    /// Checks whether you have the permissions required for the action, but does not make the request. If you have the permissions, the request returns DryRunOperation; otherwise, it returns UnauthorizedException. Defaults to false if not specified.
    public var dryRun: Swift.Bool?
    /// Product code is used to uniquely identify a product in AWS Marketplace. The product code should be the same as the one used during the publishing of a new product.
    /// This member is required.
    public var productCode: Swift.String?
    /// Timestamp, in UTC, for which the usage is being reported. Your application can meter usage for up to one hour in the past. Make sure the timestamp value is not before the start of the software usage.
    /// This member is required.
    public var timestamp: Foundation.Date?
    /// The set of UsageAllocations to submit. The sum of all UsageAllocation quantities must equal the UsageQuantity of the MeterUsage request, and each UsageAllocation must have a unique set of tags (include no tags).
    public var usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]?
    /// It will be one of the fcp dimension name provided during the publishing of the product.
    /// This member is required.
    public var usageDimension: Swift.String?
    /// Consumption value for the hour. Defaults to 0 if not specified.
    public var usageQuantity: Swift.Int?

    public init(
        dryRun: Swift.Bool? = nil,
        productCode: Swift.String? = nil,
        timestamp: Foundation.Date? = nil,
        usageAllocations: [MarketplaceMeteringClientTypes.UsageAllocation]? = nil,
        usageDimension: Swift.String? = nil,
        usageQuantity: Swift.Int? = nil
    )
    {
        self.dryRun = dryRun
        self.productCode = productCode
        self.timestamp = timestamp
        self.usageAllocations = usageAllocations
        self.usageDimension = usageDimension
        self.usageQuantity = usageQuantity
    }
}

public struct MeterUsageOutput: Swift.Sendable {
    /// Metering record id.
    public var meteringRecordId: Swift.String?

    public init(
        meteringRecordId: Swift.String? = nil
    )
    {
        self.meteringRecordId = meteringRecordId
    }
}

/// Public Key version is invalid.
public struct InvalidPublicKeyVersionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPublicKeyVersionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// RegisterUsage must be called in the same AWS Region the ECS task was launched in. This prevents a container from hardcoding a Region (e.g. withRegion(“us-east-1”) when calling RegisterUsage.
public struct InvalidRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRegionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// AWS Marketplace does not support metering usage from the underlying platform. Currently, Amazon ECS, Amazon EKS, and AWS Fargate are supported.
public struct PlatformNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PlatformNotSupportedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct RegisterUsageInput: Swift.Sendable {
    /// (Optional) To scope down the registration to a specific running software instance and guard against replay attacks.
    public var nonce: Swift.String?
    /// Product code is used to uniquely identify a product in AWS Marketplace. The product code should be the same as the one used during the publishing of a new product.
    /// This member is required.
    public var productCode: Swift.String?
    /// Public Key Version provided by AWS Marketplace
    /// This member is required.
    public var publicKeyVersion: Swift.Int?

    public init(
        nonce: Swift.String? = nil,
        productCode: Swift.String? = nil,
        publicKeyVersion: Swift.Int? = nil
    )
    {
        self.nonce = nonce
        self.productCode = productCode
        self.publicKeyVersion = publicKeyVersion
    }
}

public struct RegisterUsageOutput: Swift.Sendable {
    /// (Optional) Only included when public key version has expired
    public var publicKeyRotationTimestamp: Foundation.Date?
    /// JWT Token
    public var signature: Swift.String?

    public init(
        publicKeyRotationTimestamp: Foundation.Date? = nil,
        signature: Swift.String? = nil
    )
    {
        self.publicKeyRotationTimestamp = publicKeyRotationTimestamp
        self.signature = signature
    }
}

/// The submitted registration token has expired. This can happen if the buyer's browser takes too long to redirect to your page, the buyer has resubmitted the registration token, or your application has held on to the registration token for too long. Your SaaS registration website should redeem this token as soon as it is submitted by the buyer's browser.
public struct ExpiredTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Registration token is invalid.
public struct InvalidTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains input to the ResolveCustomer operation.
public struct ResolveCustomerInput: Swift.Sendable {
    /// When a buyer visits your website during the registration process, the buyer submits a registration token through the browser. The registration token is resolved to obtain a CustomerIdentifier along with the CustomerAWSAccountId and ProductCode.
    /// This member is required.
    public var registrationToken: Swift.String?

    public init(
        registrationToken: Swift.String? = nil
    )
    {
        self.registrationToken = registrationToken
    }
}

/// The result of the ResolveCustomer operation. Contains the CustomerIdentifier along with the CustomerAWSAccountId and ProductCode.
public struct ResolveCustomerOutput: Swift.Sendable {
    /// The CustomerAWSAccountId provides the AWS account ID associated with the CustomerIdentifier for the individual customer.
    public var customerAWSAccountId: Swift.String?
    /// The CustomerIdentifier is used to identify an individual customer in your application. Calls to BatchMeterUsage require CustomerIdentifiers for each UsageRecord.
    public var customerIdentifier: Swift.String?
    /// The product code is returned to confirm that the buyer is registering for your product. Subsequent BatchMeterUsage calls should be made using this product code.
    public var productCode: Swift.String?

    public init(
        customerAWSAccountId: Swift.String? = nil,
        customerIdentifier: Swift.String? = nil,
        productCode: Swift.String? = nil
    )
    {
        self.customerAWSAccountId = customerAWSAccountId
        self.customerIdentifier = customerIdentifier
        self.productCode = productCode
    }
}

extension BatchMeterUsageInput {

    static func urlPathProvider(_ value: BatchMeterUsageInput) -> Swift.String? {
        return "/"
    }
}

extension MeterUsageInput {

    static func urlPathProvider(_ value: MeterUsageInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterUsageInput {

    static func urlPathProvider(_ value: RegisterUsageInput) -> Swift.String? {
        return "/"
    }
}

extension ResolveCustomerInput {

    static func urlPathProvider(_ value: ResolveCustomerInput) -> Swift.String? {
        return "/"
    }
}

extension BatchMeterUsageInput {

    static func write(value: BatchMeterUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProductCode"].write(value.productCode)
        try writer["UsageRecords"].writeList(value.usageRecords, memberWritingClosure: MarketplaceMeteringClientTypes.UsageRecord.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MeterUsageInput {

    static func write(value: MeterUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DryRun"].write(value.dryRun)
        try writer["ProductCode"].write(value.productCode)
        try writer["Timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["UsageAllocations"].writeList(value.usageAllocations, memberWritingClosure: MarketplaceMeteringClientTypes.UsageAllocation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UsageDimension"].write(value.usageDimension)
        try writer["UsageQuantity"].write(value.usageQuantity)
    }
}

extension RegisterUsageInput {

    static func write(value: RegisterUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Nonce"].write(value.nonce)
        try writer["ProductCode"].write(value.productCode)
        try writer["PublicKeyVersion"].write(value.publicKeyVersion)
    }
}

extension ResolveCustomerInput {

    static func write(value: ResolveCustomerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistrationToken"].write(value.registrationToken)
    }
}

extension BatchMeterUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchMeterUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchMeterUsageOutput()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: MarketplaceMeteringClientTypes.UsageRecordResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedRecords = try reader["UnprocessedRecords"].readListIfPresent(memberReadingClosure: MarketplaceMeteringClientTypes.UsageRecord.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MeterUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MeterUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MeterUsageOutput()
        value.meteringRecordId = try reader["MeteringRecordId"].readIfPresent()
        return value
    }
}

extension RegisterUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterUsageOutput()
        value.publicKeyRotationTimestamp = try reader["PublicKeyRotationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.signature = try reader["Signature"].readIfPresent()
        return value
    }
}

extension ResolveCustomerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResolveCustomerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResolveCustomerOutput()
        value.customerAWSAccountId = try reader["CustomerAWSAccountId"].readIfPresent()
        value.customerIdentifier = try reader["CustomerIdentifier"].readIfPresent()
        value.productCode = try reader["ProductCode"].readIfPresent()
        return value
    }
}

enum BatchMeterUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledApiException": return try DisabledApiException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidCustomerIdentifierException": return try InvalidCustomerIdentifierException.makeError(baseError: baseError)
            case "InvalidProductCodeException": return try InvalidProductCodeException.makeError(baseError: baseError)
            case "InvalidTagException": return try InvalidTagException.makeError(baseError: baseError)
            case "InvalidUsageAllocationsException": return try InvalidUsageAllocationsException.makeError(baseError: baseError)
            case "InvalidUsageDimensionException": return try InvalidUsageDimensionException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TimestampOutOfBoundsException": return try TimestampOutOfBoundsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MeterUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CustomerNotEntitledException": return try CustomerNotEntitledException.makeError(baseError: baseError)
            case "DuplicateRequestException": return try DuplicateRequestException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidEndpointRegionException": return try InvalidEndpointRegionException.makeError(baseError: baseError)
            case "InvalidProductCodeException": return try InvalidProductCodeException.makeError(baseError: baseError)
            case "InvalidTagException": return try InvalidTagException.makeError(baseError: baseError)
            case "InvalidUsageAllocationsException": return try InvalidUsageAllocationsException.makeError(baseError: baseError)
            case "InvalidUsageDimensionException": return try InvalidUsageDimensionException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TimestampOutOfBoundsException": return try TimestampOutOfBoundsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CustomerNotEntitledException": return try CustomerNotEntitledException.makeError(baseError: baseError)
            case "DisabledApiException": return try DisabledApiException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidProductCodeException": return try InvalidProductCodeException.makeError(baseError: baseError)
            case "InvalidPublicKeyVersionException": return try InvalidPublicKeyVersionException.makeError(baseError: baseError)
            case "InvalidRegionException": return try InvalidRegionException.makeError(baseError: baseError)
            case "PlatformNotSupportedException": return try PlatformNotSupportedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResolveCustomerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledApiException": return try DisabledApiException.makeError(baseError: baseError)
            case "ExpiredTokenException": return try ExpiredTokenException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidTokenException": return try InvalidTokenException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisabledApiException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DisabledApiException {
        let reader = baseError.errorBodyReader
        var value = DisabledApiException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidUsageAllocationsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidUsageAllocationsException {
        let reader = baseError.errorBodyReader
        var value = InvalidUsageAllocationsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidUsageDimensionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidUsageDimensionException {
        let reader = baseError.errorBodyReader
        var value = InvalidUsageDimensionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServiceErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCustomerIdentifierException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCustomerIdentifierException {
        let reader = baseError.errorBodyReader
        var value = InvalidCustomerIdentifierException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTagException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTagException {
        let reader = baseError.errorBodyReader
        var value = InvalidTagException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TimestampOutOfBoundsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TimestampOutOfBoundsException {
        let reader = baseError.errorBodyReader
        var value = TimestampOutOfBoundsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidProductCodeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidProductCodeException {
        let reader = baseError.errorBodyReader
        var value = InvalidProductCodeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DuplicateRequestException {
        let reader = baseError.errorBodyReader
        var value = DuplicateRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidEndpointRegionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidEndpointRegionException {
        let reader = baseError.errorBodyReader
        var value = InvalidEndpointRegionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CustomerNotEntitledException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CustomerNotEntitledException {
        let reader = baseError.errorBodyReader
        var value = CustomerNotEntitledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRegionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRegionException {
        let reader = baseError.errorBodyReader
        var value = InvalidRegionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPublicKeyVersionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPublicKeyVersionException {
        let reader = baseError.errorBodyReader
        var value = InvalidPublicKeyVersionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PlatformNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PlatformNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = PlatformNotSupportedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExpiredTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ExpiredTokenException {
        let reader = baseError.errorBodyReader
        var value = ExpiredTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MarketplaceMeteringClientTypes.UsageRecordResult {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceMeteringClientTypes.UsageRecordResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceMeteringClientTypes.UsageRecordResult()
        value.usageRecord = try reader["UsageRecord"].readIfPresent(with: MarketplaceMeteringClientTypes.UsageRecord.read(from:))
        value.meteringRecordId = try reader["MeteringRecordId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension MarketplaceMeteringClientTypes.UsageRecord {

    static func write(value: MarketplaceMeteringClientTypes.UsageRecord?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomerIdentifier"].write(value.customerIdentifier)
        try writer["Dimension"].write(value.dimension)
        try writer["Quantity"].write(value.quantity)
        try writer["Timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["UsageAllocations"].writeList(value.usageAllocations, memberWritingClosure: MarketplaceMeteringClientTypes.UsageAllocation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceMeteringClientTypes.UsageRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceMeteringClientTypes.UsageRecord()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerIdentifier = try reader["CustomerIdentifier"].readIfPresent() ?? ""
        value.dimension = try reader["Dimension"].readIfPresent() ?? ""
        value.quantity = try reader["Quantity"].readIfPresent()
        value.usageAllocations = try reader["UsageAllocations"].readListIfPresent(memberReadingClosure: MarketplaceMeteringClientTypes.UsageAllocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MarketplaceMeteringClientTypes.UsageAllocation {

    static func write(value: MarketplaceMeteringClientTypes.UsageAllocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedUsageQuantity"].write(value.allocatedUsageQuantity)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MarketplaceMeteringClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceMeteringClientTypes.UsageAllocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceMeteringClientTypes.UsageAllocation()
        value.allocatedUsageQuantity = try reader["AllocatedUsageQuantity"].readIfPresent() ?? 0
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: MarketplaceMeteringClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MarketplaceMeteringClientTypes.Tag {

    static func write(value: MarketplaceMeteringClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceMeteringClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceMeteringClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

public enum MarketplaceMeteringClientTypes {}
