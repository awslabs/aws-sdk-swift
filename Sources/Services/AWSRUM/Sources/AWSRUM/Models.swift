//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You don't have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RUMClientTypes {

    public enum Telemetry: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Includes JS error event plugin
        case errors
        /// Includes X-Ray Xhr and X-Ray Fetch plugin
        case http
        /// Includes navigation, paint, resource and web vital event plugins
        case performance
        case sdkUnknown(Swift.String)

        public static var allCases: [Telemetry] {
            return [
                .errors,
                .http,
                .performance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .errors: return "errors"
            case .http: return "http"
            case .performance: return "performance"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RUMClientTypes {
    /// This structure contains much of the configuration data for the app monitor.
    public struct AppMonitorConfiguration {
        /// If you set this to true, the RUM web client sets two cookies, a session cookie and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.
        public var allowCookies: Swift.Bool?
        /// If you set this to true, RUM enables X-Ray tracing for the user sessions that RUM samples. RUM adds an X-Ray trace header to allowed HTTP requests. It also records an X-Ray segment for allowed HTTP requests. You can see traces and segments from these user sessions in the X-Ray console and the CloudWatch ServiceLens console. For more information, see [What is X-Ray?](https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html)
        public var enableXRay: Swift.Bool?
        /// A list of URLs in your website or application to exclude from RUM data collection. You can't include both ExcludedPages and IncludedPages in the same operation.
        public var excludedPages: [Swift.String]?
        /// A list of pages in your application that are to be displayed with a "favorite" icon in the CloudWatch RUM console.
        public var favoritePages: [Swift.String]?
        /// The ARN of the guest IAM role that is attached to the Amazon Cognito identity pool that is used to authorize the sending of data to RUM. It is possible that an app monitor does not have a value for GuestRoleArn. For example, this can happen when you use the console to create an app monitor and you allow CloudWatch RUM to create a new identity pool for Authorization. In this case, GuestRoleArn is not present in the [GetAppMonitor](https://docs.aws.amazon.com/cloudwatchrum/latest/APIReference/API_GetAppMonitor.html) response because it is not stored by the service. If this issue affects you, you can take one of the following steps:
        ///
        /// * Use the Cloud Development Kit (CDK) to create an identity pool and the associated IAM role, and use that for your app monitor.
        ///
        /// * Make a separate [GetIdentityPoolRoles](https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetIdentityPoolRoles.html) call to Amazon Cognito to retrieve the GuestRoleArn.
        public var guestRoleArn: Swift.String?
        /// The ID of the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.
        public var identityPoolId: Swift.String?
        /// If this app monitor is to collect data from only certain pages in your application, this structure lists those pages. You can't include both ExcludedPages and IncludedPages in the same operation.
        public var includedPages: [Swift.String]?
        /// Specifies the portion of user sessions to use for RUM data collection. Choosing a higher portion gives you more data but also incurs more costs. The range for this value is 0 to 1 inclusive. Setting this to 1 means that 100% of user sessions are sampled, and setting it to 0.1 means that 10% of user sessions are sampled. If you omit this parameter, the default of 0.1 is used, and 10% of sessions will be sampled.
        public var sessionSampleRate: Swift.Double
        /// An array that lists the types of telemetry data that this app monitor is to collect.
        ///
        /// * errors indicates that RUM collects data about unhandled JavaScript errors raised by your application.
        ///
        /// * performance indicates that RUM collects performance data about how your application and its resources are loaded and rendered. This includes Core Web Vitals.
        ///
        /// * http indicates that RUM collects data about HTTP errors thrown by your application.
        public var telemetries: [RUMClientTypes.Telemetry]?

        public init(
            allowCookies: Swift.Bool? = nil,
            enableXRay: Swift.Bool? = nil,
            excludedPages: [Swift.String]? = nil,
            favoritePages: [Swift.String]? = nil,
            guestRoleArn: Swift.String? = nil,
            identityPoolId: Swift.String? = nil,
            includedPages: [Swift.String]? = nil,
            sessionSampleRate: Swift.Double = 0.0,
            telemetries: [RUMClientTypes.Telemetry]? = nil
        )
        {
            self.allowCookies = allowCookies
            self.enableXRay = enableXRay
            self.excludedPages = excludedPages
            self.favoritePages = favoritePages
            self.guestRoleArn = guestRoleArn
            self.identityPoolId = identityPoolId
            self.includedPages = includedPages
            self.sessionSampleRate = sessionSampleRate
            self.telemetries = telemetries
        }
    }

}

extension RUMClientTypes {

    public enum CustomEventsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomEventsStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RUMClientTypes {
    /// A structure that contains information about custom events for this app monitor.
    public struct CustomEvents {
        /// Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be DISABLED.
        public var status: RUMClientTypes.CustomEventsStatus?

        public init(
            status: RUMClientTypes.CustomEventsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension RUMClientTypes {
    /// A structure that contains the information about whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs. If it does, this structure also contains the name of the log group.
    public struct CwLog {
        /// Indicated whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs.
        public var cwLogEnabled: Swift.Bool?
        /// The name of the log group where the copies are stored.
        public var cwLogGroup: Swift.String?

        public init(
            cwLogEnabled: Swift.Bool? = nil,
            cwLogGroup: Swift.String? = nil
        )
        {
            self.cwLogEnabled = cwLogEnabled
            self.cwLogGroup = cwLogGroup
        }
    }

}

extension RUMClientTypes {
    /// A structure that contains information about whether this app monitor stores a copy of the telemetry data that RUM collects using CloudWatch Logs.
    public struct DataStorage {
        /// A structure that contains the information about whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs. If it does, this structure also contains the name of the log group.
        public var cwLog: RUMClientTypes.CwLog?

        public init(
            cwLog: RUMClientTypes.CwLog? = nil
        )
        {
            self.cwLog = cwLog
        }
    }

}

extension RUMClientTypes {

    public enum StateEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case created
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [StateEnum] {
            return [
                .active,
                .created,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .created: return "CREATED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RUMClientTypes {
    /// A RUM app monitor collects telemetry data from your application and sends that data to RUM. The data includes performance and reliability information such as page load time, client-side errors, and user behavior.
    public struct AppMonitor {
        /// A structure that contains much of the configuration data for the app monitor.
        public var appMonitorConfiguration: RUMClientTypes.AppMonitorConfiguration?
        /// The date and time that this app monitor was created.
        public var created: Swift.String?
        /// Specifies whether this app monitor allows the web client to define and send custom events. For more information about custom events, see [Send custom events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-custom-events.html).
        public var customEvents: RUMClientTypes.CustomEvents?
        /// A structure that contains information about whether this app monitor stores a copy of the telemetry data that RUM collects using CloudWatch Logs.
        public var dataStorage: RUMClientTypes.DataStorage?
        /// The top-level internet domain name for which your application has administrative authority.
        public var domain: Swift.String?
        /// The unique ID of this app monitor.
        public var id: Swift.String?
        /// The date and time of the most recent changes to this app monitor's configuration.
        public var lastModified: Swift.String?
        /// The name of the app monitor.
        public var name: Swift.String?
        /// The current state of the app monitor.
        public var state: RUMClientTypes.StateEnum?
        /// The list of tag keys and values associated with this app monitor.
        public var tags: [Swift.String: Swift.String]?

        public init(
            appMonitorConfiguration: RUMClientTypes.AppMonitorConfiguration? = nil,
            created: Swift.String? = nil,
            customEvents: RUMClientTypes.CustomEvents? = nil,
            dataStorage: RUMClientTypes.DataStorage? = nil,
            domain: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            name: Swift.String? = nil,
            state: RUMClientTypes.StateEnum? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.appMonitorConfiguration = appMonitorConfiguration
            self.created = created
            self.customEvents = customEvents
            self.dataStorage = dataStorage
            self.domain = domain
            self.id = id
            self.lastModified = lastModified
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension RUMClientTypes {
    /// A structure that contains information about the RUM app monitor.
    public struct AppMonitorDetails {
        /// The unique ID of the app monitor.
        public var id: Swift.String?
        /// The name of the app monitor.
        public var name: Swift.String?
        /// The version of the app monitor.
        public var version: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.version = version
        }
    }

}

/// This operation attempted to create a resource that already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

/// Internal service exception.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The value of a parameter in the request caused an error.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// Resource not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

/// This request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was throttled because of quota limits.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The value of a parameter in the request caused an error.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The ID of the service that is associated with the error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

/// One of the arguments for the request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RUMClientTypes {

    public enum MetricDestination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloudwatch
        case evidently
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricDestination] {
            return [
                .cloudwatch,
                .evidently
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloudwatch: return "CloudWatch"
            case .evidently: return "Evidently"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RUMClientTypes {
    /// Use this structure to define one extended metric or custom metric that RUM will send to CloudWatch or CloudWatch Evidently. For more information, see [ Custom metrics and extended metrics that you can send to CloudWatch and CloudWatch Evidently](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-custom-and-extended-metrics.html). This structure is validated differently for extended metrics and custom metrics. For extended metrics that are sent to the AWS/RUM namespace, the following validations apply:
    ///
    /// * The Namespace parameter must be omitted or set to AWS/RUM.
    ///
    /// * Only certain combinations of values for Name, ValueKey, and EventPattern are valid. In addition to what is displayed in the following list, the EventPattern can also include information used by the DimensionKeys field.
    ///
    /// * If Name is PerformanceNavigationDuration, then ValueKeymust be event_details.duration and the EventPattern must include {"event_type":["com.amazon.rum.performance_navigation_event"]}
    ///
    /// * If Name is PerformanceResourceDuration, then ValueKeymust be event_details.duration and the EventPattern must include {"event_type":["com.amazon.rum.performance_resource_event"]}
    ///
    /// * If Name is NavigationSatisfiedTransaction, then ValueKeymust be null and the EventPattern must include { "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": [">",2000] }] } }
    ///
    /// * If Name is NavigationToleratedTransaction, then ValueKeymust be null and the EventPattern must include { "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": [">=",2000,"<"8000] }] } }
    ///
    /// * If Name is NavigationFrustratedTransaction, then ValueKeymust be null and the EventPattern must include { "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": [">=",8000] }] } }
    ///
    /// * If Name is WebVitalsCumulativeLayoutShift, then ValueKeymust be event_details.value and the EventPattern must include {"event_type":["com.amazon.rum.cumulative_layout_shift_event"]}
    ///
    /// * If Name is WebVitalsFirstInputDelay, then ValueKeymust be event_details.value and the EventPattern must include {"event_type":["com.amazon.rum.first_input_delay_event"]}
    ///
    /// * If Name is WebVitalsLargestContentfulPaint, then ValueKeymust be event_details.value and the EventPattern must include {"event_type":["com.amazon.rum.largest_contentful_paint_event"]}
    ///
    /// * If Name is JsErrorCount, then ValueKeymust be null and the EventPattern must include {"event_type":["com.amazon.rum.js_error_event"]}
    ///
    /// * If Name is HttpErrorCount, then ValueKeymust be null and the EventPattern must include {"event_type":["com.amazon.rum.http_event"]}
    ///
    /// * If Name is SessionCount, then ValueKeymust be null and the EventPattern must include {"event_type":["com.amazon.rum.session_start_event"]}
    ///
    /// * If Name is PageViewCount, then ValueKeymust be null and the EventPattern must include {"event_type":["com.amazon.rum.page_view_event"]}
    ///
    /// * If Name is Http4xxCount, then ValueKeymust be null and the EventPattern must include {"event_type": ["com.amazon.rum.http_event"],"event_details":{"response":{"status":[{"numeric":[">=",400,"<",500]}]}}} }
    ///
    /// * If Name is Http5xxCount, then ValueKeymust be null and the EventPattern must include {"event_type": ["com.amazon.rum.http_event"],"event_details":{"response":{"status":[{"numeric":[">=",500,"<=",599]}]}}} }
    ///
    ///
    ///
    ///
    ///
    /// For custom metrics, the following validation rules apply:
    ///
    /// * The namespace can't be omitted and can't be AWS/RUM. You can use the AWS/RUM namespace only for extended metrics.
    ///
    /// * All dimensions listed in the DimensionKeys field must be present in the value of EventPattern.
    ///
    /// * The values that you specify for ValueKey, EventPattern, and DimensionKeys must be fields in RUM events, so all first-level keys in these fields must be one of the keys in the list later in this section.
    ///
    /// * If you set a value for EventPattern, it must be a JSON object.
    ///
    /// * For every non-empty event_details, there must be a non-empty event_type.
    ///
    /// * If EventPattern contains an event_details field, it must also contain an event_type. For every built-in event_type that you use, you must use a value for event_details that corresponds to that event_type. For information about event details that correspond to event types, see [ RUM event details](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-datacollected.html#CloudWatch-RUM-datacollected-eventDetails).
    ///
    /// * In EventPattern, any JSON array must contain only one value.
    ///
    ///
    /// Valid key values for first-level keys in the ValueKey, EventPattern, and DimensionKeys fields:
    ///
    /// * account_id
    ///
    /// * application_Id
    ///
    /// * application_version
    ///
    /// * application_name
    ///
    /// * batch_id
    ///
    /// * event_details
    ///
    /// * event_id
    ///
    /// * event_interaction
    ///
    /// * event_timestamp
    ///
    /// * event_type
    ///
    /// * event_version
    ///
    /// * log_stream
    ///
    /// * metadata
    ///
    /// * sessionId
    ///
    /// * user_details
    ///
    /// * userId
    public struct MetricDefinitionRequest {
        /// Use this field only if you are sending the metric to CloudWatch. This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. For extended metrics, valid values for the entries in this field are the following:
        ///
        /// * "metadata.pageId": "PageId"
        ///
        /// * "metadata.browserName": "BrowserName"
        ///
        /// * "metadata.deviceType": "DeviceType"
        ///
        /// * "metadata.osName": "OSName"
        ///
        /// * "metadata.countryCode": "CountryCode"
        ///
        /// * "event_details.fileType": "FileType"
        ///
        ///
        /// For both extended metrics and custom metrics, all dimensions listed in this field must also be included in EventPattern.
        public var dimensionKeys: [Swift.String: Swift.String]?
        /// The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination. When you define extended metrics, the metric definition is not valid if EventPattern is omitted. Example event patterns:
        ///
        /// * '{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'
        ///
        /// * '{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "<", 2000 ] }] } }'
        ///
        /// * '{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ ">=", 2000, "<", 8000 ] }] } }'
        ///
        ///
        /// If the metrics destination is CloudWatch and the event also matches a value in DimensionKeys, then the metric is published with the specified dimensions.
        public var eventPattern: Swift.String?
        /// The name for the metric that is defined in this structure. For custom metrics, you can specify any name that you like. For extended metrics, valid values are the following:
        ///
        /// * PerformanceNavigationDuration
        ///
        /// * PerformanceResourceDuration
        ///
        /// * NavigationSatisfiedTransaction
        ///
        /// * NavigationToleratedTransaction
        ///
        /// * NavigationFrustratedTransaction
        ///
        /// * WebVitalsCumulativeLayoutShift
        ///
        /// * WebVitalsFirstInputDelay
        ///
        /// * WebVitalsLargestContentfulPaint
        ///
        /// * JsErrorCount
        ///
        /// * HttpErrorCount
        ///
        /// * SessionCount
        /// This member is required.
        public var name: Swift.String?
        /// If this structure is for a custom metric instead of an extended metrics, use this parameter to define the metric namespace for that custom metric. Do not specify this parameter if this structure is for an extended metric. You cannot use any string that starts with AWS/ for your namespace.
        public var namespace: Swift.String?
        /// The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.
        public var unitLabel: Swift.String?
        /// The field within the event object that the metric value is sourced from. If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you want to count the number of events that the filter catches. If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw. Evidently will handle data extraction from the event.
        public var valueKey: Swift.String?

        public init(
            dimensionKeys: [Swift.String: Swift.String]? = nil,
            eventPattern: Swift.String? = nil,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil,
            unitLabel: Swift.String? = nil,
            valueKey: Swift.String? = nil
        )
        {
            self.dimensionKeys = dimensionKeys
            self.eventPattern = eventPattern
            self.name = name
            self.namespace = namespace
            self.unitLabel = unitLabel
            self.valueKey = valueKey
        }
    }

}

public struct BatchCreateRumMetricDefinitionsInput {
    /// The name of the CloudWatch RUM app monitor that is to send the metrics.
    /// This member is required.
    public var appMonitorName: Swift.String?
    /// The destination to send the metrics to. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the Amazon Resource Name (ARN) of the CloudWatchEvidently experiment that will receive the metrics and an IAM role that has permission to write to the experiment.
    /// This member is required.
    public var destination: RUMClientTypes.MetricDestination?
    /// This parameter is required if Destination is Evidently. If Destination is CloudWatch, do not use this parameter. This parameter specifies the ARN of the Evidently experiment that is to receive the metrics. You must have already defined this experiment as a valid destination. For more information, see [PutRumMetricsDestination](https://docs.aws.amazon.com/cloudwatchrum/latest/APIReference/API_PutRumMetricsDestination.html).
    public var destinationArn: Swift.String?
    /// An array of structures which define the metrics that you want to send.
    /// This member is required.
    public var metricDefinitions: [RUMClientTypes.MetricDefinitionRequest]?

    public init(
        appMonitorName: Swift.String? = nil,
        destination: RUMClientTypes.MetricDestination? = nil,
        destinationArn: Swift.String? = nil,
        metricDefinitions: [RUMClientTypes.MetricDefinitionRequest]? = nil
    )
    {
        self.appMonitorName = appMonitorName
        self.destination = destination
        self.destinationArn = destinationArn
        self.metricDefinitions = metricDefinitions
    }
}

extension RUMClientTypes {
    /// A structure that defines one error caused by a [BatchCreateRumMetricsDefinitions](https://docs.aws.amazon.com/cloudwatchrum/latest/APIReference/API_BatchCreateRumMetricsDefinitions.html) operation.
    public struct BatchCreateRumMetricDefinitionsError {
        /// The error code.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message for this metric definition.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The metric definition that caused this error.
        /// This member is required.
        public var metricDefinition: RUMClientTypes.MetricDefinitionRequest?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            metricDefinition: RUMClientTypes.MetricDefinitionRequest? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.metricDefinition = metricDefinition
        }
    }

}

extension RUMClientTypes {
    /// A structure that displays the definition of one extended metric that RUM sends to CloudWatch or CloudWatch Evidently. For more information, see [ Additional metrics that you can send to CloudWatch and CloudWatch Evidently](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-vended-metrics.html).
    public struct MetricDefinition {
        /// This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch The value of this field is used only if the metric destination is CloudWatch. If the metric destination is Evidently, the value of DimensionKeys is ignored.
        public var dimensionKeys: [Swift.String: Swift.String]?
        /// The pattern that defines the metric. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination. If the metrics destination is CloudWatch and the event also matches a value in DimensionKeys, then the metric is published with the specified dimensions.
        public var eventPattern: Swift.String?
        /// The ID of this metric definition.
        /// This member is required.
        public var metricDefinitionId: Swift.String?
        /// The name of the metric that is defined in this structure.
        /// This member is required.
        public var name: Swift.String?
        /// If this metric definition is for a custom metric instead of an extended metric, this field displays the metric namespace that the custom metric is published to.
        public var namespace: Swift.String?
        /// Use this field only if you are sending this metric to CloudWatch. It defines the CloudWatch metric unit that this metric is measured in.
        public var unitLabel: Swift.String?
        /// The field within the event object that the metric value is sourced from.
        public var valueKey: Swift.String?

        public init(
            dimensionKeys: [Swift.String: Swift.String]? = nil,
            eventPattern: Swift.String? = nil,
            metricDefinitionId: Swift.String? = nil,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil,
            unitLabel: Swift.String? = nil,
            valueKey: Swift.String? = nil
        )
        {
            self.dimensionKeys = dimensionKeys
            self.eventPattern = eventPattern
            self.metricDefinitionId = metricDefinitionId
            self.name = name
            self.namespace = namespace
            self.unitLabel = unitLabel
            self.valueKey = valueKey
        }
    }

}

public struct BatchCreateRumMetricDefinitionsOutput {
    /// An array of error objects, if the operation caused any errors.
    /// This member is required.
    public var errors: [RUMClientTypes.BatchCreateRumMetricDefinitionsError]?
    /// An array of structures that define the extended metrics.
    public var metricDefinitions: [RUMClientTypes.MetricDefinition]?

    public init(
        errors: [RUMClientTypes.BatchCreateRumMetricDefinitionsError]? = nil,
        metricDefinitions: [RUMClientTypes.MetricDefinition]? = nil
    )
    {
        self.errors = errors
        self.metricDefinitions = metricDefinitions
    }
}

public struct BatchDeleteRumMetricDefinitionsInput {
    /// The name of the CloudWatch RUM app monitor that is sending these metrics.
    /// This member is required.
    public var appMonitorName: Swift.String?
    /// Defines the destination where you want to stop sending the specified metrics. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the ARN of the CloudWatchEvidently experiment that is to be the destination and an IAM role that has permission to write to the experiment.
    /// This member is required.
    public var destination: RUMClientTypes.MetricDestination?
    /// This parameter is required if Destination is Evidently. If Destination is CloudWatch, do not use this parameter. This parameter specifies the ARN of the Evidently experiment that was receiving the metrics that are being deleted.
    public var destinationArn: Swift.String?
    /// An array of structures which define the metrics that you want to stop sending.
    /// This member is required.
    public var metricDefinitionIds: [Swift.String]?

    public init(
        appMonitorName: Swift.String? = nil,
        destination: RUMClientTypes.MetricDestination? = nil,
        destinationArn: Swift.String? = nil,
        metricDefinitionIds: [Swift.String]? = nil
    )
    {
        self.appMonitorName = appMonitorName
        self.destination = destination
        self.destinationArn = destinationArn
        self.metricDefinitionIds = metricDefinitionIds
    }
}

extension RUMClientTypes {
    /// A structure that defines one error caused by a [BatchCreateRumMetricsDefinitions](https://docs.aws.amazon.com/cloudwatchrum/latest/APIReference/API_BatchDeleteRumMetricsDefinitions.html) operation.
    public struct BatchDeleteRumMetricDefinitionsError {
        /// The error code.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message for this metric definition.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The ID of the metric definition that caused this error.
        /// This member is required.
        public var metricDefinitionId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            metricDefinitionId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.metricDefinitionId = metricDefinitionId
        }
    }

}

public struct BatchDeleteRumMetricDefinitionsOutput {
    /// An array of error objects, if the operation caused any errors.
    /// This member is required.
    public var errors: [RUMClientTypes.BatchDeleteRumMetricDefinitionsError]?
    /// The IDs of the metric definitions that were deleted.
    public var metricDefinitionIds: [Swift.String]?

    public init(
        errors: [RUMClientTypes.BatchDeleteRumMetricDefinitionsError]? = nil,
        metricDefinitionIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.metricDefinitionIds = metricDefinitionIds
    }
}

public struct BatchGetRumMetricDefinitionsInput {
    /// The name of the CloudWatch RUM app monitor that is sending the metrics.
    /// This member is required.
    public var appMonitorName: Swift.String?
    /// The type of destination that you want to view metrics for. Valid values are CloudWatch and Evidently.
    /// This member is required.
    public var destination: RUMClientTypes.MetricDestination?
    /// This parameter is required if Destination is Evidently. If Destination is CloudWatch, do not use this parameter. This parameter specifies the ARN of the Evidently experiment that corresponds to the destination.
    public var destinationArn: Swift.String?
    /// The maximum number of results to return in one operation. The default is 50. The maximum that you can specify is 100. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// Use the token returned by the previous operation to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        appMonitorName: Swift.String? = nil,
        destination: RUMClientTypes.MetricDestination? = nil,
        destinationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appMonitorName = appMonitorName
        self.destination = destination
        self.destinationArn = destinationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct BatchGetRumMetricDefinitionsOutput {
    /// An array of structures that display information about the metrics that are sent by the specified app monitor to the specified destination.
    public var metricDefinitions: [RUMClientTypes.MetricDefinition]?
    /// A token that you can use in a subsequent operation to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        metricDefinitions: [RUMClientTypes.MetricDefinition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricDefinitions = metricDefinitions
        self.nextToken = nextToken
    }
}

public struct CreateAppMonitorInput {
    /// A structure that contains much of the configuration data for the app monitor. If you are using Amazon Cognito for authorization, you must include this structure in your request, and it must include the ID of the Amazon Cognito identity pool to use for authorization. If you don't include AppMonitorConfiguration, you must set up your own authorization method. For more information, see [Authorize your application to send data to Amazon Web Services](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-get-started-authorization.html). If you omit this argument, the sample rate used for RUM is set to 10% of the user sessions.
    public var appMonitorConfiguration: RUMClientTypes.AppMonitorConfiguration?
    /// Specifies whether this app monitor allows the web client to define and send custom events. If you omit this parameter, custom events are DISABLED. For more information about custom events, see [Send custom events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-custom-events.html).
    public var customEvents: RUMClientTypes.CustomEvents?
    /// Data collected by RUM is kept by RUM for 30 days and then deleted. This parameter specifies whether RUM sends a copy of this telemetry data to Amazon CloudWatch Logs in your account. This enables you to keep the telemetry data for more than 30 days, but it does incur Amazon CloudWatch Logs charges. If you omit this parameter, the default is false.
    public var cwLogEnabled: Swift.Bool?
    /// The top-level internet domain name for which your application has administrative authority.
    /// This member is required.
    public var domain: Swift.String?
    /// A name for the app monitor.
    /// This member is required.
    public var name: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the app monitor. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with an app monitor. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        appMonitorConfiguration: RUMClientTypes.AppMonitorConfiguration? = nil,
        customEvents: RUMClientTypes.CustomEvents? = nil,
        cwLogEnabled: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.appMonitorConfiguration = appMonitorConfiguration
        self.customEvents = customEvents
        self.cwLogEnabled = cwLogEnabled
        self.domain = domain
        self.name = name
        self.tags = tags
    }
}

public struct CreateAppMonitorOutput {
    /// The unique ID of the new app monitor.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteAppMonitorInput {
    /// The name of the app monitor to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteAppMonitorOutput {

    public init() { }
}

public struct DeleteRumMetricsDestinationInput {
    /// The name of the app monitor that is sending metrics to the destination that you want to delete.
    /// This member is required.
    public var appMonitorName: Swift.String?
    /// The type of destination to delete. Valid values are CloudWatch and Evidently.
    /// This member is required.
    public var destination: RUMClientTypes.MetricDestination?
    /// This parameter is required if Destination is Evidently. If Destination is CloudWatch, do not use this parameter. This parameter specifies the ARN of the Evidently experiment that corresponds to the destination to delete.
    public var destinationArn: Swift.String?

    public init(
        appMonitorName: Swift.String? = nil,
        destination: RUMClientTypes.MetricDestination? = nil,
        destinationArn: Swift.String? = nil
    )
    {
        self.appMonitorName = appMonitorName
        self.destination = destination
        self.destinationArn = destinationArn
    }
}

public struct DeleteRumMetricsDestinationOutput {

    public init() { }
}

public struct GetAppMonitorInput {
    /// The app monitor to retrieve information for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetAppMonitorOutput {
    /// A structure containing all the configuration information for the app monitor.
    public var appMonitor: RUMClientTypes.AppMonitor?

    public init(
        appMonitor: RUMClientTypes.AppMonitor? = nil
    )
    {
        self.appMonitor = appMonitor
    }
}

extension RUMClientTypes {
    /// A structure that defines a key and values that you can use to filter the results. The only performance events that are returned are those that have values matching the ones that you specify in one of your QueryFilter structures. For example, you could specify Browser as the Name and specify Chrome,Firefox as the Values to return events generated only from those browsers. Specifying Invert as the Name works as a "not equal to" filter. For example, specify Invert as the Name and specify Chrome as the value to return all events except events from user sessions with the Chrome browser.
    public struct QueryFilter {
        /// The name of a key to search for. The filter returns only the events that match the Name and Values that you specify. Valid values for Name are Browser | Device | Country | Page | OS | EventType | Invert
        public var name: Swift.String?
        /// The values of the Name that are to be be included in the returned results.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension RUMClientTypes {
    /// A structure that defines the time range that you want to retrieve results from.
    public struct TimeRange {
        /// The beginning of the time range to retrieve performance events from.
        /// This member is required.
        public var after: Swift.Int
        /// The end of the time range to retrieve performance events from. If you omit this, the time range extends to the time that this operation is performed.
        public var before: Swift.Int

        public init(
            after: Swift.Int = 0,
            before: Swift.Int = 0
        )
        {
            self.after = after
            self.before = before
        }
    }

}

public struct GetAppMonitorDataInput {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [RUMClientTypes.QueryFilter]?
    /// The maximum number of results to return in one operation.
    public var maxResults: Swift.Int
    /// The name of the app monitor that collected the data that you want to retrieve.
    /// This member is required.
    public var name: Swift.String?
    /// Use the token returned by the previous operation to request the next page of results.
    public var nextToken: Swift.String?
    /// A structure that defines the time range that you want to retrieve results from.
    /// This member is required.
    public var timeRange: RUMClientTypes.TimeRange?

    public init(
        filters: [RUMClientTypes.QueryFilter]? = nil,
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        timeRange: RUMClientTypes.TimeRange? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.timeRange = timeRange
    }
}

public struct GetAppMonitorDataOutput {
    /// The events that RUM collected that match your request.
    public var events: [Swift.String]?
    /// A token that you can use in a subsequent operation to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        events: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

public struct ListAppMonitorsInput {
    /// The maximum number of results to return in one operation. The default is 50. The maximum that you can specify is 100.
    public var maxResults: Swift.Int?
    /// Use the token returned by the previous operation to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension RUMClientTypes {
    /// A structure that includes some data about app monitors and their settings.
    public struct AppMonitorSummary {
        /// The date and time that the app monitor was created.
        public var created: Swift.String?
        /// The unique ID of this app monitor.
        public var id: Swift.String?
        /// The date and time of the most recent changes to this app monitor's configuration.
        public var lastModified: Swift.String?
        /// The name of this app monitor.
        public var name: Swift.String?
        /// The current state of this app monitor.
        public var state: RUMClientTypes.StateEnum?

        public init(
            created: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            name: Swift.String? = nil,
            state: RUMClientTypes.StateEnum? = nil
        )
        {
            self.created = created
            self.id = id
            self.lastModified = lastModified
            self.name = name
            self.state = state
        }
    }

}

public struct ListAppMonitorsOutput {
    /// An array of structures that contain information about the returned app monitors.
    public var appMonitorSummaries: [RUMClientTypes.AppMonitorSummary]?
    /// A token that you can use in a subsequent operation to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        appMonitorSummaries: [RUMClientTypes.AppMonitorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appMonitorSummaries = appMonitorSummaries
        self.nextToken = nextToken
    }
}

public struct ListRumMetricsDestinationsInput {
    /// The name of the app monitor associated with the destinations that you want to retrieve.
    /// This member is required.
    public var appMonitorName: Swift.String?
    /// The maximum number of results to return in one operation. The default is 50. The maximum that you can specify is 100. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// Use the token returned by the previous operation to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        appMonitorName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appMonitorName = appMonitorName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension RUMClientTypes {
    /// A structure that displays information about one destination that CloudWatch RUM sends extended metrics to.
    public struct MetricDestinationSummary {
        /// Specifies whether the destination is CloudWatch or Evidently.
        public var destination: RUMClientTypes.MetricDestination?
        /// If the destination is Evidently, this specifies the ARN of the Evidently experiment that receives the metrics.
        public var destinationArn: Swift.String?
        /// This field appears only when the destination is Evidently. It specifies the ARN of the IAM role that is used to write to the Evidently experiment that receives the metrics.
        public var iamRoleArn: Swift.String?

        public init(
            destination: RUMClientTypes.MetricDestination? = nil,
            destinationArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil
        )
        {
            self.destination = destination
            self.destinationArn = destinationArn
            self.iamRoleArn = iamRoleArn
        }
    }

}

public struct ListRumMetricsDestinationsOutput {
    /// The list of CloudWatch RUM extended metrics destinations associated with the app monitor that you specified.
    public var destinations: [RUMClientTypes.MetricDestinationSummary]?
    /// A token that you can use in a subsequent operation to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        destinations: [RUMClientTypes.MetricDestinationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinations = destinations
        self.nextToken = nextToken
    }
}

public struct PutRumMetricsDestinationInput {
    /// The name of the CloudWatch RUM app monitor that will send the metrics.
    /// This member is required.
    public var appMonitorName: Swift.String?
    /// Defines the destination to send the metrics to. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the ARN of the CloudWatchEvidently experiment that is to be the destination and an IAM role that has permission to write to the experiment.
    /// This member is required.
    public var destination: RUMClientTypes.MetricDestination?
    /// Use this parameter only if Destination is Evidently. This parameter specifies the ARN of the Evidently experiment that will receive the extended metrics.
    public var destinationArn: Swift.String?
    /// This parameter is required if Destination is Evidently. If Destination is CloudWatch, don't use this parameter. This parameter specifies the ARN of an IAM role that RUM will assume to write to the Evidently experiment that you are sending metrics to. This role must have permission to write to that experiment. If you specify this parameter, you must be signed on to a role that has [PassRole](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html) permissions attached to it, to allow the role to be passed. The [ CloudWatchAmazonCloudWatchRUMFullAccess](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/auth-and-access-control-cw.html#managed-policies-cloudwatch-RUM) policy doesn't include PassRole permissions.
    public var iamRoleArn: Swift.String?

    public init(
        appMonitorName: Swift.String? = nil,
        destination: RUMClientTypes.MetricDestination? = nil,
        destinationArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil
    )
    {
        self.appMonitorName = appMonitorName
        self.destination = destination
        self.destinationArn = destinationArn
        self.iamRoleArn = iamRoleArn
    }
}

public struct PutRumMetricsDestinationOutput {

    public init() { }
}

public struct UpdateAppMonitorInput {
    /// A structure that contains much of the configuration data for the app monitor. If you are using Amazon Cognito for authorization, you must include this structure in your request, and it must include the ID of the Amazon Cognito identity pool to use for authorization. If you don't include AppMonitorConfiguration, you must set up your own authorization method. For more information, see [Authorize your application to send data to Amazon Web Services](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-get-started-authorization.html).
    public var appMonitorConfiguration: RUMClientTypes.AppMonitorConfiguration?
    /// Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be DISABLED. For more information about custom events, see [Send custom events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-custom-events.html).
    public var customEvents: RUMClientTypes.CustomEvents?
    /// Data collected by RUM is kept by RUM for 30 days and then deleted. This parameter specifies whether RUM sends a copy of this telemetry data to Amazon CloudWatch Logs in your account. This enables you to keep the telemetry data for more than 30 days, but it does incur Amazon CloudWatch Logs charges.
    public var cwLogEnabled: Swift.Bool?
    /// The top-level internet domain name for which your application has administrative authority.
    public var domain: Swift.String?
    /// The name of the app monitor to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        appMonitorConfiguration: RUMClientTypes.AppMonitorConfiguration? = nil,
        customEvents: RUMClientTypes.CustomEvents? = nil,
        cwLogEnabled: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appMonitorConfiguration = appMonitorConfiguration
        self.customEvents = customEvents
        self.cwLogEnabled = cwLogEnabled
        self.domain = domain
        self.name = name
    }
}

public struct UpdateAppMonitorOutput {

    public init() { }
}

public struct UpdateRumMetricDefinitionInput {
    /// The name of the CloudWatch RUM app monitor that sends these metrics.
    /// This member is required.
    public var appMonitorName: Swift.String?
    /// The destination to send the metrics to. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the ARN of the CloudWatchEvidently experiment that will receive the metrics and an IAM role that has permission to write to the experiment.
    /// This member is required.
    public var destination: RUMClientTypes.MetricDestination?
    /// This parameter is required if Destination is Evidently. If Destination is CloudWatch, do not use this parameter. This parameter specifies the ARN of the Evidently experiment that is to receive the metrics. You must have already defined this experiment as a valid destination. For more information, see [PutRumMetricsDestination](https://docs.aws.amazon.com/cloudwatchrum/latest/APIReference/API_PutRumMetricsDestination.html).
    public var destinationArn: Swift.String?
    /// A structure that contains the new definition that you want to use for this metric.
    /// This member is required.
    public var metricDefinition: RUMClientTypes.MetricDefinitionRequest?
    /// The ID of the metric definition to update.
    /// This member is required.
    public var metricDefinitionId: Swift.String?

    public init(
        appMonitorName: Swift.String? = nil,
        destination: RUMClientTypes.MetricDestination? = nil,
        destinationArn: Swift.String? = nil,
        metricDefinition: RUMClientTypes.MetricDefinitionRequest? = nil,
        metricDefinitionId: Swift.String? = nil
    )
    {
        self.appMonitorName = appMonitorName
        self.destination = destination
        self.destinationArn = destinationArn
        self.metricDefinition = metricDefinition
        self.metricDefinitionId = metricDefinitionId
    }
}

public struct UpdateRumMetricDefinitionOutput {

    public init() { }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource that you want to see the tags of.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The ARN of the resource that you are viewing.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys and values associated with the resource you specified.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension RUMClientTypes {
    /// A structure that contains the information for one performance event that RUM collects from a user session with your application.
    public struct RumEvent {
        /// A string containing details about the event.
        /// This member is required.
        public var details: Swift.String?
        /// A unique ID for this event.
        /// This member is required.
        public var id: Swift.String?
        /// Metadata about this event, which contains a JSON serialization of the identity of the user for this session. The user information comes from information such as the HTTP user-agent request header and document interface.
        public var metadata: Swift.String?
        /// The exact time that this event occurred.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// The JSON schema that denotes the type of event this is, such as a page load or a new session.
        /// This member is required.
        public var type: Swift.String?

        public init(
            details: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            type: Swift.String? = nil
        )
        {
            self.details = details
            self.id = id
            self.metadata = metadata
            self.timestamp = timestamp
            self.type = type
        }
    }

}

extension RUMClientTypes {
    /// A structure that contains information about the user session that this batch of events was collected from.
    public struct UserDetails {
        /// The session ID that the performance events are from.
        public var sessionId: Swift.String?
        /// The ID of the user for this user session. This ID is generated by RUM and does not include any personally identifiable information about the user.
        public var userId: Swift.String?

        public init(
            sessionId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.sessionId = sessionId
            self.userId = userId
        }
    }

}

public struct PutRumEventsInput {
    /// A structure that contains information about the app monitor that collected this telemetry information.
    /// This member is required.
    public var appMonitorDetails: RUMClientTypes.AppMonitorDetails?
    /// A unique identifier for this batch of RUM event data.
    /// This member is required.
    public var batchId: Swift.String?
    /// The ID of the app monitor that is sending this data.
    /// This member is required.
    public var id: Swift.String?
    /// An array of structures that contain the telemetry event data.
    /// This member is required.
    public var rumEvents: [RUMClientTypes.RumEvent]?
    /// A structure that contains information about the user session that this batch of events was collected from.
    /// This member is required.
    public var userDetails: RUMClientTypes.UserDetails?

    public init(
        appMonitorDetails: RUMClientTypes.AppMonitorDetails? = nil,
        batchId: Swift.String? = nil,
        id: Swift.String? = nil,
        rumEvents: [RUMClientTypes.RumEvent]? = nil,
        userDetails: RUMClientTypes.UserDetails? = nil
    )
    {
        self.appMonitorDetails = appMonitorDetails
        self.batchId = batchId
        self.id = id
        self.rumEvents = rumEvents
        self.userDetails = userDetails
    }
}

public struct PutRumEventsOutput {

    public init() { }
}

public struct TagResourceInput {
    /// The ARN of the CloudWatch RUM resource that you're adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The ARN of the CloudWatch RUM resource that you're removing tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension BatchCreateRumMetricDefinitionsInput {

    static func urlPathProvider(_ value: BatchCreateRumMetricDefinitionsInput) -> Swift.String? {
        guard let appMonitorName = value.appMonitorName else {
            return nil
        }
        return "/rummetrics/\(appMonitorName.urlPercentEncoding())/metrics"
    }
}

extension BatchDeleteRumMetricDefinitionsInput {

    static func urlPathProvider(_ value: BatchDeleteRumMetricDefinitionsInput) -> Swift.String? {
        guard let appMonitorName = value.appMonitorName else {
            return nil
        }
        return "/rummetrics/\(appMonitorName.urlPercentEncoding())/metrics"
    }
}

extension BatchDeleteRumMetricDefinitionsInput {

    static func queryItemProvider(_ value: BatchDeleteRumMetricDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let destination = value.destination else {
            let message = "Creating a URL Query Item failed. destination is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let destinationQueryItem = Smithy.URIQueryItem(name: "destination".urlPercentEncoding(), value: Swift.String(destination.rawValue).urlPercentEncoding())
        items.append(destinationQueryItem)
        guard let metricDefinitionIds = value.metricDefinitionIds else {
            let message = "Creating a URL Query Item failed. metricDefinitionIds is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        metricDefinitionIds.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "metricDefinitionIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        if let destinationArn = value.destinationArn {
            let destinationArnQueryItem = Smithy.URIQueryItem(name: "destinationArn".urlPercentEncoding(), value: Swift.String(destinationArn).urlPercentEncoding())
            items.append(destinationArnQueryItem)
        }
        return items
    }
}

extension BatchGetRumMetricDefinitionsInput {

    static func urlPathProvider(_ value: BatchGetRumMetricDefinitionsInput) -> Swift.String? {
        guard let appMonitorName = value.appMonitorName else {
            return nil
        }
        return "/rummetrics/\(appMonitorName.urlPercentEncoding())/metrics"
    }
}

extension BatchGetRumMetricDefinitionsInput {

    static func queryItemProvider(_ value: BatchGetRumMetricDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let destination = value.destination else {
            let message = "Creating a URL Query Item failed. destination is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let destinationQueryItem = Smithy.URIQueryItem(name: "destination".urlPercentEncoding(), value: Swift.String(destination.rawValue).urlPercentEncoding())
        items.append(destinationQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let destinationArn = value.destinationArn {
            let destinationArnQueryItem = Smithy.URIQueryItem(name: "destinationArn".urlPercentEncoding(), value: Swift.String(destinationArn).urlPercentEncoding())
            items.append(destinationArnQueryItem)
        }
        return items
    }
}

extension CreateAppMonitorInput {

    static func urlPathProvider(_ value: CreateAppMonitorInput) -> Swift.String? {
        return "/appmonitor"
    }
}

extension DeleteAppMonitorInput {

    static func urlPathProvider(_ value: DeleteAppMonitorInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/appmonitor/\(name.urlPercentEncoding())"
    }
}

extension DeleteRumMetricsDestinationInput {

    static func urlPathProvider(_ value: DeleteRumMetricsDestinationInput) -> Swift.String? {
        guard let appMonitorName = value.appMonitorName else {
            return nil
        }
        return "/rummetrics/\(appMonitorName.urlPercentEncoding())/metricsdestination"
    }
}

extension DeleteRumMetricsDestinationInput {

    static func queryItemProvider(_ value: DeleteRumMetricsDestinationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let destination = value.destination else {
            let message = "Creating a URL Query Item failed. destination is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let destinationQueryItem = Smithy.URIQueryItem(name: "destination".urlPercentEncoding(), value: Swift.String(destination.rawValue).urlPercentEncoding())
        items.append(destinationQueryItem)
        if let destinationArn = value.destinationArn {
            let destinationArnQueryItem = Smithy.URIQueryItem(name: "destinationArn".urlPercentEncoding(), value: Swift.String(destinationArn).urlPercentEncoding())
            items.append(destinationArnQueryItem)
        }
        return items
    }
}

extension GetAppMonitorInput {

    static func urlPathProvider(_ value: GetAppMonitorInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/appmonitor/\(name.urlPercentEncoding())"
    }
}

extension GetAppMonitorDataInput {

    static func urlPathProvider(_ value: GetAppMonitorDataInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/appmonitor/\(name.urlPercentEncoding())/data"
    }
}

extension ListAppMonitorsInput {

    static func urlPathProvider(_ value: ListAppMonitorsInput) -> Swift.String? {
        return "/appmonitors"
    }
}

extension ListAppMonitorsInput {

    static func queryItemProvider(_ value: ListAppMonitorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRumMetricsDestinationsInput {

    static func urlPathProvider(_ value: ListRumMetricsDestinationsInput) -> Swift.String? {
        guard let appMonitorName = value.appMonitorName else {
            return nil
        }
        return "/rummetrics/\(appMonitorName.urlPercentEncoding())/metricsdestination"
    }
}

extension ListRumMetricsDestinationsInput {

    static func queryItemProvider(_ value: ListRumMetricsDestinationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutRumEventsInput {

    static func urlPathProvider(_ value: PutRumEventsInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/appmonitors/\(id.urlPercentEncoding())"
    }
}

extension PutRumMetricsDestinationInput {

    static func urlPathProvider(_ value: PutRumMetricsDestinationInput) -> Swift.String? {
        guard let appMonitorName = value.appMonitorName else {
            return nil
        }
        return "/rummetrics/\(appMonitorName.urlPercentEncoding())/metricsdestination"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAppMonitorInput {

    static func urlPathProvider(_ value: UpdateAppMonitorInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/appmonitor/\(name.urlPercentEncoding())"
    }
}

extension UpdateRumMetricDefinitionInput {

    static func urlPathProvider(_ value: UpdateRumMetricDefinitionInput) -> Swift.String? {
        guard let appMonitorName = value.appMonitorName else {
            return nil
        }
        return "/rummetrics/\(appMonitorName.urlPercentEncoding())/metrics"
    }
}

extension BatchCreateRumMetricDefinitionsInput {

    static func write(value: BatchCreateRumMetricDefinitionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
        try writer["DestinationArn"].write(value.destinationArn)
        try writer["MetricDefinitions"].writeList(value.metricDefinitions, memberWritingClosure: RUMClientTypes.MetricDefinitionRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAppMonitorInput {

    static func write(value: CreateAppMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppMonitorConfiguration"].write(value.appMonitorConfiguration, with: RUMClientTypes.AppMonitorConfiguration.write(value:to:))
        try writer["CustomEvents"].write(value.customEvents, with: RUMClientTypes.CustomEvents.write(value:to:))
        try writer["CwLogEnabled"].write(value.cwLogEnabled)
        try writer["Domain"].write(value.domain)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension GetAppMonitorDataInput {

    static func write(value: GetAppMonitorDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: RUMClientTypes.QueryFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TimeRange"].write(value.timeRange, with: RUMClientTypes.TimeRange.write(value:to:))
    }
}

extension PutRumEventsInput {

    static func write(value: PutRumEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppMonitorDetails"].write(value.appMonitorDetails, with: RUMClientTypes.AppMonitorDetails.write(value:to:))
        try writer["BatchId"].write(value.batchId)
        try writer["RumEvents"].writeList(value.rumEvents, memberWritingClosure: RUMClientTypes.RumEvent.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserDetails"].write(value.userDetails, with: RUMClientTypes.UserDetails.write(value:to:))
    }
}

extension PutRumMetricsDestinationInput {

    static func write(value: PutRumMetricsDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
        try writer["DestinationArn"].write(value.destinationArn)
        try writer["IamRoleArn"].write(value.iamRoleArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAppMonitorInput {

    static func write(value: UpdateAppMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppMonitorConfiguration"].write(value.appMonitorConfiguration, with: RUMClientTypes.AppMonitorConfiguration.write(value:to:))
        try writer["CustomEvents"].write(value.customEvents, with: RUMClientTypes.CustomEvents.write(value:to:))
        try writer["CwLogEnabled"].write(value.cwLogEnabled)
        try writer["Domain"].write(value.domain)
    }
}

extension UpdateRumMetricDefinitionInput {

    static func write(value: UpdateRumMetricDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
        try writer["DestinationArn"].write(value.destinationArn)
        try writer["MetricDefinition"].write(value.metricDefinition, with: RUMClientTypes.MetricDefinitionRequest.write(value:to:))
        try writer["MetricDefinitionId"].write(value.metricDefinitionId)
    }
}

extension BatchCreateRumMetricDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateRumMetricDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateRumMetricDefinitionsOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: RUMClientTypes.BatchCreateRumMetricDefinitionsError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.metricDefinitions = try reader["MetricDefinitions"].readListIfPresent(memberReadingClosure: RUMClientTypes.MetricDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteRumMetricDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteRumMetricDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteRumMetricDefinitionsOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: RUMClientTypes.BatchDeleteRumMetricDefinitionsError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.metricDefinitionIds = try reader["MetricDefinitionIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetRumMetricDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetRumMetricDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetRumMetricDefinitionsOutput()
        value.metricDefinitions = try reader["MetricDefinitions"].readListIfPresent(memberReadingClosure: RUMClientTypes.MetricDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CreateAppMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppMonitorOutput()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension DeleteAppMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppMonitorOutput {
        return DeleteAppMonitorOutput()
    }
}

extension DeleteRumMetricsDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRumMetricsDestinationOutput {
        return DeleteRumMetricsDestinationOutput()
    }
}

extension GetAppMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppMonitorOutput()
        value.appMonitor = try reader["AppMonitor"].readIfPresent(with: RUMClientTypes.AppMonitor.read(from:))
        return value
    }
}

extension GetAppMonitorDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppMonitorDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppMonitorDataOutput()
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAppMonitorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppMonitorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppMonitorsOutput()
        value.appMonitorSummaries = try reader["AppMonitorSummaries"].readListIfPresent(memberReadingClosure: RUMClientTypes.AppMonitorSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListRumMetricsDestinationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRumMetricsDestinationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRumMetricsDestinationsOutput()
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: RUMClientTypes.MetricDestinationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceArn = try reader["ResourceArn"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PutRumEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRumEventsOutput {
        return PutRumEventsOutput()
    }
}

extension PutRumMetricsDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRumMetricsDestinationOutput {
        return PutRumMetricsDestinationOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAppMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAppMonitorOutput {
        return UpdateAppMonitorOutput()
    }
}

extension UpdateRumMetricDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRumMetricDefinitionOutput {
        return UpdateRumMetricDefinitionOutput()
    }
}

enum BatchCreateRumMetricDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteRumMetricDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetRumMetricDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRumMetricsDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppMonitorDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppMonitorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRumMetricsDestinationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRumEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRumMetricsDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAppMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRumMetricDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceName = try reader["resourceName"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceName = try reader["resourceName"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RUMClientTypes.BatchCreateRumMetricDefinitionsError {

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.BatchCreateRumMetricDefinitionsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.BatchCreateRumMetricDefinitionsError()
        value.metricDefinition = try reader["MetricDefinition"].readIfPresent(with: RUMClientTypes.MetricDefinitionRequest.read(from:))
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.errorMessage = try reader["ErrorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension RUMClientTypes.MetricDefinitionRequest {

    static func write(value: RUMClientTypes.MetricDefinitionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionKeys"].writeMap(value.dimensionKeys, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["EventPattern"].write(value.eventPattern)
        try writer["Name"].write(value.name)
        try writer["Namespace"].write(value.namespace)
        try writer["UnitLabel"].write(value.unitLabel)
        try writer["ValueKey"].write(value.valueKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.MetricDefinitionRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.MetricDefinitionRequest()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.valueKey = try reader["ValueKey"].readIfPresent()
        value.unitLabel = try reader["UnitLabel"].readIfPresent()
        value.dimensionKeys = try reader["DimensionKeys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.eventPattern = try reader["EventPattern"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        return value
    }
}

extension RUMClientTypes.MetricDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.MetricDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.MetricDefinition()
        value.metricDefinitionId = try reader["MetricDefinitionId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.valueKey = try reader["ValueKey"].readIfPresent()
        value.unitLabel = try reader["UnitLabel"].readIfPresent()
        value.dimensionKeys = try reader["DimensionKeys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.eventPattern = try reader["EventPattern"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        return value
    }
}

extension RUMClientTypes.BatchDeleteRumMetricDefinitionsError {

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.BatchDeleteRumMetricDefinitionsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.BatchDeleteRumMetricDefinitionsError()
        value.metricDefinitionId = try reader["MetricDefinitionId"].readIfPresent() ?? ""
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.errorMessage = try reader["ErrorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension RUMClientTypes.AppMonitor {

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.AppMonitor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.AppMonitor()
        value.name = try reader["Name"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.created = try reader["Created"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.state = try reader["State"].readIfPresent()
        value.appMonitorConfiguration = try reader["AppMonitorConfiguration"].readIfPresent(with: RUMClientTypes.AppMonitorConfiguration.read(from:))
        value.dataStorage = try reader["DataStorage"].readIfPresent(with: RUMClientTypes.DataStorage.read(from:))
        value.customEvents = try reader["CustomEvents"].readIfPresent(with: RUMClientTypes.CustomEvents.read(from:))
        return value
    }
}

extension RUMClientTypes.CustomEvents {

    static func write(value: RUMClientTypes.CustomEvents?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.CustomEvents {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.CustomEvents()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension RUMClientTypes.DataStorage {

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.DataStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.DataStorage()
        value.cwLog = try reader["CwLog"].readIfPresent(with: RUMClientTypes.CwLog.read(from:))
        return value
    }
}

extension RUMClientTypes.CwLog {

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.CwLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.CwLog()
        value.cwLogEnabled = try reader["CwLogEnabled"].readIfPresent()
        value.cwLogGroup = try reader["CwLogGroup"].readIfPresent()
        return value
    }
}

extension RUMClientTypes.AppMonitorConfiguration {

    static func write(value: RUMClientTypes.AppMonitorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowCookies"].write(value.allowCookies)
        try writer["EnableXRay"].write(value.enableXRay)
        try writer["ExcludedPages"].writeList(value.excludedPages, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FavoritePages"].writeList(value.favoritePages, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GuestRoleArn"].write(value.guestRoleArn)
        try writer["IdentityPoolId"].write(value.identityPoolId)
        try writer["IncludedPages"].writeList(value.includedPages, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SessionSampleRate"].write(value.sessionSampleRate)
        try writer["Telemetries"].writeList(value.telemetries, memberWritingClosure: SmithyReadWrite.WritingClosureBox<RUMClientTypes.Telemetry>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.AppMonitorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.AppMonitorConfiguration()
        value.identityPoolId = try reader["IdentityPoolId"].readIfPresent()
        value.excludedPages = try reader["ExcludedPages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.includedPages = try reader["IncludedPages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.favoritePages = try reader["FavoritePages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sessionSampleRate = try reader["SessionSampleRate"].readIfPresent() ?? 0
        value.guestRoleArn = try reader["GuestRoleArn"].readIfPresent()
        value.allowCookies = try reader["AllowCookies"].readIfPresent()
        value.telemetries = try reader["Telemetries"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<RUMClientTypes.Telemetry>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.enableXRay = try reader["EnableXRay"].readIfPresent()
        return value
    }
}

extension RUMClientTypes.AppMonitorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.AppMonitorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.AppMonitorSummary()
        value.name = try reader["Name"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.created = try reader["Created"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension RUMClientTypes.MetricDestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RUMClientTypes.MetricDestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RUMClientTypes.MetricDestinationSummary()
        value.destination = try reader["Destination"].readIfPresent()
        value.destinationArn = try reader["DestinationArn"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        return value
    }
}

extension RUMClientTypes.TimeRange {

    static func write(value: RUMClientTypes.TimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["After"].write(value.after)
        try writer["Before"].write(value.before)
    }
}

extension RUMClientTypes.QueryFilter {

    static func write(value: RUMClientTypes.QueryFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RUMClientTypes.AppMonitorDetails {

    static func write(value: RUMClientTypes.AppMonitorDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["version"].write(value.version)
    }
}

extension RUMClientTypes.UserDetails {

    static func write(value: RUMClientTypes.UserDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionId"].write(value.sessionId)
        try writer["userId"].write(value.userId)
    }
}

extension RUMClientTypes.RumEvent {

    static func write(value: RUMClientTypes.RumEvent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["details"].write(value.details)
        try writer["id"].write(value.id)
        try writer["metadata"].write(value.metadata)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["type"].write(value.type)
    }
}

public enum RUMClientTypes {}
