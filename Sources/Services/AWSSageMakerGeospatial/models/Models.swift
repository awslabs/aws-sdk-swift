// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    public enum AlgorithmNameCloudRemoval: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// INTERPOLATION
        case interpolation
        case sdkUnknown(Swift.String)

        public static var allCases: [AlgorithmNameCloudRemoval] {
            return [
                .interpolation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .interpolation: return "INTERPOLATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlgorithmNameCloudRemoval(rawValue: rawValue) ?? AlgorithmNameCloudRemoval.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum AlgorithmNameGeoMosaic: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// AVERAGE
        case average
        /// BILINEAR
        case bilinear
        /// CUBIC
        case cubic
        /// CUBICSPLINE
        case cubicspline
        /// LANCZOS
        case lanczos
        /// MAX
        case max
        /// MED
        case med
        /// MIN
        case min
        /// MODE
        case mode
        /// NEAR
        case near
        /// Q1
        case q1
        /// Q3
        case q3
        /// RMS
        case rms
        /// SUM
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AlgorithmNameGeoMosaic] {
            return [
                .average,
                .bilinear,
                .cubic,
                .cubicspline,
                .lanczos,
                .max,
                .med,
                .min,
                .mode,
                .near,
                .q1,
                .q3,
                .rms,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .bilinear: return "BILINEAR"
            case .cubic: return "CUBIC"
            case .cubicspline: return "CUBICSPLINE"
            case .lanczos: return "LANCZOS"
            case .max: return "MAX"
            case .med: return "MED"
            case .min: return "MIN"
            case .mode: return "MODE"
            case .near: return "NEAR"
            case .q1: return "Q1"
            case .q3: return "Q3"
            case .rms: return "RMS"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlgorithmNameGeoMosaic(rawValue: rawValue) ?? AlgorithmNameGeoMosaic.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum AlgorithmNameResampling: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// AVERAGE
        case average
        /// BILINEAR
        case bilinear
        /// CUBIC
        case cubic
        /// CUBICSPLINE
        case cubicspline
        /// LANCZOS
        case lanczos
        /// MAX
        case max
        /// MED
        case med
        /// MIN
        case min
        /// MODE
        case mode
        /// NEAR
        case near
        /// Q1
        case q1
        /// Q3
        case q3
        /// RMS
        case rms
        /// SUM
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AlgorithmNameResampling] {
            return [
                .average,
                .bilinear,
                .cubic,
                .cubicspline,
                .lanczos,
                .max,
                .med,
                .min,
                .mode,
                .near,
                .q1,
                .q3,
                .rms,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .bilinear: return "BILINEAR"
            case .cubic: return "CUBIC"
            case .cubicspline: return "CUBICSPLINE"
            case .lanczos: return "LANCZOS"
            case .max: return "MAX"
            case .med: return "MED"
            case .min: return "MIN"
            case .mode: return "MODE"
            case .near: return "NEAR"
            case .q1: return "Q1"
            case .q3: return "Q3"
            case .rms: return "RMS"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlgorithmNameResampling(rawValue: rawValue) ?? AlgorithmNameResampling.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.AreaOfInterest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaofinterestgeometry = "AreaOfInterestGeometry"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .areaofinterestgeometry(areaofinterestgeometry):
                try container.encode(areaofinterestgeometry, forKey: .areaofinterestgeometry)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let areaofinterestgeometryDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.AreaOfInterestGeometry.self, forKey: .areaofinterestgeometry)
        if let areaofinterestgeometry = areaofinterestgeometryDecoded {
            self = .areaofinterestgeometry(areaofinterestgeometry)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    /// The geographic extent of the Earth Observation job.
    public enum AreaOfInterest: Swift.Equatable {
        /// A GeoJSON object representing the geographic extent in the coordinate space.
        case areaofinterestgeometry(SageMakerGeospatialClientTypes.AreaOfInterestGeometry)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes.AreaOfInterestGeometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multipolygongeometry = "MultiPolygonGeometry"
        case polygongeometry = "PolygonGeometry"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .multipolygongeometry(multipolygongeometry):
                try container.encode(multipolygongeometry, forKey: .multipolygongeometry)
            case let .polygongeometry(polygongeometry):
                try container.encode(polygongeometry, forKey: .polygongeometry)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let polygongeometryDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.PolygonGeometryInput.self, forKey: .polygongeometry)
        if let polygongeometry = polygongeometryDecoded {
            self = .polygongeometry(polygongeometry)
            return
        }
        let multipolygongeometryDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.MultiPolygonGeometryInput.self, forKey: .multipolygongeometry)
        if let multipolygongeometry = multipolygongeometryDecoded {
            self = .multipolygongeometry(multipolygongeometry)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    /// A GeoJSON object representing the geographic extent in the coordinate space.
    public enum AreaOfInterestGeometry: Swift.Equatable {
        /// The structure representing Polygon Geometry.
        case polygongeometry(SageMakerGeospatialClientTypes.PolygonGeometryInput)
        /// The structure representing the MultiPolygon Geometry.
        case multipolygongeometry(SageMakerGeospatialClientTypes.MultiPolygonGeometryInput)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes.AssetValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case href = "Href"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let href = self.href {
            try encodeContainer.encode(href, forKey: .href)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hrefDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .href)
        href = hrefDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure containing the asset properties.
    public struct AssetValue: Swift.Equatable {
        /// Link to the asset object.
        public var href: Swift.String?

        public init(
            href: Swift.String? = nil
        )
        {
            self.href = href
        }
    }

}

extension SageMakerGeospatialClientTypes.BandMathConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customIndices = "CustomIndices"
        case predefinedIndices = "PredefinedIndices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customIndices = self.customIndices {
            try encodeContainer.encode(customIndices, forKey: .customIndices)
        }
        if let predefinedIndices = predefinedIndices {
            var predefinedIndicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predefinedIndices)
            for string0 in predefinedIndices {
                try predefinedIndicesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predefinedIndicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .predefinedIndices)
        var predefinedIndicesDecoded0:[Swift.String]? = nil
        if let predefinedIndicesContainer = predefinedIndicesContainer {
            predefinedIndicesDecoded0 = [Swift.String]()
            for string0 in predefinedIndicesContainer {
                if let string0 = string0 {
                    predefinedIndicesDecoded0?.append(string0)
                }
            }
        }
        predefinedIndices = predefinedIndicesDecoded0
        let customIndicesDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.CustomIndicesInput.self, forKey: .customIndices)
        customIndices = customIndicesDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// Input structure for the BandMath operation type. Defines Predefined and CustomIndices to be computed using BandMath.
    public struct BandMathConfigInput: Swift.Equatable {
        /// CustomIndices that are computed.
        public var customIndices: SageMakerGeospatialClientTypes.CustomIndicesInput?
        /// One or many of the supported predefined indices to compute. Allowed values: NDVI, EVI2, MSAVI, NDWI, NDMI, NDSI, and WDRVI.
        public var predefinedIndices: [Swift.String]?

        public init(
            customIndices: SageMakerGeospatialClientTypes.CustomIndicesInput? = nil,
            predefinedIndices: [Swift.String]? = nil
        )
        {
            self.customIndices = customIndices
            self.predefinedIndices = predefinedIndices
        }
    }

}

extension SageMakerGeospatialClientTypes.CloudMaskingConfigInput: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SageMakerGeospatialClientTypes {
    /// Input structure for CloudMasking operation type.
    public struct CloudMaskingConfigInput: Swift.Equatable {

        public init() { }
    }

}

extension SageMakerGeospatialClientTypes.CloudRemovalConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmName = "AlgorithmName"
        case interpolationValue = "InterpolationValue"
        case targetBands = "TargetBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmName = self.algorithmName {
            try encodeContainer.encode(algorithmName.rawValue, forKey: .algorithmName)
        }
        if let interpolationValue = self.interpolationValue {
            try encodeContainer.encode(interpolationValue, forKey: .interpolationValue)
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmNameDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AlgorithmNameCloudRemoval.self, forKey: .algorithmName)
        algorithmName = algorithmNameDecoded
        let interpolationValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interpolationValue)
        interpolationValue = interpolationValueDecoded
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// Input structure for Cloud Removal Operation type
    public struct CloudRemovalConfigInput: Swift.Equatable {
        /// The name of the algorithm used for cloud removal.
        public var algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameCloudRemoval?
        /// The interpolation value you provide for cloud removal.
        public var interpolationValue: Swift.String?
        /// TargetBands to be returned in the output of CloudRemoval operation.
        public var targetBands: [Swift.String]?

        public init(
            algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameCloudRemoval? = nil,
            interpolationValue: Swift.String? = nil,
            targetBands: [Swift.String]? = nil
        )
        {
            self.algorithmName = algorithmName
            self.interpolationValue = interpolationValue
            self.targetBands = targetBands
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// EQUALS
        case equals
        /// NOT_EQUALS
        case notEquals
        /// STARTS_WITH
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equals,
                .notEquals,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes.CustomIndicesInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operations = "Operations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for operation0 in operations {
                try operationsContainer.encode(operation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.Operation?].self, forKey: .operations)
        var operationsDecoded0:[SageMakerGeospatialClientTypes.Operation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [SageMakerGeospatialClientTypes.Operation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// Input object defining the custom BandMath indices to compute.
    public struct CustomIndicesInput: Swift.Equatable {
        /// A list of BandMath indices to compute.
        public var operations: [SageMakerGeospatialClientTypes.Operation]?

        public init(
            operations: [SageMakerGeospatialClientTypes.Operation]? = nil
        )
        {
            self.operations = operations
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum DataCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// PREMIUM
        case premium
        /// PUBLIC
        case `public`
        /// USER
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [DataCollectionType] {
            return [
                .premium,
                .public,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .premium: return "PREMIUM"
            case .public: return "PUBLIC"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataCollectionType(rawValue: rawValue) ?? DataCollectionType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteEarthObservationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/earth-observation-jobs/\(arn.urlPercentEncoding())"
    }
}

public struct DeleteEarthObservationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Earth Observation job being deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteEarthObservationJobInputBody: Swift.Equatable {
}

extension DeleteEarthObservationJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEarthObservationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEarthObservationJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEarthObservationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVectorEnrichmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/vector-enrichment-jobs/\(arn.urlPercentEncoding())"
    }
}

public struct DeleteVectorEnrichmentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job being deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteVectorEnrichmentJobInputBody: Swift.Equatable {
}

extension DeleteVectorEnrichmentJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVectorEnrichmentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVectorEnrichmentJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVectorEnrichmentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerGeospatialClientTypes.EarthObservationJobErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing the errors in an EarthObservationJob.
    public struct EarthObservationJobErrorDetails: Swift.Equatable {
        /// A detailed message describing the error in an Earth Observation job.
        public var message: Swift.String?
        /// The type of error in an Earth Observation job.
        public var type: SageMakerGeospatialClientTypes.EarthObservationJobErrorType?

        public init(
            message: Swift.String? = nil,
            type: SageMakerGeospatialClientTypes.EarthObservationJobErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum EarthObservationJobErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// CLIENT_ERROR
        case clientError
        /// SERVER_ERROR
        case serverError
        case sdkUnknown(Swift.String)

        public static var allCases: [EarthObservationJobErrorType] {
            return [
                .clientError,
                .serverError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientError: return "CLIENT_ERROR"
            case .serverError: return "SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EarthObservationJobErrorType(rawValue: rawValue) ?? EarthObservationJobErrorType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum EarthObservationJobExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// FAILED
        case failed
        /// IN_PROGRESS
        case inProgress
        /// SUCCEEDED
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [EarthObservationJobExportStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EarthObservationJobExportStatus(rawValue: rawValue) ?? EarthObservationJobExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum EarthObservationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// COMPLETED
        case completed
        /// DELETED
        case deleted
        /// DELETING
        case deleting
        /// FAILED
        case failed
        /// INITIALIZING
        case initializing
        /// IN_PROGRESS
        case inProgress
        /// STOPPED
        case stopped
        /// STOPPING
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [EarthObservationJobStatus] {
            return [
                .completed,
                .deleted,
                .deleting,
                .failed,
                .initializing,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .initializing: return "INITIALIZING"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EarthObservationJobStatus(rawValue: rawValue) ?? EarthObservationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.EoCloudCoverInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBound = "LowerBound"
        case upperBound = "UpperBound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBound = self.lowerBound {
            try encodeContainer.encode(lowerBound, forKey: .lowerBound)
        }
        if let upperBound = self.upperBound {
            try encodeContainer.encode(upperBound, forKey: .upperBound)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBound)
        lowerBound = lowerBoundDecoded
        let upperBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBound)
        upperBound = upperBoundDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing the EoCloudCover filter.
    public struct EoCloudCoverInput: Swift.Equatable {
        /// Lower bound for EoCloudCover.
        /// This member is required.
        public var lowerBound: Swift.Float?
        /// Upper bound for EoCloudCover.
        /// This member is required.
        public var upperBound: Swift.Float?

        public init(
            lowerBound: Swift.Float? = nil,
            upperBound: Swift.Float? = nil
        )
        {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }
    }

}

extension ExportEarthObservationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case exportSourceImages = "ExportSourceImages"
        case outputConfig = "OutputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let exportSourceImages = self.exportSourceImages {
            try encodeContainer.encode(exportSourceImages, forKey: .exportSourceImages)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
    }
}

extension ExportEarthObservationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/export-earth-observation-job"
    }
}

public struct ExportEarthObservationJobInput: Swift.Equatable {
    /// The input Amazon Resource Name (ARN) of the Earth Observation job being exported.
    /// This member is required.
    public var arn: Swift.String?
    /// A unique token that guarantees that the call to this API is idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The source images provided to the Earth Observation job being exported.
    public var exportSourceImages: Swift.Bool?
    /// An object containing information about the output file.
    /// This member is required.
    public var outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        exportSourceImages: Swift.Bool? = nil,
        outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput? = nil
    )
    {
        self.arn = arn
        self.clientToken = clientToken
        self.executionRoleArn = executionRoleArn
        self.exportSourceImages = exportSourceImages
        self.outputConfig = outputConfig
    }
}

struct ExportEarthObservationJobInputBody: Swift.Equatable {
    let arn: Swift.String?
    let clientToken: Swift.String?
    let executionRoleArn: Swift.String?
    let outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput?
    let exportSourceImages: Swift.Bool?
}

extension ExportEarthObservationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case exportSourceImages = "ExportSourceImages"
        case outputConfig = "OutputConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputConfigInput.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let exportSourceImagesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .exportSourceImages)
        exportSourceImages = exportSourceImagesDecoded
    }
}

extension ExportEarthObservationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportEarthObservationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.executionRoleArn = output.executionRoleArn
            self.exportSourceImages = output.exportSourceImages
            self.exportStatus = output.exportStatus
            self.outputConfig = output.outputConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.executionRoleArn = nil
            self.exportSourceImages = nil
            self.exportStatus = nil
            self.outputConfig = nil
        }
    }
}

public struct ExportEarthObservationJobOutput: Swift.Equatable {
    /// The output Amazon Resource Name (ARN) of the Earth Observation job being exported.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The source images provided to the Earth Observation job being exported.
    public var exportSourceImages: Swift.Bool?
    /// The status of the results of the Earth Observation job being exported.
    /// This member is required.
    public var exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus?
    /// An object containing information about the output file.
    /// This member is required.
    public var outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        executionRoleArn: Swift.String? = nil,
        exportSourceImages: Swift.Bool? = nil,
        exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus? = nil,
        outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.executionRoleArn = executionRoleArn
        self.exportSourceImages = exportSourceImages
        self.exportStatus = exportStatus
        self.outputConfig = outputConfig
    }
}

struct ExportEarthObservationJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus?
    let executionRoleArn: Swift.String?
    let outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput?
    let exportSourceImages: Swift.Bool?
}

extension ExportEarthObservationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case executionRoleArn = "ExecutionRoleArn"
        case exportSourceImages = "ExportSourceImages"
        case exportStatus = "ExportStatus"
        case outputConfig = "OutputConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputConfigInput.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let exportSourceImagesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .exportSourceImages)
        exportSourceImages = exportSourceImagesDecoded
    }
}

enum ExportEarthObservationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerGeospatialClientTypes.ExportErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportResults = "ExportResults"
        case exportSourceImages = "ExportSourceImages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportResults = self.exportResults {
            try encodeContainer.encode(exportResults, forKey: .exportResults)
        }
        if let exportSourceImages = self.exportSourceImages {
            try encodeContainer.encode(exportSourceImages, forKey: .exportSourceImages)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportResultsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportErrorDetailsOutput.self, forKey: .exportResults)
        exportResults = exportResultsDecoded
        let exportSourceImagesDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportErrorDetailsOutput.self, forKey: .exportSourceImages)
        exportSourceImages = exportSourceImagesDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure for returning the export error details in a GetEarthObservationJob.
    public struct ExportErrorDetails: Swift.Equatable {
        /// The structure for returning the export error details while exporting results of an Earth Observation job.
        public var exportResults: SageMakerGeospatialClientTypes.ExportErrorDetailsOutput?
        /// The structure for returning the export error details while exporting the source images of an Earth Observation job.
        public var exportSourceImages: SageMakerGeospatialClientTypes.ExportErrorDetailsOutput?

        public init(
            exportResults: SageMakerGeospatialClientTypes.ExportErrorDetailsOutput? = nil,
            exportSourceImages: SageMakerGeospatialClientTypes.ExportErrorDetailsOutput? = nil
        )
        {
            self.exportResults = exportResults
            self.exportSourceImages = exportSourceImages
        }
    }

}

extension SageMakerGeospatialClientTypes.ExportErrorDetailsOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing the errors in an export EarthObservationJob operation.
    public struct ExportErrorDetailsOutput: Swift.Equatable {
        /// A detailed message describing the error in an export EarthObservationJob operation.
        public var message: Swift.String?
        /// The type of error in an export EarthObservationJob operation.
        public var type: SageMakerGeospatialClientTypes.ExportErrorType?

        public init(
            message: Swift.String? = nil,
            type: SageMakerGeospatialClientTypes.ExportErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum ExportErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// CLIENT_ERROR
        case clientError
        /// SERVER_ERROR
        case serverError
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportErrorType] {
            return [
                .clientError,
                .serverError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientError: return "CLIENT_ERROR"
            case .serverError: return "SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportErrorType(rawValue: rawValue) ?? ExportErrorType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.ExportS3DataInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure containing the Amazon S3 path to export the Earth Observation job output.
    public struct ExportS3DataInput: Swift.Equatable {
        /// The Key Management Service key ID for server-side encryption.
        public var kmsKeyId: Swift.String?
        /// The URL to the Amazon S3 data input.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension ExportVectorEnrichmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case outputConfig = "OutputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
    }
}

extension ExportVectorEnrichmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/export-vector-enrichment-jobs"
    }
}

public struct ExportVectorEnrichmentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
    /// This member is required.
    public var arn: Swift.String?
    /// A unique token that guarantees that the call to this API is idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM rolewith permission to upload to the location in OutputConfig.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// Output location information for exporting Vector Enrichment Job results.
    /// This member is required.
    public var outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig? = nil
    )
    {
        self.arn = arn
        self.clientToken = clientToken
        self.executionRoleArn = executionRoleArn
        self.outputConfig = outputConfig
    }
}

struct ExportVectorEnrichmentJobInputBody: Swift.Equatable {
    let arn: Swift.String?
    let clientToken: Swift.String?
    let executionRoleArn: Swift.String?
    let outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig?
}

extension ExportVectorEnrichmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case outputConfig = "OutputConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
    }
}

extension ExportVectorEnrichmentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportVectorEnrichmentJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.executionRoleArn = output.executionRoleArn
            self.exportStatus = output.exportStatus
            self.outputConfig = output.outputConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.executionRoleArn = nil
            self.exportStatus = nil
            self.outputConfig = nil
        }
    }
}

public struct ExportVectorEnrichmentJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job being exported.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role with permission to upload to the location in OutputConfig.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The status of the results the Vector Enrichment job being exported.
    /// This member is required.
    public var exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus?
    /// Output location information for exporting Vector Enrichment Job results.
    /// This member is required.
    public var outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        executionRoleArn: Swift.String? = nil,
        exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus? = nil,
        outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.executionRoleArn = executionRoleArn
        self.exportStatus = exportStatus
        self.outputConfig = outputConfig
    }
}

struct ExportVectorEnrichmentJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let executionRoleArn: Swift.String?
    let exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus?
    let outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig?
}

extension ExportVectorEnrichmentJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case executionRoleArn = "ExecutionRoleArn"
        case exportStatus = "ExportStatus"
        case outputConfig = "OutputConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
    }
}

extension SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Data = "S3Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Data = self.s3Data {
            try encodeContainer.encode(s3Data, forKey: .s3Data)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data.self, forKey: .s3Data)
        s3Data = s3DataDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// An object containing information about the output file.
    public struct ExportVectorEnrichmentJobOutputConfig: Swift.Equatable {
        /// The input structure for Amazon S3 data; representing the Amazon S3 location of the input data objects.
        /// This member is required.
        public var s3Data: SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data?

        public init(
            s3Data: SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data? = nil
        )
        {
            self.s3Data = s3Data
        }
    }

}

enum ExportVectorEnrichmentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerGeospatialClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximum = "Maximum"
        case minimum = "Minimum"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximum = self.maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = self.minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .minimum)
        minimum = minimumDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .maximum)
        maximum = maximumDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing the filters supported by a RasterDataCollection.
    public struct Filter: Swift.Equatable {
        /// The maximum value of the filter.
        public var maximum: Swift.Float?
        /// The minimum value of the filter.
        public var minimum: Swift.Float?
        /// The name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the filter being used.
        /// This member is required.
        public var type: Swift.String?

        public init(
            maximum: Swift.Float? = nil,
            minimum: Swift.Float? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.maximum = maximum
            self.minimum = minimum
            self.name = name
            self.type = type
        }
    }

}

extension SageMakerGeospatialClientTypes.GeoMosaicConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmName = "AlgorithmName"
        case targetBands = "TargetBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmName = self.algorithmName {
            try encodeContainer.encode(algorithmName.rawValue, forKey: .algorithmName)
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmNameDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AlgorithmNameGeoMosaic.self, forKey: .algorithmName)
        algorithmName = algorithmNameDecoded
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// Input configuration information for the geomosaic.
    public struct GeoMosaicConfigInput: Swift.Equatable {
        /// The name of the algorithm being used for geomosaic.
        public var algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameGeoMosaic?
        /// The target bands for geomosaic.
        public var targetBands: [Swift.String]?

        public init(
            algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameGeoMosaic? = nil,
            targetBands: [Swift.String]? = nil
        )
        {
            self.algorithmName = algorithmName
            self.targetBands = targetBands
        }
    }

}

extension SageMakerGeospatialClientTypes.Geometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coordinates = "Coordinates"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coordinates = coordinates {
            var coordinatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .coordinates)
            for linearring0 in coordinates {
                var linearring0Container = coordinatesContainer.nestedUnkeyedContainer()
                for position1 in linearring0 {
                    var position1Container = linearring0Container.nestedUnkeyedContainer()
                    for double2 in position1 {
                        try position1Container.encode(double2)
                    }
                }
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let coordinatesContainer = try containerValues.decodeIfPresent([[[Swift.Double?]?]?].self, forKey: .coordinates)
        var coordinatesDecoded0:[[[Swift.Double]]]? = nil
        if let coordinatesContainer = coordinatesContainer {
            coordinatesDecoded0 = [[[Swift.Double]]]()
            for list0 in coordinatesContainer {
                var list0Decoded0: [[Swift.Double]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.Double]]()
                    for list1 in list0 {
                        var list1Decoded1: [Swift.Double]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Double]()
                            for double2 in list1 {
                                if let double2 = double2 {
                                    list1Decoded1?.append(double2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            list0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    coordinatesDecoded0?.append(list0Decoded0)
                }
            }
        }
        coordinates = coordinatesDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing a Geometry in terms of Type and Coordinates as per GeoJson spec.
    public struct Geometry: Swift.Equatable {
        /// The coordinates of the GeoJson Geometry.
        /// This member is required.
        public var coordinates: [[[Swift.Double]]]?
        /// GeoJson Geometry types like Polygon and MultiPolygon.
        /// This member is required.
        public var type: Swift.String?

        public init(
            coordinates: [[[Swift.Double]]]? = nil,
            type: Swift.String? = nil
        )
        {
            self.coordinates = coordinates
            self.type = type
        }
    }

}

extension GetEarthObservationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/earth-observation-jobs/\(arn.urlPercentEncoding())"
    }
}

public struct GetEarthObservationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Earth Observation job.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetEarthObservationJobInputBody: Swift.Equatable {
}

extension GetEarthObservationJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEarthObservationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEarthObservationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.durationInSeconds = output.durationInSeconds
            self.errorDetails = output.errorDetails
            self.executionRoleArn = output.executionRoleArn
            self.exportErrorDetails = output.exportErrorDetails
            self.exportStatus = output.exportStatus
            self.inputConfig = output.inputConfig
            self.jobConfig = output.jobConfig
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.outputBands = output.outputBands
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTime = nil
            self.durationInSeconds = nil
            self.errorDetails = nil
            self.executionRoleArn = nil
            self.exportErrorDetails = nil
            self.exportStatus = nil
            self.inputConfig = nil
            self.jobConfig = nil
            self.kmsKeyId = nil
            self.name = nil
            self.outputBands = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetEarthObservationJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Earth Observation job.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time of the initiated Earth Observation job.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The duration of Earth Observation job, in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int?
    /// Details about the errors generated during the Earth Observation job.
    public var errorDetails: SageMakerGeospatialClientTypes.EarthObservationJobErrorDetails?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    public var executionRoleArn: Swift.String?
    /// Details about the errors generated during ExportEarthObservationJob.
    public var exportErrorDetails: SageMakerGeospatialClientTypes.ExportErrorDetails?
    /// The status of the Earth Observation job.
    public var exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus?
    /// Input data for the Earth Observation job.
    /// This member is required.
    public var inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    /// The Key Management Service key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Earth Observation job.
    /// This member is required.
    public var name: Swift.String?
    /// Bands available in the output of an operation.
    public var outputBands: [SageMakerGeospatialClientTypes.OutputBand]?
    /// The status of a previously initiated Earth Observation job.
    /// This member is required.
    public var status: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        durationInSeconds: Swift.Int? = nil,
        errorDetails: SageMakerGeospatialClientTypes.EarthObservationJobErrorDetails? = nil,
        executionRoleArn: Swift.String? = nil,
        exportErrorDetails: SageMakerGeospatialClientTypes.ExportErrorDetails? = nil,
        exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus? = nil,
        inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput? = nil,
        jobConfig: SageMakerGeospatialClientTypes.JobConfigInput? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        outputBands: [SageMakerGeospatialClientTypes.OutputBand]? = nil,
        status: SageMakerGeospatialClientTypes.EarthObservationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.durationInSeconds = durationInSeconds
        self.errorDetails = errorDetails
        self.executionRoleArn = executionRoleArn
        self.exportErrorDetails = exportErrorDetails
        self.exportStatus = exportStatus
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.outputBands = outputBands
        self.status = status
        self.tags = tags
    }
}

struct GetEarthObservationJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let creationTime: ClientRuntime.Date?
    let durationInSeconds: Swift.Int?
    let status: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput?
    let jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    let outputBands: [SageMakerGeospatialClientTypes.OutputBand]?
    let executionRoleArn: Swift.String?
    let errorDetails: SageMakerGeospatialClientTypes.EarthObservationJobErrorDetails?
    let exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus?
    let exportErrorDetails: SageMakerGeospatialClientTypes.ExportErrorDetails?
    let tags: [Swift.String:Swift.String]?
}

extension GetEarthObservationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case errorDetails = "ErrorDetails"
        case executionRoleArn = "ExecutionRoleArn"
        case exportErrorDetails = "ExportErrorDetails"
        case exportStatus = "ExportStatus"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case outputBands = "OutputBands"
        case status = "Status"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.InputConfigOutput.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.JobConfigInput.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let outputBandsContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.OutputBand?].self, forKey: .outputBands)
        var outputBandsDecoded0:[SageMakerGeospatialClientTypes.OutputBand]? = nil
        if let outputBandsContainer = outputBandsContainer {
            outputBandsDecoded0 = [SageMakerGeospatialClientTypes.OutputBand]()
            for structure0 in outputBandsContainer {
                if let structure0 = structure0 {
                    outputBandsDecoded0?.append(structure0)
                }
            }
        }
        outputBands = outputBandsDecoded0
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let exportErrorDetailsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportErrorDetails.self, forKey: .exportErrorDetails)
        exportErrorDetails = exportErrorDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetEarthObservationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRasterDataCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/raster-data-collection/\(arn.urlPercentEncoding())"
    }
}

public struct GetRasterDataCollectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the raster data collection.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRasterDataCollectionInputBody: Swift.Equatable {
}

extension GetRasterDataCollectionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRasterDataCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRasterDataCollectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.descriptionPageUrl = output.descriptionPageUrl
            self.imageSourceBands = output.imageSourceBands
            self.name = output.name
            self.supportedFilters = output.supportedFilters
            self.tags = output.tags
            self.type = output.type
        } else {
            self.arn = nil
            self.description = nil
            self.descriptionPageUrl = nil
            self.imageSourceBands = nil
            self.name = nil
            self.supportedFilters = nil
            self.tags = nil
            self.type = nil
        }
    }
}

public struct GetRasterDataCollectionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the raster data collection.
    /// This member is required.
    public var arn: Swift.String?
    /// A description of the raster data collection.
    /// This member is required.
    public var description: Swift.String?
    /// The URL of the description page.
    /// This member is required.
    public var descriptionPageUrl: Swift.String?
    /// The list of image source bands in the raster data collection.
    /// This member is required.
    public var imageSourceBands: [Swift.String]?
    /// The name of the raster data collection.
    /// This member is required.
    public var name: Swift.String?
    /// The filters supported by the raster data collection.
    /// This member is required.
    public var supportedFilters: [SageMakerGeospatialClientTypes.Filter]?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?
    /// The raster data collection type.
    /// This member is required.
    public var type: SageMakerGeospatialClientTypes.DataCollectionType?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        descriptionPageUrl: Swift.String? = nil,
        imageSourceBands: [Swift.String]? = nil,
        name: Swift.String? = nil,
        supportedFilters: [SageMakerGeospatialClientTypes.Filter]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: SageMakerGeospatialClientTypes.DataCollectionType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.descriptionPageUrl = descriptionPageUrl
        self.imageSourceBands = imageSourceBands
        self.name = name
        self.supportedFilters = supportedFilters
        self.tags = tags
        self.type = type
    }
}

struct GetRasterDataCollectionOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let type: SageMakerGeospatialClientTypes.DataCollectionType?
    let description: Swift.String?
    let descriptionPageUrl: Swift.String?
    let supportedFilters: [SageMakerGeospatialClientTypes.Filter]?
    let imageSourceBands: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension GetRasterDataCollectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case descriptionPageUrl = "DescriptionPageUrl"
        case imageSourceBands = "ImageSourceBands"
        case name = "Name"
        case supportedFilters = "SupportedFilters"
        case tags = "Tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.DataCollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let descriptionPageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .descriptionPageUrl)
        descriptionPageUrl = descriptionPageUrlDecoded
        let supportedFiltersContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.Filter?].self, forKey: .supportedFilters)
        var supportedFiltersDecoded0:[SageMakerGeospatialClientTypes.Filter]? = nil
        if let supportedFiltersContainer = supportedFiltersContainer {
            supportedFiltersDecoded0 = [SageMakerGeospatialClientTypes.Filter]()
            for structure0 in supportedFiltersContainer {
                if let structure0 = structure0 {
                    supportedFiltersDecoded0?.append(structure0)
                }
            }
        }
        supportedFilters = supportedFiltersDecoded0
        let imageSourceBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageSourceBands)
        var imageSourceBandsDecoded0:[Swift.String]? = nil
        if let imageSourceBandsContainer = imageSourceBandsContainer {
            imageSourceBandsDecoded0 = [Swift.String]()
            for string0 in imageSourceBandsContainer {
                if let string0 = string0 {
                    imageSourceBandsDecoded0?.append(string0)
                }
            }
        }
        imageSourceBands = imageSourceBandsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetRasterDataCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageAssets = imageAssets else {
                let message = "Creating a URL Query Item failed. imageAssets is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            imageAssets.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "ImageAssets".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            if let imageMask = imageMask {
                let imageMaskQueryItem = ClientRuntime.URLQueryItem(name: "ImageMask".urlPercentEncoding(), value: Swift.String(imageMask).urlPercentEncoding())
                items.append(imageMaskQueryItem)
            }
            if let executionRoleArn = executionRoleArn {
                let executionRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "ExecutionRoleArn".urlPercentEncoding(), value: Swift.String(executionRoleArn).urlPercentEncoding())
                items.append(executionRoleArnQueryItem)
            }
            guard let target = target else {
                let message = "Creating a URL Query Item failed. target is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let targetQueryItem = ClientRuntime.URLQueryItem(name: "Target".urlPercentEncoding(), value: Swift.String(target.rawValue).urlPercentEncoding())
            items.append(targetQueryItem)
            if let propertyFilters = propertyFilters {
                let propertyFiltersQueryItem = ClientRuntime.URLQueryItem(name: "PropertyFilters".urlPercentEncoding(), value: Swift.String(propertyFilters).urlPercentEncoding())
                items.append(propertyFiltersQueryItem)
            }
            if let outputDataType = outputDataType {
                let outputDataTypeQueryItem = ClientRuntime.URLQueryItem(name: "OutputDataType".urlPercentEncoding(), value: Swift.String(outputDataType.rawValue).urlPercentEncoding())
                items.append(outputDataTypeQueryItem)
            }
            if let timeRangeFilter = timeRangeFilter {
                let timeRangeFilterQueryItem = ClientRuntime.URLQueryItem(name: "TimeRangeFilter".urlPercentEncoding(), value: Swift.String(timeRangeFilter).urlPercentEncoding())
                items.append(timeRangeFilterQueryItem)
            }
            if let outputFormat = outputFormat {
                let outputFormatQueryItem = ClientRuntime.URLQueryItem(name: "OutputFormat".urlPercentEncoding(), value: Swift.String(outputFormat).urlPercentEncoding())
                items.append(outputFormatQueryItem)
            }
            guard let arn = arn else {
                let message = "Creating a URL Query Item failed. arn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "Arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
            return items
        }
    }
}

extension GetTileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let z = z else {
            return nil
        }
        guard let x = x else {
            return nil
        }
        guard let y = y else {
            return nil
        }
        return "/tile/\(z)/\(x)/\(y)"
    }
}

public struct GetTileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the tile operation.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that you specify.
    public var executionRoleArn: Swift.String?
    /// The particular assets or bands to tile.
    /// This member is required.
    public var imageAssets: [Swift.String]?
    /// Determines whether or not to return a valid data mask.
    public var imageMask: Swift.Bool?
    /// The output data type of the tile operation.
    public var outputDataType: SageMakerGeospatialClientTypes.OutputType?
    /// The data format of the output tile. The formats include .npy, .png and .jpg.
    public var outputFormat: Swift.String?
    /// Property filters for the imagery to tile.
    public var propertyFilters: Swift.String?
    /// Determines what part of the Earth Observation job to tile. 'INPUT' or 'OUTPUT' are the valid options.
    /// This member is required.
    public var target: SageMakerGeospatialClientTypes.TargetOptions?
    /// Time range filter applied to imagery to find the images to tile.
    public var timeRangeFilter: Swift.String?
    /// The x coordinate of the tile input.
    /// This member is required.
    public var x: Swift.Int?
    /// The y coordinate of the tile input.
    /// This member is required.
    public var y: Swift.Int?
    /// The z coordinate of the tile input.
    /// This member is required.
    public var z: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        imageAssets: [Swift.String]? = nil,
        imageMask: Swift.Bool? = nil,
        outputDataType: SageMakerGeospatialClientTypes.OutputType? = nil,
        outputFormat: Swift.String? = nil,
        propertyFilters: Swift.String? = nil,
        target: SageMakerGeospatialClientTypes.TargetOptions? = nil,
        timeRangeFilter: Swift.String? = nil,
        x: Swift.Int? = nil,
        y: Swift.Int? = nil,
        z: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.executionRoleArn = executionRoleArn
        self.imageAssets = imageAssets
        self.imageMask = imageMask
        self.outputDataType = outputDataType
        self.outputFormat = outputFormat
        self.propertyFilters = propertyFilters
        self.target = target
        self.timeRangeFilter = timeRangeFilter
        self.x = x
        self.y = y
        self.z = z
    }
}

struct GetTileInputBody: Swift.Equatable {
}

extension GetTileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.binaryFile = .data(data)
        case .stream(let stream):
            self.binaryFile = .stream(stream)
        case .none:
            self.binaryFile = nil
        }
    }
}

public struct GetTileOutput: Swift.Equatable {
    /// The output binary file.
    public var binaryFile: ClientRuntime.ByteStream?

    public init(
        binaryFile: ClientRuntime.ByteStream? = nil
    )
    {
        self.binaryFile = binaryFile
    }
}

struct GetTileOutputBody: Swift.Equatable {
    let binaryFile: ClientRuntime.ByteStream?
}

extension GetTileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binaryFile = "BinaryFile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let binaryFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .binaryFile)
        binaryFile = binaryFileDecoded
    }
}

enum GetTileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVectorEnrichmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/vector-enrichment-jobs/\(arn.urlPercentEncoding())"
    }
}

public struct GetVectorEnrichmentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetVectorEnrichmentJobInputBody: Swift.Equatable {
}

extension GetVectorEnrichmentJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVectorEnrichmentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVectorEnrichmentJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.durationInSeconds = output.durationInSeconds
            self.errorDetails = output.errorDetails
            self.executionRoleArn = output.executionRoleArn
            self.exportErrorDetails = output.exportErrorDetails
            self.exportStatus = output.exportStatus
            self.inputConfig = output.inputConfig
            self.jobConfig = output.jobConfig
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
            self.type = output.type
        } else {
            self.arn = nil
            self.creationTime = nil
            self.durationInSeconds = nil
            self.errorDetails = nil
            self.executionRoleArn = nil
            self.exportErrorDetails = nil
            self.exportStatus = nil
            self.inputConfig = nil
            self.jobConfig = nil
            self.kmsKeyId = nil
            self.name = nil
            self.status = nil
            self.tags = nil
            self.type = nil
        }
    }
}

public struct GetVectorEnrichmentJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The duration of the Vector Enrichment job, in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int?
    /// Details about the errors generated during the Vector Enrichment job.
    public var errorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorDetails?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// Details about the errors generated during the ExportVectorEnrichmentJob.
    public var exportErrorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorDetails?
    /// The export status of the Vector Enrichment job being initiated.
    public var exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus?
    /// Input configuration information for the Vector Enrichment job.
    /// This member is required.
    public var inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    /// The Key Management Service key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Vector Enrichment job.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the initiated Vector Enrichment job.
    /// This member is required.
    public var status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the Vector Enrichment job being initiated.
    /// This member is required.
    public var type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        durationInSeconds: Swift.Int? = nil,
        errorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorDetails? = nil,
        executionRoleArn: Swift.String? = nil,
        exportErrorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorDetails? = nil,
        exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus? = nil,
        inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig? = nil,
        jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.durationInSeconds = durationInSeconds
        self.errorDetails = errorDetails
        self.executionRoleArn = executionRoleArn
        self.exportErrorDetails = exportErrorDetails
        self.exportStatus = exportStatus
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tags = tags
        self.type = type
    }
}

struct GetVectorEnrichmentJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType?
    let name: Swift.String?
    let creationTime: ClientRuntime.Date?
    let durationInSeconds: Swift.Int?
    let status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    let jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    let executionRoleArn: Swift.String?
    let errorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorDetails?
    let exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus?
    let exportErrorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorDetails?
    let tags: [Swift.String:Swift.String]?
}

extension GetVectorEnrichmentJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case errorDetails = "ErrorDetails"
        case executionRoleArn = "ExecutionRoleArn"
        case exportErrorDetails = "ExportErrorDetails"
        case exportStatus = "ExportStatus"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let exportErrorDetailsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorDetails.self, forKey: .exportErrorDetails)
        exportErrorDetails = exportErrorDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetVectorEnrichmentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum GroupBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// ALL
        case all
        /// YEARLY
        case yearly
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupBy] {
            return [
                .all,
                .yearly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .yearly: return "YEARLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupBy(rawValue: rawValue) ?? GroupBy.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.InputConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case previousEarthObservationJobArn = "PreviousEarthObservationJobArn"
        case rasterDataCollectionQuery = "RasterDataCollectionQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let previousEarthObservationJobArn = self.previousEarthObservationJobArn {
            try encodeContainer.encode(previousEarthObservationJobArn, forKey: .previousEarthObservationJobArn)
        }
        if let rasterDataCollectionQuery = self.rasterDataCollectionQuery {
            try encodeContainer.encode(rasterDataCollectionQuery, forKey: .rasterDataCollectionQuery)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previousEarthObservationJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousEarthObservationJobArn)
        previousEarthObservationJobArn = previousEarthObservationJobArnDecoded
        let rasterDataCollectionQueryDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.RasterDataCollectionQueryInput.self, forKey: .rasterDataCollectionQuery)
        rasterDataCollectionQuery = rasterDataCollectionQueryDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// Input configuration information.
    public struct InputConfigInput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the previous Earth Observation job.
        public var previousEarthObservationJobArn: Swift.String?
        /// The structure representing the RasterDataCollection Query consisting of the Area of Interest, RasterDataCollectionArn,TimeRange and Property Filters.
        public var rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryInput?

        public init(
            previousEarthObservationJobArn: Swift.String? = nil,
            rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryInput? = nil
        )
        {
            self.previousEarthObservationJobArn = previousEarthObservationJobArn
            self.rasterDataCollectionQuery = rasterDataCollectionQuery
        }
    }

}

extension SageMakerGeospatialClientTypes.InputConfigOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case previousEarthObservationJobArn = "PreviousEarthObservationJobArn"
        case rasterDataCollectionQuery = "RasterDataCollectionQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let previousEarthObservationJobArn = self.previousEarthObservationJobArn {
            try encodeContainer.encode(previousEarthObservationJobArn, forKey: .previousEarthObservationJobArn)
        }
        if let rasterDataCollectionQuery = self.rasterDataCollectionQuery {
            try encodeContainer.encode(rasterDataCollectionQuery, forKey: .rasterDataCollectionQuery)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previousEarthObservationJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousEarthObservationJobArn)
        previousEarthObservationJobArn = previousEarthObservationJobArnDecoded
        let rasterDataCollectionQueryDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.RasterDataCollectionQueryOutput.self, forKey: .rasterDataCollectionQuery)
        rasterDataCollectionQuery = rasterDataCollectionQueryDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The InputConfig for an EarthObservationJob response.
    public struct InputConfigOutput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the previous Earth Observation job.
        public var previousEarthObservationJobArn: Swift.String?
        /// The structure representing the RasterDataCollection Query consisting of the Area of Interest, RasterDataCollectionArn, RasterDataCollectionName, TimeRange, and Property Filters.
        public var rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryOutput?

        public init(
            previousEarthObservationJobArn: Swift.String? = nil,
            rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryOutput? = nil
        )
        {
            self.previousEarthObservationJobArn = previousEarthObservationJobArn
            self.rasterDataCollectionQuery = rasterDataCollectionQuery
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes.ItemSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets = "Assets"
        case dateTime = "DateTime"
        case geometry = "Geometry"
        case id = "Id"
        case properties = "Properties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assets = assets {
            var assetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .assets)
            for (dictKey0, assetsMap0) in assets {
                try assetsContainer.encode(assetsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dateTime = self.dateTime {
            try encodeContainer.encodeTimestamp(dateTime, format: .epochSeconds, forKey: .dateTime)
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let properties = self.properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.Geometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let assetsContainer = try containerValues.decodeIfPresent([Swift.String: SageMakerGeospatialClientTypes.AssetValue?].self, forKey: .assets)
        var assetsDecoded0: [Swift.String:SageMakerGeospatialClientTypes.AssetValue]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [Swift.String:SageMakerGeospatialClientTypes.AssetValue]()
            for (key0, assetvalue0) in assetsContainer {
                if let assetvalue0 = assetvalue0 {
                    assetsDecoded0?[key0] = assetvalue0
                }
            }
        }
        assets = assetsDecoded0
        let dateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateTime)
        dateTime = dateTimeDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.Properties.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing the items in the response for SearchRasterDataCollection.
    public struct ItemSource: Swift.Equatable {
        /// This is a dictionary of Asset Objects data associated with the Item that can be downloaded or streamed, each with a unique key.
        public var assets: [Swift.String:SageMakerGeospatialClientTypes.AssetValue]?
        /// The searchable date and time of the item, in UTC.
        /// This member is required.
        public var dateTime: ClientRuntime.Date?
        /// The item Geometry in GeoJson format.
        /// This member is required.
        public var geometry: SageMakerGeospatialClientTypes.Geometry?
        /// A unique Id for the source item.
        /// This member is required.
        public var id: Swift.String?
        /// This field contains additional properties of the item.
        public var properties: SageMakerGeospatialClientTypes.Properties?

        public init(
            assets: [Swift.String:SageMakerGeospatialClientTypes.AssetValue]? = nil,
            dateTime: ClientRuntime.Date? = nil,
            geometry: SageMakerGeospatialClientTypes.Geometry? = nil,
            id: Swift.String? = nil,
            properties: SageMakerGeospatialClientTypes.Properties? = nil
        )
        {
            self.assets = assets
            self.dateTime = dateTime
            self.geometry = geometry
            self.id = id
            self.properties = properties
        }
    }

}

extension SageMakerGeospatialClientTypes.JobConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandmathconfig = "BandMathConfig"
        case cloudmaskingconfig = "CloudMaskingConfig"
        case cloudremovalconfig = "CloudRemovalConfig"
        case geomosaicconfig = "GeoMosaicConfig"
        case landcoversegmentationconfig = "LandCoverSegmentationConfig"
        case resamplingconfig = "ResamplingConfig"
        case stackconfig = "StackConfig"
        case temporalstatisticsconfig = "TemporalStatisticsConfig"
        case zonalstatisticsconfig = "ZonalStatisticsConfig"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .bandmathconfig(bandmathconfig):
                try container.encode(bandmathconfig, forKey: .bandmathconfig)
            case let .cloudmaskingconfig(cloudmaskingconfig):
                try container.encode(cloudmaskingconfig, forKey: .cloudmaskingconfig)
            case let .cloudremovalconfig(cloudremovalconfig):
                try container.encode(cloudremovalconfig, forKey: .cloudremovalconfig)
            case let .geomosaicconfig(geomosaicconfig):
                try container.encode(geomosaicconfig, forKey: .geomosaicconfig)
            case let .landcoversegmentationconfig(landcoversegmentationconfig):
                try container.encode(landcoversegmentationconfig, forKey: .landcoversegmentationconfig)
            case let .resamplingconfig(resamplingconfig):
                try container.encode(resamplingconfig, forKey: .resamplingconfig)
            case let .stackconfig(stackconfig):
                try container.encode(stackconfig, forKey: .stackconfig)
            case let .temporalstatisticsconfig(temporalstatisticsconfig):
                try container.encode(temporalstatisticsconfig, forKey: .temporalstatisticsconfig)
            case let .zonalstatisticsconfig(zonalstatisticsconfig):
                try container.encode(zonalstatisticsconfig, forKey: .zonalstatisticsconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let bandmathconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.BandMathConfigInput.self, forKey: .bandmathconfig)
        if let bandmathconfig = bandmathconfigDecoded {
            self = .bandmathconfig(bandmathconfig)
            return
        }
        let resamplingconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ResamplingConfigInput.self, forKey: .resamplingconfig)
        if let resamplingconfig = resamplingconfigDecoded {
            self = .resamplingconfig(resamplingconfig)
            return
        }
        let temporalstatisticsconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.TemporalStatisticsConfigInput.self, forKey: .temporalstatisticsconfig)
        if let temporalstatisticsconfig = temporalstatisticsconfigDecoded {
            self = .temporalstatisticsconfig(temporalstatisticsconfig)
            return
        }
        let cloudremovalconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.CloudRemovalConfigInput.self, forKey: .cloudremovalconfig)
        if let cloudremovalconfig = cloudremovalconfigDecoded {
            self = .cloudremovalconfig(cloudremovalconfig)
            return
        }
        let zonalstatisticsconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ZonalStatisticsConfigInput.self, forKey: .zonalstatisticsconfig)
        if let zonalstatisticsconfig = zonalstatisticsconfigDecoded {
            self = .zonalstatisticsconfig(zonalstatisticsconfig)
            return
        }
        let geomosaicconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.GeoMosaicConfigInput.self, forKey: .geomosaicconfig)
        if let geomosaicconfig = geomosaicconfigDecoded {
            self = .geomosaicconfig(geomosaicconfig)
            return
        }
        let stackconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.StackConfigInput.self, forKey: .stackconfig)
        if let stackconfig = stackconfigDecoded {
            self = .stackconfig(stackconfig)
            return
        }
        let cloudmaskingconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.CloudMaskingConfigInput.self, forKey: .cloudmaskingconfig)
        if let cloudmaskingconfig = cloudmaskingconfigDecoded {
            self = .cloudmaskingconfig(cloudmaskingconfig)
            return
        }
        let landcoversegmentationconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.LandCoverSegmentationConfigInput.self, forKey: .landcoversegmentationconfig)
        if let landcoversegmentationconfig = landcoversegmentationconfigDecoded {
            self = .landcoversegmentationconfig(landcoversegmentationconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for the JobConfig in an EarthObservationJob.
    public enum JobConfigInput: Swift.Equatable {
        /// An object containing information about the job configuration for BandMath.
        case bandmathconfig(SageMakerGeospatialClientTypes.BandMathConfigInput)
        /// An object containing information about the job configuration for resampling.
        case resamplingconfig(SageMakerGeospatialClientTypes.ResamplingConfigInput)
        /// An object containing information about the job configuration for temporal statistics.
        case temporalstatisticsconfig(SageMakerGeospatialClientTypes.TemporalStatisticsConfigInput)
        /// An object containing information about the job configuration for cloud removal.
        case cloudremovalconfig(SageMakerGeospatialClientTypes.CloudRemovalConfigInput)
        /// An object containing information about the job configuration for zonal statistics.
        case zonalstatisticsconfig(SageMakerGeospatialClientTypes.ZonalStatisticsConfigInput)
        /// An object containing information about the job configuration for geomosaic.
        case geomosaicconfig(SageMakerGeospatialClientTypes.GeoMosaicConfigInput)
        /// An object containing information about the job configuration for a Stacking Earth Observation job.
        case stackconfig(SageMakerGeospatialClientTypes.StackConfigInput)
        /// An object containing information about the job configuration for cloud masking.
        case cloudmaskingconfig(SageMakerGeospatialClientTypes.CloudMaskingConfigInput)
        /// An object containing information about the job configuration for land cover segmentation.
        case landcoversegmentationconfig(SageMakerGeospatialClientTypes.LandCoverSegmentationConfigInput)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes.LandCoverSegmentationConfigInput: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for Land Cover Operation type.
    public struct LandCoverSegmentationConfigInput: Swift.Equatable {

        public init() { }
    }

}

extension SageMakerGeospatialClientTypes.LandsatCloudCoverLandInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBound = "LowerBound"
        case upperBound = "UpperBound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBound = self.lowerBound {
            try encodeContainer.encode(lowerBound, forKey: .lowerBound)
        }
        if let upperBound = self.upperBound {
            try encodeContainer.encode(upperBound, forKey: .upperBound)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBound)
        lowerBound = lowerBoundDecoded
        let upperBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBound)
        upperBound = upperBoundDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing Land Cloud Cover property for Landsat data collection.
    public struct LandsatCloudCoverLandInput: Swift.Equatable {
        /// The minimum value for Land Cloud Cover property filter. This will filter items having Land Cloud Cover greater than or equal to this value.
        /// This member is required.
        public var lowerBound: Swift.Float?
        /// The maximum value for Land Cloud Cover property filter. This will filter items having Land Cloud Cover less than or equal to this value.
        /// This member is required.
        public var upperBound: Swift.Float?

        public init(
            lowerBound: Swift.Float? = nil,
            upperBound: Swift.Float? = nil
        )
        {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }
    }

}

extension SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case name = "Name"
        case operationType = "OperationType"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType, forKey: .operationType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobStatus.self, forKey: .status)
        status = statusDecoded
        let operationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// An object containing information about the output file.
    public struct ListEarthObservationJobOutputConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the list of the Earth Observation jobs.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The duration of the session, in seconds.
        /// This member is required.
        public var durationInSeconds: Swift.Int?
        /// The names of the Earth Observation jobs in the list.
        /// This member is required.
        public var name: Swift.String?
        /// The operation type for an Earth Observation job.
        /// This member is required.
        public var operationType: Swift.String?
        /// The status of the list of the Earth Observation jobs.
        /// This member is required.
        public var status: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
        /// Each tag consists of a key and a value.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            durationInSeconds: Swift.Int? = nil,
            name: Swift.String? = nil,
            operationType: Swift.String? = nil,
            status: SageMakerGeospatialClientTypes.EarthObservationJobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.name = name
            self.operationType = operationType
            self.status = status
            self.tags = tags
        }
    }

}

extension ListEarthObservationJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEarthObservationJobsInput(maxResults: \(Swift.String(describing: maxResults)), sortBy: \(Swift.String(describing: sortBy)), sortOrder: \(Swift.String(describing: sortOrder)), statusEquals: \(Swift.String(describing: statusEquals)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListEarthObservationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
        case statusEquals = "StatusEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let statusEquals = self.statusEquals {
            try encodeContainer.encode(statusEquals.rawValue, forKey: .statusEquals)
        }
    }
}

extension ListEarthObservationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-earth-observation-jobs"
    }
}

public struct ListEarthObservationJobsInput: Swift.Equatable {
    /// The total number of items to return.
    public var maxResults: Swift.Int?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?
    /// The parameter by which to sort the results.
    public var sortBy: Swift.String?
    /// An optional value that specifies whether you want the results sorted in Ascending or Descending order.
    public var sortOrder: SageMakerGeospatialClientTypes.SortOrder?
    /// A filter that retrieves only jobs with a specific status.
    public var statusEquals: SageMakerGeospatialClientTypes.EarthObservationJobStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: SageMakerGeospatialClientTypes.SortOrder? = nil,
        statusEquals: SageMakerGeospatialClientTypes.EarthObservationJobStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

struct ListEarthObservationJobsInputBody: Swift.Equatable {
    let statusEquals: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
    let sortOrder: SageMakerGeospatialClientTypes.SortOrder?
    let sortBy: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEarthObservationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
        case statusEquals = "StatusEquals"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusEqualsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobStatus.self, forKey: .statusEquals)
        statusEquals = statusEqualsDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEarthObservationJobsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEarthObservationJobsOutput(earthObservationJobSummaries: \(Swift.String(describing: earthObservationJobSummaries)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListEarthObservationJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEarthObservationJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.earthObservationJobSummaries = output.earthObservationJobSummaries
            self.nextToken = output.nextToken
        } else {
            self.earthObservationJobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListEarthObservationJobsOutput: Swift.Equatable {
    /// Contains summary information about the Earth Observation jobs.
    /// This member is required.
    public var earthObservationJobSummaries: [SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig]?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        earthObservationJobSummaries: [SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.earthObservationJobSummaries = earthObservationJobSummaries
        self.nextToken = nextToken
    }
}

struct ListEarthObservationJobsOutputBody: Swift.Equatable {
    let earthObservationJobSummaries: [SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig]?
    let nextToken: Swift.String?
}

extension ListEarthObservationJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case earthObservationJobSummaries = "EarthObservationJobSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let earthObservationJobSummariesContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig?].self, forKey: .earthObservationJobSummaries)
        var earthObservationJobSummariesDecoded0:[SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig]? = nil
        if let earthObservationJobSummariesContainer = earthObservationJobSummariesContainer {
            earthObservationJobSummariesDecoded0 = [SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig]()
            for structure0 in earthObservationJobSummariesContainer {
                if let structure0 = structure0 {
                    earthObservationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        earthObservationJobSummaries = earthObservationJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEarthObservationJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRasterDataCollectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRasterDataCollectionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListRasterDataCollectionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRasterDataCollectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/raster-data-collections"
    }
}

public struct ListRasterDataCollectionsInput: Swift.Equatable {
    /// The total number of items to return.
    public var maxResults: Swift.Int?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRasterDataCollectionsInputBody: Swift.Equatable {
}

extension ListRasterDataCollectionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRasterDataCollectionsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRasterDataCollectionsOutput(rasterDataCollectionSummaries: \(Swift.String(describing: rasterDataCollectionSummaries)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListRasterDataCollectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRasterDataCollectionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rasterDataCollectionSummaries = output.rasterDataCollectionSummaries
        } else {
            self.nextToken = nil
            self.rasterDataCollectionSummaries = nil
        }
    }
}

public struct ListRasterDataCollectionsOutput: Swift.Equatable {
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?
    /// Contains summary information about the raster data collection.
    /// This member is required.
    public var rasterDataCollectionSummaries: [SageMakerGeospatialClientTypes.RasterDataCollectionMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        rasterDataCollectionSummaries: [SageMakerGeospatialClientTypes.RasterDataCollectionMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.rasterDataCollectionSummaries = rasterDataCollectionSummaries
    }
}

struct ListRasterDataCollectionsOutputBody: Swift.Equatable {
    let rasterDataCollectionSummaries: [SageMakerGeospatialClientTypes.RasterDataCollectionMetadata]?
    let nextToken: Swift.String?
}

extension ListRasterDataCollectionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rasterDataCollectionSummaries = "RasterDataCollectionSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rasterDataCollectionSummariesContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.RasterDataCollectionMetadata?].self, forKey: .rasterDataCollectionSummaries)
        var rasterDataCollectionSummariesDecoded0:[SageMakerGeospatialClientTypes.RasterDataCollectionMetadata]? = nil
        if let rasterDataCollectionSummariesContainer = rasterDataCollectionSummariesContainer {
            rasterDataCollectionSummariesDecoded0 = [SageMakerGeospatialClientTypes.RasterDataCollectionMetadata]()
            for structure0 in rasterDataCollectionSummariesContainer {
                if let structure0 = structure0 {
                    rasterDataCollectionSummariesDecoded0?.append(structure0)
                }
            }
        }
        rasterDataCollectionSummaries = rasterDataCollectionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRasterDataCollectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobType.self, forKey: .type)
        type = typeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// An object containing information about the output file.
    public struct ListVectorEnrichmentJobOutputConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the list of the Vector Enrichment jobs.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The duration of the session, in seconds.
        /// This member is required.
        public var durationInSeconds: Swift.Int?
        /// The names of the Vector Enrichment jobs in the list.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the Vector Enrichment jobs list.
        /// This member is required.
        public var status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus?
        /// Each tag consists of a key and a value.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the list of Vector Enrichment jobs.
        /// This member is required.
        public var type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            durationInSeconds: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension ListVectorEnrichmentJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVectorEnrichmentJobsInput(maxResults: \(Swift.String(describing: maxResults)), sortBy: \(Swift.String(describing: sortBy)), sortOrder: \(Swift.String(describing: sortOrder)), statusEquals: \(Swift.String(describing: statusEquals)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListVectorEnrichmentJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
        case statusEquals = "StatusEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let statusEquals = self.statusEquals {
            try encodeContainer.encode(statusEquals, forKey: .statusEquals)
        }
    }
}

extension ListVectorEnrichmentJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-vector-enrichment-jobs"
    }
}

public struct ListVectorEnrichmentJobsInput: Swift.Equatable {
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?
    /// The parameter by which to sort the results.
    public var sortBy: Swift.String?
    /// An optional value that specifies whether you want the results sorted in Ascending or Descending order.
    public var sortOrder: SageMakerGeospatialClientTypes.SortOrder?
    /// A filter that retrieves only jobs with a specific status.
    public var statusEquals: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: SageMakerGeospatialClientTypes.SortOrder? = nil,
        statusEquals: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

struct ListVectorEnrichmentJobsInputBody: Swift.Equatable {
    let statusEquals: Swift.String?
    let sortOrder: SageMakerGeospatialClientTypes.SortOrder?
    let sortBy: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListVectorEnrichmentJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
        case statusEquals = "StatusEquals"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusEqualsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusEquals)
        statusEquals = statusEqualsDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListVectorEnrichmentJobsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVectorEnrichmentJobsOutput(vectorEnrichmentJobSummaries: \(Swift.String(describing: vectorEnrichmentJobSummaries)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListVectorEnrichmentJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVectorEnrichmentJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vectorEnrichmentJobSummaries = output.vectorEnrichmentJobSummaries
        } else {
            self.nextToken = nil
            self.vectorEnrichmentJobSummaries = nil
        }
    }
}

public struct ListVectorEnrichmentJobsOutput: Swift.Equatable {
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?
    /// Contains summary information about the Vector Enrichment jobs.
    /// This member is required.
    public var vectorEnrichmentJobSummaries: [SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig]?

    public init(
        nextToken: Swift.String? = nil,
        vectorEnrichmentJobSummaries: [SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.vectorEnrichmentJobSummaries = vectorEnrichmentJobSummaries
    }
}

struct ListVectorEnrichmentJobsOutputBody: Swift.Equatable {
    let vectorEnrichmentJobSummaries: [SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig]?
    let nextToken: Swift.String?
}

extension ListVectorEnrichmentJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case vectorEnrichmentJobSummaries = "VectorEnrichmentJobSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorEnrichmentJobSummariesContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig?].self, forKey: .vectorEnrichmentJobSummaries)
        var vectorEnrichmentJobSummariesDecoded0:[SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig]? = nil
        if let vectorEnrichmentJobSummariesContainer = vectorEnrichmentJobSummariesContainer {
            vectorEnrichmentJobSummariesDecoded0 = [SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig]()
            for structure0 in vectorEnrichmentJobSummariesContainer {
                if let structure0 = structure0 {
                    vectorEnrichmentJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        vectorEnrichmentJobSummaries = vectorEnrichmentJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVectorEnrichmentJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum LogicalOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// AND
        case and
        case sdkUnknown(Swift.String)

        public static var allCases: [LogicalOperator] {
            return [
                .and,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogicalOperator(rawValue: rawValue) ?? LogicalOperator.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.MapMatchingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idAttributeName = "IdAttributeName"
        case timestampAttributeName = "TimestampAttributeName"
        case xAttributeName = "XAttributeName"
        case yAttributeName = "YAttributeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idAttributeName = self.idAttributeName {
            try encodeContainer.encode(idAttributeName, forKey: .idAttributeName)
        }
        if let timestampAttributeName = self.timestampAttributeName {
            try encodeContainer.encode(timestampAttributeName, forKey: .timestampAttributeName)
        }
        if let xAttributeName = self.xAttributeName {
            try encodeContainer.encode(xAttributeName, forKey: .xAttributeName)
        }
        if let yAttributeName = self.yAttributeName {
            try encodeContainer.encode(yAttributeName, forKey: .yAttributeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idAttributeName)
        idAttributeName = idAttributeNameDecoded
        let yAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .yAttributeName)
        yAttributeName = yAttributeNameDecoded
        let xAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xAttributeName)
        xAttributeName = xAttributeNameDecoded
        let timestampAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampAttributeName)
        timestampAttributeName = timestampAttributeNameDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for Map Matching operation type.
    public struct MapMatchingConfig: Swift.Equatable {
        /// The field name for the data that describes the identifier representing a collection of GPS points belonging to an individual trace.
        /// This member is required.
        public var idAttributeName: Swift.String?
        /// The name of the timestamp attribute.
        /// This member is required.
        public var timestampAttributeName: Swift.String?
        /// The name of the X-attribute
        /// This member is required.
        public var xAttributeName: Swift.String?
        /// The name of the Y-attribute
        /// This member is required.
        public var yAttributeName: Swift.String?

        public init(
            idAttributeName: Swift.String? = nil,
            timestampAttributeName: Swift.String? = nil,
            xAttributeName: Swift.String? = nil,
            yAttributeName: Swift.String? = nil
        )
        {
            self.idAttributeName = idAttributeName
            self.timestampAttributeName = timestampAttributeName
            self.xAttributeName = xAttributeName
            self.yAttributeName = yAttributeName
        }
    }

}

extension SageMakerGeospatialClientTypes.MultiPolygonGeometryInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coordinates = "Coordinates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coordinates = coordinates {
            var coordinatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .coordinates)
            for linearrings0 in coordinates {
                var linearrings0Container = coordinatesContainer.nestedUnkeyedContainer()
                for linearring1 in linearrings0 {
                    var linearring1Container = linearrings0Container.nestedUnkeyedContainer()
                    for position2 in linearring1 {
                        var position2Container = linearring1Container.nestedUnkeyedContainer()
                        for double3 in position2 {
                            try position2Container.encode(double3)
                        }
                    }
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coordinatesContainer = try containerValues.decodeIfPresent([[[[Swift.Double?]?]?]?].self, forKey: .coordinates)
        var coordinatesDecoded0:[[[[Swift.Double]]]]? = nil
        if let coordinatesContainer = coordinatesContainer {
            coordinatesDecoded0 = [[[[Swift.Double]]]]()
            for list0 in coordinatesContainer {
                var list0Decoded0: [[[Swift.Double]]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[[Swift.Double]]]()
                    for list1 in list0 {
                        var list1Decoded1: [[Swift.Double]]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [[Swift.Double]]()
                            for list2 in list1 {
                                var list2Decoded2: [Swift.Double]? = nil
                                if let list2 = list2 {
                                    list2Decoded2 = [Swift.Double]()
                                    for double3 in list2 {
                                        if let double3 = double3 {
                                            list2Decoded2?.append(double3)
                                        }
                                    }
                                }
                                if let list2Decoded2 = list2Decoded2 {
                                    list1Decoded1?.append(list2Decoded2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            list0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    coordinatesDecoded0?.append(list0Decoded0)
                }
            }
        }
        coordinates = coordinatesDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing Polygon Geometry based on the [GeoJson spec](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.6).
    public struct MultiPolygonGeometryInput: Swift.Equatable {
        /// The coordinates of the multipolygon geometry.
        /// This member is required.
        public var coordinates: [[[[Swift.Double]]]]?

        public init(
            coordinates: [[[[Swift.Double]]]]? = nil
        )
        {
            self.coordinates = coordinates
        }
    }

}

extension SageMakerGeospatialClientTypes.Operation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case equation = "Equation"
        case name = "Name"
        case outputType = "OutputType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let equation = self.equation {
            try encodeContainer.encode(equation, forKey: .equation)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputType = self.outputType {
            try encodeContainer.encode(outputType.rawValue, forKey: .outputType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let equationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .equation)
        equation = equationDecoded
        let outputTypeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputType.self, forKey: .outputType)
        outputType = outputTypeDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// Represents an arithmetic operation to compute spectral index.
    public struct Operation: Swift.Equatable {
        /// Textual representation of the math operation; Equation used to compute the spectral index.
        /// This member is required.
        public var equation: Swift.String?
        /// The name of the operation.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the operation.
        public var outputType: SageMakerGeospatialClientTypes.OutputType?

        public init(
            equation: Swift.String? = nil,
            name: Swift.String? = nil,
            outputType: SageMakerGeospatialClientTypes.OutputType? = nil
        )
        {
            self.equation = equation
            self.name = name
            self.outputType = outputType
        }
    }

}

extension SageMakerGeospatialClientTypes.OutputBand: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandName = "BandName"
        case outputDataType = "OutputDataType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandName = self.bandName {
            try encodeContainer.encode(bandName, forKey: .bandName)
        }
        if let outputDataType = self.outputDataType {
            try encodeContainer.encode(outputDataType.rawValue, forKey: .outputDataType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bandNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandName)
        bandName = bandNameDecoded
        let outputDataTypeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputType.self, forKey: .outputDataType)
        outputDataType = outputDataTypeDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// A single EarthObservationJob output band.
    public struct OutputBand: Swift.Equatable {
        /// The name of the band.
        /// This member is required.
        public var bandName: Swift.String?
        /// The datatype of the output band.
        /// This member is required.
        public var outputDataType: SageMakerGeospatialClientTypes.OutputType?

        public init(
            bandName: Swift.String? = nil,
            outputDataType: SageMakerGeospatialClientTypes.OutputType? = nil
        )
        {
            self.bandName = bandName
            self.outputDataType = outputDataType
        }
    }

}

extension SageMakerGeospatialClientTypes.OutputConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Data = "S3Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Data = self.s3Data {
            try encodeContainer.encode(s3Data, forKey: .s3Data)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportS3DataInput.self, forKey: .s3Data)
        s3Data = s3DataDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The response structure for an OutputConfig returned by an ExportEarthObservationJob.
    public struct OutputConfigInput: Swift.Equatable {
        /// Path to Amazon S3 storage location for the output configuration file.
        /// This member is required.
        public var s3Data: SageMakerGeospatialClientTypes.ExportS3DataInput?

        public init(
            s3Data: SageMakerGeospatialClientTypes.ExportS3DataInput? = nil
        )
        {
            self.s3Data = s3Data
        }
    }

}

extension SageMakerGeospatialClientTypes.OutputResolutionResamplingInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userDefined = "UserDefined"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userDefined = self.userDefined {
            try encodeContainer.encode(userDefined, forKey: .userDefined)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDefinedDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.UserDefined.self, forKey: .userDefined)
        userDefined = userDefinedDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// OutputResolution Configuration indicating the target resolution for the output of Resampling operation.
    public struct OutputResolutionResamplingInput: Swift.Equatable {
        /// User Defined Resolution for the output of Resampling operation defined by value and unit.
        /// This member is required.
        public var userDefined: SageMakerGeospatialClientTypes.UserDefined?

        public init(
            userDefined: SageMakerGeospatialClientTypes.UserDefined? = nil
        )
        {
            self.userDefined = userDefined
        }
    }

}

extension SageMakerGeospatialClientTypes.OutputResolutionStackInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predefined = "Predefined"
        case userDefined = "UserDefined"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predefined = self.predefined {
            try encodeContainer.encode(predefined.rawValue, forKey: .predefined)
        }
        if let userDefined = self.userDefined {
            try encodeContainer.encode(userDefined, forKey: .userDefined)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predefinedDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.PredefinedResolution.self, forKey: .predefined)
        predefined = predefinedDecoded
        let userDefinedDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.UserDefined.self, forKey: .userDefined)
        userDefined = userDefinedDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure representing Output Resolution for Stacking Operation.
    public struct OutputResolutionStackInput: Swift.Equatable {
        /// A string value representing Predefined Output Resolution for a stacking operation. Allowed values are HIGHEST, LOWEST, and AVERAGE.
        public var predefined: SageMakerGeospatialClientTypes.PredefinedResolution?
        /// The structure representing User Output Resolution for a Stacking operation defined as a value and unit.
        public var userDefined: SageMakerGeospatialClientTypes.UserDefined?

        public init(
            predefined: SageMakerGeospatialClientTypes.PredefinedResolution? = nil,
            userDefined: SageMakerGeospatialClientTypes.UserDefined? = nil
        )
        {
            self.predefined = predefined
            self.userDefined = userDefined
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum OutputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// FLOAT32
        case float32
        /// FLOAT64
        case float64
        /// INT16
        case int16
        /// INT32
        case int32
        /// UINT16
        case uint16
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputType] {
            return [
                .float32,
                .float64,
                .int16,
                .int32,
                .uint16,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .float32: return "FLOAT32"
            case .float64: return "FLOAT64"
            case .int16: return "INT16"
            case .int32: return "INT32"
            case .uint16: return "UINT16"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputType(rawValue: rawValue) ?? OutputType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.PlatformInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for specifying Platform. Platform refers to the unique name of the specific platform the instrument is attached to. For satellites it is the name of the satellite, eg. landsat-8 (Landsat-8), sentinel-2a.
    public struct PlatformInput: Swift.Equatable {
        /// The ComparisonOperator to use with PlatformInput.
        public var comparisonOperator: SageMakerGeospatialClientTypes.ComparisonOperator?
        /// The value of the platform.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparisonOperator: SageMakerGeospatialClientTypes.ComparisonOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.value = value
        }
    }

}

extension SageMakerGeospatialClientTypes.PolygonGeometryInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coordinates = "Coordinates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coordinates = coordinates {
            var coordinatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .coordinates)
            for linearring0 in coordinates {
                var linearring0Container = coordinatesContainer.nestedUnkeyedContainer()
                for position1 in linearring0 {
                    var position1Container = linearring0Container.nestedUnkeyedContainer()
                    for double2 in position1 {
                        try position1Container.encode(double2)
                    }
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coordinatesContainer = try containerValues.decodeIfPresent([[[Swift.Double?]?]?].self, forKey: .coordinates)
        var coordinatesDecoded0:[[[Swift.Double]]]? = nil
        if let coordinatesContainer = coordinatesContainer {
            coordinatesDecoded0 = [[[Swift.Double]]]()
            for list0 in coordinatesContainer {
                var list0Decoded0: [[Swift.Double]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.Double]]()
                    for list1 in list0 {
                        var list1Decoded1: [Swift.Double]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Double]()
                            for double2 in list1 {
                                if let double2 = double2 {
                                    list1Decoded1?.append(double2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            list0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    coordinatesDecoded0?.append(list0Decoded0)
                }
            }
        }
        coordinates = coordinatesDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing Polygon Geometry based on the [GeoJson spec](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.6).
    public struct PolygonGeometryInput: Swift.Equatable {
        /// Coordinates representing a Polygon based on the [GeoJson spec](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.6).
        /// This member is required.
        public var coordinates: [[[Swift.Double]]]?

        public init(
            coordinates: [[[Swift.Double]]]? = nil
        )
        {
            self.coordinates = coordinates
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum PredefinedResolution: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// AVERAGE
        case average
        /// HIGHEST
        case highest
        /// LOWEST
        case lowest
        case sdkUnknown(Swift.String)

        public static var allCases: [PredefinedResolution] {
            return [
                .average,
                .highest,
                .lowest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .highest: return "HIGHEST"
            case .lowest: return "LOWEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PredefinedResolution(rawValue: rawValue) ?? PredefinedResolution.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.Properties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eoCloudCover = "EoCloudCover"
        case landsatCloudCoverLand = "LandsatCloudCoverLand"
        case platform = "Platform"
        case viewOffNadir = "ViewOffNadir"
        case viewSunAzimuth = "ViewSunAzimuth"
        case viewSunElevation = "ViewSunElevation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eoCloudCover = self.eoCloudCover {
            try encodeContainer.encode(eoCloudCover, forKey: .eoCloudCover)
        }
        if let landsatCloudCoverLand = self.landsatCloudCoverLand {
            try encodeContainer.encode(landsatCloudCoverLand, forKey: .landsatCloudCoverLand)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let viewOffNadir = self.viewOffNadir {
            try encodeContainer.encode(viewOffNadir, forKey: .viewOffNadir)
        }
        if let viewSunAzimuth = self.viewSunAzimuth {
            try encodeContainer.encode(viewSunAzimuth, forKey: .viewSunAzimuth)
        }
        if let viewSunElevation = self.viewSunElevation {
            try encodeContainer.encode(viewSunElevation, forKey: .viewSunElevation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eoCloudCoverDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .eoCloudCover)
        eoCloudCover = eoCloudCoverDecoded
        let viewOffNadirDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .viewOffNadir)
        viewOffNadir = viewOffNadirDecoded
        let viewSunAzimuthDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .viewSunAzimuth)
        viewSunAzimuth = viewSunAzimuthDecoded
        let viewSunElevationDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .viewSunElevation)
        viewSunElevation = viewSunElevationDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let landsatCloudCoverLandDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .landsatCloudCoverLand)
        landsatCloudCoverLand = landsatCloudCoverLandDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// Properties associated with the Item.
    public struct Properties: Swift.Equatable {
        /// Estimate of cloud cover.
        public var eoCloudCover: Swift.Float?
        /// Land cloud cover for Landsat Data Collection.
        public var landsatCloudCoverLand: Swift.Float?
        /// Platform property. Platform refers to the unique name of the specific platform the instrument is attached to. For satellites it is the name of the satellite, eg. landsat-8 (Landsat-8), sentinel-2a.
        public var platform: Swift.String?
        /// The angle from the sensor between nadir (straight down) and the scene center. Measured in degrees (0-90).
        public var viewOffNadir: Swift.Float?
        /// The sun azimuth angle. From the scene center point on the ground, this is the angle between truth north and the sun. Measured clockwise in degrees (0-360).
        public var viewSunAzimuth: Swift.Float?
        /// The sun elevation angle. The angle from the tangent of the scene center point to the sun. Measured from the horizon in degrees (-90-90). Negative values indicate the sun is below the horizon, e.g. sun elevation of -10 means the data was captured during [nautical twilight](https://www.timeanddate.com/astronomy/different-types-twilight.html).
        public var viewSunElevation: Swift.Float?

        public init(
            eoCloudCover: Swift.Float? = nil,
            landsatCloudCoverLand: Swift.Float? = nil,
            platform: Swift.String? = nil,
            viewOffNadir: Swift.Float? = nil,
            viewSunAzimuth: Swift.Float? = nil,
            viewSunElevation: Swift.Float? = nil
        )
        {
            self.eoCloudCover = eoCloudCover
            self.landsatCloudCoverLand = landsatCloudCoverLand
            self.platform = platform
            self.viewOffNadir = viewOffNadir
            self.viewSunAzimuth = viewSunAzimuth
            self.viewSunElevation = viewSunElevation
        }
    }

}

extension SageMakerGeospatialClientTypes.Property: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eocloudcover = "EoCloudCover"
        case landsatcloudcoverland = "LandsatCloudCoverLand"
        case platform = "Platform"
        case viewoffnadir = "ViewOffNadir"
        case viewsunazimuth = "ViewSunAzimuth"
        case viewsunelevation = "ViewSunElevation"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .eocloudcover(eocloudcover):
                try container.encode(eocloudcover, forKey: .eocloudcover)
            case let .landsatcloudcoverland(landsatcloudcoverland):
                try container.encode(landsatcloudcoverland, forKey: .landsatcloudcoverland)
            case let .platform(platform):
                try container.encode(platform, forKey: .platform)
            case let .viewoffnadir(viewoffnadir):
                try container.encode(viewoffnadir, forKey: .viewoffnadir)
            case let .viewsunazimuth(viewsunazimuth):
                try container.encode(viewsunazimuth, forKey: .viewsunazimuth)
            case let .viewsunelevation(viewsunelevation):
                try container.encode(viewsunelevation, forKey: .viewsunelevation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let eocloudcoverDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.EoCloudCoverInput.self, forKey: .eocloudcover)
        if let eocloudcover = eocloudcoverDecoded {
            self = .eocloudcover(eocloudcover)
            return
        }
        let viewoffnadirDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ViewOffNadirInput.self, forKey: .viewoffnadir)
        if let viewoffnadir = viewoffnadirDecoded {
            self = .viewoffnadir(viewoffnadir)
            return
        }
        let viewsunazimuthDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ViewSunAzimuthInput.self, forKey: .viewsunazimuth)
        if let viewsunazimuth = viewsunazimuthDecoded {
            self = .viewsunazimuth(viewsunazimuth)
            return
        }
        let viewsunelevationDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ViewSunElevationInput.self, forKey: .viewsunelevation)
        if let viewsunelevation = viewsunelevationDecoded {
            self = .viewsunelevation(viewsunelevation)
            return
        }
        let platformDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.PlatformInput.self, forKey: .platform)
        if let platform = platformDecoded {
            self = .platform(platform)
            return
        }
        let landsatcloudcoverlandDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.LandsatCloudCoverLandInput.self, forKey: .landsatcloudcoverland)
        if let landsatcloudcoverland = landsatcloudcoverlandDecoded {
            self = .landsatcloudcoverland(landsatcloudcoverland)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    /// Represents a single searchable property to search on.
    public enum Property: Swift.Equatable {
        /// The structure representing EoCloudCover property filter containing a lower bound and upper bound.
        case eocloudcover(SageMakerGeospatialClientTypes.EoCloudCoverInput)
        /// The structure representing ViewOffNadir property filter containing a lower bound and upper bound.
        case viewoffnadir(SageMakerGeospatialClientTypes.ViewOffNadirInput)
        /// The structure representing ViewSunAzimuth property filter containing a lower bound and upper bound.
        case viewsunazimuth(SageMakerGeospatialClientTypes.ViewSunAzimuthInput)
        /// The structure representing ViewSunElevation property filter containing a lower bound and upper bound.
        case viewsunelevation(SageMakerGeospatialClientTypes.ViewSunElevationInput)
        /// The structure representing Platform property filter consisting of value and comparison operator.
        case platform(SageMakerGeospatialClientTypes.PlatformInput)
        /// The structure representing Land Cloud Cover property filter for Landsat collection containing a lower bound and upper bound.
        case landsatcloudcoverland(SageMakerGeospatialClientTypes.LandsatCloudCoverLandInput)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes.PropertyFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case property = "Property"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.Property.self, forKey: .property)
        property = propertyDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing a single PropertyFilter.
    public struct PropertyFilter: Swift.Equatable {
        /// Represents a single property to match with when searching a raster data collection.
        /// This member is required.
        public var property: SageMakerGeospatialClientTypes.Property?

        public init(
            property: SageMakerGeospatialClientTypes.Property? = nil
        )
        {
            self.property = property
        }
    }

}

extension SageMakerGeospatialClientTypes.PropertyFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logicalOperator = "LogicalOperator"
        case properties = "Properties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logicalOperator = self.logicalOperator {
            try encodeContainer.encode(logicalOperator.rawValue, forKey: .logicalOperator)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for propertyfilter0 in properties {
                try propertiesContainer.encode(propertyfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertiesContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.PropertyFilter?].self, forKey: .properties)
        var propertiesDecoded0:[SageMakerGeospatialClientTypes.PropertyFilter]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [SageMakerGeospatialClientTypes.PropertyFilter]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
        let logicalOperatorDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.LogicalOperator.self, forKey: .logicalOperator)
        logicalOperator = logicalOperatorDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// A list of PropertyFilter objects.
    public struct PropertyFilters: Swift.Equatable {
        /// The Logical Operator used to combine the Property Filters.
        public var logicalOperator: SageMakerGeospatialClientTypes.LogicalOperator?
        /// A list of Property Filters.
        public var properties: [SageMakerGeospatialClientTypes.PropertyFilter]?

        public init(
            logicalOperator: SageMakerGeospatialClientTypes.LogicalOperator? = nil,
            properties: [SageMakerGeospatialClientTypes.PropertyFilter]? = nil
        )
        {
            self.logicalOperator = logicalOperator
            self.properties = properties
        }
    }

}

extension SageMakerGeospatialClientTypes.RasterDataCollectionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case descriptionPageUrl = "DescriptionPageUrl"
        case name = "Name"
        case supportedFilters = "SupportedFilters"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let descriptionPageUrl = self.descriptionPageUrl {
            try encodeContainer.encode(descriptionPageUrl, forKey: .descriptionPageUrl)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let supportedFilters = supportedFilters {
            var supportedFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedFilters)
            for filter0 in supportedFilters {
                try supportedFiltersContainer.encode(filter0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.DataCollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let descriptionPageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .descriptionPageUrl)
        descriptionPageUrl = descriptionPageUrlDecoded
        let supportedFiltersContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.Filter?].self, forKey: .supportedFilters)
        var supportedFiltersDecoded0:[SageMakerGeospatialClientTypes.Filter]? = nil
        if let supportedFiltersContainer = supportedFiltersContainer {
            supportedFiltersDecoded0 = [SageMakerGeospatialClientTypes.Filter]()
            for structure0 in supportedFiltersContainer {
                if let structure0 = structure0 {
                    supportedFiltersDecoded0?.append(structure0)
                }
            }
        }
        supportedFilters = supportedFiltersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// Response object containing details for a specific RasterDataCollection.
    public struct RasterDataCollectionMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the raster data collection.
        /// This member is required.
        public var arn: Swift.String?
        /// A description of the raster data collection.
        /// This member is required.
        public var description: Swift.String?
        /// The description URL of the raster data collection.
        public var descriptionPageUrl: Swift.String?
        /// The name of the raster data collection.
        /// This member is required.
        public var name: Swift.String?
        /// The list of filters supported by the raster data collection.
        /// This member is required.
        public var supportedFilters: [SageMakerGeospatialClientTypes.Filter]?
        /// Each tag consists of a key and a value.
        public var tags: [Swift.String:Swift.String]?
        /// The type of raster data collection.
        /// This member is required.
        public var type: SageMakerGeospatialClientTypes.DataCollectionType?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            descriptionPageUrl: Swift.String? = nil,
            name: Swift.String? = nil,
            supportedFilters: [SageMakerGeospatialClientTypes.Filter]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: SageMakerGeospatialClientTypes.DataCollectionType? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.descriptionPageUrl = descriptionPageUrl
            self.name = name
            self.supportedFilters = supportedFilters
            self.tags = tags
            self.type = type
        }
    }

}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaOfInterest = "AreaOfInterest"
        case propertyFilters = "PropertyFilters"
        case rasterDataCollectionArn = "RasterDataCollectionArn"
        case timeRangeFilter = "TimeRangeFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaOfInterest = self.areaOfInterest {
            try encodeContainer.encode(areaOfInterest, forKey: .areaOfInterest)
        }
        if let propertyFilters = self.propertyFilters {
            try encodeContainer.encode(propertyFilters, forKey: .propertyFilters)
        }
        if let rasterDataCollectionArn = self.rasterDataCollectionArn {
            try encodeContainer.encode(rasterDataCollectionArn, forKey: .rasterDataCollectionArn)
        }
        if let timeRangeFilter = self.timeRangeFilter {
            try encodeContainer.encode(timeRangeFilter, forKey: .timeRangeFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rasterDataCollectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rasterDataCollectionArn)
        rasterDataCollectionArn = rasterDataCollectionArnDecoded
        let timeRangeFilterDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.TimeRangeFilterInput.self, forKey: .timeRangeFilter)
        timeRangeFilter = timeRangeFilterDecoded
        let areaOfInterestDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AreaOfInterest.self, forKey: .areaOfInterest)
        areaOfInterest = areaOfInterestDecoded
        let propertyFiltersDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.PropertyFilters.self, forKey: .propertyFilters)
        propertyFilters = propertyFiltersDecoded
    }
}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RasterDataCollectionQueryInput(areaOfInterest: \(Swift.String(describing: areaOfInterest)), propertyFilters: \(Swift.String(describing: propertyFilters)), rasterDataCollectionArn: \(Swift.String(describing: rasterDataCollectionArn)), timeRangeFilter: \"CONTENT_REDACTED\")"}
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for Raster Data Collection Query containing the Area of Interest, TimeRange Filters, and Property Filters.
    public struct RasterDataCollectionQueryInput: Swift.Equatable {
        /// The area of interest being queried for the raster data collection.
        public var areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest?
        /// The list of Property filters used in the Raster Data Collection Query.
        public var propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters?
        /// The Amazon Resource Name (ARN) of the raster data collection.
        /// This member is required.
        public var rasterDataCollectionArn: Swift.String?
        /// The TimeRange Filter used in the RasterDataCollection Query.
        /// This member is required.
        public var timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterInput?

        public init(
            areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest? = nil,
            propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters? = nil,
            rasterDataCollectionArn: Swift.String? = nil,
            timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterInput? = nil
        )
        {
            self.areaOfInterest = areaOfInterest
            self.propertyFilters = propertyFilters
            self.rasterDataCollectionArn = rasterDataCollectionArn
            self.timeRangeFilter = timeRangeFilter
        }
    }

}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaOfInterest = "AreaOfInterest"
        case propertyFilters = "PropertyFilters"
        case rasterDataCollectionArn = "RasterDataCollectionArn"
        case rasterDataCollectionName = "RasterDataCollectionName"
        case timeRangeFilter = "TimeRangeFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaOfInterest = self.areaOfInterest {
            try encodeContainer.encode(areaOfInterest, forKey: .areaOfInterest)
        }
        if let propertyFilters = self.propertyFilters {
            try encodeContainer.encode(propertyFilters, forKey: .propertyFilters)
        }
        if let rasterDataCollectionArn = self.rasterDataCollectionArn {
            try encodeContainer.encode(rasterDataCollectionArn, forKey: .rasterDataCollectionArn)
        }
        if let rasterDataCollectionName = self.rasterDataCollectionName {
            try encodeContainer.encode(rasterDataCollectionName, forKey: .rasterDataCollectionName)
        }
        if let timeRangeFilter = self.timeRangeFilter {
            try encodeContainer.encode(timeRangeFilter, forKey: .timeRangeFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rasterDataCollectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rasterDataCollectionArn)
        rasterDataCollectionArn = rasterDataCollectionArnDecoded
        let rasterDataCollectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rasterDataCollectionName)
        rasterDataCollectionName = rasterDataCollectionNameDecoded
        let timeRangeFilterDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.TimeRangeFilterOutput.self, forKey: .timeRangeFilter)
        timeRangeFilter = timeRangeFilterDecoded
        let areaOfInterestDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AreaOfInterest.self, forKey: .areaOfInterest)
        areaOfInterest = areaOfInterestDecoded
        let propertyFiltersDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.PropertyFilters.self, forKey: .propertyFilters)
        propertyFilters = propertyFiltersDecoded
    }
}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RasterDataCollectionQueryOutput(areaOfInterest: \(Swift.String(describing: areaOfInterest)), propertyFilters: \(Swift.String(describing: propertyFilters)), rasterDataCollectionArn: \(Swift.String(describing: rasterDataCollectionArn)), rasterDataCollectionName: \(Swift.String(describing: rasterDataCollectionName)), timeRangeFilter: \"CONTENT_REDACTED\")"}
}

extension SageMakerGeospatialClientTypes {
    /// The output structure contains the Raster Data Collection Query input along with some additional metadata.
    public struct RasterDataCollectionQueryOutput: Swift.Equatable {
        /// The Area of Interest used in the search.
        public var areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest?
        /// Property filters used in the search.
        public var propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters?
        /// The ARN of the Raster Data Collection against which the search is done.
        /// This member is required.
        public var rasterDataCollectionArn: Swift.String?
        /// The name of the raster data collection.
        /// This member is required.
        public var rasterDataCollectionName: Swift.String?
        /// The TimeRange filter used in the search.
        /// This member is required.
        public var timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterOutput?

        public init(
            areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest? = nil,
            propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters? = nil,
            rasterDataCollectionArn: Swift.String? = nil,
            rasterDataCollectionName: Swift.String? = nil,
            timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterOutput? = nil
        )
        {
            self.areaOfInterest = areaOfInterest
            self.propertyFilters = propertyFilters
            self.rasterDataCollectionArn = rasterDataCollectionArn
            self.rasterDataCollectionName = rasterDataCollectionName
            self.timeRangeFilter = timeRangeFilter
        }
    }

}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaOfInterest = "AreaOfInterest"
        case bandFilter = "BandFilter"
        case propertyFilters = "PropertyFilters"
        case timeRangeFilter = "TimeRangeFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaOfInterest = self.areaOfInterest {
            try encodeContainer.encode(areaOfInterest, forKey: .areaOfInterest)
        }
        if let bandFilter = bandFilter {
            var bandFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bandFilter)
            for string0 in bandFilter {
                try bandFilterContainer.encode(string0)
            }
        }
        if let propertyFilters = self.propertyFilters {
            try encodeContainer.encode(propertyFilters, forKey: .propertyFilters)
        }
        if let timeRangeFilter = self.timeRangeFilter {
            try encodeContainer.encode(timeRangeFilter, forKey: .timeRangeFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeRangeFilterDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.TimeRangeFilterInput.self, forKey: .timeRangeFilter)
        timeRangeFilter = timeRangeFilterDecoded
        let areaOfInterestDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AreaOfInterest.self, forKey: .areaOfInterest)
        areaOfInterest = areaOfInterestDecoded
        let propertyFiltersDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.PropertyFilters.self, forKey: .propertyFilters)
        propertyFilters = propertyFiltersDecoded
        let bandFilterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bandFilter)
        var bandFilterDecoded0:[Swift.String]? = nil
        if let bandFilterContainer = bandFilterContainer {
            bandFilterDecoded0 = [Swift.String]()
            for string0 in bandFilterContainer {
                if let string0 = string0 {
                    bandFilterDecoded0?.append(string0)
                }
            }
        }
        bandFilter = bandFilterDecoded0
    }
}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RasterDataCollectionQueryWithBandFilterInput(areaOfInterest: \(Swift.String(describing: areaOfInterest)), bandFilter: \(Swift.String(describing: bandFilter)), propertyFilters: \(Swift.String(describing: propertyFilters)), timeRangeFilter: \"CONTENT_REDACTED\")"}
}

extension SageMakerGeospatialClientTypes {
    /// This is a RasterDataCollectionQueryInput containing AreaOfInterest, Time Range filter and Property filters.
    public struct RasterDataCollectionQueryWithBandFilterInput: Swift.Equatable {
        /// The Area of interest to be used in the search query.
        public var areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest?
        /// The list of Bands to be displayed in the result for each item.
        public var bandFilter: [Swift.String]?
        /// The Property Filters used in the search query.
        public var propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters?
        /// The TimeRange Filter used in the search query.
        /// This member is required.
        public var timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterInput?

        public init(
            areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest? = nil,
            bandFilter: [Swift.String]? = nil,
            propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters? = nil,
            timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterInput? = nil
        )
        {
            self.areaOfInterest = areaOfInterest
            self.bandFilter = bandFilter
            self.propertyFilters = propertyFilters
            self.timeRangeFilter = timeRangeFilter
        }
    }

}

extension SageMakerGeospatialClientTypes.ResamplingConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmName = "AlgorithmName"
        case outputResolution = "OutputResolution"
        case targetBands = "TargetBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmName = self.algorithmName {
            try encodeContainer.encode(algorithmName.rawValue, forKey: .algorithmName)
        }
        if let outputResolution = self.outputResolution {
            try encodeContainer.encode(outputResolution, forKey: .outputResolution)
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputResolutionDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputResolutionResamplingInput.self, forKey: .outputResolution)
        outputResolution = outputResolutionDecoded
        let algorithmNameDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AlgorithmNameResampling.self, forKey: .algorithmName)
        algorithmName = algorithmNameDecoded
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing input for resampling operation.
    public struct ResamplingConfigInput: Swift.Equatable {
        /// The name of the algorithm used for resampling.
        public var algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameResampling?
        /// The structure representing output resolution (in target georeferenced units) of the result of resampling operation.
        /// This member is required.
        public var outputResolution: SageMakerGeospatialClientTypes.OutputResolutionResamplingInput?
        /// Bands used in the operation. If no target bands are specified, it uses all bands available in the input.
        public var targetBands: [Swift.String]?

        public init(
            algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameResampling? = nil,
            outputResolution: SageMakerGeospatialClientTypes.OutputResolutionResamplingInput? = nil,
            targetBands: [Swift.String]? = nil
        )
        {
            self.algorithmName = algorithmName
            self.outputResolution = outputResolution
            self.targetBands = targetBands
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource that was not found.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes.ReverseGeocodingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case xAttributeName = "XAttributeName"
        case yAttributeName = "YAttributeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let xAttributeName = self.xAttributeName {
            try encodeContainer.encode(xAttributeName, forKey: .xAttributeName)
        }
        if let yAttributeName = self.yAttributeName {
            try encodeContainer.encode(yAttributeName, forKey: .yAttributeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let yAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .yAttributeName)
        yAttributeName = yAttributeNameDecoded
        let xAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xAttributeName)
        xAttributeName = xAttributeNameDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for Reverse Geocoding operation type.
    public struct ReverseGeocodingConfig: Swift.Equatable {
        /// The field name for the data that describes x-axis coordinate, eg. longitude of a point.
        /// This member is required.
        public var xAttributeName: Swift.String?
        /// The field name for the data that describes y-axis coordinate, eg. latitude of a point.
        /// This member is required.
        public var yAttributeName: Swift.String?

        public init(
            xAttributeName: Swift.String? = nil,
            yAttributeName: Swift.String? = nil
        )
        {
            self.xAttributeName = xAttributeName
            self.yAttributeName = yAttributeName
        }
    }

}

extension SearchRasterDataCollectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchRasterDataCollectionInput(arn: \(Swift.String(describing: arn)), rasterDataCollectionQuery: \(Swift.String(describing: rasterDataCollectionQuery)), nextToken: \"CONTENT_REDACTED\")"}
}

extension SearchRasterDataCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case nextToken = "NextToken"
        case rasterDataCollectionQuery = "RasterDataCollectionQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rasterDataCollectionQuery = self.rasterDataCollectionQuery {
            try encodeContainer.encode(rasterDataCollectionQuery, forKey: .rasterDataCollectionQuery)
        }
    }
}

extension SearchRasterDataCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search-raster-data-collection"
    }
}

public struct SearchRasterDataCollectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the raster data collection.
    /// This member is required.
    public var arn: Swift.String?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?
    /// RasterDataCollectionQuery consisting of [AreaOfInterest(AOI)](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_geospatial_AreaOfInterest.html), [PropertyFilters](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_geospatial_PropertyFilter.html) and [TimeRangeFilterInput](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_geospatial_TimeRangeFilterInput.html) used in [SearchRasterDataCollection](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_geospatial_SearchRasterDataCollection.html).
    /// This member is required.
    public var rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.rasterDataCollectionQuery = rasterDataCollectionQuery
    }
}

struct SearchRasterDataCollectionInputBody: Swift.Equatable {
    let arn: Swift.String?
    let rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput?
    let nextToken: Swift.String?
}

extension SearchRasterDataCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case nextToken = "NextToken"
        case rasterDataCollectionQuery = "RasterDataCollectionQuery"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let rasterDataCollectionQueryDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput.self, forKey: .rasterDataCollectionQuery)
        rasterDataCollectionQuery = rasterDataCollectionQueryDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchRasterDataCollectionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchRasterDataCollectionOutput(approximateResultCount: \(Swift.String(describing: approximateResultCount)), items: \(Swift.String(describing: items)), nextToken: \"CONTENT_REDACTED\")"}
}

extension SearchRasterDataCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchRasterDataCollectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateResultCount = output.approximateResultCount
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.approximateResultCount = nil
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct SearchRasterDataCollectionOutput: Swift.Equatable {
    /// Approximate number of results in the response.
    /// This member is required.
    public var approximateResultCount: Swift.Int?
    /// List of items matching the Raster DataCollectionQuery.
    public var items: [SageMakerGeospatialClientTypes.ItemSource]?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        approximateResultCount: Swift.Int? = nil,
        items: [SageMakerGeospatialClientTypes.ItemSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approximateResultCount = approximateResultCount
        self.items = items
        self.nextToken = nextToken
    }
}

struct SearchRasterDataCollectionOutputBody: Swift.Equatable {
    let approximateResultCount: Swift.Int?
    let nextToken: Swift.String?
    let items: [SageMakerGeospatialClientTypes.ItemSource]?
}

extension SearchRasterDataCollectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateResultCount = "ApproximateResultCount"
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateResultCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateResultCount)
        approximateResultCount = approximateResultCountDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.ItemSource?].self, forKey: .items)
        var itemsDecoded0:[SageMakerGeospatialClientTypes.ItemSource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SageMakerGeospatialClientTypes.ItemSource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum SearchRasterDataCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded the service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// ASCENDING
        case ascending
        /// DESCENDING
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.StackConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputResolution = "OutputResolution"
        case targetBands = "TargetBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputResolution = self.outputResolution {
            try encodeContainer.encode(outputResolution, forKey: .outputResolution)
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputResolutionDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputResolutionStackInput.self, forKey: .outputResolution)
        outputResolution = outputResolutionDecoded
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for Stacking Operation.
    public struct StackConfigInput: Swift.Equatable {
        /// The structure representing output resolution (in target georeferenced units) of the result of stacking operation.
        public var outputResolution: SageMakerGeospatialClientTypes.OutputResolutionStackInput?
        /// A list of bands to be stacked in the specified order. When the parameter is not provided, all the available bands in the data collection are stacked in the alphabetical order of their asset names.
        public var targetBands: [Swift.String]?

        public init(
            outputResolution: SageMakerGeospatialClientTypes.OutputResolutionStackInput? = nil,
            targetBands: [Swift.String]? = nil
        )
        {
            self.outputResolution = outputResolution
            self.targetBands = targetBands
        }
    }

}

extension StartEarthObservationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let inputConfig = self.inputConfig {
            try encodeContainer.encode(inputConfig, forKey: .inputConfig)
        }
        if let jobConfig = self.jobConfig {
            try encodeContainer.encode(jobConfig, forKey: .jobConfig)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartEarthObservationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/earth-observation-jobs"
    }
}

public struct StartEarthObservationJobInput: Swift.Equatable {
    /// A unique token that guarantees that the call to this API is idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// Input configuration information for the Earth Observation job.
    /// This member is required.
    public var inputConfig: SageMakerGeospatialClientTypes.InputConfigInput?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    /// The Key Management Service key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Earth Observation job.
    /// This member is required.
    public var name: Swift.String?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        inputConfig: SageMakerGeospatialClientTypes.InputConfigInput? = nil,
        jobConfig: SageMakerGeospatialClientTypes.JobConfigInput? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.executionRoleArn = executionRoleArn
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.tags = tags
    }
}

struct StartEarthObservationJobInputBody: Swift.Equatable {
    let name: Swift.String?
    let clientToken: Swift.String?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.InputConfigInput?
    let jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    let executionRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartEarthObservationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.InputConfigInput.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.JobConfigInput.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartEarthObservationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartEarthObservationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.durationInSeconds = output.durationInSeconds
            self.executionRoleArn = output.executionRoleArn
            self.inputConfig = output.inputConfig
            self.jobConfig = output.jobConfig
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTime = nil
            self.durationInSeconds = nil
            self.executionRoleArn = nil
            self.inputConfig = nil
            self.jobConfig = nil
            self.kmsKeyId = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct StartEarthObservationJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Earth Observation job.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The duration of the session, in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// Input configuration information for the Earth Observation job.
    public var inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    /// The Key Management Service key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Earth Observation job.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the Earth Observation job.
    /// This member is required.
    public var status: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        durationInSeconds: Swift.Int? = nil,
        executionRoleArn: Swift.String? = nil,
        inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput? = nil,
        jobConfig: SageMakerGeospatialClientTypes.JobConfigInput? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: SageMakerGeospatialClientTypes.EarthObservationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.durationInSeconds = durationInSeconds
        self.executionRoleArn = executionRoleArn
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct StartEarthObservationJobOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let durationInSeconds: Swift.Int?
    let status: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput?
    let jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    let executionRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartEarthObservationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.InputConfigOutput.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.JobConfigInput.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum StartEarthObservationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartVectorEnrichmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let inputConfig = self.inputConfig {
            try encodeContainer.encode(inputConfig, forKey: .inputConfig)
        }
        if let jobConfig = self.jobConfig {
            try encodeContainer.encode(jobConfig, forKey: .jobConfig)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartVectorEnrichmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/vector-enrichment-jobs"
    }
}

public struct StartVectorEnrichmentJobInput: Swift.Equatable {
    /// A unique token that guarantees that the call to this API is idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// Input configuration information for the Vector Enrichment job.
    /// This member is required.
    public var inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    /// The Key Management Service key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Vector Enrichment job.
    /// This member is required.
    public var name: Swift.String?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig? = nil,
        jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.executionRoleArn = executionRoleArn
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.tags = tags
    }
}

struct StartVectorEnrichmentJobInputBody: Swift.Equatable {
    let name: Swift.String?
    let clientToken: Swift.String?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    let jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    let executionRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartVectorEnrichmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartVectorEnrichmentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartVectorEnrichmentJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.durationInSeconds = output.durationInSeconds
            self.executionRoleArn = output.executionRoleArn
            self.inputConfig = output.inputConfig
            self.jobConfig = output.jobConfig
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
            self.type = output.type
        } else {
            self.arn = nil
            self.creationTime = nil
            self.durationInSeconds = nil
            self.executionRoleArn = nil
            self.inputConfig = nil
            self.jobConfig = nil
            self.kmsKeyId = nil
            self.name = nil
            self.status = nil
            self.tags = nil
            self.type = nil
        }
    }
}

public struct StartVectorEnrichmentJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The duration of the Vector Enrichment job, in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// Input configuration information for starting the Vector Enrichment job.
    /// This member is required.
    public var inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    /// The Key Management Service key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Vector Enrichment job.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the Vector Enrichment job being started.
    /// This member is required.
    public var status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the Vector Enrichment job.
    /// This member is required.
    public var type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        durationInSeconds: Swift.Int? = nil,
        executionRoleArn: Swift.String? = nil,
        inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig? = nil,
        jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.durationInSeconds = durationInSeconds
        self.executionRoleArn = executionRoleArn
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tags = tags
        self.type = type
    }
}

struct StartVectorEnrichmentJobOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType?
    let creationTime: ClientRuntime.Date?
    let durationInSeconds: Swift.Int?
    let status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    let jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    let executionRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartVectorEnrichmentJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobType.self, forKey: .type)
        type = typeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum StartVectorEnrichmentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopEarthObservationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension StopEarthObservationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/earth-observation-jobs/stop"
    }
}

public struct StopEarthObservationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Earth Observation job being stopped.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopEarthObservationJobInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension StopEarthObservationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopEarthObservationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopEarthObservationJobOutput: Swift.Equatable {

    public init() { }
}

enum StopEarthObservationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopVectorEnrichmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension StopVectorEnrichmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/vector-enrichment-jobs/stop"
    }
}

public struct StopVectorEnrichmentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopVectorEnrichmentJobInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension StopVectorEnrichmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopVectorEnrichmentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopVectorEnrichmentJobOutput: Swift.Equatable {

    public init() { }
}

enum StopVectorEnrichmentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Each tag consists of a key and a value.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum TargetOptions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// INPUT
        case input
        /// OUTPUT
        case output
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetOptions] {
            return [
                .input,
                .output,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .input: return "INPUT"
            case .output: return "OUTPUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetOptions(rawValue: rawValue) ?? TargetOptions.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum TemporalStatistics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// MEAN
        case mean
        /// MEDIAN
        case median
        /// STANDARD_DEVIATION
        case standardDeviation
        case sdkUnknown(Swift.String)

        public static var allCases: [TemporalStatistics] {
            return [
                .mean,
                .median,
                .standardDeviation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mean: return "MEAN"
            case .median: return "MEDIAN"
            case .standardDeviation: return "STANDARD_DEVIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemporalStatistics(rawValue: rawValue) ?? TemporalStatistics.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.TemporalStatisticsConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupBy = "GroupBy"
        case statistics = "Statistics"
        case targetBands = "TargetBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupBy = self.groupBy {
            try encodeContainer.encode(groupBy.rawValue, forKey: .groupBy)
        }
        if let statistics = statistics {
            var statisticsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statistics)
            for temporalstatistics0 in statistics {
                try statisticsContainer.encode(temporalstatistics0.rawValue)
            }
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupByDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.GroupBy.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let statisticsContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.TemporalStatistics?].self, forKey: .statistics)
        var statisticsDecoded0:[SageMakerGeospatialClientTypes.TemporalStatistics]? = nil
        if let statisticsContainer = statisticsContainer {
            statisticsDecoded0 = [SageMakerGeospatialClientTypes.TemporalStatistics]()
            for string0 in statisticsContainer {
                if let string0 = string0 {
                    statisticsDecoded0?.append(string0)
                }
            }
        }
        statistics = statisticsDecoded0
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing the configuration for Temporal Statistics operation.
    public struct TemporalStatisticsConfigInput: Swift.Equatable {
        /// The input for the temporal statistics grouping by time frequency option.
        public var groupBy: SageMakerGeospatialClientTypes.GroupBy?
        /// The list of the statistics method options.
        /// This member is required.
        public var statistics: [SageMakerGeospatialClientTypes.TemporalStatistics]?
        /// The list of target band names for the temporal statistic to calculate.
        public var targetBands: [Swift.String]?

        public init(
            groupBy: SageMakerGeospatialClientTypes.GroupBy? = nil,
            statistics: [SageMakerGeospatialClientTypes.TemporalStatistics]? = nil,
            targetBands: [Swift.String]? = nil
        )
        {
            self.groupBy = groupBy
            self.statistics = statistics
            self.targetBands = targetBands
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes.TimeRangeFilterInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension SageMakerGeospatialClientTypes.TimeRangeFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input for the time-range filter.
    public struct TimeRangeFilterInput: Swift.Equatable {
        /// The end time for the time-range filter.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The start time for the time-range filter.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension SageMakerGeospatialClientTypes.TimeRangeFilterOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension SageMakerGeospatialClientTypes.TimeRangeFilterOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension SageMakerGeospatialClientTypes {
    /// The output structure of the time range filter.
    public struct TimeRangeFilterOutput: Swift.Equatable {
        /// The ending time for the time range filter.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The starting time for the time range filter.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum Unit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// METERS
        case meters
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .meters,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .meters: return "METERS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of the tags you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerGeospatialClientTypes.UserDefined: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The output resolution (in target georeferenced units) of the result of the operation
    public struct UserDefined: Swift.Equatable {
        /// The units for output resolution of the result.
        /// This member is required.
        public var unit: SageMakerGeospatialClientTypes.Unit?
        /// The value for output resolution of the result.
        /// This member is required.
        public var value: Swift.Float?

        public init(
            unit: SageMakerGeospatialClientTypes.Unit? = nil,
            value: Swift.Float? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mapmatchingconfig = "MapMatchingConfig"
        case reversegeocodingconfig = "ReverseGeocodingConfig"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .mapmatchingconfig(mapmatchingconfig):
                try container.encode(mapmatchingconfig, forKey: .mapmatchingconfig)
            case let .reversegeocodingconfig(reversegeocodingconfig):
                try container.encode(reversegeocodingconfig, forKey: .reversegeocodingconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let reversegeocodingconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ReverseGeocodingConfig.self, forKey: .reversegeocodingconfig)
        if let reversegeocodingconfig = reversegeocodingconfigDecoded {
            self = .reversegeocodingconfig(reversegeocodingconfig)
            return
        }
        let mapmatchingconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.MapMatchingConfig.self, forKey: .mapmatchingconfig)
        if let mapmatchingconfig = mapmatchingconfigDecoded {
            self = .mapmatchingconfig(mapmatchingconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    /// It contains configs such as ReverseGeocodingConfig and MapMatchingConfig.
    public enum VectorEnrichmentJobConfig: Swift.Equatable {
        /// The input structure for Reverse Geocoding operation type.
        case reversegeocodingconfig(SageMakerGeospatialClientTypes.ReverseGeocodingConfig)
        /// The input structure for Map Matching operation type.
        case mapmatchingconfig(SageMakerGeospatialClientTypes.MapMatchingConfig)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobDataSourceConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3data = "S3Data"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3data(s3data):
                try container.encode(s3data, forKey: .s3data)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3dataDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data.self, forKey: .s3data)
        if let s3data = s3dataDecoded {
            self = .s3data(s3data)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for the data source that represents the storage type of the input data objects.
    public enum VectorEnrichmentJobDataSourceConfigInput: Swift.Equatable {
        /// The input structure for the Amazon S3 data that represents the Amazon S3 location of the input data objects.
        case s3data(SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobDocumentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobDocumentType] {
            return [
                .csv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobDocumentType(rawValue: rawValue) ?? VectorEnrichmentJobDocumentType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case errorType = "ErrorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType.rawValue, forKey: .errorType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorTypeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorType.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// VectorEnrichmentJob error details in response from GetVectorEnrichmentJob.
    public struct VectorEnrichmentJobErrorDetails: Swift.Equatable {
        /// A message that you define and then is processed and rendered by the Vector Enrichment job when the error occurs.
        public var errorMessage: Swift.String?
        /// The type of error generated during the Vector Enrichment job.
        public var errorType: SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorType?

        public init(
            errorMessage: Swift.String? = nil,
            errorType: SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorType? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// CLIENT_ERROR
        case clientError
        /// SERVER_ERROR
        case serverError
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobErrorType] {
            return [
                .clientError,
                .serverError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientError: return "CLIENT_ERROR"
            case .serverError: return "SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobErrorType(rawValue: rawValue) ?? VectorEnrichmentJobErrorType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// VectorEnrichmentJob export error details in response from GetVectorEnrichmentJob.
    public struct VectorEnrichmentJobExportErrorDetails: Swift.Equatable {
        /// The message providing details about the errors generated during the Vector Enrichment job.
        public var message: Swift.String?
        /// The output error details for an Export operation on a Vector Enrichment job.
        public var type: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorType?

        public init(
            message: Swift.String? = nil,
            type: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobExportErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clientError
        case serverError
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobExportErrorType] {
            return [
                .clientError,
                .serverError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientError: return "CLIENT_ERROR"
            case .serverError: return "SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobExportErrorType(rawValue: rawValue) ?? VectorEnrichmentJobExportErrorType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobExportStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobExportStatus(rawValue: rawValue) ?? VectorEnrichmentJobExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfig = "DataSourceConfig"
        case documentType = "DocumentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceConfig = self.dataSourceConfig {
            try encodeContainer.encode(dataSourceConfig, forKey: .dataSourceConfig)
        }
        if let documentType = self.documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentTypeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobDocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let dataSourceConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobDataSourceConfigInput.self, forKey: .dataSourceConfig)
        dataSourceConfig = dataSourceConfigDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for the InputConfig in a VectorEnrichmentJob.
    public struct VectorEnrichmentJobInputConfig: Swift.Equatable {
        /// The input structure for the data source that represents the storage type of the input data objects.
        /// This member is required.
        public var dataSourceConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobDataSourceConfigInput?
        /// The input structure that defines the data source file type.
        /// This member is required.
        public var documentType: SageMakerGeospatialClientTypes.VectorEnrichmentJobDocumentType?

        public init(
            dataSourceConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobDataSourceConfigInput? = nil,
            documentType: SageMakerGeospatialClientTypes.VectorEnrichmentJobDocumentType? = nil
        )
        {
            self.dataSourceConfig = dataSourceConfig
            self.documentType = documentType
        }
    }

}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The Amazon S3 data for the Vector Enrichment job.
    public struct VectorEnrichmentJobS3Data: Swift.Equatable {
        /// The Key Management Service key ID for server-side encryption.
        public var kmsKeyId: Swift.String?
        /// The URL to the Amazon S3 data for the Vector Enrichment job.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case deleted
        case deleting
        case failed
        case initializing
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobStatus] {
            return [
                .completed,
                .deleted,
                .deleting,
                .failed,
                .initializing,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .initializing: return "INITIALIZING"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobStatus(rawValue: rawValue) ?? VectorEnrichmentJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mapMatching
        case reverseGeocoding
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobType] {
            return [
                .mapMatching,
                .reverseGeocoding,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mapMatching: return "MAP_MATCHING"
            case .reverseGeocoding: return "REVERSE_GEOCODING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobType(rawValue: rawValue) ?? VectorEnrichmentJobType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.ViewOffNadirInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBound = "LowerBound"
        case upperBound = "UpperBound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBound = self.lowerBound {
            try encodeContainer.encode(lowerBound, forKey: .lowerBound)
        }
        if let upperBound = self.upperBound {
            try encodeContainer.encode(upperBound, forKey: .upperBound)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBound)
        lowerBound = lowerBoundDecoded
        let upperBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBound)
        upperBound = upperBoundDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for specifying ViewOffNadir property filter. ViewOffNadir refers to the angle from the sensor between nadir (straight down) and the scene center. Measured in degrees (0-90).
    public struct ViewOffNadirInput: Swift.Equatable {
        /// The minimum value for ViewOffNadir property filter. This filters items having ViewOffNadir greater than or equal to this value.
        /// This member is required.
        public var lowerBound: Swift.Float?
        /// The maximum value for ViewOffNadir property filter. This filters items having ViewOffNadir lesser than or equal to this value.
        /// This member is required.
        public var upperBound: Swift.Float?

        public init(
            lowerBound: Swift.Float? = nil,
            upperBound: Swift.Float? = nil
        )
        {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }
    }

}

extension SageMakerGeospatialClientTypes.ViewSunAzimuthInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBound = "LowerBound"
        case upperBound = "UpperBound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBound = self.lowerBound {
            try encodeContainer.encode(lowerBound, forKey: .lowerBound)
        }
        if let upperBound = self.upperBound {
            try encodeContainer.encode(upperBound, forKey: .upperBound)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBound)
        lowerBound = lowerBoundDecoded
        let upperBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBound)
        upperBound = upperBoundDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for specifying ViewSunAzimuth property filter. ViewSunAzimuth refers to the Sun azimuth angle. From the scene center point on the ground, this is the angle between truth north and the sun. Measured clockwise in degrees (0-360).
    public struct ViewSunAzimuthInput: Swift.Equatable {
        /// The minimum value for ViewSunAzimuth property filter. This filters items having ViewSunAzimuth greater than or equal to this value.
        /// This member is required.
        public var lowerBound: Swift.Float?
        /// The maximum value for ViewSunAzimuth property filter. This filters items having ViewSunAzimuth lesser than or equal to this value.
        /// This member is required.
        public var upperBound: Swift.Float?

        public init(
            lowerBound: Swift.Float? = nil,
            upperBound: Swift.Float? = nil
        )
        {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }
    }

}

extension SageMakerGeospatialClientTypes.ViewSunElevationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBound = "LowerBound"
        case upperBound = "UpperBound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBound = self.lowerBound {
            try encodeContainer.encode(lowerBound, forKey: .lowerBound)
        }
        if let upperBound = self.upperBound {
            try encodeContainer.encode(upperBound, forKey: .upperBound)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBound)
        lowerBound = lowerBoundDecoded
        let upperBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBound)
        upperBound = upperBoundDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for specifying ViewSunElevation angle property filter.
    public struct ViewSunElevationInput: Swift.Equatable {
        /// The lower bound to view the sun elevation.
        /// This member is required.
        public var lowerBound: Swift.Float?
        /// The upper bound to view the sun elevation.
        /// This member is required.
        public var upperBound: Swift.Float?

        public init(
            lowerBound: Swift.Float? = nil,
            upperBound: Swift.Float? = nil
        )
        {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum ZonalStatistics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// MAX
        case max
        /// MEAN
        case mean
        /// MEDIAN
        case median
        /// MIN
        case min
        /// STANDARD_DEVIATION
        case standardDeviation
        /// SUM
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [ZonalStatistics] {
            return [
                .max,
                .mean,
                .median,
                .min,
                .standardDeviation,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .max: return "MAX"
            case .mean: return "MEAN"
            case .median: return "MEDIAN"
            case .min: return "MIN"
            case .standardDeviation: return "STANDARD_DEVIATION"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ZonalStatistics(rawValue: rawValue) ?? ZonalStatistics.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.ZonalStatisticsConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statistics = "Statistics"
        case targetBands = "TargetBands"
        case zoneS3Path = "ZoneS3Path"
        case zoneS3PathKmsKeyId = "ZoneS3PathKmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statistics = statistics {
            var statisticsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statistics)
            for zonalstatistics0 in statistics {
                try statisticsContainer.encode(zonalstatistics0.rawValue)
            }
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
        if let zoneS3Path = self.zoneS3Path {
            try encodeContainer.encode(zoneS3Path, forKey: .zoneS3Path)
        }
        if let zoneS3PathKmsKeyId = self.zoneS3PathKmsKeyId {
            try encodeContainer.encode(zoneS3PathKmsKeyId, forKey: .zoneS3PathKmsKeyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zoneS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zoneS3Path)
        zoneS3Path = zoneS3PathDecoded
        let statisticsContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.ZonalStatistics?].self, forKey: .statistics)
        var statisticsDecoded0:[SageMakerGeospatialClientTypes.ZonalStatistics]? = nil
        if let statisticsContainer = statisticsContainer {
            statisticsDecoded0 = [SageMakerGeospatialClientTypes.ZonalStatistics]()
            for string0 in statisticsContainer {
                if let string0 = string0 {
                    statisticsDecoded0?.append(string0)
                }
            }
        }
        statistics = statisticsDecoded0
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
        let zoneS3PathKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zoneS3PathKmsKeyId)
        zoneS3PathKmsKeyId = zoneS3PathKmsKeyIdDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing input configuration of ZonalStatistics operation.
    public struct ZonalStatisticsConfigInput: Swift.Equatable {
        /// List of zonal statistics to compute.
        /// This member is required.
        public var statistics: [SageMakerGeospatialClientTypes.ZonalStatistics]?
        /// Bands used in the operation. If no target bands are specified, it uses all bands available input.
        public var targetBands: [Swift.String]?
        /// The Amazon S3 path pointing to the GeoJSON containing the polygonal zones.
        /// This member is required.
        public var zoneS3Path: Swift.String?
        /// The Amazon Resource Name (ARN) or an ID of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to decrypt your output artifacts with Amazon S3 server-side encryption. The SageMaker execution role must have kms:GenerateDataKey permission. The KmsKeyId can be any of the following formats:
        ///
        /// * // KMS Key ID "1234abcd-12ab-34cd-56ef-1234567890ab"
        ///
        /// * // Amazon Resource Name (ARN) of a KMS Key "arn:aws:kms:<region>:<account>:key/<key-id-12ab-34cd-56ef-1234567890ab>"
        ///
        ///
        /// For more information about key identifiers, see [Key identifiers (KeyID)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-id) in the Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.
        public var zoneS3PathKmsKeyId: Swift.String?

        public init(
            statistics: [SageMakerGeospatialClientTypes.ZonalStatistics]? = nil,
            targetBands: [Swift.String]? = nil,
            zoneS3Path: Swift.String? = nil,
            zoneS3PathKmsKeyId: Swift.String? = nil
        )
        {
            self.statistics = statistics
            self.targetBands = targetBands
            self.zoneS3Path = zoneS3Path
            self.zoneS3PathKmsKeyId = zoneS3PathKmsKeyId
        }
    }

}
