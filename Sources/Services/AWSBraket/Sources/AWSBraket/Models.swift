//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BraketClientTypes {

    /// Contains metadata about the quantum task action, including the action type and program statistics.
    public struct ActionMetadata: Swift.Sendable {
        /// The type of action associated with the quantum task.
        /// This member is required.
        public var actionType: Swift.String?
        /// The number of executables in a program set. This is only available for a Program Set.
        public var executableCount: Swift.Int?
        /// The number of programs in a program set. This is only available for a Program Set.
        public var programCount: Swift.Int?

        public init(
            actionType: Swift.String? = nil,
            executableCount: Swift.Int? = nil,
            programCount: Swift.Int? = nil
        ) {
            self.actionType = actionType
            self.executableCount = executableCount
            self.programCount = programCount
        }
    }
}

extension BraketClientTypes {

    /// The container image used to create an Amazon Braket hybrid job.
    public struct ContainerImage: Swift.Sendable {
        /// The URI locating the container image.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        ) {
            self.uri = uri
        }
    }
}

extension BraketClientTypes {

    public enum CompressionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionType] {
            return [
                .gzip,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    /// Contains information about algorithm scripts used for the Amazon Braket hybrid job.
    public struct ScriptModeConfig: Swift.Sendable {
        /// The type of compression used to store the algorithm scripts in Amazon S3 storage.
        public var compressionType: BraketClientTypes.CompressionType?
        /// The entry point in the algorithm scripts from where the execution begins in the hybrid job.
        /// This member is required.
        public var entryPoint: Swift.String?
        /// The URI that specifies the S3 path to the algorithm scripts used by an Amazon Braket hybrid job.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            compressionType: BraketClientTypes.CompressionType? = nil,
            entryPoint: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        ) {
            self.compressionType = compressionType
            self.entryPoint = entryPoint
            self.s3Uri = s3Uri
        }
    }
}

extension BraketClientTypes {

    /// Defines the Amazon Braket hybrid job to be created. Specifies the container image the job uses and the paths to the Python scripts used for entry and training.
    public struct AlgorithmSpecification: Swift.Sendable {
        /// The container image used to create an Amazon Braket hybrid job.
        public var containerImage: BraketClientTypes.ContainerImage?
        /// Configures the paths to the Python scripts used for entry and training.
        public var scriptModeConfig: BraketClientTypes.ScriptModeConfig?

        public init(
            containerImage: BraketClientTypes.ContainerImage? = nil,
            scriptModeConfig: BraketClientTypes.ScriptModeConfig? = nil
        ) {
            self.containerImage = containerImage
            self.scriptModeConfig = scriptModeConfig
        }
    }
}

extension BraketClientTypes {

    public enum AssociationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case reservationTimeWindowArn
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationType] {
            return [
                .reservationTimeWindowArn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .reservationTimeWindowArn: return "RESERVATION_TIME_WINDOW_ARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    /// The Amazon Braket resource and the association type.
    public struct Association: Swift.Sendable {
        /// The Amazon Braket resource arn.
        /// This member is required.
        public var arn: Swift.String?
        /// The association type for the specified Amazon Braket resource arn.
        /// This member is required.
        public var type: BraketClientTypes.AssociationType?

        public init(
            arn: Swift.String? = nil,
            type: BraketClientTypes.AssociationType? = nil
        ) {
            self.arn = arn
            self.type = type
        }
    }
}

/// The request failed because of an unknown error.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The API throttling rate limit is exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BraketClientTypes {

    /// Contains information about validation failures that occurred during the processing of a program set in a quantum task.
    public struct ProgramSetValidationFailure: Swift.Sendable {
        /// A list of error messages describing the validation failures that occurred.
        public var errors: [Swift.String]?
        /// The index of the input within the program set that failed validation.
        public var inputsIndex: Swift.Int?
        /// The index of the program within the program set that failed validation.
        /// This member is required.
        public var programIndex: Swift.Int?

        public init(
            errors: [Swift.String]? = nil,
            inputsIndex: Swift.Int? = nil,
            programIndex: Swift.Int? = nil
        ) {
            self.errors = errors
            self.inputsIndex = inputsIndex
            self.programIndex = programIndex
        }
    }
}

extension BraketClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case programSetValidationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .programSetValidationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .programSetValidationFailed: return "ProgramSetValidationFailed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input request failed to satisfy constraints expected by Amazon Braket.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The validation failures in the program set submitted in the request.
        public internal(set) var programSetValidationFailures: [BraketClientTypes.ProgramSetValidationFailure]? = nil
        /// The reason for validation failure.
        public internal(set) var reason: BraketClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        programSetValidationFailures: [BraketClientTypes.ProgramSetValidationFailure]? = nil,
        reason: BraketClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.message = message
        self.properties.programSetValidationFailures = programSetValidationFailures
        self.properties.reason = reason
    }
}

public struct GetDeviceInput: Swift.Sendable {
    /// The ARN of the device to retrieve.
    /// This member is required.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    ) {
        self.deviceArn = deviceArn
    }
}

extension BraketClientTypes {

    public enum QueueName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jobsQueue
        case quantumTasksQueue
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueName] {
            return [
                .jobsQueue,
                .quantumTasksQueue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jobsQueue: return "JOBS_QUEUE"
            case .quantumTasksQueue: return "QUANTUM_TASKS_QUEUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    public enum QueuePriority: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case normal
        case priority
        case sdkUnknown(Swift.String)

        public static var allCases: [QueuePriority] {
            return [
                .normal,
                .priority
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .normal: return "Normal"
            case .priority: return "Priority"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    /// Information about quantum tasks and hybrid jobs queued on a device.
    public struct DeviceQueueInfo: Swift.Sendable {
        /// The name of the queue.
        /// This member is required.
        public var queue: BraketClientTypes.QueueName?
        /// Optional. Specifies the priority of the queue. Quantum tasks in a priority queue are processed before the quantum tasks in a normal queue.
        public var queuePriority: BraketClientTypes.QueuePriority?
        /// The number of hybrid jobs or quantum tasks in the queue for a given device.
        /// This member is required.
        public var queueSize: Swift.String?

        public init(
            queue: BraketClientTypes.QueueName? = nil,
            queuePriority: BraketClientTypes.QueuePriority? = nil,
            queueSize: Swift.String? = nil
        ) {
            self.queue = queue
            self.queuePriority = queuePriority
            self.queueSize = queueSize
        }
    }
}

extension BraketClientTypes {

    public enum DeviceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case offline
        case online
        case retired
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .offline,
                .online,
                .retired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .retired: return "RETIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    public enum DeviceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case qpu
        case simulator
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceType] {
            return [
                .qpu,
                .simulator
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .qpu: return "QPU"
            case .simulator: return "SIMULATOR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDeviceOutput: Swift.Sendable {
    /// The ARN of the device.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// Details about the capabilities of the device.
    /// This member is required.
    public var deviceCapabilities: Swift.String?
    /// The name of the device.
    /// This member is required.
    public var deviceName: Swift.String?
    /// The number of quantum tasks and hybrid jobs currently queued on the device.
    public var deviceQueueInfo: [BraketClientTypes.DeviceQueueInfo]?
    /// The status of the device.
    /// This member is required.
    public var deviceStatus: BraketClientTypes.DeviceStatus?
    /// The type of the device.
    /// This member is required.
    public var deviceType: BraketClientTypes.DeviceType?
    /// The name of the partner company for the device.
    /// This member is required.
    public var providerName: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        deviceCapabilities: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        deviceQueueInfo: [BraketClientTypes.DeviceQueueInfo]? = nil,
        deviceStatus: BraketClientTypes.DeviceStatus? = nil,
        deviceType: BraketClientTypes.DeviceType? = nil,
        providerName: Swift.String? = nil
    ) {
        self.deviceArn = deviceArn
        self.deviceCapabilities = deviceCapabilities
        self.deviceName = deviceName
        self.deviceQueueInfo = deviceQueueInfo
        self.deviceStatus = deviceStatus
        self.deviceType = deviceType
        self.providerName = providerName
    }
}

extension BraketClientTypes {

    /// The filter used to search for devices.
    public struct SearchDevicesFilter: Swift.Sendable {
        /// The name of the device parameter to filter based on. Only deviceArn filter name is currently supported.
        /// This member is required.
        public var name: Swift.String?
        /// The values used to filter devices based on the filter name.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        ) {
            self.name = name
            self.values = values
        }
    }
}

public struct SearchDevicesInput: Swift.Sendable {
    /// Array of SearchDevicesFilter objects to use when searching for devices.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchDevicesFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request to continue search where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        filters: [BraketClientTypes.SearchDevicesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BraketClientTypes {

    /// Includes information about the device.
    public struct DeviceSummary: Swift.Sendable {
        /// The ARN of the device.
        /// This member is required.
        public var deviceArn: Swift.String?
        /// The name of the device.
        /// This member is required.
        public var deviceName: Swift.String?
        /// The status of the device.
        /// This member is required.
        public var deviceStatus: BraketClientTypes.DeviceStatus?
        /// The type of the device.
        /// This member is required.
        public var deviceType: BraketClientTypes.DeviceType?
        /// The provider of the device.
        /// This member is required.
        public var providerName: Swift.String?

        public init(
            deviceArn: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            deviceStatus: BraketClientTypes.DeviceStatus? = nil,
            deviceType: BraketClientTypes.DeviceType? = nil,
            providerName: Swift.String? = nil
        ) {
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceStatus = deviceStatus
            self.deviceType = deviceType
            self.providerName = providerName
        }
    }
}

public struct SearchDevicesOutput: Swift.Sendable {
    /// An array of DeviceSummary objects for devices that match the specified filter values.
    /// This member is required.
    public var devices: [BraketClientTypes.DeviceSummary]?
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue search where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        devices: [BraketClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.devices = devices
        self.nextToken = nextToken
    }
}

/// An error occurred due to a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CancelJobInput: Swift.Sendable {
    /// The ARN of the Amazon Braket hybrid job to cancel.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    ) {
        self.jobArn = jobArn
    }
}

extension BraketClientTypes {

    public enum CancellationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case sdkUnknown(Swift.String)

        public static var allCases: [CancellationStatus] {
            return [
                .cancelled,
                .cancelling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelJobOutput: Swift.Sendable {
    /// The status of the hybrid job.
    /// This member is required.
    public var cancellationStatus: BraketClientTypes.CancellationStatus?
    /// The ARN of the Amazon Braket job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        cancellationStatus: BraketClientTypes.CancellationStatus? = nil,
        jobArn: Swift.String? = nil
    ) {
        self.cancellationStatus = cancellationStatus
        self.jobArn = jobArn
    }
}

/// The specified device is currently offline.
public struct DeviceOfflineException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeviceOfflineException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified device has been retired.
public struct DeviceRetiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeviceRetiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request failed because a service quota is exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BraketClientTypes {

    /// Contains information about the output locations for hybrid job checkpoint data.
    public struct JobCheckpointConfig: Swift.Sendable {
        /// (Optional) The local directory where checkpoint data is stored. The default directory is /opt/braket/checkpoints/.
        public var localPath: Swift.String?
        /// Identifies the S3 path where you want Amazon Braket to store checkpoint data. For example, s3://bucket-name/key-name-prefix.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            localPath: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        ) {
            self.localPath = localPath
            self.s3Uri = s3Uri
        }
    }
}

extension BraketClientTypes {

    /// Configures the primary device used to create and run an Amazon Braket hybrid job.
    public struct DeviceConfig: Swift.Sendable {
        /// The primary device ARN used to create and run an Amazon Braket hybrid job.
        /// This member is required.
        public var device: Swift.String?

        public init(
            device: Swift.String? = nil
        ) {
            self.device = device
        }
    }
}

extension BraketClientTypes {

    /// Information about the Amazon S3 storage used by the Amazon Braket hybrid job.
    public struct S3DataSource: Swift.Sendable {
        /// Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest that locates the S3 data source.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        ) {
            self.s3Uri = s3Uri
        }
    }
}

extension BraketClientTypes {

    /// Information about the source of the input data used by the Amazon Braket hybrid job.
    public struct DataSource: Swift.Sendable {
        /// Amazon S3 path of the input data used by the hybrid job.
        /// This member is required.
        public var s3DataSource: BraketClientTypes.S3DataSource?

        public init(
            s3DataSource: BraketClientTypes.S3DataSource? = nil
        ) {
            self.s3DataSource = s3DataSource
        }
    }
}

extension BraketClientTypes {

    /// A list of parameters that specify the input channels, type of input data, and where it is located.
    public struct InputFileConfig: Swift.Sendable {
        /// A named input source that an Amazon Braket hybrid job can consume.
        /// This member is required.
        public var channelName: Swift.String?
        /// The MIME type of the data.
        public var contentType: Swift.String?
        /// The location of the input data.
        /// This member is required.
        public var dataSource: BraketClientTypes.DataSource?

        public init(
            channelName: Swift.String? = nil,
            contentType: Swift.String? = nil,
            dataSource: BraketClientTypes.DataSource? = nil
        ) {
            self.channelName = channelName
            self.contentType = contentType
            self.dataSource = dataSource
        }
    }
}

extension BraketClientTypes {

    public enum InstanceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mlC42xlarge
        case mlC44xlarge
        case mlC48xlarge
        case mlC4Xlarge
        case mlC5n18xlarge
        case mlC5n2xlarge
        case mlC5n4xlarge
        case mlC5n9xlarge
        case mlC5nXlarge
        case mlC518xlarge
        case mlC52xlarge
        case mlC54xlarge
        case mlC59xlarge
        case mlC5Xlarge
        case mlG4dn12xlarge
        case mlG4dn16xlarge
        case mlG4dn2xlarge
        case mlG4dn4xlarge
        case mlG4dn8xlarge
        case mlG4dnXlarge
        case mlM410xlarge
        case mlM416xlarge
        case mlM42xlarge
        case mlM44xlarge
        case mlM4Xlarge
        case mlM512xlarge
        case mlM524xlarge
        case mlM52xlarge
        case mlM54xlarge
        case mlM5Large
        case mlM5Xlarge
        case mlP216xlarge
        case mlP28xlarge
        case mlP2Xlarge
        case mlP3dn24xlarge
        case mlP316xlarge
        case mlP32xlarge
        case mlP38xlarge
        case mlP4d24xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceType] {
            return [
                .mlC42xlarge,
                .mlC44xlarge,
                .mlC48xlarge,
                .mlC4Xlarge,
                .mlC5n18xlarge,
                .mlC5n2xlarge,
                .mlC5n4xlarge,
                .mlC5n9xlarge,
                .mlC5nXlarge,
                .mlC518xlarge,
                .mlC52xlarge,
                .mlC54xlarge,
                .mlC59xlarge,
                .mlC5Xlarge,
                .mlG4dn12xlarge,
                .mlG4dn16xlarge,
                .mlG4dn2xlarge,
                .mlG4dn4xlarge,
                .mlG4dn8xlarge,
                .mlG4dnXlarge,
                .mlM410xlarge,
                .mlM416xlarge,
                .mlM42xlarge,
                .mlM44xlarge,
                .mlM4Xlarge,
                .mlM512xlarge,
                .mlM524xlarge,
                .mlM52xlarge,
                .mlM54xlarge,
                .mlM5Large,
                .mlM5Xlarge,
                .mlP216xlarge,
                .mlP28xlarge,
                .mlP2Xlarge,
                .mlP3dn24xlarge,
                .mlP316xlarge,
                .mlP32xlarge,
                .mlP38xlarge,
                .mlP4d24xlarge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mlC42xlarge: return "ml.c4.2xlarge"
            case .mlC44xlarge: return "ml.c4.4xlarge"
            case .mlC48xlarge: return "ml.c4.8xlarge"
            case .mlC4Xlarge: return "ml.c4.xlarge"
            case .mlC5n18xlarge: return "ml.c5n.18xlarge"
            case .mlC5n2xlarge: return "ml.c5n.2xlarge"
            case .mlC5n4xlarge: return "ml.c5n.4xlarge"
            case .mlC5n9xlarge: return "ml.c5n.9xlarge"
            case .mlC5nXlarge: return "ml.c5n.xlarge"
            case .mlC518xlarge: return "ml.c5.18xlarge"
            case .mlC52xlarge: return "ml.c5.2xlarge"
            case .mlC54xlarge: return "ml.c5.4xlarge"
            case .mlC59xlarge: return "ml.c5.9xlarge"
            case .mlC5Xlarge: return "ml.c5.xlarge"
            case .mlG4dn12xlarge: return "ml.g4dn.12xlarge"
            case .mlG4dn16xlarge: return "ml.g4dn.16xlarge"
            case .mlG4dn2xlarge: return "ml.g4dn.2xlarge"
            case .mlG4dn4xlarge: return "ml.g4dn.4xlarge"
            case .mlG4dn8xlarge: return "ml.g4dn.8xlarge"
            case .mlG4dnXlarge: return "ml.g4dn.xlarge"
            case .mlM410xlarge: return "ml.m4.10xlarge"
            case .mlM416xlarge: return "ml.m4.16xlarge"
            case .mlM42xlarge: return "ml.m4.2xlarge"
            case .mlM44xlarge: return "ml.m4.4xlarge"
            case .mlM4Xlarge: return "ml.m4.xlarge"
            case .mlM512xlarge: return "ml.m5.12xlarge"
            case .mlM524xlarge: return "ml.m5.24xlarge"
            case .mlM52xlarge: return "ml.m5.2xlarge"
            case .mlM54xlarge: return "ml.m5.4xlarge"
            case .mlM5Large: return "ml.m5.large"
            case .mlM5Xlarge: return "ml.m5.xlarge"
            case .mlP216xlarge: return "ml.p2.16xlarge"
            case .mlP28xlarge: return "ml.p2.8xlarge"
            case .mlP2Xlarge: return "ml.p2.xlarge"
            case .mlP3dn24xlarge: return "ml.p3dn.24xlarge"
            case .mlP316xlarge: return "ml.p3.16xlarge"
            case .mlP32xlarge: return "ml.p3.2xlarge"
            case .mlP38xlarge: return "ml.p3.8xlarge"
            case .mlP4d24xlarge: return "ml.p4d.24xlarge"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    /// Configures the resource instances to use while running the Amazon Braket hybrid job on Amazon Braket.
    public struct InstanceConfig: Swift.Sendable {
        /// Configures the number of resource instances to use while running an Amazon Braket hybrid job on Amazon Braket. The default value is 1.
        public var instanceCount: Swift.Int?
        /// Configures the type of resource instances to use while running an Amazon Braket hybrid job.
        /// This member is required.
        public var instanceType: BraketClientTypes.InstanceType?
        /// The size of the storage volume, in GB, to provision.
        /// This member is required.
        public var volumeSizeInGb: Swift.Int?

        public init(
            instanceCount: Swift.Int? = nil,
            instanceType: BraketClientTypes.InstanceType? = nil,
            volumeSizeInGb: Swift.Int? = nil
        ) {
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.volumeSizeInGb = volumeSizeInGb
        }
    }
}

extension BraketClientTypes {

    /// Specifies the path to the S3 location where you want to store hybrid job artifacts and the encryption key used to store them.
    public struct JobOutputDataConfig: Swift.Sendable {
        /// The AWS Key Management Service (AWS KMS) key that Amazon Braket uses to encrypt the hybrid job training artifacts at rest using Amazon S3 server-side encryption.
        public var kmsKeyId: Swift.String?
        /// Identifies the S3 path where you want Amazon Braket to store the hybrid job training artifacts. For example, s3://bucket-name/key-name-prefix.
        /// This member is required.
        public var s3Path: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            s3Path: Swift.String? = nil
        ) {
            self.kmsKeyId = kmsKeyId
            self.s3Path = s3Path
        }
    }
}

extension BraketClientTypes {

    /// Specifies limits for how long an Amazon Braket hybrid job can run.
    public struct JobStoppingCondition: Swift.Sendable {
        /// The maximum length of time, in seconds, that an Amazon Braket hybrid job can run.
        public var maxRuntimeInSeconds: Swift.Int?

        public init(
            maxRuntimeInSeconds: Swift.Int? = nil
        ) {
            self.maxRuntimeInSeconds = maxRuntimeInSeconds
        }
    }
}

public struct CreateJobInput: Swift.Sendable {
    /// Definition of the Amazon Braket job to be created. Specifies the container image the job uses and information about the Python scripts used for entry and training.
    /// This member is required.
    public var algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    /// The list of Amazon Braket resources associated with the hybrid job.
    public var associations: [BraketClientTypes.Association]?
    /// Information about the output locations for hybrid job checkpoint data.
    public var checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    /// The client token associated with this request that guarantees that the request is idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The quantum processing unit (QPU) or simulator used to create an Amazon Braket hybrid job.
    /// This member is required.
    public var deviceConfig: BraketClientTypes.DeviceConfig?
    /// Algorithm-specific parameters used by an Amazon Braket hybrid job that influence the quality of the training job. The values are set with a map of JSON key:value pairs, where the key is the name of the hyperparameter and the value is the value of the hyperparameter. Do not include any security-sensitive information including account access IDs, secrets, or tokens in any hyperparameter fields. As part of the shared responsibility model, you are responsible for any potential exposure, unauthorized access, or compromise of your sensitive data if caused by security-sensitive information included in the request hyperparameter variable or plain text fields.
    public var hyperParameters: [Swift.String: Swift.String]?
    /// A list of parameters that specify the name and type of input data and where it is located.
    public var inputDataConfig: [BraketClientTypes.InputFileConfig]?
    /// Configuration of the resource instances to use while running the hybrid job on Amazon Braket.
    /// This member is required.
    public var instanceConfig: BraketClientTypes.InstanceConfig?
    /// The name of the Amazon Braket hybrid job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the S3 location where you want to store hybrid job artifacts and the encryption key used to store them.
    /// This member is required.
    public var outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can assume to perform tasks on behalf of a user. It can access user resources, run an Amazon Braket job container on behalf of user, and output results and hybrid job details to the users' s3 buckets.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The user-defined criteria that specifies when a hybrid job stops running.
    public var stoppingCondition: BraketClientTypes.JobStoppingCondition?
    /// Tags to be added to the hybrid job you're creating.
    public var tags: [Swift.String: Swift.String]?

    public init(
        algorithmSpecification: BraketClientTypes.AlgorithmSpecification? = nil,
        associations: [BraketClientTypes.Association]? = nil,
        checkpointConfig: BraketClientTypes.JobCheckpointConfig? = nil,
        clientToken: Swift.String? = nil,
        deviceConfig: BraketClientTypes.DeviceConfig? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        inputDataConfig: [BraketClientTypes.InputFileConfig]? = nil,
        instanceConfig: BraketClientTypes.InstanceConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: BraketClientTypes.JobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        stoppingCondition: BraketClientTypes.JobStoppingCondition? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.algorithmSpecification = algorithmSpecification
        self.associations = associations
        self.checkpointConfig = checkpointConfig
        self.clientToken = clientToken
        self.deviceConfig = deviceConfig
        self.hyperParameters = hyperParameters
        self.inputDataConfig = inputDataConfig
        self.instanceConfig = instanceConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.stoppingCondition = stoppingCondition
        self.tags = tags
    }
}

public struct CreateJobOutput: Swift.Sendable {
    /// The ARN of the Amazon Braket hybrid job created.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    ) {
        self.jobArn = jobArn
    }
}

extension BraketClientTypes {

    public enum HybridJobAdditionalAttributeName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case queueInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [HybridJobAdditionalAttributeName] {
            return [
                .queueInfo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .queueInfo: return "QueueInfo"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetJobInput: Swift.Sendable {
    /// A list of attributes to return additional information for. Only the QueueInfo additional attribute name is currently supported.
    public var additionalAttributeNames: [BraketClientTypes.HybridJobAdditionalAttributeName]?
    /// The ARN of the hybrid job to retrieve.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        additionalAttributeNames: [BraketClientTypes.HybridJobAdditionalAttributeName]? = nil,
        jobArn: Swift.String? = nil
    ) {
        self.additionalAttributeNames = additionalAttributeNames
        self.jobArn = jobArn
    }
}

extension BraketClientTypes {

    public enum JobEventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case deprioritizedDueToInactivity
        case downloadingData
        case failed
        case maxRuntimeExceeded
        case queuedForExecution
        case running
        case startingInstance
        case uploadingResults
        case waitingForPriority
        case sdkUnknown(Swift.String)

        public static var allCases: [JobEventType] {
            return [
                .cancelled,
                .completed,
                .deprioritizedDueToInactivity,
                .downloadingData,
                .failed,
                .maxRuntimeExceeded,
                .queuedForExecution,
                .running,
                .startingInstance,
                .uploadingResults,
                .waitingForPriority
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .deprioritizedDueToInactivity: return "DEPRIORITIZED_DUE_TO_INACTIVITY"
            case .downloadingData: return "DOWNLOADING_DATA"
            case .failed: return "FAILED"
            case .maxRuntimeExceeded: return "MAX_RUNTIME_EXCEEDED"
            case .queuedForExecution: return "QUEUED_FOR_EXECUTION"
            case .running: return "RUNNING"
            case .startingInstance: return "STARTING_INSTANCE"
            case .uploadingResults: return "UPLOADING_RESULTS"
            case .waitingForPriority: return "WAITING_FOR_PRIORITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    /// Details about the type and time events that occurred related to the Amazon Braket hybrid job.
    public struct JobEventDetails: Swift.Sendable {
        /// The type of event that occurred related to the Amazon Braket hybrid job.
        public var eventType: BraketClientTypes.JobEventType?
        /// A message describing the event that occurred related to the Amazon Braket hybrid job.
        public var message: Swift.String?
        /// The time of the event that occurred related to the Amazon Braket hybrid job.
        public var timeOfEvent: Foundation.Date?

        public init(
            eventType: BraketClientTypes.JobEventType? = nil,
            message: Swift.String? = nil,
            timeOfEvent: Foundation.Date? = nil
        ) {
            self.eventType = eventType
            self.message = message
            self.timeOfEvent = timeOfEvent
        }
    }
}

extension BraketClientTypes {

    /// Information about the queue for a specified hybrid job.
    public struct HybridJobQueueInfo: Swift.Sendable {
        /// Optional. Provides more information about the queue position. For example, if the hybrid job is complete and no longer in the queue, the message field contains that information.
        public var message: Swift.String?
        /// Current position of the hybrid job in the jobs queue.
        /// This member is required.
        public var position: Swift.String?
        /// The name of the queue.
        /// This member is required.
        public var queue: BraketClientTypes.QueueName?

        public init(
            message: Swift.String? = nil,
            position: Swift.String? = nil,
            queue: BraketClientTypes.QueueName? = nil
        ) {
            self.message = message
            self.position = position
            self.queue = queue
        }
    }
}

extension BraketClientTypes {

    public enum JobPrimaryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [JobPrimaryStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .queued,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetJobOutput: Swift.Sendable {
    /// Definition of the Amazon Braket hybrid job created. Provides information about the container image used, and the Python scripts used for training.
    /// This member is required.
    public var algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    /// The list of Amazon Braket resources associated with the hybrid job.
    public var associations: [BraketClientTypes.Association]?
    /// The billable time for which the Amazon Braket hybrid job used to complete.
    public var billableDuration: Swift.Int?
    /// Information about the output locations for hybrid job checkpoint data.
    public var checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    /// The time at which the Amazon Braket hybrid job was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The primary device used by the Amazon Braket hybrid job.
    public var deviceConfig: BraketClientTypes.DeviceConfig?
    /// The time at which the Amazon Braket hybrid job ended.
    public var endedAt: Foundation.Date?
    /// Details about the time and type of events occurred related to the Amazon Braket hybrid job.
    public var events: [BraketClientTypes.JobEventDetails]?
    /// A description of the reason why an Amazon Braket hybrid job failed, if it failed.
    public var failureReason: Swift.String?
    /// Algorithm-specific parameters used by an Amazon Braket hybrid job that influence the quality of the traiing job. The values are set with a map of JSON key:value pairs, where the key is the name of the hyperparameter and the value is the value of th hyperparameter.
    public var hyperParameters: [Swift.String: Swift.String]?
    /// A list of parameters that specify the name and type of input data and where it is located.
    public var inputDataConfig: [BraketClientTypes.InputFileConfig]?
    /// The resource instances to use while running the hybrid job on Amazon Braket.
    /// This member is required.
    public var instanceConfig: BraketClientTypes.InstanceConfig?
    /// The ARN of the Amazon Braket hybrid job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The name of the Amazon Braket hybrid job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the S3 location where hybrid job artifacts are stored and the encryption key used to store them there.
    /// This member is required.
    public var outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    /// Queue information for the requested hybrid job. Only returned if QueueInfo is specified in the additionalAttributeNames" field in the GetJob API request.
    public var queueInfo: BraketClientTypes.HybridJobQueueInfo?
    /// The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can assume to perform tasks on behalf of a user. It can access user resources, run an Amazon Braket job container on behalf of user, and output results and other hybrid job details to the s3 buckets of a user.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The time at which the Amazon Braket hybrid job was started.
    public var startedAt: Foundation.Date?
    /// The status of the Amazon Braket hybrid job.
    /// This member is required.
    public var status: BraketClientTypes.JobPrimaryStatus?
    /// The user-defined criteria that specifies when to stop a running hybrid job.
    public var stoppingCondition: BraketClientTypes.JobStoppingCondition?
    /// The tags associated with this hybrid job.
    public var tags: [Swift.String: Swift.String]?

    public init(
        algorithmSpecification: BraketClientTypes.AlgorithmSpecification? = nil,
        associations: [BraketClientTypes.Association]? = nil,
        billableDuration: Swift.Int? = nil,
        checkpointConfig: BraketClientTypes.JobCheckpointConfig? = nil,
        createdAt: Foundation.Date? = nil,
        deviceConfig: BraketClientTypes.DeviceConfig? = nil,
        endedAt: Foundation.Date? = nil,
        events: [BraketClientTypes.JobEventDetails]? = nil,
        failureReason: Swift.String? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        inputDataConfig: [BraketClientTypes.InputFileConfig]? = nil,
        instanceConfig: BraketClientTypes.InstanceConfig? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: BraketClientTypes.JobOutputDataConfig? = nil,
        queueInfo: BraketClientTypes.HybridJobQueueInfo? = nil,
        roleArn: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: BraketClientTypes.JobPrimaryStatus? = nil,
        stoppingCondition: BraketClientTypes.JobStoppingCondition? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.algorithmSpecification = algorithmSpecification
        self.associations = associations
        self.billableDuration = billableDuration
        self.checkpointConfig = checkpointConfig
        self.createdAt = createdAt
        self.deviceConfig = deviceConfig
        self.endedAt = endedAt
        self.events = events
        self.failureReason = failureReason
        self.hyperParameters = hyperParameters
        self.inputDataConfig = inputDataConfig
        self.instanceConfig = instanceConfig
        self.jobArn = jobArn
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.queueInfo = queueInfo
        self.roleArn = roleArn
        self.startedAt = startedAt
        self.status = status
        self.stoppingCondition = stoppingCondition
        self.tags = tags
    }
}

extension BraketClientTypes {

    public enum SearchJobsFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case between
        case contains
        case equal
        case gt
        case gte
        case lt
        case lte
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchJobsFilterOperator] {
            return [
                .between,
                .contains,
                .equal,
                .gt,
                .gte,
                .lt,
                .lte
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .equal: return "EQUAL"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .lt: return "LT"
            case .lte: return "LTE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    /// A filter used to search for Amazon Braket hybrid jobs.
    public struct SearchJobsFilter: Swift.Sendable {
        /// The name of the hybrid job parameter to filter based on. Filter name can be either jobArn or createdAt.
        /// This member is required.
        public var name: Swift.String?
        /// An operator to use for the filter.
        /// This member is required.
        public var `operator`: BraketClientTypes.SearchJobsFilterOperator?
        /// The values used to filter hybrid jobs based on the filter name and operator.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            `operator`: BraketClientTypes.SearchJobsFilterOperator? = nil,
            values: [Swift.String]? = nil
        ) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }
}

public struct SearchJobsInput: Swift.Sendable {
    /// Array of SearchJobsFilter objects to use when searching for hybrid jobs.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchJobsFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request to continue search where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        filters: [BraketClientTypes.SearchJobsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BraketClientTypes {

    /// Provides summary information about an Amazon Braket hybrid job.
    public struct JobSummary: Swift.Sendable {
        /// The time at which the Amazon Braket hybrid job was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The primary device used by an Amazon Braket hybrid job.
        /// This member is required.
        public var device: Swift.String?
        /// The time at which the Amazon Braket hybrid job ended.
        public var endedAt: Foundation.Date?
        /// The ARN of the Amazon Braket hybrid job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name of the Amazon Braket hybrid job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The time at which the Amazon Braket hybrid job was started.
        public var startedAt: Foundation.Date?
        /// The status of the Amazon Braket hybrid job.
        /// This member is required.
        public var status: BraketClientTypes.JobPrimaryStatus?
        /// Displays the key, value pairs of tags associated with this hybrid job.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            device: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            status: BraketClientTypes.JobPrimaryStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.createdAt = createdAt
            self.device = device
            self.endedAt = endedAt
            self.jobArn = jobArn
            self.jobName = jobName
            self.startedAt = startedAt
            self.status = status
            self.tags = tags
        }
    }
}

public struct SearchJobsOutput: Swift.Sendable {
    /// An array of JobSummary objects for devices that match the specified filter values.
    /// This member is required.
    public var jobs: [BraketClientTypes.JobSummary]?
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue search where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        jobs: [BraketClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// Specify the resourceArn for the resource whose tags to display.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Displays the key, value pairs of tags associated with this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct CancelQuantumTaskInput: Swift.Sendable {
    /// The client token associated with the cancellation request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ARN of the quantum task to cancel.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        quantumTaskArn: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.quantumTaskArn = quantumTaskArn
    }
}

public struct CancelQuantumTaskOutput: Swift.Sendable {
    /// The status of the quantum task.
    /// This member is required.
    public var cancellationStatus: BraketClientTypes.CancellationStatus?
    /// The ARN of the quantum task.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        cancellationStatus: BraketClientTypes.CancellationStatus? = nil,
        quantumTaskArn: Swift.String? = nil
    ) {
        self.cancellationStatus = cancellationStatus
        self.quantumTaskArn = quantumTaskArn
    }
}

public struct CreateQuantumTaskInput: Swift.Sendable {
    /// The action associated with the quantum task.
    /// This member is required.
    public var action: Swift.String?
    /// The list of Amazon Braket resources associated with the quantum task.
    public var associations: [BraketClientTypes.Association]?
    /// The client token associated with the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ARN of the device to run the quantum task on.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The parameters for the device to run the quantum task on.
    public var deviceParameters: Swift.String?
    /// The token for an Amazon Braket hybrid job that associates it with the quantum task.
    public var jobToken: Swift.String?
    /// The S3 bucket to store quantum task result files in.
    /// This member is required.
    public var outputS3Bucket: Swift.String?
    /// The key prefix for the location in the S3 bucket to store quantum task results in.
    /// This member is required.
    public var outputS3KeyPrefix: Swift.String?
    /// The number of shots to use for the quantum task.
    /// This member is required.
    public var shots: Swift.Int?
    /// Tags to be added to the quantum task you're creating.
    public var tags: [Swift.String: Swift.String]?

    public init(
        action: Swift.String? = nil,
        associations: [BraketClientTypes.Association]? = nil,
        clientToken: Swift.String? = nil,
        deviceArn: Swift.String? = nil,
        deviceParameters: Swift.String? = nil,
        jobToken: Swift.String? = nil,
        outputS3Bucket: Swift.String? = nil,
        outputS3KeyPrefix: Swift.String? = nil,
        shots: Swift.Int? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.action = action
        self.associations = associations
        self.clientToken = clientToken
        self.deviceArn = deviceArn
        self.deviceParameters = deviceParameters
        self.jobToken = jobToken
        self.outputS3Bucket = outputS3Bucket
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.shots = shots
        self.tags = tags
    }
}

public struct CreateQuantumTaskOutput: Swift.Sendable {
    /// The ARN of the quantum task created by the request.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        quantumTaskArn: Swift.String? = nil
    ) {
        self.quantumTaskArn = quantumTaskArn
    }
}

extension BraketClientTypes {

    public enum QuantumTaskAdditionalAttributeName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case queueInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [QuantumTaskAdditionalAttributeName] {
            return [
                .queueInfo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .queueInfo: return "QueueInfo"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQuantumTaskInput: Swift.Sendable {
    /// A list of attributes to return additional information for. Only the QueueInfo additional attribute name is currently supported.
    public var additionalAttributeNames: [BraketClientTypes.QuantumTaskAdditionalAttributeName]?
    /// The ARN of the quantum task to retrieve.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        additionalAttributeNames: [BraketClientTypes.QuantumTaskAdditionalAttributeName]? = nil,
        quantumTaskArn: Swift.String? = nil
    ) {
        self.additionalAttributeNames = additionalAttributeNames
        self.quantumTaskArn = quantumTaskArn
    }
}

extension BraketClientTypes {

    /// The queue information for the specified quantum task.
    public struct QuantumTaskQueueInfo: Swift.Sendable {
        /// Optional. Provides more information about the queue position. For example, if the quantum task is complete and no longer in the queue, the message field contains that information.
        public var message: Swift.String?
        /// Current position of the quantum task in the quantum tasks queue.
        /// This member is required.
        public var position: Swift.String?
        /// The name of the queue.
        /// This member is required.
        public var queue: BraketClientTypes.QueueName?
        /// Optional. Specifies the priority of the queue. Quantum tasks in a priority queue are processed before the quantum tasks in a normal queue.
        public var queuePriority: BraketClientTypes.QueuePriority?

        public init(
            message: Swift.String? = nil,
            position: Swift.String? = nil,
            queue: BraketClientTypes.QueueName? = nil,
            queuePriority: BraketClientTypes.QueuePriority? = nil
        ) {
            self.message = message
            self.position = position
            self.queue = queue
            self.queuePriority = queuePriority
        }
    }
}

extension BraketClientTypes {

    public enum QuantumTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case created
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [QuantumTaskStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .created,
                .failed,
                .queued,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQuantumTaskOutput: Swift.Sendable {
    /// Metadata about the action performed by the quantum task, including information about the type of action and program counts.
    public var actionMetadata: BraketClientTypes.ActionMetadata?
    /// The list of Amazon Braket resources associated with the quantum task.
    public var associations: [BraketClientTypes.Association]?
    /// The time at which the quantum task was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ARN of the device the quantum task was run on.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The parameters for the device on which the quantum task ran.
    /// This member is required.
    public var deviceParameters: Swift.String?
    /// The time at which the quantum task ended.
    public var endedAt: Foundation.Date?
    /// The reason that a quantum task failed.
    public var failureReason: Swift.String?
    /// The ARN of the Amazon Braket job associated with the quantum task.
    public var jobArn: Swift.String?
    /// The number of successful shots for the quantum task. This is available after a successfully completed quantum task.
    public var numSuccessfulShots: Swift.Int?
    /// The S3 bucket where quantum task results are stored.
    /// This member is required.
    public var outputS3Bucket: Swift.String?
    /// The folder in the S3 bucket where quantum task results are stored.
    /// This member is required.
    public var outputS3Directory: Swift.String?
    /// The ARN of the quantum task.
    /// This member is required.
    public var quantumTaskArn: Swift.String?
    /// Queue information for the requested quantum task. Only returned if QueueInfo is specified in the additionalAttributeNames" field in the GetQuantumTask API request.
    public var queueInfo: BraketClientTypes.QuantumTaskQueueInfo?
    /// The number of shots used in the quantum task.
    /// This member is required.
    public var shots: Swift.Int?
    /// The status of the quantum task.
    /// This member is required.
    public var status: BraketClientTypes.QuantumTaskStatus?
    /// The tags that belong to this quantum task.
    public var tags: [Swift.String: Swift.String]?

    public init(
        actionMetadata: BraketClientTypes.ActionMetadata? = nil,
        associations: [BraketClientTypes.Association]? = nil,
        createdAt: Foundation.Date? = nil,
        deviceArn: Swift.String? = nil,
        deviceParameters: Swift.String? = nil,
        endedAt: Foundation.Date? = nil,
        failureReason: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        numSuccessfulShots: Swift.Int? = nil,
        outputS3Bucket: Swift.String? = nil,
        outputS3Directory: Swift.String? = nil,
        quantumTaskArn: Swift.String? = nil,
        queueInfo: BraketClientTypes.QuantumTaskQueueInfo? = nil,
        shots: Swift.Int? = nil,
        status: BraketClientTypes.QuantumTaskStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.actionMetadata = actionMetadata
        self.associations = associations
        self.createdAt = createdAt
        self.deviceArn = deviceArn
        self.deviceParameters = deviceParameters
        self.endedAt = endedAt
        self.failureReason = failureReason
        self.jobArn = jobArn
        self.numSuccessfulShots = numSuccessfulShots
        self.outputS3Bucket = outputS3Bucket
        self.outputS3Directory = outputS3Directory
        self.quantumTaskArn = quantumTaskArn
        self.queueInfo = queueInfo
        self.shots = shots
        self.status = status
        self.tags = tags
    }
}

extension BraketClientTypes {

    public enum SearchQuantumTasksFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case between
        case equal
        case gt
        case gte
        case lt
        case lte
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchQuantumTasksFilterOperator] {
            return [
                .between,
                .equal,
                .gt,
                .gte,
                .lt,
                .lte
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .equal: return "EQUAL"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .lt: return "LT"
            case .lte: return "LTE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    /// A filter used to search for quantum tasks.
    public struct SearchQuantumTasksFilter: Swift.Sendable {
        /// The name of the quantum task parameter to filter based on. Filter name can be either quantumTaskArn, deviceArn, jobArn, status or createdAt.
        /// This member is required.
        public var name: Swift.String?
        /// An operator to use for the filter.
        /// This member is required.
        public var `operator`: BraketClientTypes.SearchQuantumTasksFilterOperator?
        /// The values used to filter quantum tasks based on the filter name and operator.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            `operator`: BraketClientTypes.SearchQuantumTasksFilterOperator? = nil,
            values: [Swift.String]? = nil
        ) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }
}

public struct SearchQuantumTasksInput: Swift.Sendable {
    /// Array of SearchQuantumTasksFilter objects to use when searching for quantum tasks.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchQuantumTasksFilter]?
    /// Maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request to continue search where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        filters: [BraketClientTypes.SearchQuantumTasksFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BraketClientTypes {

    /// Includes information about a quantum task.
    public struct QuantumTaskSummary: Swift.Sendable {
        /// The time at which the quantum task was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The ARN of the device the quantum task ran on.
        /// This member is required.
        public var deviceArn: Swift.String?
        /// The time at which the quantum task finished.
        public var endedAt: Foundation.Date?
        /// The S3 bucket where the quantum task result file is stored.
        /// This member is required.
        public var outputS3Bucket: Swift.String?
        /// The folder in the S3 bucket where the quantum task result file is stored.
        /// This member is required.
        public var outputS3Directory: Swift.String?
        /// The ARN of the quantum task.
        /// This member is required.
        public var quantumTaskArn: Swift.String?
        /// The shots used for the quantum task.
        /// This member is required.
        public var shots: Swift.Int?
        /// The status of the quantum task.
        /// This member is required.
        public var status: BraketClientTypes.QuantumTaskStatus?
        /// Displays the key, value pairs of tags associated with this quantum task.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            deviceArn: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            outputS3Bucket: Swift.String? = nil,
            outputS3Directory: Swift.String? = nil,
            quantumTaskArn: Swift.String? = nil,
            shots: Swift.Int? = nil,
            status: BraketClientTypes.QuantumTaskStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.createdAt = createdAt
            self.deviceArn = deviceArn
            self.endedAt = endedAt
            self.outputS3Bucket = outputS3Bucket
            self.outputS3Directory = outputS3Directory
            self.quantumTaskArn = quantumTaskArn
            self.shots = shots
            self.status = status
            self.tags = tags
        }
    }
}

public struct SearchQuantumTasksOutput: Swift.Sendable {
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue search where the previous request ended.
    public var nextToken: Swift.String?
    /// An array of QuantumTaskSummary objects for quantum tasks that match the specified filters.
    /// This member is required.
    public var quantumTasks: [BraketClientTypes.QuantumTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        quantumTasks: [BraketClientTypes.QuantumTaskSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.quantumTasks = quantumTasks
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// Specify the resourceArn of the resource to which a tag will be added.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specify the tags to add to the resource. Tags can be specified as a key-value map.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// Specify the resourceArn for the resource from which to remove the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specify the keys for the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CancelJobInput {

    static func urlPathProvider(_ value: CancelJobInput) -> Swift.String? {
        guard let jobArn = value.jobArn else {
            return nil
        }
        return "/job/\(jobArn.urlPercentEncoding())/cancel"
    }
}

extension CancelQuantumTaskInput {

    static func urlPathProvider(_ value: CancelQuantumTaskInput) -> Swift.String? {
        guard let quantumTaskArn = value.quantumTaskArn else {
            return nil
        }
        return "/quantum-task/\(quantumTaskArn.urlPercentEncoding())/cancel"
    }
}

extension CreateJobInput {

    static func urlPathProvider(_ value: CreateJobInput) -> Swift.String? {
        return "/job"
    }
}

extension CreateQuantumTaskInput {

    static func urlPathProvider(_ value: CreateQuantumTaskInput) -> Swift.String? {
        return "/quantum-task"
    }
}

extension GetDeviceInput {

    static func urlPathProvider(_ value: GetDeviceInput) -> Swift.String? {
        guard let deviceArn = value.deviceArn else {
            return nil
        }
        return "/device/\(deviceArn.urlPercentEncoding())"
    }
}

extension GetJobInput {

    static func urlPathProvider(_ value: GetJobInput) -> Swift.String? {
        guard let jobArn = value.jobArn else {
            return nil
        }
        return "/job/\(jobArn.urlPercentEncoding())"
    }
}

extension GetJobInput {

    static func queryItemProvider(_ value: GetJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let additionalAttributeNames = value.additionalAttributeNames {
            additionalAttributeNames.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "additionalAttributeNames".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetQuantumTaskInput {

    static func urlPathProvider(_ value: GetQuantumTaskInput) -> Swift.String? {
        guard let quantumTaskArn = value.quantumTaskArn else {
            return nil
        }
        return "/quantum-task/\(quantumTaskArn.urlPercentEncoding())"
    }
}

extension GetQuantumTaskInput {

    static func queryItemProvider(_ value: GetQuantumTaskInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let additionalAttributeNames = value.additionalAttributeNames {
            additionalAttributeNames.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "additionalAttributeNames".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension SearchDevicesInput {

    static func urlPathProvider(_ value: SearchDevicesInput) -> Swift.String? {
        return "/devices"
    }
}

extension SearchJobsInput {

    static func urlPathProvider(_ value: SearchJobsInput) -> Swift.String? {
        return "/jobs"
    }
}

extension SearchQuantumTasksInput {

    static func urlPathProvider(_ value: SearchQuantumTasksInput) -> Swift.String? {
        return "/quantum-tasks"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension CancelQuantumTaskInput {

    static func write(value: CancelQuantumTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension CreateJobInput {

    static func write(value: CreateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["algorithmSpecification"].write(value.algorithmSpecification, with: BraketClientTypes.AlgorithmSpecification.write(value:to:))
        try writer["associations"].writeList(value.associations, memberWritingClosure: BraketClientTypes.Association.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["checkpointConfig"].write(value.checkpointConfig, with: BraketClientTypes.JobCheckpointConfig.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["deviceConfig"].write(value.deviceConfig, with: BraketClientTypes.DeviceConfig.write(value:to:))
        try writer["hyperParameters"].writeMap(value.hyperParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["inputDataConfig"].writeList(value.inputDataConfig, memberWritingClosure: BraketClientTypes.InputFileConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["instanceConfig"].write(value.instanceConfig, with: BraketClientTypes.InstanceConfig.write(value:to:))
        try writer["jobName"].write(value.jobName)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BraketClientTypes.JobOutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["stoppingCondition"].write(value.stoppingCondition, with: BraketClientTypes.JobStoppingCondition.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateQuantumTaskInput {

    static func write(value: CreateQuantumTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["associations"].writeList(value.associations, memberWritingClosure: BraketClientTypes.Association.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["deviceArn"].write(value.deviceArn)
        try writer["deviceParameters"].write(value.deviceParameters)
        try writer["jobToken"].write(value.jobToken)
        try writer["outputS3Bucket"].write(value.outputS3Bucket)
        try writer["outputS3KeyPrefix"].write(value.outputS3KeyPrefix)
        try writer["shots"].write(value.shots)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension SearchDevicesInput {

    static func write(value: SearchDevicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: BraketClientTypes.SearchDevicesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SearchJobsInput {

    static func write(value: SearchJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: BraketClientTypes.SearchJobsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SearchQuantumTasksInput {

    static func write(value: SearchQuantumTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: BraketClientTypes.SearchQuantumTasksFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CancelJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelJobOutput()
        value.cancellationStatus = try reader["cancellationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CancelQuantumTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelQuantumTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelQuantumTaskOutput()
        value.cancellationStatus = try reader["cancellationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.quantumTaskArn = try reader["quantumTaskArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateQuantumTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQuantumTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateQuantumTaskOutput()
        value.quantumTaskArn = try reader["quantumTaskArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceOutput()
        value.deviceArn = try reader["deviceArn"].readIfPresent() ?? ""
        value.deviceCapabilities = try reader["deviceCapabilities"].readIfPresent() ?? ""
        value.deviceName = try reader["deviceName"].readIfPresent() ?? ""
        value.deviceQueueInfo = try reader["deviceQueueInfo"].readListIfPresent(memberReadingClosure: BraketClientTypes.DeviceQueueInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deviceStatus = try reader["deviceStatus"].readIfPresent() ?? .sdkUnknown("")
        value.deviceType = try reader["deviceType"].readIfPresent() ?? .sdkUnknown("")
        value.providerName = try reader["providerName"].readIfPresent() ?? ""
        return value
    }
}

extension GetJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobOutput()
        value.algorithmSpecification = try reader["algorithmSpecification"].readIfPresent(with: BraketClientTypes.AlgorithmSpecification.read(from:))
        value.associations = try reader["associations"].readListIfPresent(memberReadingClosure: BraketClientTypes.Association.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.billableDuration = try reader["billableDuration"].readIfPresent()
        value.checkpointConfig = try reader["checkpointConfig"].readIfPresent(with: BraketClientTypes.JobCheckpointConfig.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deviceConfig = try reader["deviceConfig"].readIfPresent(with: BraketClientTypes.DeviceConfig.read(from:))
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: BraketClientTypes.JobEventDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.hyperParameters = try reader["hyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.inputDataConfig = try reader["inputDataConfig"].readListIfPresent(memberReadingClosure: BraketClientTypes.InputFileConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceConfig = try reader["instanceConfig"].readIfPresent(with: BraketClientTypes.InstanceConfig.read(from:))
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BraketClientTypes.JobOutputDataConfig.read(from:))
        value.queueInfo = try reader["queueInfo"].readIfPresent(with: BraketClientTypes.HybridJobQueueInfo.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.stoppingCondition = try reader["stoppingCondition"].readIfPresent(with: BraketClientTypes.JobStoppingCondition.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetQuantumTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQuantumTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQuantumTaskOutput()
        value.actionMetadata = try reader["actionMetadata"].readIfPresent(with: BraketClientTypes.ActionMetadata.read(from:))
        value.associations = try reader["associations"].readListIfPresent(memberReadingClosure: BraketClientTypes.Association.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deviceArn = try reader["deviceArn"].readIfPresent() ?? ""
        value.deviceParameters = try reader["deviceParameters"].readIfPresent() ?? ""
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.numSuccessfulShots = try reader["numSuccessfulShots"].readIfPresent()
        value.outputS3Bucket = try reader["outputS3Bucket"].readIfPresent() ?? ""
        value.outputS3Directory = try reader["outputS3Directory"].readIfPresent() ?? ""
        value.quantumTaskArn = try reader["quantumTaskArn"].readIfPresent() ?? ""
        value.queueInfo = try reader["queueInfo"].readIfPresent(with: BraketClientTypes.QuantumTaskQueueInfo.read(from:))
        value.shots = try reader["shots"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SearchDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchDevicesOutput()
        value.devices = try reader["devices"].readListIfPresent(memberReadingClosure: BraketClientTypes.DeviceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SearchJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchJobsOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: BraketClientTypes.JobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SearchQuantumTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchQuantumTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchQuantumTasksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.quantumTasks = try reader["quantumTasks"].readListIfPresent(memberReadingClosure: BraketClientTypes.QuantumTaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CancelJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelQuantumTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DeviceOfflineException": return try DeviceOfflineException.makeError(baseError: baseError)
            case "DeviceRetiredException": return try DeviceRetiredException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQuantumTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DeviceOfflineException": return try DeviceOfflineException.makeError(baseError: baseError)
            case "DeviceRetiredException": return try DeviceRetiredException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQuantumTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchQuantumTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServiceException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.programSetValidationFailures = try reader["programSetValidationFailures"].readListIfPresent(memberReadingClosure: BraketClientTypes.ProgramSetValidationFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DeviceOfflineException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DeviceOfflineException {
        let reader = baseError.errorBodyReader
        var value = DeviceOfflineException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DeviceRetiredException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DeviceRetiredException {
        let reader = baseError.errorBodyReader
        var value = DeviceRetiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BraketClientTypes.DeviceQueueInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.DeviceQueueInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.DeviceQueueInfo()
        value.queue = try reader["queue"].readIfPresent() ?? .sdkUnknown("")
        value.queueSize = try reader["queueSize"].readIfPresent() ?? ""
        value.queuePriority = try reader["queuePriority"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.InputFileConfig {

    static func write(value: BraketClientTypes.InputFileConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelName"].write(value.channelName)
        try writer["contentType"].write(value.contentType)
        try writer["dataSource"].write(value.dataSource, with: BraketClientTypes.DataSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.InputFileConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.InputFileConfig()
        value.channelName = try reader["channelName"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent()
        value.dataSource = try reader["dataSource"].readIfPresent(with: BraketClientTypes.DataSource.read(from:))
        return value
    }
}

extension BraketClientTypes.DataSource {

    static func write(value: BraketClientTypes.DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3DataSource"].write(value.s3DataSource, with: BraketClientTypes.S3DataSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.DataSource()
        value.s3DataSource = try reader["s3DataSource"].readIfPresent(with: BraketClientTypes.S3DataSource.read(from:))
        return value
    }
}

extension BraketClientTypes.S3DataSource {

    static func write(value: BraketClientTypes.S3DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.S3DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.S3DataSource()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BraketClientTypes.JobOutputDataConfig {

    static func write(value: BraketClientTypes.JobOutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["s3Path"].write(value.s3Path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.JobOutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.JobOutputDataConfig()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.s3Path = try reader["s3Path"].readIfPresent() ?? ""
        return value
    }
}

extension BraketClientTypes.JobStoppingCondition {

    static func write(value: BraketClientTypes.JobStoppingCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxRuntimeInSeconds"].write(value.maxRuntimeInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.JobStoppingCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.JobStoppingCondition()
        value.maxRuntimeInSeconds = try reader["maxRuntimeInSeconds"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.JobCheckpointConfig {

    static func write(value: BraketClientTypes.JobCheckpointConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["localPath"].write(value.localPath)
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.JobCheckpointConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.JobCheckpointConfig()
        value.localPath = try reader["localPath"].readIfPresent()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BraketClientTypes.AlgorithmSpecification {

    static func write(value: BraketClientTypes.AlgorithmSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["containerImage"].write(value.containerImage, with: BraketClientTypes.ContainerImage.write(value:to:))
        try writer["scriptModeConfig"].write(value.scriptModeConfig, with: BraketClientTypes.ScriptModeConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.AlgorithmSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.AlgorithmSpecification()
        value.scriptModeConfig = try reader["scriptModeConfig"].readIfPresent(with: BraketClientTypes.ScriptModeConfig.read(from:))
        value.containerImage = try reader["containerImage"].readIfPresent(with: BraketClientTypes.ContainerImage.read(from:))
        return value
    }
}

extension BraketClientTypes.ContainerImage {

    static func write(value: BraketClientTypes.ContainerImage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.ContainerImage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.ContainerImage()
        value.uri = try reader["uri"].readIfPresent() ?? ""
        return value
    }
}

extension BraketClientTypes.ScriptModeConfig {

    static func write(value: BraketClientTypes.ScriptModeConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["compressionType"].write(value.compressionType)
        try writer["entryPoint"].write(value.entryPoint)
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.ScriptModeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.ScriptModeConfig()
        value.entryPoint = try reader["entryPoint"].readIfPresent() ?? ""
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        value.compressionType = try reader["compressionType"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.InstanceConfig {

    static func write(value: BraketClientTypes.InstanceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceCount"].write(value.instanceCount)
        try writer["instanceType"].write(value.instanceType)
        try writer["volumeSizeInGb"].write(value.volumeSizeInGb)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.InstanceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.InstanceConfig()
        value.instanceType = try reader["instanceType"].readIfPresent() ?? .sdkUnknown("")
        value.volumeSizeInGb = try reader["volumeSizeInGb"].readIfPresent() ?? 0
        value.instanceCount = try reader["instanceCount"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.DeviceConfig {

    static func write(value: BraketClientTypes.DeviceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["device"].write(value.device)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.DeviceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.DeviceConfig()
        value.device = try reader["device"].readIfPresent() ?? ""
        return value
    }
}

extension BraketClientTypes.JobEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.JobEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.JobEventDetails()
        value.eventType = try reader["eventType"].readIfPresent()
        value.timeOfEvent = try reader["timeOfEvent"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.HybridJobQueueInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.HybridJobQueueInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.HybridJobQueueInfo()
        value.queue = try reader["queue"].readIfPresent() ?? .sdkUnknown("")
        value.position = try reader["position"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.Association {

    static func write(value: BraketClientTypes.Association?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.Association {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.Association()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BraketClientTypes.QuantumTaskQueueInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.QuantumTaskQueueInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.QuantumTaskQueueInfo()
        value.queue = try reader["queue"].readIfPresent() ?? .sdkUnknown("")
        value.position = try reader["position"].readIfPresent() ?? ""
        value.queuePriority = try reader["queuePriority"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.ActionMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.ActionMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.ActionMetadata()
        value.actionType = try reader["actionType"].readIfPresent() ?? ""
        value.programCount = try reader["programCount"].readIfPresent()
        value.executableCount = try reader["executableCount"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.DeviceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.DeviceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.DeviceSummary()
        value.deviceArn = try reader["deviceArn"].readIfPresent() ?? ""
        value.deviceName = try reader["deviceName"].readIfPresent() ?? ""
        value.providerName = try reader["providerName"].readIfPresent() ?? ""
        value.deviceType = try reader["deviceType"].readIfPresent() ?? .sdkUnknown("")
        value.deviceStatus = try reader["deviceStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BraketClientTypes.JobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.JobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.JobSummary()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.device = try reader["device"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BraketClientTypes.QuantumTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.QuantumTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.QuantumTaskSummary()
        value.quantumTaskArn = try reader["quantumTaskArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.deviceArn = try reader["deviceArn"].readIfPresent() ?? ""
        value.shots = try reader["shots"].readIfPresent() ?? 0
        value.outputS3Bucket = try reader["outputS3Bucket"].readIfPresent() ?? ""
        value.outputS3Directory = try reader["outputS3Directory"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BraketClientTypes.ProgramSetValidationFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.ProgramSetValidationFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.ProgramSetValidationFailure()
        value.programIndex = try reader["programIndex"].readIfPresent() ?? 0
        value.inputsIndex = try reader["inputsIndex"].readIfPresent()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BraketClientTypes.SearchDevicesFilter {

    static func write(value: BraketClientTypes.SearchDevicesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BraketClientTypes.SearchJobsFilter {

    static func write(value: BraketClientTypes.SearchJobsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BraketClientTypes.SearchQuantumTasksFilter {

    static func write(value: BraketClientTypes.SearchQuantumTasksFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum BraketClientTypes {}
