//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BraketClientTypes {
    /// The container image used to create an Amazon Braket job.
    public struct ContainerImage {
        /// The URI locating the container image.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension BraketClientTypes {

    public enum CompressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionType] {
            return [
                .gzip,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {
    /// Contains information about the Python scripts used for entry and by an Amazon Braket job.
    public struct ScriptModeConfig {
        /// The type of compression used by the Python scripts for an Amazon Braket job.
        public var compressionType: BraketClientTypes.CompressionType?
        /// The path to the Python script that serves as the entry point for an Amazon Braket job.
        /// This member is required.
        public var entryPoint: Swift.String?
        /// The URI that specifies the S3 path to the Python script module that contains the training script used by an Amazon Braket job.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            compressionType: BraketClientTypes.CompressionType? = nil,
            entryPoint: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.compressionType = compressionType
            self.entryPoint = entryPoint
            self.s3Uri = s3Uri
        }
    }

}

extension BraketClientTypes {
    /// Defines the Amazon Braket job to be created. Specifies the container image the job uses and the paths to the Python scripts used for entry and training.
    public struct AlgorithmSpecification {
        /// The container image used to create an Amazon Braket job.
        public var containerImage: BraketClientTypes.ContainerImage?
        /// Configures the paths to the Python scripts used for entry and training.
        public var scriptModeConfig: BraketClientTypes.ScriptModeConfig?

        public init(
            containerImage: BraketClientTypes.ContainerImage? = nil,
            scriptModeConfig: BraketClientTypes.ScriptModeConfig? = nil
        )
        {
            self.containerImage = containerImage
            self.scriptModeConfig = scriptModeConfig
        }
    }

}

extension BraketClientTypes {

    public enum AssociationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case reservationTimeWindowArn
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationType] {
            return [
                .reservationTimeWindowArn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .reservationTimeWindowArn: return "RESERVATION_TIME_WINDOW_ARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {
    /// The Amazon Braket resource and the association type.
    public struct Association {
        /// The Amazon Braket resource arn.
        /// This member is required.
        public var arn: Swift.String?
        /// The association type for the specified Amazon Braket resource arn.
        /// This member is required.
        public var type: BraketClientTypes.AssociationType?

        public init(
            arn: Swift.String? = nil,
            type: BraketClientTypes.AssociationType? = nil
        )
        {
            self.arn = arn
            self.type = type
        }
    }

}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The throttling rate limit is met.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetDeviceInput {
    /// The ARN of the device to retrieve.
    /// This member is required.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

extension BraketClientTypes {

    public enum QueueName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jobsQueue
        case quantumTasksQueue
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueName] {
            return [
                .jobsQueue,
                .quantumTasksQueue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jobsQueue: return "JOBS_QUEUE"
            case .quantumTasksQueue: return "QUANTUM_TASKS_QUEUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    public enum QueuePriority: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case normal
        case priority
        case sdkUnknown(Swift.String)

        public static var allCases: [QueuePriority] {
            return [
                .normal,
                .priority
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .normal: return "Normal"
            case .priority: return "Priority"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {
    /// Information about tasks and jobs queued on a device.
    public struct DeviceQueueInfo {
        /// The name of the queue.
        /// This member is required.
        public var queue: BraketClientTypes.QueueName?
        /// Optional. Specifies the priority of the queue. Tasks in a priority queue are processed before the tasks in a normal queue.
        public var queuePriority: BraketClientTypes.QueuePriority?
        /// The number of jobs or tasks in the queue for a given device.
        /// This member is required.
        public var queueSize: Swift.String?

        public init(
            queue: BraketClientTypes.QueueName? = nil,
            queuePriority: BraketClientTypes.QueuePriority? = nil,
            queueSize: Swift.String? = nil
        )
        {
            self.queue = queue
            self.queuePriority = queuePriority
            self.queueSize = queueSize
        }
    }

}

extension BraketClientTypes {

    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case offline
        case online
        case retired
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .offline,
                .online,
                .retired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .retired: return "RETIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {

    public enum DeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case qpu
        case simulator
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceType] {
            return [
                .qpu,
                .simulator
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .qpu: return "QPU"
            case .simulator: return "SIMULATOR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDeviceOutput {
    /// The ARN of the device.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// Details about the capabilities of the device.
    /// This member is required.
    public var deviceCapabilities: Swift.String?
    /// The name of the device.
    /// This member is required.
    public var deviceName: Swift.String?
    /// List of information about tasks and jobs queued on a device.
    public var deviceQueueInfo: [BraketClientTypes.DeviceQueueInfo]?
    /// The status of the device.
    /// This member is required.
    public var deviceStatus: BraketClientTypes.DeviceStatus?
    /// The type of the device.
    /// This member is required.
    public var deviceType: BraketClientTypes.DeviceType?
    /// The name of the partner company for the device.
    /// This member is required.
    public var providerName: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        deviceCapabilities: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        deviceQueueInfo: [BraketClientTypes.DeviceQueueInfo]? = nil,
        deviceStatus: BraketClientTypes.DeviceStatus? = nil,
        deviceType: BraketClientTypes.DeviceType? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceCapabilities = deviceCapabilities
        self.deviceName = deviceName
        self.deviceQueueInfo = deviceQueueInfo
        self.deviceStatus = deviceStatus
        self.deviceType = deviceType
        self.providerName = providerName
    }
}

extension BraketClientTypes {
    /// The filter to use for searching devices.
    public struct SearchDevicesFilter {
        /// The name to use to filter results.
        /// This member is required.
        public var name: Swift.String?
        /// The values to use to filter results.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

public struct SearchDevicesInput {
    /// The filter values to use to search for a device.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchDevicesFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        filters: [BraketClientTypes.SearchDevicesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BraketClientTypes {
    /// Includes information about the device.
    public struct DeviceSummary {
        /// The ARN of the device.
        /// This member is required.
        public var deviceArn: Swift.String?
        /// The name of the device.
        /// This member is required.
        public var deviceName: Swift.String?
        /// The status of the device.
        /// This member is required.
        public var deviceStatus: BraketClientTypes.DeviceStatus?
        /// The type of the device.
        /// This member is required.
        public var deviceType: BraketClientTypes.DeviceType?
        /// The provider of the device.
        /// This member is required.
        public var providerName: Swift.String?

        public init(
            deviceArn: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            deviceStatus: BraketClientTypes.DeviceStatus? = nil,
            deviceType: BraketClientTypes.DeviceType? = nil,
            providerName: Swift.String? = nil
        )
        {
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceStatus = deviceStatus
            self.deviceType = deviceType
            self.providerName = providerName
        }
    }

}

public struct SearchDevicesOutput {
    /// An array of DeviceSummary objects for devices that match the specified filter values.
    /// This member is required.
    public var devices: [BraketClientTypes.DeviceSummary]?
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        devices: [BraketClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

/// An error occurred due to a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelJobInput {
    /// The ARN of the Amazon Braket job to cancel.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

extension BraketClientTypes {

    public enum CancellationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case sdkUnknown(Swift.String)

        public static var allCases: [CancellationStatus] {
            return [
                .cancelled,
                .cancelling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelJobOutput {
    /// The status of the job cancellation request.
    /// This member is required.
    public var cancellationStatus: BraketClientTypes.CancellationStatus?
    /// The ARN of the Amazon Braket job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        cancellationStatus: BraketClientTypes.CancellationStatus? = nil,
        jobArn: Swift.String? = nil
    )
    {
        self.cancellationStatus = cancellationStatus
        self.jobArn = jobArn
    }
}

/// The specified device is currently offline.
public struct DeviceOfflineException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeviceOfflineException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified device has been retired.
public struct DeviceRetiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeviceRetiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request failed because a service quota is exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BraketClientTypes {
    /// Contains information about the output locations for job checkpoint data.
    public struct JobCheckpointConfig {
        /// (Optional) The local directory where checkpoints are written. The default directory is /opt/braket/checkpoints/.
        public var localPath: Swift.String?
        /// Identifies the S3 path where you want Amazon Braket to store checkpoints. For example, s3://bucket-name/key-name-prefix.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            localPath: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.localPath = localPath
            self.s3Uri = s3Uri
        }
    }

}

extension BraketClientTypes {
    /// Configures the quantum processing units (QPUs) or simulator used to create and run an Amazon Braket job.
    public struct DeviceConfig {
        /// The primary quantum processing unit (QPU) or simulator used to create and run an Amazon Braket job.
        /// This member is required.
        public var device: Swift.String?

        public init(
            device: Swift.String? = nil
        )
        {
            self.device = device
        }
    }

}

extension BraketClientTypes {
    /// Information about the data stored in Amazon S3 used by the Amazon Braket job.
    public struct S3DataSource {
        /// Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest that locates the S3 data source.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BraketClientTypes {
    /// Information about the source of the data used by the Amazon Braket job.
    public struct DataSource {
        /// Information about the data stored in Amazon S3 used by the Amazon Braket job.
        /// This member is required.
        public var s3DataSource: BraketClientTypes.S3DataSource?

        public init(
            s3DataSource: BraketClientTypes.S3DataSource? = nil
        )
        {
            self.s3DataSource = s3DataSource
        }
    }

}

extension BraketClientTypes {
    /// A list of parameters that specify the input channels, type of input data, and where it is located.
    public struct InputFileConfig {
        /// A named input source that an Amazon Braket job can consume.
        /// This member is required.
        public var channelName: Swift.String?
        /// The MIME type of the data.
        public var contentType: Swift.String?
        /// The location of the channel data.
        /// This member is required.
        public var dataSource: BraketClientTypes.DataSource?

        public init(
            channelName: Swift.String? = nil,
            contentType: Swift.String? = nil,
            dataSource: BraketClientTypes.DataSource? = nil
        )
        {
            self.channelName = channelName
            self.contentType = contentType
            self.dataSource = dataSource
        }
    }

}

extension BraketClientTypes {

    public enum InstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mlC42xlarge
        case mlC44xlarge
        case mlC48xlarge
        case mlC4Xlarge
        case mlC5n18xlarge
        case mlC5n2xlarge
        case mlC5n4xlarge
        case mlC5n9xlarge
        case mlC5nXlarge
        case mlC518xlarge
        case mlC52xlarge
        case mlC54xlarge
        case mlC59xlarge
        case mlC5Xlarge
        case mlG4dn12xlarge
        case mlG4dn16xlarge
        case mlG4dn2xlarge
        case mlG4dn4xlarge
        case mlG4dn8xlarge
        case mlG4dnXlarge
        case mlM410xlarge
        case mlM416xlarge
        case mlM42xlarge
        case mlM44xlarge
        case mlM4Xlarge
        case mlM512xlarge
        case mlM524xlarge
        case mlM52xlarge
        case mlM54xlarge
        case mlM5Large
        case mlM5Xlarge
        case mlP216xlarge
        case mlP28xlarge
        case mlP2Xlarge
        case mlP3dn24xlarge
        case mlP316xlarge
        case mlP32xlarge
        case mlP38xlarge
        case mlP4d24xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceType] {
            return [
                .mlC42xlarge,
                .mlC44xlarge,
                .mlC48xlarge,
                .mlC4Xlarge,
                .mlC5n18xlarge,
                .mlC5n2xlarge,
                .mlC5n4xlarge,
                .mlC5n9xlarge,
                .mlC5nXlarge,
                .mlC518xlarge,
                .mlC52xlarge,
                .mlC54xlarge,
                .mlC59xlarge,
                .mlC5Xlarge,
                .mlG4dn12xlarge,
                .mlG4dn16xlarge,
                .mlG4dn2xlarge,
                .mlG4dn4xlarge,
                .mlG4dn8xlarge,
                .mlG4dnXlarge,
                .mlM410xlarge,
                .mlM416xlarge,
                .mlM42xlarge,
                .mlM44xlarge,
                .mlM4Xlarge,
                .mlM512xlarge,
                .mlM524xlarge,
                .mlM52xlarge,
                .mlM54xlarge,
                .mlM5Large,
                .mlM5Xlarge,
                .mlP216xlarge,
                .mlP28xlarge,
                .mlP2Xlarge,
                .mlP3dn24xlarge,
                .mlP316xlarge,
                .mlP32xlarge,
                .mlP38xlarge,
                .mlP4d24xlarge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mlC42xlarge: return "ml.c4.2xlarge"
            case .mlC44xlarge: return "ml.c4.4xlarge"
            case .mlC48xlarge: return "ml.c4.8xlarge"
            case .mlC4Xlarge: return "ml.c4.xlarge"
            case .mlC5n18xlarge: return "ml.c5n.18xlarge"
            case .mlC5n2xlarge: return "ml.c5n.2xlarge"
            case .mlC5n4xlarge: return "ml.c5n.4xlarge"
            case .mlC5n9xlarge: return "ml.c5n.9xlarge"
            case .mlC5nXlarge: return "ml.c5n.xlarge"
            case .mlC518xlarge: return "ml.c5.18xlarge"
            case .mlC52xlarge: return "ml.c5.2xlarge"
            case .mlC54xlarge: return "ml.c5.4xlarge"
            case .mlC59xlarge: return "ml.c5.9xlarge"
            case .mlC5Xlarge: return "ml.c5.xlarge"
            case .mlG4dn12xlarge: return "ml.g4dn.12xlarge"
            case .mlG4dn16xlarge: return "ml.g4dn.16xlarge"
            case .mlG4dn2xlarge: return "ml.g4dn.2xlarge"
            case .mlG4dn4xlarge: return "ml.g4dn.4xlarge"
            case .mlG4dn8xlarge: return "ml.g4dn.8xlarge"
            case .mlG4dnXlarge: return "ml.g4dn.xlarge"
            case .mlM410xlarge: return "ml.m4.10xlarge"
            case .mlM416xlarge: return "ml.m4.16xlarge"
            case .mlM42xlarge: return "ml.m4.2xlarge"
            case .mlM44xlarge: return "ml.m4.4xlarge"
            case .mlM4Xlarge: return "ml.m4.xlarge"
            case .mlM512xlarge: return "ml.m5.12xlarge"
            case .mlM524xlarge: return "ml.m5.24xlarge"
            case .mlM52xlarge: return "ml.m5.2xlarge"
            case .mlM54xlarge: return "ml.m5.4xlarge"
            case .mlM5Large: return "ml.m5.large"
            case .mlM5Xlarge: return "ml.m5.xlarge"
            case .mlP216xlarge: return "ml.p2.16xlarge"
            case .mlP28xlarge: return "ml.p2.8xlarge"
            case .mlP2Xlarge: return "ml.p2.xlarge"
            case .mlP3dn24xlarge: return "ml.p3dn.24xlarge"
            case .mlP316xlarge: return "ml.p3.16xlarge"
            case .mlP32xlarge: return "ml.p3.2xlarge"
            case .mlP38xlarge: return "ml.p3.8xlarge"
            case .mlP4d24xlarge: return "ml.p4d.24xlarge"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {
    /// Configures the resource instances to use while running the Amazon Braket hybrid job on Amazon Braket.
    public struct InstanceConfig {
        /// Configures the number of resource instances to use while running an Amazon Braket job on Amazon Braket. The default value is 1.
        public var instanceCount: Swift.Int?
        /// Configures the type resource instances to use while running an Amazon Braket hybrid job.
        /// This member is required.
        public var instanceType: BraketClientTypes.InstanceType?
        /// The size of the storage volume, in GB, that user wants to provision.
        /// This member is required.
        public var volumeSizeInGb: Swift.Int?

        public init(
            instanceCount: Swift.Int? = nil,
            instanceType: BraketClientTypes.InstanceType? = nil,
            volumeSizeInGb: Swift.Int? = nil
        )
        {
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.volumeSizeInGb = volumeSizeInGb
        }
    }

}

extension BraketClientTypes {
    /// Specifies the path to the S3 location where you want to store job artifacts and the encryption key used to store them.
    public struct JobOutputDataConfig {
        /// The AWS Key Management Service (AWS KMS) key that Amazon Braket uses to encrypt the job training artifacts at rest using Amazon S3 server-side encryption.
        public var kmsKeyId: Swift.String?
        /// Identifies the S3 path where you want Amazon Braket to store the job training artifacts. For example, s3://bucket-name/key-name-prefix.
        /// This member is required.
        public var s3Path: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            s3Path: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Path = s3Path
        }
    }

}

extension BraketClientTypes {
    /// Specifies limits for how long an Amazon Braket job can run.
    public struct JobStoppingCondition {
        /// The maximum length of time, in seconds, that an Amazon Braket job can run.
        public var maxRuntimeInSeconds: Swift.Int?

        public init(
            maxRuntimeInSeconds: Swift.Int? = nil
        )
        {
            self.maxRuntimeInSeconds = maxRuntimeInSeconds
        }
    }

}

public struct CreateJobInput {
    /// Definition of the Amazon Braket job to be created. Specifies the container image the job uses and information about the Python scripts used for entry and training.
    /// This member is required.
    public var algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    /// The list of Amazon Braket resources associated with the hybrid job.
    public var associations: [BraketClientTypes.Association]?
    /// Information about the output locations for job checkpoint data.
    public var checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    /// A unique token that guarantees that the call to this API is idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The quantum processing unit (QPU) or simulator used to create an Amazon Braket job.
    /// This member is required.
    public var deviceConfig: BraketClientTypes.DeviceConfig?
    /// Algorithm-specific parameters used by an Amazon Braket job that influence the quality of the training job. The values are set with a string of JSON key:value pairs, where the key is the name of the hyperparameter and the value is the value of th hyperparameter.
    public var hyperParameters: [Swift.String: Swift.String]?
    /// A list of parameters that specify the name and type of input data and where it is located.
    public var inputDataConfig: [BraketClientTypes.InputFileConfig]?
    /// Configuration of the resource instances to use while running the hybrid job on Amazon Braket.
    /// This member is required.
    public var instanceConfig: BraketClientTypes.InstanceConfig?
    /// The name of the Amazon Braket job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the S3 location where you want to store job artifacts and the encryption key used to store them.
    /// This member is required.
    public var outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can assume to perform tasks on behalf of a user. It can access user resources, run an Amazon Braket job container on behalf of user, and output resources to the users' s3 buckets.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The user-defined criteria that specifies when a job stops running.
    public var stoppingCondition: BraketClientTypes.JobStoppingCondition?
    /// A tag object that consists of a key and an optional value, used to manage metadata for Amazon Braket resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        algorithmSpecification: BraketClientTypes.AlgorithmSpecification? = nil,
        associations: [BraketClientTypes.Association]? = nil,
        checkpointConfig: BraketClientTypes.JobCheckpointConfig? = nil,
        clientToken: Swift.String? = nil,
        deviceConfig: BraketClientTypes.DeviceConfig? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        inputDataConfig: [BraketClientTypes.InputFileConfig]? = nil,
        instanceConfig: BraketClientTypes.InstanceConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: BraketClientTypes.JobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        stoppingCondition: BraketClientTypes.JobStoppingCondition? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.algorithmSpecification = algorithmSpecification
        self.associations = associations
        self.checkpointConfig = checkpointConfig
        self.clientToken = clientToken
        self.deviceConfig = deviceConfig
        self.hyperParameters = hyperParameters
        self.inputDataConfig = inputDataConfig
        self.instanceConfig = instanceConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.stoppingCondition = stoppingCondition
        self.tags = tags
    }
}

public struct CreateJobOutput {
    /// The ARN of the Amazon Braket job created.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

extension BraketClientTypes {

    public enum HybridJobAdditionalAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case queueInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [HybridJobAdditionalAttributeName] {
            return [
                .queueInfo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .queueInfo: return "QueueInfo"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetJobInput {
    /// A list of attributes to return information for.
    public var additionalAttributeNames: [BraketClientTypes.HybridJobAdditionalAttributeName]?
    /// The ARN of the job to retrieve.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        additionalAttributeNames: [BraketClientTypes.HybridJobAdditionalAttributeName]? = nil,
        jobArn: Swift.String? = nil
    )
    {
        self.additionalAttributeNames = additionalAttributeNames
        self.jobArn = jobArn
    }
}

extension BraketClientTypes {

    public enum JobEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case deprioritizedDueToInactivity
        case downloadingData
        case failed
        case maxRuntimeExceeded
        case queuedForExecution
        case running
        case startingInstance
        case uploadingResults
        case waitingForPriority
        case sdkUnknown(Swift.String)

        public static var allCases: [JobEventType] {
            return [
                .cancelled,
                .completed,
                .deprioritizedDueToInactivity,
                .downloadingData,
                .failed,
                .maxRuntimeExceeded,
                .queuedForExecution,
                .running,
                .startingInstance,
                .uploadingResults,
                .waitingForPriority
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .deprioritizedDueToInactivity: return "DEPRIORITIZED_DUE_TO_INACTIVITY"
            case .downloadingData: return "DOWNLOADING_DATA"
            case .failed: return "FAILED"
            case .maxRuntimeExceeded: return "MAX_RUNTIME_EXCEEDED"
            case .queuedForExecution: return "QUEUED_FOR_EXECUTION"
            case .running: return "RUNNING"
            case .startingInstance: return "STARTING_INSTANCE"
            case .uploadingResults: return "UPLOADING_RESULTS"
            case .waitingForPriority: return "WAITING_FOR_PRIORITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {
    /// Details about the type and time events occurred related to the Amazon Braket job.
    public struct JobEventDetails {
        /// The type of event that occurred related to the Amazon Braket job.
        public var eventType: BraketClientTypes.JobEventType?
        /// A message describing the event that occurred related to the Amazon Braket job.
        public var message: Swift.String?
        /// The type of event that occurred related to the Amazon Braket job.
        public var timeOfEvent: Foundation.Date?

        public init(
            eventType: BraketClientTypes.JobEventType? = nil,
            message: Swift.String? = nil,
            timeOfEvent: Foundation.Date? = nil
        )
        {
            self.eventType = eventType
            self.message = message
            self.timeOfEvent = timeOfEvent
        }
    }

}

extension BraketClientTypes {
    /// Information about the queue for a specified job.
    public struct HybridJobQueueInfo {
        /// Optional. Provides more information about the queue position. For example, if the job is complete and no longer in the queue, the message field contains that information.
        public var message: Swift.String?
        /// Current position of the job in the jobs queue.
        /// This member is required.
        public var position: Swift.String?
        /// The name of the queue.
        /// This member is required.
        public var queue: BraketClientTypes.QueueName?

        public init(
            message: Swift.String? = nil,
            position: Swift.String? = nil,
            queue: BraketClientTypes.QueueName? = nil
        )
        {
            self.message = message
            self.position = position
            self.queue = queue
        }
    }

}

extension BraketClientTypes {

    public enum JobPrimaryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [JobPrimaryStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .queued,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetJobOutput {
    /// Definition of the Amazon Braket job created. Specifies the container image the job uses, information about the Python scripts used for entry and training, and the user-defined metrics used to evaluation the job.
    /// This member is required.
    public var algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    /// The list of Amazon Braket resources associated with the hybrid job.
    public var associations: [BraketClientTypes.Association]?
    /// The billable time the Amazon Braket job used to complete.
    public var billableDuration: Swift.Int?
    /// Information about the output locations for job checkpoint data.
    public var checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    /// The date and time that the Amazon Braket job was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The quantum processing unit (QPU) or simulator used to run the Amazon Braket job.
    public var deviceConfig: BraketClientTypes.DeviceConfig?
    /// The date and time that the Amazon Braket job ended.
    public var endedAt: Foundation.Date?
    /// Details about the type and time events occurred related to the Amazon Braket job.
    public var events: [BraketClientTypes.JobEventDetails]?
    /// A description of the reason why an Amazon Braket job failed, if it failed.
    public var failureReason: Swift.String?
    /// Algorithm-specific parameters used by an Amazon Braket job that influence the quality of the traiing job. The values are set with a string of JSON key:value pairs, where the key is the name of the hyperparameter and the value is the value of th hyperparameter.
    public var hyperParameters: [Swift.String: Swift.String]?
    /// A list of parameters that specify the name and type of input data and where it is located.
    public var inputDataConfig: [BraketClientTypes.InputFileConfig]?
    /// The resource instances to use while running the hybrid job on Amazon Braket.
    /// This member is required.
    public var instanceConfig: BraketClientTypes.InstanceConfig?
    /// The ARN of the Amazon Braket job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The name of the Amazon Braket job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the S3 location where job artifacts are stored and the encryption key used to store them there.
    /// This member is required.
    public var outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    /// Queue information for the requested job. Only returned if QueueInfo is specified in the additionalAttributeNames" field in the GetJob API request.
    public var queueInfo: BraketClientTypes.HybridJobQueueInfo?
    /// The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can assume to perform tasks on behalf of a user. It can access user resources, run an Amazon Braket job container on behalf of user, and output resources to the s3 buckets of a user.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The date and time that the Amazon Braket job was started.
    public var startedAt: Foundation.Date?
    /// The status of the Amazon Braket job.
    /// This member is required.
    public var status: BraketClientTypes.JobPrimaryStatus?
    /// The user-defined criteria that specifies when to stop a job running.
    public var stoppingCondition: BraketClientTypes.JobStoppingCondition?
    /// A tag object that consists of a key and an optional value, used to manage metadata for Amazon Braket resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        algorithmSpecification: BraketClientTypes.AlgorithmSpecification? = nil,
        associations: [BraketClientTypes.Association]? = nil,
        billableDuration: Swift.Int? = nil,
        checkpointConfig: BraketClientTypes.JobCheckpointConfig? = nil,
        createdAt: Foundation.Date? = nil,
        deviceConfig: BraketClientTypes.DeviceConfig? = nil,
        endedAt: Foundation.Date? = nil,
        events: [BraketClientTypes.JobEventDetails]? = nil,
        failureReason: Swift.String? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        inputDataConfig: [BraketClientTypes.InputFileConfig]? = nil,
        instanceConfig: BraketClientTypes.InstanceConfig? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: BraketClientTypes.JobOutputDataConfig? = nil,
        queueInfo: BraketClientTypes.HybridJobQueueInfo? = nil,
        roleArn: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: BraketClientTypes.JobPrimaryStatus? = nil,
        stoppingCondition: BraketClientTypes.JobStoppingCondition? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.algorithmSpecification = algorithmSpecification
        self.associations = associations
        self.billableDuration = billableDuration
        self.checkpointConfig = checkpointConfig
        self.createdAt = createdAt
        self.deviceConfig = deviceConfig
        self.endedAt = endedAt
        self.events = events
        self.failureReason = failureReason
        self.hyperParameters = hyperParameters
        self.inputDataConfig = inputDataConfig
        self.instanceConfig = instanceConfig
        self.jobArn = jobArn
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.queueInfo = queueInfo
        self.roleArn = roleArn
        self.startedAt = startedAt
        self.status = status
        self.stoppingCondition = stoppingCondition
        self.tags = tags
    }
}

extension BraketClientTypes {

    public enum SearchJobsFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case between
        case contains
        case equal
        case gt
        case gte
        case lt
        case lte
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchJobsFilterOperator] {
            return [
                .between,
                .contains,
                .equal,
                .gt,
                .gte,
                .lt,
                .lte
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .equal: return "EQUAL"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .lt: return "LT"
            case .lte: return "LTE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {
    /// A filter used to search for Amazon Braket jobs.
    public struct SearchJobsFilter {
        /// The name to use for the jobs filter.
        /// This member is required.
        public var name: Swift.String?
        /// An operator to use for the jobs filter.
        /// This member is required.
        public var `operator`: BraketClientTypes.SearchJobsFilterOperator?
        /// The values to use for the jobs filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            `operator`: BraketClientTypes.SearchJobsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

public struct SearchJobsInput {
    /// The filter values to use when searching for a job.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchJobsFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request to continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        filters: [BraketClientTypes.SearchJobsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BraketClientTypes {
    /// Provides summary information about an Amazon Braket job.
    public struct JobSummary {
        /// The date and time that the Amazon Braket job was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Provides summary information about the primary device used by an Amazon Braket job.
        /// This member is required.
        public var device: Swift.String?
        /// The date and time that the Amazon Braket job ended.
        public var endedAt: Foundation.Date?
        /// The ARN of the Amazon Braket job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name of the Amazon Braket job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The date and time that the Amazon Braket job was started.
        public var startedAt: Foundation.Date?
        /// The status of the Amazon Braket job.
        /// This member is required.
        public var status: BraketClientTypes.JobPrimaryStatus?
        /// A tag object that consists of a key and an optional value, used to manage metadata for Amazon Braket resources.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            device: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            status: BraketClientTypes.JobPrimaryStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.device = device
            self.endedAt = endedAt
            self.jobArn = jobArn
            self.jobName = jobName
            self.startedAt = startedAt
            self.status = status
            self.tags = tags
        }
    }

}

public struct SearchJobsOutput {
    /// An array of JobSummary objects for devices that match the specified filter values.
    /// This member is required.
    public var jobs: [BraketClientTypes.JobSummary]?
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        jobs: [BraketClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// Specify the resourceArn for the resource whose tags to display.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// Displays the key, value pairs of tags associated with this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct CancelQuantumTaskInput {
    /// The client token associated with the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ARN of the task to cancel.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.quantumTaskArn = quantumTaskArn
    }
}

public struct CancelQuantumTaskOutput {
    /// The status of the cancellation request.
    /// This member is required.
    public var cancellationStatus: BraketClientTypes.CancellationStatus?
    /// The ARN of the task.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        cancellationStatus: BraketClientTypes.CancellationStatus? = nil,
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.cancellationStatus = cancellationStatus
        self.quantumTaskArn = quantumTaskArn
    }
}

public struct CreateQuantumTaskInput {
    /// The action associated with the task.
    /// This member is required.
    public var action: Swift.String?
    /// The list of Amazon Braket resources associated with the quantum task.
    public var associations: [BraketClientTypes.Association]?
    /// The client token associated with the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ARN of the device to run the task on.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The parameters for the device to run the task on.
    public var deviceParameters: Swift.String?
    /// The token for an Amazon Braket job that associates it with the quantum task.
    public var jobToken: Swift.String?
    /// The S3 bucket to store task result files in.
    /// This member is required.
    public var outputS3Bucket: Swift.String?
    /// The key prefix for the location in the S3 bucket to store task results in.
    /// This member is required.
    public var outputS3KeyPrefix: Swift.String?
    /// The number of shots to use for the task.
    /// This member is required.
    public var shots: Swift.Int?
    /// Tags to be added to the quantum task you're creating.
    public var tags: [Swift.String: Swift.String]?

    public init(
        action: Swift.String? = nil,
        associations: [BraketClientTypes.Association]? = nil,
        clientToken: Swift.String? = nil,
        deviceArn: Swift.String? = nil,
        deviceParameters: Swift.String? = nil,
        jobToken: Swift.String? = nil,
        outputS3Bucket: Swift.String? = nil,
        outputS3KeyPrefix: Swift.String? = nil,
        shots: Swift.Int? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.action = action
        self.associations = associations
        self.clientToken = clientToken
        self.deviceArn = deviceArn
        self.deviceParameters = deviceParameters
        self.jobToken = jobToken
        self.outputS3Bucket = outputS3Bucket
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.shots = shots
        self.tags = tags
    }
}

public struct CreateQuantumTaskOutput {
    /// The ARN of the task created by the request.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.quantumTaskArn = quantumTaskArn
    }
}

extension BraketClientTypes {

    public enum QuantumTaskAdditionalAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case queueInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [QuantumTaskAdditionalAttributeName] {
            return [
                .queueInfo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .queueInfo: return "QueueInfo"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQuantumTaskInput {
    /// A list of attributes to return information for.
    public var additionalAttributeNames: [BraketClientTypes.QuantumTaskAdditionalAttributeName]?
    /// The ARN of the task to retrieve.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        additionalAttributeNames: [BraketClientTypes.QuantumTaskAdditionalAttributeName]? = nil,
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.additionalAttributeNames = additionalAttributeNames
        self.quantumTaskArn = quantumTaskArn
    }
}

extension BraketClientTypes {
    /// Information about the queue for the specified quantum task.
    public struct QuantumTaskQueueInfo {
        /// Optional. Provides more information about the queue position. For example, if the task is complete and no longer in the queue, the message field contains that information.
        public var message: Swift.String?
        /// Current position of the task in the quantum tasks queue.
        /// This member is required.
        public var position: Swift.String?
        /// The name of the queue.
        /// This member is required.
        public var queue: BraketClientTypes.QueueName?
        /// Optional. Specifies the priority of the queue. Quantum tasks in a priority queue are processed before the tasks in a normal queue.
        public var queuePriority: BraketClientTypes.QueuePriority?

        public init(
            message: Swift.String? = nil,
            position: Swift.String? = nil,
            queue: BraketClientTypes.QueueName? = nil,
            queuePriority: BraketClientTypes.QueuePriority? = nil
        )
        {
            self.message = message
            self.position = position
            self.queue = queue
            self.queuePriority = queuePriority
        }
    }

}

extension BraketClientTypes {

    public enum QuantumTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case created
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [QuantumTaskStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .created,
                .failed,
                .queued,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQuantumTaskOutput {
    /// The list of Amazon Braket resources associated with the quantum task.
    public var associations: [BraketClientTypes.Association]?
    /// The time at which the task was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ARN of the device the task was run on.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The parameters for the device on which the task ran.
    /// This member is required.
    public var deviceParameters: Swift.String?
    /// The time at which the task ended.
    public var endedAt: Foundation.Date?
    /// The reason that a task failed.
    public var failureReason: Swift.String?
    /// The ARN of the Amazon Braket job associated with the quantum task.
    public var jobArn: Swift.String?
    /// The S3 bucket where task results are stored.
    /// This member is required.
    public var outputS3Bucket: Swift.String?
    /// The folder in the S3 bucket where task results are stored.
    /// This member is required.
    public var outputS3Directory: Swift.String?
    /// The ARN of the task.
    /// This member is required.
    public var quantumTaskArn: Swift.String?
    /// Queue information for the requested quantum task. Only returned if QueueInfo is specified in the additionalAttributeNames" field in the GetQuantumTask API request.
    public var queueInfo: BraketClientTypes.QuantumTaskQueueInfo?
    /// The number of shots used in the task.
    /// This member is required.
    public var shots: Swift.Int?
    /// The status of the task.
    /// This member is required.
    public var status: BraketClientTypes.QuantumTaskStatus?
    /// The tags that belong to this task.
    public var tags: [Swift.String: Swift.String]?

    public init(
        associations: [BraketClientTypes.Association]? = nil,
        createdAt: Foundation.Date? = nil,
        deviceArn: Swift.String? = nil,
        deviceParameters: Swift.String? = nil,
        endedAt: Foundation.Date? = nil,
        failureReason: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        outputS3Bucket: Swift.String? = nil,
        outputS3Directory: Swift.String? = nil,
        quantumTaskArn: Swift.String? = nil,
        queueInfo: BraketClientTypes.QuantumTaskQueueInfo? = nil,
        shots: Swift.Int? = nil,
        status: BraketClientTypes.QuantumTaskStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.associations = associations
        self.createdAt = createdAt
        self.deviceArn = deviceArn
        self.deviceParameters = deviceParameters
        self.endedAt = endedAt
        self.failureReason = failureReason
        self.jobArn = jobArn
        self.outputS3Bucket = outputS3Bucket
        self.outputS3Directory = outputS3Directory
        self.quantumTaskArn = quantumTaskArn
        self.queueInfo = queueInfo
        self.shots = shots
        self.status = status
        self.tags = tags
    }
}

extension BraketClientTypes {

    public enum SearchQuantumTasksFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case between
        case equal
        case gt
        case gte
        case lt
        case lte
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchQuantumTasksFilterOperator] {
            return [
                .between,
                .equal,
                .gt,
                .gte,
                .lt,
                .lte
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .equal: return "EQUAL"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .lt: return "LT"
            case .lte: return "LTE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BraketClientTypes {
    /// A filter to use to search for tasks.
    public struct SearchQuantumTasksFilter {
        /// The name of the device used for the task.
        /// This member is required.
        public var name: Swift.String?
        /// An operator to use in the filter.
        /// This member is required.
        public var `operator`: BraketClientTypes.SearchQuantumTasksFilterOperator?
        /// The values to use for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            `operator`: BraketClientTypes.SearchQuantumTasksFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

public struct SearchQuantumTasksInput {
    /// Array of SearchQuantumTasksFilter objects.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchQuantumTasksFilter]?
    /// Maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        filters: [BraketClientTypes.SearchQuantumTasksFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BraketClientTypes {
    /// Includes information about a quantum task.
    public struct QuantumTaskSummary {
        /// The time at which the task was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The ARN of the device the task ran on.
        /// This member is required.
        public var deviceArn: Swift.String?
        /// The time at which the task finished.
        public var endedAt: Foundation.Date?
        /// The S3 bucket where the task result file is stored..
        /// This member is required.
        public var outputS3Bucket: Swift.String?
        /// The folder in the S3 bucket where the task result file is stored.
        /// This member is required.
        public var outputS3Directory: Swift.String?
        /// The ARN of the task.
        /// This member is required.
        public var quantumTaskArn: Swift.String?
        /// The shots used for the task.
        /// This member is required.
        public var shots: Swift.Int?
        /// The status of the task.
        /// This member is required.
        public var status: BraketClientTypes.QuantumTaskStatus?
        /// Displays the key, value pairs of tags associated with this quantum task.
        public var tags: [Swift.String: Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            deviceArn: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            outputS3Bucket: Swift.String? = nil,
            outputS3Directory: Swift.String? = nil,
            quantumTaskArn: Swift.String? = nil,
            shots: Swift.Int? = nil,
            status: BraketClientTypes.QuantumTaskStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.deviceArn = deviceArn
            self.endedAt = endedAt
            self.outputS3Bucket = outputS3Bucket
            self.outputS3Directory = outputS3Directory
            self.quantumTaskArn = quantumTaskArn
            self.shots = shots
            self.status = status
            self.tags = tags
        }
    }

}

public struct SearchQuantumTasksOutput {
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.
    public var nextToken: Swift.String?
    /// An array of QuantumTaskSummary objects for tasks that match the specified filters.
    /// This member is required.
    public var quantumTasks: [BraketClientTypes.QuantumTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        quantumTasks: [BraketClientTypes.QuantumTaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quantumTasks = quantumTasks
    }
}

public struct TagResourceInput {
    /// Specify the resourceArn of the resource to which a tag will be added.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specify the tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// Specify the resourceArn for the resource from which to remove the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specify the keys for the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension CancelJobInput {

    static func urlPathProvider(_ value: CancelJobInput) -> Swift.String? {
        guard let jobArn = value.jobArn else {
            return nil
        }
        return "/job/\(jobArn.urlPercentEncoding())/cancel"
    }
}

extension CancelQuantumTaskInput {

    static func urlPathProvider(_ value: CancelQuantumTaskInput) -> Swift.String? {
        guard let quantumTaskArn = value.quantumTaskArn else {
            return nil
        }
        return "/quantum-task/\(quantumTaskArn.urlPercentEncoding())/cancel"
    }
}

extension CreateJobInput {

    static func urlPathProvider(_ value: CreateJobInput) -> Swift.String? {
        return "/job"
    }
}

extension CreateQuantumTaskInput {

    static func urlPathProvider(_ value: CreateQuantumTaskInput) -> Swift.String? {
        return "/quantum-task"
    }
}

extension GetDeviceInput {

    static func urlPathProvider(_ value: GetDeviceInput) -> Swift.String? {
        guard let deviceArn = value.deviceArn else {
            return nil
        }
        return "/device/\(deviceArn.urlPercentEncoding())"
    }
}

extension GetJobInput {

    static func urlPathProvider(_ value: GetJobInput) -> Swift.String? {
        guard let jobArn = value.jobArn else {
            return nil
        }
        return "/job/\(jobArn.urlPercentEncoding())"
    }
}

extension GetJobInput {

    static func queryItemProvider(_ value: GetJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let additionalAttributeNames = value.additionalAttributeNames {
            additionalAttributeNames.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "additionalAttributeNames".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetQuantumTaskInput {

    static func urlPathProvider(_ value: GetQuantumTaskInput) -> Swift.String? {
        guard let quantumTaskArn = value.quantumTaskArn else {
            return nil
        }
        return "/quantum-task/\(quantumTaskArn.urlPercentEncoding())"
    }
}

extension GetQuantumTaskInput {

    static func queryItemProvider(_ value: GetQuantumTaskInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let additionalAttributeNames = value.additionalAttributeNames {
            additionalAttributeNames.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "additionalAttributeNames".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension SearchDevicesInput {

    static func urlPathProvider(_ value: SearchDevicesInput) -> Swift.String? {
        return "/devices"
    }
}

extension SearchJobsInput {

    static func urlPathProvider(_ value: SearchJobsInput) -> Swift.String? {
        return "/jobs"
    }
}

extension SearchQuantumTasksInput {

    static func urlPathProvider(_ value: SearchQuantumTasksInput) -> Swift.String? {
        return "/quantum-tasks"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension CancelQuantumTaskInput {

    static func write(value: CancelQuantumTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension CreateJobInput {

    static func write(value: CreateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["algorithmSpecification"].write(value.algorithmSpecification, with: BraketClientTypes.AlgorithmSpecification.write(value:to:))
        try writer["associations"].writeList(value.associations, memberWritingClosure: BraketClientTypes.Association.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["checkpointConfig"].write(value.checkpointConfig, with: BraketClientTypes.JobCheckpointConfig.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["deviceConfig"].write(value.deviceConfig, with: BraketClientTypes.DeviceConfig.write(value:to:))
        try writer["hyperParameters"].writeMap(value.hyperParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["inputDataConfig"].writeList(value.inputDataConfig, memberWritingClosure: BraketClientTypes.InputFileConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["instanceConfig"].write(value.instanceConfig, with: BraketClientTypes.InstanceConfig.write(value:to:))
        try writer["jobName"].write(value.jobName)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BraketClientTypes.JobOutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["stoppingCondition"].write(value.stoppingCondition, with: BraketClientTypes.JobStoppingCondition.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateQuantumTaskInput {

    static func write(value: CreateQuantumTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["associations"].writeList(value.associations, memberWritingClosure: BraketClientTypes.Association.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["deviceArn"].write(value.deviceArn)
        try writer["deviceParameters"].write(value.deviceParameters)
        try writer["jobToken"].write(value.jobToken)
        try writer["outputS3Bucket"].write(value.outputS3Bucket)
        try writer["outputS3KeyPrefix"].write(value.outputS3KeyPrefix)
        try writer["shots"].write(value.shots)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension SearchDevicesInput {

    static func write(value: SearchDevicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: BraketClientTypes.SearchDevicesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SearchJobsInput {

    static func write(value: SearchJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: BraketClientTypes.SearchJobsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SearchQuantumTasksInput {

    static func write(value: SearchQuantumTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: BraketClientTypes.SearchQuantumTasksFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CancelJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelJobOutput()
        value.cancellationStatus = try reader["cancellationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CancelQuantumTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelQuantumTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelQuantumTaskOutput()
        value.cancellationStatus = try reader["cancellationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.quantumTaskArn = try reader["quantumTaskArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateQuantumTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQuantumTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateQuantumTaskOutput()
        value.quantumTaskArn = try reader["quantumTaskArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceOutput()
        value.deviceArn = try reader["deviceArn"].readIfPresent() ?? ""
        value.deviceCapabilities = try reader["deviceCapabilities"].readIfPresent() ?? ""
        value.deviceName = try reader["deviceName"].readIfPresent() ?? ""
        value.deviceQueueInfo = try reader["deviceQueueInfo"].readListIfPresent(memberReadingClosure: BraketClientTypes.DeviceQueueInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deviceStatus = try reader["deviceStatus"].readIfPresent() ?? .sdkUnknown("")
        value.deviceType = try reader["deviceType"].readIfPresent() ?? .sdkUnknown("")
        value.providerName = try reader["providerName"].readIfPresent() ?? ""
        return value
    }
}

extension GetJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobOutput()
        value.algorithmSpecification = try reader["algorithmSpecification"].readIfPresent(with: BraketClientTypes.AlgorithmSpecification.read(from:))
        value.associations = try reader["associations"].readListIfPresent(memberReadingClosure: BraketClientTypes.Association.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.billableDuration = try reader["billableDuration"].readIfPresent()
        value.checkpointConfig = try reader["checkpointConfig"].readIfPresent(with: BraketClientTypes.JobCheckpointConfig.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deviceConfig = try reader["deviceConfig"].readIfPresent(with: BraketClientTypes.DeviceConfig.read(from:))
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: BraketClientTypes.JobEventDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.hyperParameters = try reader["hyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.inputDataConfig = try reader["inputDataConfig"].readListIfPresent(memberReadingClosure: BraketClientTypes.InputFileConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceConfig = try reader["instanceConfig"].readIfPresent(with: BraketClientTypes.InstanceConfig.read(from:))
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BraketClientTypes.JobOutputDataConfig.read(from:))
        value.queueInfo = try reader["queueInfo"].readIfPresent(with: BraketClientTypes.HybridJobQueueInfo.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.stoppingCondition = try reader["stoppingCondition"].readIfPresent(with: BraketClientTypes.JobStoppingCondition.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetQuantumTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQuantumTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQuantumTaskOutput()
        value.associations = try reader["associations"].readListIfPresent(memberReadingClosure: BraketClientTypes.Association.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deviceArn = try reader["deviceArn"].readIfPresent() ?? ""
        value.deviceParameters = try reader["deviceParameters"].readIfPresent() ?? ""
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.outputS3Bucket = try reader["outputS3Bucket"].readIfPresent() ?? ""
        value.outputS3Directory = try reader["outputS3Directory"].readIfPresent() ?? ""
        value.quantumTaskArn = try reader["quantumTaskArn"].readIfPresent() ?? ""
        value.queueInfo = try reader["queueInfo"].readIfPresent(with: BraketClientTypes.QuantumTaskQueueInfo.read(from:))
        value.shots = try reader["shots"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SearchDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchDevicesOutput()
        value.devices = try reader["devices"].readListIfPresent(memberReadingClosure: BraketClientTypes.DeviceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SearchJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchJobsOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: BraketClientTypes.JobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SearchQuantumTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchQuantumTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchQuantumTasksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.quantumTasks = try reader["quantumTasks"].readListIfPresent(memberReadingClosure: BraketClientTypes.QuantumTaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CancelJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelQuantumTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DeviceOfflineException": return try DeviceOfflineException.makeError(baseError: baseError)
            case "DeviceRetiredException": return try DeviceRetiredException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQuantumTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DeviceOfflineException": return try DeviceOfflineException.makeError(baseError: baseError)
            case "DeviceRetiredException": return try DeviceRetiredException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQuantumTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchQuantumTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServiceException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DeviceRetiredException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DeviceRetiredException {
        let reader = baseError.errorBodyReader
        var value = DeviceRetiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DeviceOfflineException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DeviceOfflineException {
        let reader = baseError.errorBodyReader
        var value = DeviceOfflineException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BraketClientTypes.DeviceQueueInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.DeviceQueueInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.DeviceQueueInfo()
        value.queue = try reader["queue"].readIfPresent() ?? .sdkUnknown("")
        value.queueSize = try reader["queueSize"].readIfPresent() ?? ""
        value.queuePriority = try reader["queuePriority"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.InputFileConfig {

    static func write(value: BraketClientTypes.InputFileConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelName"].write(value.channelName)
        try writer["contentType"].write(value.contentType)
        try writer["dataSource"].write(value.dataSource, with: BraketClientTypes.DataSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.InputFileConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.InputFileConfig()
        value.channelName = try reader["channelName"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent()
        value.dataSource = try reader["dataSource"].readIfPresent(with: BraketClientTypes.DataSource.read(from:))
        return value
    }
}

extension BraketClientTypes.DataSource {

    static func write(value: BraketClientTypes.DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3DataSource"].write(value.s3DataSource, with: BraketClientTypes.S3DataSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.DataSource()
        value.s3DataSource = try reader["s3DataSource"].readIfPresent(with: BraketClientTypes.S3DataSource.read(from:))
        return value
    }
}

extension BraketClientTypes.S3DataSource {

    static func write(value: BraketClientTypes.S3DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.S3DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.S3DataSource()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BraketClientTypes.JobOutputDataConfig {

    static func write(value: BraketClientTypes.JobOutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["s3Path"].write(value.s3Path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.JobOutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.JobOutputDataConfig()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.s3Path = try reader["s3Path"].readIfPresent() ?? ""
        return value
    }
}

extension BraketClientTypes.JobStoppingCondition {

    static func write(value: BraketClientTypes.JobStoppingCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxRuntimeInSeconds"].write(value.maxRuntimeInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.JobStoppingCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.JobStoppingCondition()
        value.maxRuntimeInSeconds = try reader["maxRuntimeInSeconds"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.JobCheckpointConfig {

    static func write(value: BraketClientTypes.JobCheckpointConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["localPath"].write(value.localPath)
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.JobCheckpointConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.JobCheckpointConfig()
        value.localPath = try reader["localPath"].readIfPresent()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BraketClientTypes.AlgorithmSpecification {

    static func write(value: BraketClientTypes.AlgorithmSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["containerImage"].write(value.containerImage, with: BraketClientTypes.ContainerImage.write(value:to:))
        try writer["scriptModeConfig"].write(value.scriptModeConfig, with: BraketClientTypes.ScriptModeConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.AlgorithmSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.AlgorithmSpecification()
        value.scriptModeConfig = try reader["scriptModeConfig"].readIfPresent(with: BraketClientTypes.ScriptModeConfig.read(from:))
        value.containerImage = try reader["containerImage"].readIfPresent(with: BraketClientTypes.ContainerImage.read(from:))
        return value
    }
}

extension BraketClientTypes.ContainerImage {

    static func write(value: BraketClientTypes.ContainerImage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.ContainerImage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.ContainerImage()
        value.uri = try reader["uri"].readIfPresent() ?? ""
        return value
    }
}

extension BraketClientTypes.ScriptModeConfig {

    static func write(value: BraketClientTypes.ScriptModeConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["compressionType"].write(value.compressionType)
        try writer["entryPoint"].write(value.entryPoint)
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.ScriptModeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.ScriptModeConfig()
        value.entryPoint = try reader["entryPoint"].readIfPresent() ?? ""
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        value.compressionType = try reader["compressionType"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.InstanceConfig {

    static func write(value: BraketClientTypes.InstanceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceCount"].write(value.instanceCount)
        try writer["instanceType"].write(value.instanceType)
        try writer["volumeSizeInGb"].write(value.volumeSizeInGb)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.InstanceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.InstanceConfig()
        value.instanceType = try reader["instanceType"].readIfPresent() ?? .sdkUnknown("")
        value.volumeSizeInGb = try reader["volumeSizeInGb"].readIfPresent() ?? 0
        value.instanceCount = try reader["instanceCount"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.DeviceConfig {

    static func write(value: BraketClientTypes.DeviceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["device"].write(value.device)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.DeviceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.DeviceConfig()
        value.device = try reader["device"].readIfPresent() ?? ""
        return value
    }
}

extension BraketClientTypes.JobEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.JobEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.JobEventDetails()
        value.eventType = try reader["eventType"].readIfPresent()
        value.timeOfEvent = try reader["timeOfEvent"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.HybridJobQueueInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.HybridJobQueueInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.HybridJobQueueInfo()
        value.queue = try reader["queue"].readIfPresent() ?? .sdkUnknown("")
        value.position = try reader["position"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.Association {

    static func write(value: BraketClientTypes.Association?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.Association {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.Association()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BraketClientTypes.QuantumTaskQueueInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.QuantumTaskQueueInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.QuantumTaskQueueInfo()
        value.queue = try reader["queue"].readIfPresent() ?? .sdkUnknown("")
        value.position = try reader["position"].readIfPresent() ?? ""
        value.queuePriority = try reader["queuePriority"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BraketClientTypes.DeviceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.DeviceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.DeviceSummary()
        value.deviceArn = try reader["deviceArn"].readIfPresent() ?? ""
        value.deviceName = try reader["deviceName"].readIfPresent() ?? ""
        value.providerName = try reader["providerName"].readIfPresent() ?? ""
        value.deviceType = try reader["deviceType"].readIfPresent() ?? .sdkUnknown("")
        value.deviceStatus = try reader["deviceStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BraketClientTypes.JobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.JobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.JobSummary()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.device = try reader["device"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BraketClientTypes.QuantumTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BraketClientTypes.QuantumTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BraketClientTypes.QuantumTaskSummary()
        value.quantumTaskArn = try reader["quantumTaskArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.deviceArn = try reader["deviceArn"].readIfPresent() ?? ""
        value.shots = try reader["shots"].readIfPresent() ?? 0
        value.outputS3Bucket = try reader["outputS3Bucket"].readIfPresent() ?? ""
        value.outputS3Directory = try reader["outputS3Directory"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BraketClientTypes.SearchDevicesFilter {

    static func write(value: BraketClientTypes.SearchDevicesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BraketClientTypes.SearchJobsFilter {

    static func write(value: BraketClientTypes.SearchJobsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BraketClientTypes.SearchQuantumTasksFilter {

    static func write(value: BraketClientTypes.SearchQuantumTasksFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum BraketClientTypes {}
