// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes.AlgorithmSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerImage
        case scriptModeConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerImage = self.containerImage {
            try encodeContainer.encode(containerImage, forKey: .containerImage)
        }
        if let scriptModeConfig = self.scriptModeConfig {
            try encodeContainer.encode(scriptModeConfig, forKey: .scriptModeConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptModeConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.ScriptModeConfig.self, forKey: .scriptModeConfig)
        scriptModeConfig = scriptModeConfigDecoded
        let containerImageDecoded = try containerValues.decodeIfPresent(BraketClientTypes.ContainerImage.self, forKey: .containerImage)
        containerImage = containerImageDecoded
    }
}

extension BraketClientTypes {
    /// Defines the Amazon Braket job to be created. Specifies the container image the job uses and the paths to the Python scripts used for entry and training.
    public struct AlgorithmSpecification: Swift.Equatable {
        /// The container image used to create an Amazon Braket job.
        public var containerImage: BraketClientTypes.ContainerImage?
        /// Configures the paths to the Python scripts used for entry and training.
        public var scriptModeConfig: BraketClientTypes.ScriptModeConfig?

        public init(
            containerImage: BraketClientTypes.ContainerImage? = nil,
            scriptModeConfig: BraketClientTypes.ScriptModeConfig? = nil
        )
        {
            self.containerImage = containerImage
            self.scriptModeConfig = scriptModeConfig
        }
    }

}

extension CancelJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobArn = jobArn else {
            return nil
        }
        return "/job/\(jobArn.urlPercentEncoding())/cancel"
    }
}

public struct CancelJobInput: Swift.Equatable {
    /// The ARN of the Amazon Braket job to cancel.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

struct CancelJobInputBody: Swift.Equatable {
}

extension CancelJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.cancellationStatus = output.cancellationStatus
            self.jobArn = output.jobArn
        } else {
            self.cancellationStatus = nil
            self.jobArn = nil
        }
    }
}

public struct CancelJobOutput: Swift.Equatable {
    /// The status of the job cancellation request.
    /// This member is required.
    public var cancellationStatus: BraketClientTypes.CancellationStatus?
    /// The ARN of the Amazon Braket job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        cancellationStatus: BraketClientTypes.CancellationStatus? = nil,
        jobArn: Swift.String? = nil
    )
    {
        self.cancellationStatus = cancellationStatus
        self.jobArn = jobArn
    }
}

struct CancelJobOutputBody: Swift.Equatable {
    let jobArn: Swift.String?
    let cancellationStatus: BraketClientTypes.CancellationStatus?
}

extension CancelJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancellationStatus
        case jobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let cancellationStatusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.CancellationStatus.self, forKey: .cancellationStatus)
        cancellationStatus = cancellationStatusDecoded
    }
}

enum CancelJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelQuantumTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension CancelQuantumTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let quantumTaskArn = quantumTaskArn else {
            return nil
        }
        return "/quantum-task/\(quantumTaskArn.urlPercentEncoding())/cancel"
    }
}

public struct CancelQuantumTaskInput: Swift.Equatable {
    /// The client token associated with the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ARN of the task to cancel.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.quantumTaskArn = quantumTaskArn
    }
}

struct CancelQuantumTaskInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension CancelQuantumTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CancelQuantumTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelQuantumTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.cancellationStatus = output.cancellationStatus
            self.quantumTaskArn = output.quantumTaskArn
        } else {
            self.cancellationStatus = nil
            self.quantumTaskArn = nil
        }
    }
}

public struct CancelQuantumTaskOutput: Swift.Equatable {
    /// The status of the cancellation request.
    /// This member is required.
    public var cancellationStatus: BraketClientTypes.CancellationStatus?
    /// The ARN of the task.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        cancellationStatus: BraketClientTypes.CancellationStatus? = nil,
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.cancellationStatus = cancellationStatus
        self.quantumTaskArn = quantumTaskArn
    }
}

struct CancelQuantumTaskOutputBody: Swift.Equatable {
    let quantumTaskArn: Swift.String?
    let cancellationStatus: BraketClientTypes.CancellationStatus?
}

extension CancelQuantumTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancellationStatus
        case quantumTaskArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
        let cancellationStatusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.CancellationStatus.self, forKey: .cancellationStatus)
        cancellationStatus = cancellationStatusDecoded
    }
}

enum CancelQuantumTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BraketClientTypes {
    public enum CancellationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case sdkUnknown(Swift.String)

        public static var allCases: [CancellationStatus] {
            return [
                .cancelled,
                .cancelling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CancellationStatus(rawValue: rawValue) ?? CancellationStatus.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes {
    public enum CompressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionType] {
            return [
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionType(rawValue: rawValue) ?? CompressionType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error occurred due to a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes.ContainerImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension BraketClientTypes {
    /// The container image used to create an Amazon Braket job.
    public struct ContainerImage: Swift.Equatable {
        /// The URI locating the container image.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension CreateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmSpecification
        case checkpointConfig
        case clientToken
        case deviceConfig
        case hyperParameters
        case inputDataConfig
        case instanceConfig
        case jobName
        case outputDataConfig
        case roleArn
        case stoppingCondition
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmSpecification = self.algorithmSpecification {
            try encodeContainer.encode(algorithmSpecification, forKey: .algorithmSpecification)
        }
        if let checkpointConfig = self.checkpointConfig {
            try encodeContainer.encode(checkpointConfig, forKey: .checkpointConfig)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deviceConfig = self.deviceConfig {
            try encodeContainer.encode(deviceConfig, forKey: .deviceConfig)
        }
        if let hyperParameters = hyperParameters {
            var hyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .hyperParameters)
            for (dictKey0, hyperParameters0) in hyperParameters {
                try hyperParametersContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let inputDataConfig = inputDataConfig {
            var inputDataConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputDataConfig)
            for inputfileconfig0 in inputDataConfig {
                try inputDataConfigContainer.encode(inputfileconfig0)
            }
        }
        if let instanceConfig = self.instanceConfig {
            try encodeContainer.encode(instanceConfig, forKey: .instanceConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stoppingCondition = self.stoppingCondition {
            try encodeContainer.encode(stoppingCondition, forKey: .stoppingCondition)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/job"
    }
}

public struct CreateJobInput: Swift.Equatable {
    /// Definition of the Amazon Braket job to be created. Specifies the container image the job uses and information about the Python scripts used for entry and training.
    /// This member is required.
    public var algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    /// Information about the output locations for job checkpoint data.
    public var checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    /// A unique token that guarantees that the call to this API is idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The quantum processing unit (QPU) or simulator used to create an Amazon Braket job.
    /// This member is required.
    public var deviceConfig: BraketClientTypes.DeviceConfig?
    /// Algorithm-specific parameters used by an Amazon Braket job that influence the quality of the training job. The values are set with a string of JSON key:value pairs, where the key is the name of the hyperparameter and the value is the value of th hyperparameter.
    public var hyperParameters: [Swift.String:Swift.String]?
    /// A list of parameters that specify the name and type of input data and where it is located.
    public var inputDataConfig: [BraketClientTypes.InputFileConfig]?
    /// Configuration of the resource instances to use while running the hybrid job on Amazon Braket.
    /// This member is required.
    public var instanceConfig: BraketClientTypes.InstanceConfig?
    /// The name of the Amazon Braket job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the S3 location where you want to store job artifacts and the encryption key used to store them.
    /// This member is required.
    public var outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can assume to perform tasks on behalf of a user. It can access user resources, run an Amazon Braket job container on behalf of user, and output resources to the users' s3 buckets.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The user-defined criteria that specifies when a job stops running.
    public var stoppingCondition: BraketClientTypes.JobStoppingCondition?
    /// A tag object that consists of a key and an optional value, used to manage metadata for Amazon Braket resources.
    public var tags: [Swift.String:Swift.String]?

    public init(
        algorithmSpecification: BraketClientTypes.AlgorithmSpecification? = nil,
        checkpointConfig: BraketClientTypes.JobCheckpointConfig? = nil,
        clientToken: Swift.String? = nil,
        deviceConfig: BraketClientTypes.DeviceConfig? = nil,
        hyperParameters: [Swift.String:Swift.String]? = nil,
        inputDataConfig: [BraketClientTypes.InputFileConfig]? = nil,
        instanceConfig: BraketClientTypes.InstanceConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: BraketClientTypes.JobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        stoppingCondition: BraketClientTypes.JobStoppingCondition? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmSpecification = algorithmSpecification
        self.checkpointConfig = checkpointConfig
        self.clientToken = clientToken
        self.deviceConfig = deviceConfig
        self.hyperParameters = hyperParameters
        self.inputDataConfig = inputDataConfig
        self.instanceConfig = instanceConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.stoppingCondition = stoppingCondition
        self.tags = tags
    }
}

struct CreateJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    let inputDataConfig: [BraketClientTypes.InputFileConfig]?
    let outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    let checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    let jobName: Swift.String?
    let roleArn: Swift.String?
    let stoppingCondition: BraketClientTypes.JobStoppingCondition?
    let instanceConfig: BraketClientTypes.InstanceConfig?
    let hyperParameters: [Swift.String:Swift.String]?
    let deviceConfig: BraketClientTypes.DeviceConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmSpecification
        case checkpointConfig
        case clientToken
        case deviceConfig
        case hyperParameters
        case inputDataConfig
        case instanceConfig
        case jobName
        case outputDataConfig
        case roleArn
        case stoppingCondition
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let algorithmSpecificationDecoded = try containerValues.decodeIfPresent(BraketClientTypes.AlgorithmSpecification.self, forKey: .algorithmSpecification)
        algorithmSpecification = algorithmSpecificationDecoded
        let inputDataConfigContainer = try containerValues.decodeIfPresent([BraketClientTypes.InputFileConfig?].self, forKey: .inputDataConfig)
        var inputDataConfigDecoded0:[BraketClientTypes.InputFileConfig]? = nil
        if let inputDataConfigContainer = inputDataConfigContainer {
            inputDataConfigDecoded0 = [BraketClientTypes.InputFileConfig]()
            for structure0 in inputDataConfigContainer {
                if let structure0 = structure0 {
                    inputDataConfigDecoded0?.append(structure0)
                }
            }
        }
        inputDataConfig = inputDataConfigDecoded0
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobOutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let checkpointConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobCheckpointConfig.self, forKey: .checkpointConfig)
        checkpointConfig = checkpointConfigDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stoppingConditionDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobStoppingCondition.self, forKey: .stoppingCondition)
        stoppingCondition = stoppingConditionDecoded
        let instanceConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.InstanceConfig.self, forKey: .instanceConfig)
        instanceConfig = instanceConfigDecoded
        let hyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .hyperParameters)
        var hyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let hyperParametersContainer = hyperParametersContainer {
            hyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in hyperParametersContainer {
                if let string0 = string0 {
                    hyperParametersDecoded0?[key0] = string0
                }
            }
        }
        hyperParameters = hyperParametersDecoded0
        let deviceConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceConfig.self, forKey: .deviceConfig)
        deviceConfig = deviceConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobArn = output.jobArn
        } else {
            self.jobArn = nil
        }
    }
}

public struct CreateJobOutput: Swift.Equatable {
    /// The ARN of the Amazon Braket job created.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

struct CreateJobOutputBody: Swift.Equatable {
    let jobArn: Swift.String?
}

extension CreateJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
    }
}

enum CreateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeviceRetiredException": return try await DeviceRetiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateQuantumTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case clientToken
        case deviceArn
        case deviceParameters
        case jobToken
        case outputS3Bucket
        case outputS3KeyPrefix
        case shots
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceParameters = self.deviceParameters {
            try encodeContainer.encode(deviceParameters, forKey: .deviceParameters)
        }
        if let jobToken = self.jobToken {
            try encodeContainer.encode(jobToken, forKey: .jobToken)
        }
        if let outputS3Bucket = self.outputS3Bucket {
            try encodeContainer.encode(outputS3Bucket, forKey: .outputS3Bucket)
        }
        if let outputS3KeyPrefix = self.outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let shots = self.shots {
            try encodeContainer.encode(shots, forKey: .shots)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateQuantumTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/quantum-task"
    }
}

public struct CreateQuantumTaskInput: Swift.Equatable {
    /// The action associated with the task.
    /// This member is required.
    public var action: Swift.String?
    /// The client token associated with the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ARN of the device to run the task on.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The parameters for the device to run the task on.
    public var deviceParameters: Swift.String?
    /// The token for an Amazon Braket job that associates it with the quantum task.
    public var jobToken: Swift.String?
    /// The S3 bucket to store task result files in.
    /// This member is required.
    public var outputS3Bucket: Swift.String?
    /// The key prefix for the location in the S3 bucket to store task results in.
    /// This member is required.
    public var outputS3KeyPrefix: Swift.String?
    /// The number of shots to use for the task.
    /// This member is required.
    public var shots: Swift.Int?
    /// Tags to be added to the quantum task you're creating.
    public var tags: [Swift.String:Swift.String]?

    public init(
        action: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        deviceArn: Swift.String? = nil,
        deviceParameters: Swift.String? = nil,
        jobToken: Swift.String? = nil,
        outputS3Bucket: Swift.String? = nil,
        outputS3KeyPrefix: Swift.String? = nil,
        shots: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.deviceArn = deviceArn
        self.deviceParameters = deviceParameters
        self.jobToken = jobToken
        self.outputS3Bucket = outputS3Bucket
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.shots = shots
        self.tags = tags
    }
}

struct CreateQuantumTaskInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let deviceArn: Swift.String?
    let deviceParameters: Swift.String?
    let shots: Swift.Int?
    let outputS3Bucket: Swift.String?
    let outputS3KeyPrefix: Swift.String?
    let action: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let jobToken: Swift.String?
}

extension CreateQuantumTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case clientToken
        case deviceArn
        case deviceParameters
        case jobToken
        case outputS3Bucket
        case outputS3KeyPrefix
        case shots
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceParameters)
        deviceParameters = deviceParametersDecoded
        let shotsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shots)
        shots = shotsDecoded
        let outputS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Bucket)
        outputS3Bucket = outputS3BucketDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let jobTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobToken)
        jobToken = jobTokenDecoded
    }
}

extension CreateQuantumTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateQuantumTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.quantumTaskArn = output.quantumTaskArn
        } else {
            self.quantumTaskArn = nil
        }
    }
}

public struct CreateQuantumTaskOutput: Swift.Equatable {
    /// The ARN of the task created by the request.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.quantumTaskArn = quantumTaskArn
    }
}

struct CreateQuantumTaskOutputBody: Swift.Equatable {
    let quantumTaskArn: Swift.String?
}

extension CreateQuantumTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quantumTaskArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
    }
}

enum CreateQuantumTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeviceOfflineException": return try await DeviceOfflineException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeviceRetiredException": return try await DeviceRetiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BraketClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataSource = self.s3DataSource {
            try encodeContainer.encode(s3DataSource, forKey: .s3DataSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataSourceDecoded = try containerValues.decodeIfPresent(BraketClientTypes.S3DataSource.self, forKey: .s3DataSource)
        s3DataSource = s3DataSourceDecoded
    }
}

extension BraketClientTypes {
    /// Information about the source of the data used by the Amazon Braket job.
    public struct DataSource: Swift.Equatable {
        /// Information about the data stored in Amazon S3 used by the Amazon Braket job.
        /// This member is required.
        public var s3DataSource: BraketClientTypes.S3DataSource?

        public init(
            s3DataSource: BraketClientTypes.S3DataSource? = nil
        )
        {
            self.s3DataSource = s3DataSource
        }
    }

}

extension BraketClientTypes.DeviceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let device = self.device {
            try encodeContainer.encode(device, forKey: .device)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .device)
        device = deviceDecoded
    }
}

extension BraketClientTypes {
    /// Configures the quantum processing units (QPUs) or simulator used to create and run an Amazon Braket job.
    public struct DeviceConfig: Swift.Equatable {
        /// The primary quantum processing unit (QPU) or simulator used to create and run an Amazon Braket job.
        /// This member is required.
        public var device: Swift.String?

        public init(
            device: Swift.String? = nil
        )
        {
            self.device = device
        }
    }

}

extension DeviceOfflineException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeviceOfflineExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified device is currently offline.
public struct DeviceOfflineException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeviceOfflineException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeviceOfflineExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeviceOfflineExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes.DeviceQueueInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queue
        case queuePriority
        case queueSize
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queue = self.queue {
            try encodeContainer.encode(queue.rawValue, forKey: .queue)
        }
        if let queuePriority = self.queuePriority {
            try encodeContainer.encode(queuePriority.rawValue, forKey: .queuePriority)
        }
        if let queueSize = self.queueSize {
            try encodeContainer.encode(queueSize, forKey: .queueSize)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueDecoded = try containerValues.decodeIfPresent(BraketClientTypes.QueueName.self, forKey: .queue)
        queue = queueDecoded
        let queueSizeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueSize)
        queueSize = queueSizeDecoded
        let queuePriorityDecoded = try containerValues.decodeIfPresent(BraketClientTypes.QueuePriority.self, forKey: .queuePriority)
        queuePriority = queuePriorityDecoded
    }
}

extension BraketClientTypes {
    /// Information about tasks and jobs queued on a device.
    public struct DeviceQueueInfo: Swift.Equatable {
        /// The name of the queue.
        /// This member is required.
        public var queue: BraketClientTypes.QueueName?
        /// Optional. Specifies the priority of the queue. Tasks in a priority queue are processed before the tasks in a normal queue.
        public var queuePriority: BraketClientTypes.QueuePriority?
        /// The number of jobs or tasks in the queue for a given device.
        /// This member is required.
        public var queueSize: Swift.String?

        public init(
            queue: BraketClientTypes.QueueName? = nil,
            queuePriority: BraketClientTypes.QueuePriority? = nil,
            queueSize: Swift.String? = nil
        )
        {
            self.queue = queue
            self.queuePriority = queuePriority
            self.queueSize = queueSize
        }
    }

}

extension DeviceRetiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeviceRetiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified device has been retired.
public struct DeviceRetiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeviceRetiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeviceRetiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeviceRetiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes {
    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case offline
        case online
        case retired
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .offline,
                .online,
                .retired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .retired: return "RETIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes.DeviceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn
        case deviceName
        case deviceStatus
        case deviceType
        case providerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceStatus = self.deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
        if let deviceType = self.deviceType {
            try encodeContainer.encode(deviceType.rawValue, forKey: .deviceType)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceType.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
    }
}

extension BraketClientTypes {
    /// Includes information about the device.
    public struct DeviceSummary: Swift.Equatable {
        /// The ARN of the device.
        /// This member is required.
        public var deviceArn: Swift.String?
        /// The name of the device.
        /// This member is required.
        public var deviceName: Swift.String?
        /// The status of the device.
        /// This member is required.
        public var deviceStatus: BraketClientTypes.DeviceStatus?
        /// The type of the device.
        /// This member is required.
        public var deviceType: BraketClientTypes.DeviceType?
        /// The provider of the device.
        /// This member is required.
        public var providerName: Swift.String?

        public init(
            deviceArn: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            deviceStatus: BraketClientTypes.DeviceStatus? = nil,
            deviceType: BraketClientTypes.DeviceType? = nil,
            providerName: Swift.String? = nil
        )
        {
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceStatus = deviceStatus
            self.deviceType = deviceType
            self.providerName = providerName
        }
    }

}

extension BraketClientTypes {
    public enum DeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case qpu
        case simulator
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceType] {
            return [
                .qpu,
                .simulator,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .qpu: return "QPU"
            case .simulator: return "SIMULATOR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceType(rawValue: rawValue) ?? DeviceType.sdkUnknown(rawValue)
        }
    }
}

extension GetDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceArn = deviceArn else {
            return nil
        }
        return "/device/\(deviceArn.urlPercentEncoding())"
    }
}

public struct GetDeviceInput: Swift.Equatable {
    /// The ARN of the device to retrieve.
    /// This member is required.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct GetDeviceInputBody: Swift.Equatable {
}

extension GetDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceArn = output.deviceArn
            self.deviceCapabilities = output.deviceCapabilities
            self.deviceName = output.deviceName
            self.deviceQueueInfo = output.deviceQueueInfo
            self.deviceStatus = output.deviceStatus
            self.deviceType = output.deviceType
            self.providerName = output.providerName
        } else {
            self.deviceArn = nil
            self.deviceCapabilities = nil
            self.deviceName = nil
            self.deviceQueueInfo = nil
            self.deviceStatus = nil
            self.deviceType = nil
            self.providerName = nil
        }
    }
}

public struct GetDeviceOutput: Swift.Equatable {
    /// The ARN of the device.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// Details about the capabilities of the device.
    /// This member is required.
    public var deviceCapabilities: Swift.String?
    /// The name of the device.
    /// This member is required.
    public var deviceName: Swift.String?
    /// List of information about tasks and jobs queued on a device.
    public var deviceQueueInfo: [BraketClientTypes.DeviceQueueInfo]?
    /// The status of the device.
    /// This member is required.
    public var deviceStatus: BraketClientTypes.DeviceStatus?
    /// The type of the device.
    /// This member is required.
    public var deviceType: BraketClientTypes.DeviceType?
    /// The name of the partner company for the device.
    /// This member is required.
    public var providerName: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        deviceCapabilities: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        deviceQueueInfo: [BraketClientTypes.DeviceQueueInfo]? = nil,
        deviceStatus: BraketClientTypes.DeviceStatus? = nil,
        deviceType: BraketClientTypes.DeviceType? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceCapabilities = deviceCapabilities
        self.deviceName = deviceName
        self.deviceQueueInfo = deviceQueueInfo
        self.deviceStatus = deviceStatus
        self.deviceType = deviceType
        self.providerName = providerName
    }
}

struct GetDeviceOutputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let deviceName: Swift.String?
    let providerName: Swift.String?
    let deviceType: BraketClientTypes.DeviceType?
    let deviceStatus: BraketClientTypes.DeviceStatus?
    let deviceCapabilities: Swift.String?
    let deviceQueueInfo: [BraketClientTypes.DeviceQueueInfo]?
}

extension GetDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn
        case deviceCapabilities
        case deviceName
        case deviceQueueInfo
        case deviceStatus
        case deviceType
        case providerName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceType.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
        let deviceCapabilitiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCapabilities)
        deviceCapabilities = deviceCapabilitiesDecoded
        let deviceQueueInfoContainer = try containerValues.decodeIfPresent([BraketClientTypes.DeviceQueueInfo?].self, forKey: .deviceQueueInfo)
        var deviceQueueInfoDecoded0:[BraketClientTypes.DeviceQueueInfo]? = nil
        if let deviceQueueInfoContainer = deviceQueueInfoContainer {
            deviceQueueInfoDecoded0 = [BraketClientTypes.DeviceQueueInfo]()
            for structure0 in deviceQueueInfoContainer {
                if let structure0 = structure0 {
                    deviceQueueInfoDecoded0?.append(structure0)
                }
            }
        }
        deviceQueueInfo = deviceQueueInfoDecoded0
    }
}

enum GetDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let additionalAttributeNames = additionalAttributeNames {
                additionalAttributeNames.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "additionalAttributeNames".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobArn = jobArn else {
            return nil
        }
        return "/job/\(jobArn.urlPercentEncoding())"
    }
}

public struct GetJobInput: Swift.Equatable {
    /// A list of attributes to return information for.
    public var additionalAttributeNames: [BraketClientTypes.HybridJobAdditionalAttributeName]?
    /// The ARN of the job to retrieve.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        additionalAttributeNames: [BraketClientTypes.HybridJobAdditionalAttributeName]? = nil,
        jobArn: Swift.String? = nil
    )
    {
        self.additionalAttributeNames = additionalAttributeNames
        self.jobArn = jobArn
    }
}

struct GetJobInputBody: Swift.Equatable {
}

extension GetJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.algorithmSpecification = output.algorithmSpecification
            self.billableDuration = output.billableDuration
            self.checkpointConfig = output.checkpointConfig
            self.createdAt = output.createdAt
            self.deviceConfig = output.deviceConfig
            self.endedAt = output.endedAt
            self.events = output.events
            self.failureReason = output.failureReason
            self.hyperParameters = output.hyperParameters
            self.inputDataConfig = output.inputDataConfig
            self.instanceConfig = output.instanceConfig
            self.jobArn = output.jobArn
            self.jobName = output.jobName
            self.outputDataConfig = output.outputDataConfig
            self.queueInfo = output.queueInfo
            self.roleArn = output.roleArn
            self.startedAt = output.startedAt
            self.status = output.status
            self.stoppingCondition = output.stoppingCondition
            self.tags = output.tags
        } else {
            self.algorithmSpecification = nil
            self.billableDuration = nil
            self.checkpointConfig = nil
            self.createdAt = nil
            self.deviceConfig = nil
            self.endedAt = nil
            self.events = nil
            self.failureReason = nil
            self.hyperParameters = nil
            self.inputDataConfig = nil
            self.instanceConfig = nil
            self.jobArn = nil
            self.jobName = nil
            self.outputDataConfig = nil
            self.queueInfo = nil
            self.roleArn = nil
            self.startedAt = nil
            self.status = nil
            self.stoppingCondition = nil
            self.tags = nil
        }
    }
}

public struct GetJobOutput: Swift.Equatable {
    /// Definition of the Amazon Braket job created. Specifies the container image the job uses, information about the Python scripts used for entry and training, and the user-defined metrics used to evaluation the job.
    /// This member is required.
    public var algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    /// The billable time the Amazon Braket job used to complete.
    public var billableDuration: Swift.Int?
    /// Information about the output locations for job checkpoint data.
    public var checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    /// The date and time that the Amazon Braket job was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The quantum processing unit (QPU) or simulator used to run the Amazon Braket job.
    public var deviceConfig: BraketClientTypes.DeviceConfig?
    /// The date and time that the Amazon Braket job ended.
    public var endedAt: ClientRuntime.Date?
    /// Details about the type and time events occurred related to the Amazon Braket job.
    public var events: [BraketClientTypes.JobEventDetails]?
    /// A description of the reason why an Amazon Braket job failed, if it failed.
    public var failureReason: Swift.String?
    /// Algorithm-specific parameters used by an Amazon Braket job that influence the quality of the traiing job. The values are set with a string of JSON key:value pairs, where the key is the name of the hyperparameter and the value is the value of th hyperparameter.
    public var hyperParameters: [Swift.String:Swift.String]?
    /// A list of parameters that specify the name and type of input data and where it is located.
    public var inputDataConfig: [BraketClientTypes.InputFileConfig]?
    /// The resource instances to use while running the hybrid job on Amazon Braket.
    /// This member is required.
    public var instanceConfig: BraketClientTypes.InstanceConfig?
    /// The ARN of the Amazon Braket job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The name of the Amazon Braket job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the S3 location where job artifacts are stored and the encryption key used to store them there.
    /// This member is required.
    public var outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    /// Queue information for the requested job. Only returned if QueueInfo is specified in the additionalAttributeNames" field in the GetJob API request.
    public var queueInfo: BraketClientTypes.HybridJobQueueInfo?
    /// The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can assume to perform tasks on behalf of a user. It can access user resources, run an Amazon Braket job container on behalf of user, and output resources to the s3 buckets of a user.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The date and time that the Amazon Braket job was started.
    public var startedAt: ClientRuntime.Date?
    /// The status of the Amazon Braket job.
    /// This member is required.
    public var status: BraketClientTypes.JobPrimaryStatus?
    /// The user-defined criteria that specifies when to stop a job running.
    public var stoppingCondition: BraketClientTypes.JobStoppingCondition?
    /// A tag object that consists of a key and an optional value, used to manage metadata for Amazon Braket resources.
    public var tags: [Swift.String:Swift.String]?

    public init(
        algorithmSpecification: BraketClientTypes.AlgorithmSpecification? = nil,
        billableDuration: Swift.Int? = nil,
        checkpointConfig: BraketClientTypes.JobCheckpointConfig? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deviceConfig: BraketClientTypes.DeviceConfig? = nil,
        endedAt: ClientRuntime.Date? = nil,
        events: [BraketClientTypes.JobEventDetails]? = nil,
        failureReason: Swift.String? = nil,
        hyperParameters: [Swift.String:Swift.String]? = nil,
        inputDataConfig: [BraketClientTypes.InputFileConfig]? = nil,
        instanceConfig: BraketClientTypes.InstanceConfig? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: BraketClientTypes.JobOutputDataConfig? = nil,
        queueInfo: BraketClientTypes.HybridJobQueueInfo? = nil,
        roleArn: Swift.String? = nil,
        startedAt: ClientRuntime.Date? = nil,
        status: BraketClientTypes.JobPrimaryStatus? = nil,
        stoppingCondition: BraketClientTypes.JobStoppingCondition? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmSpecification = algorithmSpecification
        self.billableDuration = billableDuration
        self.checkpointConfig = checkpointConfig
        self.createdAt = createdAt
        self.deviceConfig = deviceConfig
        self.endedAt = endedAt
        self.events = events
        self.failureReason = failureReason
        self.hyperParameters = hyperParameters
        self.inputDataConfig = inputDataConfig
        self.instanceConfig = instanceConfig
        self.jobArn = jobArn
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.queueInfo = queueInfo
        self.roleArn = roleArn
        self.startedAt = startedAt
        self.status = status
        self.stoppingCondition = stoppingCondition
        self.tags = tags
    }
}

struct GetJobOutputBody: Swift.Equatable {
    let status: BraketClientTypes.JobPrimaryStatus?
    let jobArn: Swift.String?
    let roleArn: Swift.String?
    let failureReason: Swift.String?
    let jobName: Swift.String?
    let hyperParameters: [Swift.String:Swift.String]?
    let inputDataConfig: [BraketClientTypes.InputFileConfig]?
    let outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    let stoppingCondition: BraketClientTypes.JobStoppingCondition?
    let checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    let algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    let instanceConfig: BraketClientTypes.InstanceConfig?
    let createdAt: ClientRuntime.Date?
    let startedAt: ClientRuntime.Date?
    let endedAt: ClientRuntime.Date?
    let billableDuration: Swift.Int?
    let deviceConfig: BraketClientTypes.DeviceConfig?
    let events: [BraketClientTypes.JobEventDetails]?
    let tags: [Swift.String:Swift.String]?
    let queueInfo: BraketClientTypes.HybridJobQueueInfo?
}

extension GetJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmSpecification
        case billableDuration
        case checkpointConfig
        case createdAt
        case deviceConfig
        case endedAt
        case events
        case failureReason
        case hyperParameters
        case inputDataConfig
        case instanceConfig
        case jobArn
        case jobName
        case outputDataConfig
        case queueInfo
        case roleArn
        case startedAt
        case status
        case stoppingCondition
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobPrimaryStatus.self, forKey: .status)
        status = statusDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let hyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .hyperParameters)
        var hyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let hyperParametersContainer = hyperParametersContainer {
            hyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in hyperParametersContainer {
                if let string0 = string0 {
                    hyperParametersDecoded0?[key0] = string0
                }
            }
        }
        hyperParameters = hyperParametersDecoded0
        let inputDataConfigContainer = try containerValues.decodeIfPresent([BraketClientTypes.InputFileConfig?].self, forKey: .inputDataConfig)
        var inputDataConfigDecoded0:[BraketClientTypes.InputFileConfig]? = nil
        if let inputDataConfigContainer = inputDataConfigContainer {
            inputDataConfigDecoded0 = [BraketClientTypes.InputFileConfig]()
            for structure0 in inputDataConfigContainer {
                if let structure0 = structure0 {
                    inputDataConfigDecoded0?.append(structure0)
                }
            }
        }
        inputDataConfig = inputDataConfigDecoded0
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobOutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let stoppingConditionDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobStoppingCondition.self, forKey: .stoppingCondition)
        stoppingCondition = stoppingConditionDecoded
        let checkpointConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobCheckpointConfig.self, forKey: .checkpointConfig)
        checkpointConfig = checkpointConfigDecoded
        let algorithmSpecificationDecoded = try containerValues.decodeIfPresent(BraketClientTypes.AlgorithmSpecification.self, forKey: .algorithmSpecification)
        algorithmSpecification = algorithmSpecificationDecoded
        let instanceConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.InstanceConfig.self, forKey: .instanceConfig)
        instanceConfig = instanceConfigDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let billableDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .billableDuration)
        billableDuration = billableDurationDecoded
        let deviceConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceConfig.self, forKey: .deviceConfig)
        deviceConfig = deviceConfigDecoded
        let eventsContainer = try containerValues.decodeIfPresent([BraketClientTypes.JobEventDetails?].self, forKey: .events)
        var eventsDecoded0:[BraketClientTypes.JobEventDetails]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [BraketClientTypes.JobEventDetails]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let queueInfoDecoded = try containerValues.decodeIfPresent(BraketClientTypes.HybridJobQueueInfo.self, forKey: .queueInfo)
        queueInfo = queueInfoDecoded
    }
}

enum GetJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQuantumTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let additionalAttributeNames = additionalAttributeNames {
                additionalAttributeNames.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "additionalAttributeNames".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetQuantumTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let quantumTaskArn = quantumTaskArn else {
            return nil
        }
        return "/quantum-task/\(quantumTaskArn.urlPercentEncoding())"
    }
}

public struct GetQuantumTaskInput: Swift.Equatable {
    /// A list of attributes to return information for.
    public var additionalAttributeNames: [BraketClientTypes.QuantumTaskAdditionalAttributeName]?
    /// the ARN of the task to retrieve.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init(
        additionalAttributeNames: [BraketClientTypes.QuantumTaskAdditionalAttributeName]? = nil,
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.additionalAttributeNames = additionalAttributeNames
        self.quantumTaskArn = quantumTaskArn
    }
}

struct GetQuantumTaskInputBody: Swift.Equatable {
}

extension GetQuantumTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetQuantumTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQuantumTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.deviceArn = output.deviceArn
            self.deviceParameters = output.deviceParameters
            self.endedAt = output.endedAt
            self.failureReason = output.failureReason
            self.jobArn = output.jobArn
            self.outputS3Bucket = output.outputS3Bucket
            self.outputS3Directory = output.outputS3Directory
            self.quantumTaskArn = output.quantumTaskArn
            self.queueInfo = output.queueInfo
            self.shots = output.shots
            self.status = output.status
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.deviceArn = nil
            self.deviceParameters = nil
            self.endedAt = nil
            self.failureReason = nil
            self.jobArn = nil
            self.outputS3Bucket = nil
            self.outputS3Directory = nil
            self.quantumTaskArn = nil
            self.queueInfo = nil
            self.shots = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetQuantumTaskOutput: Swift.Equatable {
    /// The time at which the task was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The ARN of the device the task was run on.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The parameters for the device on which the task ran.
    /// This member is required.
    public var deviceParameters: Swift.String?
    /// The time at which the task ended.
    public var endedAt: ClientRuntime.Date?
    /// The reason that a task failed.
    public var failureReason: Swift.String?
    /// The ARN of the Amazon Braket job associated with the quantum task.
    public var jobArn: Swift.String?
    /// The S3 bucket where task results are stored.
    /// This member is required.
    public var outputS3Bucket: Swift.String?
    /// The folder in the S3 bucket where task results are stored.
    /// This member is required.
    public var outputS3Directory: Swift.String?
    /// The ARN of the task.
    /// This member is required.
    public var quantumTaskArn: Swift.String?
    /// Queue information for the requested quantum task. Only returned if QueueInfo is specified in the additionalAttributeNames" field in the GetQuantumTask API request.
    public var queueInfo: BraketClientTypes.QuantumTaskQueueInfo?
    /// The number of shots used in the task.
    /// This member is required.
    public var shots: Swift.Int?
    /// The status of the task.
    /// This member is required.
    public var status: BraketClientTypes.QuantumTaskStatus?
    /// The tags that belong to this task.
    public var tags: [Swift.String:Swift.String]?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        deviceArn: Swift.String? = nil,
        deviceParameters: Swift.String? = nil,
        endedAt: ClientRuntime.Date? = nil,
        failureReason: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        outputS3Bucket: Swift.String? = nil,
        outputS3Directory: Swift.String? = nil,
        quantumTaskArn: Swift.String? = nil,
        queueInfo: BraketClientTypes.QuantumTaskQueueInfo? = nil,
        shots: Swift.Int? = nil,
        status: BraketClientTypes.QuantumTaskStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deviceArn = deviceArn
        self.deviceParameters = deviceParameters
        self.endedAt = endedAt
        self.failureReason = failureReason
        self.jobArn = jobArn
        self.outputS3Bucket = outputS3Bucket
        self.outputS3Directory = outputS3Directory
        self.quantumTaskArn = quantumTaskArn
        self.queueInfo = queueInfo
        self.shots = shots
        self.status = status
        self.tags = tags
    }
}

struct GetQuantumTaskOutputBody: Swift.Equatable {
    let quantumTaskArn: Swift.String?
    let status: BraketClientTypes.QuantumTaskStatus?
    let failureReason: Swift.String?
    let deviceArn: Swift.String?
    let deviceParameters: Swift.String?
    let shots: Swift.Int?
    let outputS3Bucket: Swift.String?
    let outputS3Directory: Swift.String?
    let createdAt: ClientRuntime.Date?
    let endedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let jobArn: Swift.String?
    let queueInfo: BraketClientTypes.QuantumTaskQueueInfo?
}

extension GetQuantumTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case deviceArn
        case deviceParameters
        case endedAt
        case failureReason
        case jobArn
        case outputS3Bucket
        case outputS3Directory
        case quantumTaskArn
        case queueInfo
        case shots
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.QuantumTaskStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceParameters)
        deviceParameters = deviceParametersDecoded
        let shotsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shots)
        shots = shotsDecoded
        let outputS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Bucket)
        outputS3Bucket = outputS3BucketDecoded
        let outputS3DirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Directory)
        outputS3Directory = outputS3DirectoryDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let queueInfoDecoded = try containerValues.decodeIfPresent(BraketClientTypes.QuantumTaskQueueInfo.self, forKey: .queueInfo)
        queueInfo = queueInfoDecoded
    }
}

enum GetQuantumTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BraketClientTypes {
    public enum HybridJobAdditionalAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case queueInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [HybridJobAdditionalAttributeName] {
            return [
                .queueInfo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .queueInfo: return "QueueInfo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HybridJobAdditionalAttributeName(rawValue: rawValue) ?? HybridJobAdditionalAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes.HybridJobQueueInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case position
        case queue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let queue = self.queue {
            try encodeContainer.encode(queue.rawValue, forKey: .queue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueDecoded = try containerValues.decodeIfPresent(BraketClientTypes.QueueName.self, forKey: .queue)
        queue = queueDecoded
        let positionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .position)
        position = positionDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes {
    /// Information about the queue for a specified job.
    public struct HybridJobQueueInfo: Swift.Equatable {
        /// Optional. Provides more information about the queue position. For example, if the job is complete and no longer in the queue, the message field contains that information.
        public var message: Swift.String?
        /// Current position of the job in the jobs queue.
        /// This member is required.
        public var position: Swift.String?
        /// The name of the queue.
        /// This member is required.
        public var queue: BraketClientTypes.QueueName?

        public init(
            message: Swift.String? = nil,
            position: Swift.String? = nil,
            queue: BraketClientTypes.QueueName? = nil
        )
        {
            self.message = message
            self.position = position
            self.queue = queue
        }
    }

}

extension BraketClientTypes.InputFileConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName
        case contentType
        case dataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension BraketClientTypes {
    /// A list of parameters that specify the input channels, type of input data, and where it is located.
    public struct InputFileConfig: Swift.Equatable {
        /// A named input source that an Amazon Braket job can consume.
        /// This member is required.
        public var channelName: Swift.String?
        /// The MIME type of the data.
        public var contentType: Swift.String?
        /// The location of the channel data.
        /// This member is required.
        public var dataSource: BraketClientTypes.DataSource?

        public init(
            channelName: Swift.String? = nil,
            contentType: Swift.String? = nil,
            dataSource: BraketClientTypes.DataSource? = nil
        )
        {
            self.channelName = channelName
            self.contentType = contentType
            self.dataSource = dataSource
        }
    }

}

extension BraketClientTypes.InstanceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceCount
        case instanceType
        case volumeSizeInGb
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceCount = self.instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
        if let volumeSizeInGb = self.volumeSizeInGb {
            try encodeContainer.encode(volumeSizeInGb, forKey: .volumeSizeInGb)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDecoded = try containerValues.decodeIfPresent(BraketClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let volumeSizeInGbDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInGb)
        volumeSizeInGb = volumeSizeInGbDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
    }
}

extension BraketClientTypes {
    /// Configures the resource instances to use while running the Amazon Braket hybrid job on Amazon Braket.
    public struct InstanceConfig: Swift.Equatable {
        /// Configures the number of resource instances to use while running an Amazon Braket job on Amazon Braket. The default value is 1.
        public var instanceCount: Swift.Int?
        /// Configures the type resource instances to use while running an Amazon Braket hybrid job.
        /// This member is required.
        public var instanceType: BraketClientTypes.InstanceType?
        /// The size of the storage volume, in GB, that user wants to provision.
        /// This member is required.
        public var volumeSizeInGb: Swift.Int?

        public init(
            instanceCount: Swift.Int? = nil,
            instanceType: BraketClientTypes.InstanceType? = nil,
            volumeSizeInGb: Swift.Int? = nil
        )
        {
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.volumeSizeInGb = volumeSizeInGb
        }
    }

}

extension BraketClientTypes {
    public enum InstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mlC42xlarge
        case mlC44xlarge
        case mlC48xlarge
        case mlC4Xlarge
        case mlC5n18xlarge
        case mlC5n2xlarge
        case mlC5n4xlarge
        case mlC5n9xlarge
        case mlC5nXlarge
        case mlC518xlarge
        case mlC52xlarge
        case mlC54xlarge
        case mlC59xlarge
        case mlC5Xlarge
        case mlG4dn12xlarge
        case mlG4dn16xlarge
        case mlG4dn2xlarge
        case mlG4dn4xlarge
        case mlG4dn8xlarge
        case mlG4dnXlarge
        case mlM410xlarge
        case mlM416xlarge
        case mlM42xlarge
        case mlM44xlarge
        case mlM4Xlarge
        case mlM512xlarge
        case mlM524xlarge
        case mlM52xlarge
        case mlM54xlarge
        case mlM5Large
        case mlM5Xlarge
        case mlP216xlarge
        case mlP28xlarge
        case mlP2Xlarge
        case mlP3dn24xlarge
        case mlP316xlarge
        case mlP32xlarge
        case mlP38xlarge
        case mlP4d24xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceType] {
            return [
                .mlC42xlarge,
                .mlC44xlarge,
                .mlC48xlarge,
                .mlC4Xlarge,
                .mlC5n18xlarge,
                .mlC5n2xlarge,
                .mlC5n4xlarge,
                .mlC5n9xlarge,
                .mlC5nXlarge,
                .mlC518xlarge,
                .mlC52xlarge,
                .mlC54xlarge,
                .mlC59xlarge,
                .mlC5Xlarge,
                .mlG4dn12xlarge,
                .mlG4dn16xlarge,
                .mlG4dn2xlarge,
                .mlG4dn4xlarge,
                .mlG4dn8xlarge,
                .mlG4dnXlarge,
                .mlM410xlarge,
                .mlM416xlarge,
                .mlM42xlarge,
                .mlM44xlarge,
                .mlM4Xlarge,
                .mlM512xlarge,
                .mlM524xlarge,
                .mlM52xlarge,
                .mlM54xlarge,
                .mlM5Large,
                .mlM5Xlarge,
                .mlP216xlarge,
                .mlP28xlarge,
                .mlP2Xlarge,
                .mlP3dn24xlarge,
                .mlP316xlarge,
                .mlP32xlarge,
                .mlP38xlarge,
                .mlP4d24xlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mlC42xlarge: return "ml.c4.2xlarge"
            case .mlC44xlarge: return "ml.c4.4xlarge"
            case .mlC48xlarge: return "ml.c4.8xlarge"
            case .mlC4Xlarge: return "ml.c4.xlarge"
            case .mlC5n18xlarge: return "ml.c5n.18xlarge"
            case .mlC5n2xlarge: return "ml.c5n.2xlarge"
            case .mlC5n4xlarge: return "ml.c5n.4xlarge"
            case .mlC5n9xlarge: return "ml.c5n.9xlarge"
            case .mlC5nXlarge: return "ml.c5n.xlarge"
            case .mlC518xlarge: return "ml.c5.18xlarge"
            case .mlC52xlarge: return "ml.c5.2xlarge"
            case .mlC54xlarge: return "ml.c5.4xlarge"
            case .mlC59xlarge: return "ml.c5.9xlarge"
            case .mlC5Xlarge: return "ml.c5.xlarge"
            case .mlG4dn12xlarge: return "ml.g4dn.12xlarge"
            case .mlG4dn16xlarge: return "ml.g4dn.16xlarge"
            case .mlG4dn2xlarge: return "ml.g4dn.2xlarge"
            case .mlG4dn4xlarge: return "ml.g4dn.4xlarge"
            case .mlG4dn8xlarge: return "ml.g4dn.8xlarge"
            case .mlG4dnXlarge: return "ml.g4dn.xlarge"
            case .mlM410xlarge: return "ml.m4.10xlarge"
            case .mlM416xlarge: return "ml.m4.16xlarge"
            case .mlM42xlarge: return "ml.m4.2xlarge"
            case .mlM44xlarge: return "ml.m4.4xlarge"
            case .mlM4Xlarge: return "ml.m4.xlarge"
            case .mlM512xlarge: return "ml.m5.12xlarge"
            case .mlM524xlarge: return "ml.m5.24xlarge"
            case .mlM52xlarge: return "ml.m5.2xlarge"
            case .mlM54xlarge: return "ml.m5.4xlarge"
            case .mlM5Large: return "ml.m5.large"
            case .mlM5Xlarge: return "ml.m5.xlarge"
            case .mlP216xlarge: return "ml.p2.16xlarge"
            case .mlP28xlarge: return "ml.p2.8xlarge"
            case .mlP2Xlarge: return "ml.p2.xlarge"
            case .mlP3dn24xlarge: return "ml.p3dn.24xlarge"
            case .mlP316xlarge: return "ml.p3.16xlarge"
            case .mlP32xlarge: return "ml.p3.2xlarge"
            case .mlP38xlarge: return "ml.p3.8xlarge"
            case .mlP4d24xlarge: return "ml.p4d.24xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceType(rawValue: rawValue) ?? InstanceType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes.JobCheckpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case localPath
        case s3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localPath = self.localPath {
            try encodeContainer.encode(localPath, forKey: .localPath)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localPath)
        localPath = localPathDecoded
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension BraketClientTypes {
    /// Contains information about the output locations for job checkpoint data.
    public struct JobCheckpointConfig: Swift.Equatable {
        /// (Optional) The local directory where checkpoints are written. The default directory is /opt/braket/checkpoints/.
        public var localPath: Swift.String?
        /// Identifies the S3 path where you want Amazon Braket to store checkpoints. For example, s3://bucket-name/key-name-prefix.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            localPath: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.localPath = localPath
            self.s3Uri = s3Uri
        }
    }

}

extension BraketClientTypes.JobEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType
        case message
        case timeOfEvent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let timeOfEvent = self.timeOfEvent {
            try encodeContainer.encodeTimestamp(timeOfEvent, format: .dateTime, forKey: .timeOfEvent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let timeOfEventDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .timeOfEvent)
        timeOfEvent = timeOfEventDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes {
    /// Details about the type and time events occurred related to the Amazon Braket job.
    public struct JobEventDetails: Swift.Equatable {
        /// The type of event that occurred related to the Amazon Braket job.
        public var eventType: BraketClientTypes.JobEventType?
        /// A message describing the event that occurred related to the Amazon Braket job.
        public var message: Swift.String?
        /// TThe type of event that occurred related to the Amazon Braket job.
        public var timeOfEvent: ClientRuntime.Date?

        public init(
            eventType: BraketClientTypes.JobEventType? = nil,
            message: Swift.String? = nil,
            timeOfEvent: ClientRuntime.Date? = nil
        )
        {
            self.eventType = eventType
            self.message = message
            self.timeOfEvent = timeOfEvent
        }
    }

}

extension BraketClientTypes {
    public enum JobEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case deprioritizedDueToInactivity
        case downloadingData
        case failed
        case maxRuntimeExceeded
        case queuedForExecution
        case running
        case startingInstance
        case uploadingResults
        case waitingForPriority
        case sdkUnknown(Swift.String)

        public static var allCases: [JobEventType] {
            return [
                .cancelled,
                .completed,
                .deprioritizedDueToInactivity,
                .downloadingData,
                .failed,
                .maxRuntimeExceeded,
                .queuedForExecution,
                .running,
                .startingInstance,
                .uploadingResults,
                .waitingForPriority,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .deprioritizedDueToInactivity: return "DEPRIORITIZED_DUE_TO_INACTIVITY"
            case .downloadingData: return "DOWNLOADING_DATA"
            case .failed: return "FAILED"
            case .maxRuntimeExceeded: return "MAX_RUNTIME_EXCEEDED"
            case .queuedForExecution: return "QUEUED_FOR_EXECUTION"
            case .running: return "RUNNING"
            case .startingInstance: return "STARTING_INSTANCE"
            case .uploadingResults: return "UPLOADING_RESULTS"
            case .waitingForPriority: return "WAITING_FOR_PRIORITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobEventType(rawValue: rawValue) ?? JobEventType.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes.JobOutputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
        case s3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Path = self.s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
    }
}

extension BraketClientTypes {
    /// Specifies the path to the S3 location where you want to store job artifacts and the encryption key used to store them.
    public struct JobOutputDataConfig: Swift.Equatable {
        /// The AWS Key Management Service (AWS KMS) key that Amazon Braket uses to encrypt the job training artifacts at rest using Amazon S3 server-side encryption.
        public var kmsKeyId: Swift.String?
        /// Identifies the S3 path where you want Amazon Braket to store the job training artifacts. For example, s3://bucket-name/key-name-prefix.
        /// This member is required.
        public var s3Path: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            s3Path: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Path = s3Path
        }
    }

}

extension BraketClientTypes {
    public enum JobPrimaryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [JobPrimaryStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .queued,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobPrimaryStatus(rawValue: rawValue) ?? JobPrimaryStatus.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes.JobStoppingCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRuntimeInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxRuntimeInSeconds = self.maxRuntimeInSeconds {
            try encodeContainer.encode(maxRuntimeInSeconds, forKey: .maxRuntimeInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRuntimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRuntimeInSeconds)
        maxRuntimeInSeconds = maxRuntimeInSecondsDecoded
    }
}

extension BraketClientTypes {
    /// Specifies limits for how long an Amazon Braket job can run.
    public struct JobStoppingCondition: Swift.Equatable {
        /// The maximum length of time, in seconds, that an Amazon Braket job can run.
        public var maxRuntimeInSeconds: Swift.Int?

        public init(
            maxRuntimeInSeconds: Swift.Int? = nil
        )
        {
            self.maxRuntimeInSeconds = maxRuntimeInSeconds
        }
    }

}

extension BraketClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case device
        case endedAt
        case jobArn
        case jobName
        case startedAt
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let device = self.device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let jobArn = self.jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobPrimaryStatus.self, forKey: .status)
        status = statusDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .device)
        device = deviceDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BraketClientTypes {
    /// Provides summary information about an Amazon Braket job.
    public struct JobSummary: Swift.Equatable {
        /// The date and time that the Amazon Braket job was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Provides summary information about the primary device used by an Amazon Braket job.
        /// This member is required.
        public var device: Swift.String?
        /// The date and time that the Amazon Braket job ended.
        public var endedAt: ClientRuntime.Date?
        /// The ARN of the Amazon Braket job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name of the Amazon Braket job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The date and time that the Amazon Braket job was started.
        public var startedAt: ClientRuntime.Date?
        /// The status of the Amazon Braket job.
        /// This member is required.
        public var status: BraketClientTypes.JobPrimaryStatus?
        /// A tag object that consists of a key and an optional value, used to manage metadata for Amazon Braket resources.
        public var tags: [Swift.String:Swift.String]?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            device: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: BraketClientTypes.JobPrimaryStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.device = device
            self.endedAt = endedAt
            self.jobArn = jobArn
            self.jobName = jobName
            self.startedAt = startedAt
            self.status = status
            self.tags = tags
        }
    }

}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Specify the resourceArn for the resource whose tags to display.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Displays the key, value pairs of tags associated with this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BraketClientTypes {
    public enum QuantumTaskAdditionalAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case queueInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [QuantumTaskAdditionalAttributeName] {
            return [
                .queueInfo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .queueInfo: return "QueueInfo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuantumTaskAdditionalAttributeName(rawValue: rawValue) ?? QuantumTaskAdditionalAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes.QuantumTaskQueueInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case position
        case queue
        case queuePriority
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let queue = self.queue {
            try encodeContainer.encode(queue.rawValue, forKey: .queue)
        }
        if let queuePriority = self.queuePriority {
            try encodeContainer.encode(queuePriority.rawValue, forKey: .queuePriority)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueDecoded = try containerValues.decodeIfPresent(BraketClientTypes.QueueName.self, forKey: .queue)
        queue = queueDecoded
        let positionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .position)
        position = positionDecoded
        let queuePriorityDecoded = try containerValues.decodeIfPresent(BraketClientTypes.QueuePriority.self, forKey: .queuePriority)
        queuePriority = queuePriorityDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes {
    /// Information about the queue for the specified quantum task.
    public struct QuantumTaskQueueInfo: Swift.Equatable {
        /// Optional. Provides more information about the queue position. For example, if the task is complete and no longer in the queue, the message field contains that information.
        public var message: Swift.String?
        /// Current position of the task in the quantum tasks queue.
        /// This member is required.
        public var position: Swift.String?
        /// The name of the queue.
        /// This member is required.
        public var queue: BraketClientTypes.QueueName?
        /// Optional. Specifies the priority of the queue. Quantum tasks in a priority queue are processed before the tasks in a normal queue.
        public var queuePriority: BraketClientTypes.QueuePriority?

        public init(
            message: Swift.String? = nil,
            position: Swift.String? = nil,
            queue: BraketClientTypes.QueueName? = nil,
            queuePriority: BraketClientTypes.QueuePriority? = nil
        )
        {
            self.message = message
            self.position = position
            self.queue = queue
            self.queuePriority = queuePriority
        }
    }

}

extension BraketClientTypes {
    public enum QuantumTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case created
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [QuantumTaskStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .created,
                .failed,
                .queued,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuantumTaskStatus(rawValue: rawValue) ?? QuantumTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes.QuantumTaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case deviceArn
        case endedAt
        case outputS3Bucket
        case outputS3Directory
        case quantumTaskArn
        case shots
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .dateTime, forKey: .endedAt)
        }
        if let outputS3Bucket = self.outputS3Bucket {
            try encodeContainer.encode(outputS3Bucket, forKey: .outputS3Bucket)
        }
        if let outputS3Directory = self.outputS3Directory {
            try encodeContainer.encode(outputS3Directory, forKey: .outputS3Directory)
        }
        if let quantumTaskArn = self.quantumTaskArn {
            try encodeContainer.encode(quantumTaskArn, forKey: .quantumTaskArn)
        }
        if let shots = self.shots {
            try encodeContainer.encode(shots, forKey: .shots)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.QuantumTaskStatus.self, forKey: .status)
        status = statusDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let shotsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shots)
        shots = shotsDecoded
        let outputS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Bucket)
        outputS3Bucket = outputS3BucketDecoded
        let outputS3DirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Directory)
        outputS3Directory = outputS3DirectoryDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedAt)
        endedAt = endedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BraketClientTypes {
    /// Includes information about a quantum task.
    public struct QuantumTaskSummary: Swift.Equatable {
        /// The time at which the task was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The ARN of the device the task ran on.
        /// This member is required.
        public var deviceArn: Swift.String?
        /// The time at which the task finished.
        public var endedAt: ClientRuntime.Date?
        /// The S3 bucket where the task result file is stored..
        /// This member is required.
        public var outputS3Bucket: Swift.String?
        /// The folder in the S3 bucket where the task result file is stored.
        /// This member is required.
        public var outputS3Directory: Swift.String?
        /// The ARN of the task.
        /// This member is required.
        public var quantumTaskArn: Swift.String?
        /// The shots used for the task.
        /// This member is required.
        public var shots: Swift.Int?
        /// The status of the task.
        /// This member is required.
        public var status: BraketClientTypes.QuantumTaskStatus?
        /// Displays the key, value pairs of tags associated with this quantum task.
        public var tags: [Swift.String:Swift.String]?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            deviceArn: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            outputS3Bucket: Swift.String? = nil,
            outputS3Directory: Swift.String? = nil,
            quantumTaskArn: Swift.String? = nil,
            shots: Swift.Int? = nil,
            status: BraketClientTypes.QuantumTaskStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.deviceArn = deviceArn
            self.endedAt = endedAt
            self.outputS3Bucket = outputS3Bucket
            self.outputS3Directory = outputS3Directory
            self.quantumTaskArn = quantumTaskArn
            self.shots = shots
            self.status = status
            self.tags = tags
        }
    }

}

extension BraketClientTypes {
    public enum QueueName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jobsQueue
        case quantumTasksQueue
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueName] {
            return [
                .jobsQueue,
                .quantumTasksQueue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jobsQueue: return "JOBS_QUEUE"
            case .quantumTasksQueue: return "QUANTUM_TASKS_QUEUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueueName(rawValue: rawValue) ?? QueueName.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes {
    public enum QueuePriority: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case normal
        case priority
        case sdkUnknown(Swift.String)

        public static var allCases: [QueuePriority] {
            return [
                .normal,
                .priority,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .normal: return "Normal"
            case .priority: return "Priority"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueuePriority(rawValue: rawValue) ?? QueuePriority.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes.S3DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension BraketClientTypes {
    /// Information about the data stored in Amazon S3 used by the Amazon Braket job.
    public struct S3DataSource: Swift.Equatable {
        /// Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest that locates the S3 data source.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BraketClientTypes.ScriptModeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compressionType
        case entryPoint
        case s3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compressionType = self.compressionType {
            try encodeContainer.encode(compressionType.rawValue, forKey: .compressionType)
        }
        if let entryPoint = self.entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let compressionTypeDecoded = try containerValues.decodeIfPresent(BraketClientTypes.CompressionType.self, forKey: .compressionType)
        compressionType = compressionTypeDecoded
    }
}

extension BraketClientTypes {
    /// Contains information about the Python scripts used for entry and by an Amazon Braket job.
    public struct ScriptModeConfig: Swift.Equatable {
        /// The type of compression used by the Python scripts for an Amazon Braket job.
        public var compressionType: BraketClientTypes.CompressionType?
        /// The path to the Python script that serves as the entry point for an Amazon Braket job.
        /// This member is required.
        public var entryPoint: Swift.String?
        /// The URI that specifies the S3 path to the Python script module that contains the training script used by an Amazon Braket job.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            compressionType: BraketClientTypes.CompressionType? = nil,
            entryPoint: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.compressionType = compressionType
            self.entryPoint = entryPoint
            self.s3Uri = s3Uri
        }
    }

}

extension BraketClientTypes.SearchDevicesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string2560 in values {
                try valuesContainer.encode(string2560)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension BraketClientTypes {
    /// The filter to use for searching devices.
    public struct SearchDevicesFilter: Swift.Equatable {
        /// The name to use to filter results.
        /// This member is required.
        public var name: Swift.String?
        /// The values to use to filter results.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension SearchDevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchdevicesfilter0 in filters {
                try filtersContainer.encode(searchdevicesfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/devices"
    }
}

public struct SearchDevicesInput: Swift.Equatable {
    /// The filter values to use to search for a device.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchDevicesFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        filters: [BraketClientTypes.SearchDevicesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchDevicesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [BraketClientTypes.SearchDevicesFilter]?
}

extension SearchDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([BraketClientTypes.SearchDevicesFilter?].self, forKey: .filters)
        var filtersDecoded0:[BraketClientTypes.SearchDevicesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [BraketClientTypes.SearchDevicesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchDevicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchDevicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct SearchDevicesOutput: Swift.Equatable {
    /// An array of DeviceSummary objects for devices that match the specified filter values.
    /// This member is required.
    public var devices: [BraketClientTypes.DeviceSummary]?
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        devices: [BraketClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct SearchDevicesOutputBody: Swift.Equatable {
    let devices: [BraketClientTypes.DeviceSummary]?
    let nextToken: Swift.String?
}

extension SearchDevicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([BraketClientTypes.DeviceSummary?].self, forKey: .devices)
        var devicesDecoded0:[BraketClientTypes.DeviceSummary]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [BraketClientTypes.DeviceSummary]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchDevicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BraketClientTypes.SearchJobsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string2560 in values {
                try valuesContainer.encode(string2560)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(BraketClientTypes.SearchJobsFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension BraketClientTypes {
    /// A filter used to search for Amazon Braket jobs.
    public struct SearchJobsFilter: Swift.Equatable {
        /// The name to use for the jobs filter.
        /// This member is required.
        public var name: Swift.String?
        /// An operator to use for the jobs filter.
        /// This member is required.
        public var `operator`: BraketClientTypes.SearchJobsFilterOperator?
        /// The values to use for the jobs filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            `operator`: BraketClientTypes.SearchJobsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension BraketClientTypes {
    public enum SearchJobsFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case contains
        case equal
        case gt
        case gte
        case lt
        case lte
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchJobsFilterOperator] {
            return [
                .between,
                .contains,
                .equal,
                .gt,
                .gte,
                .lt,
                .lte,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .equal: return "EQUAL"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .lt: return "LT"
            case .lte: return "LTE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchJobsFilterOperator(rawValue: rawValue) ?? SearchJobsFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension SearchJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchjobsfilter0 in filters {
                try filtersContainer.encode(searchjobsfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct SearchJobsInput: Swift.Equatable {
    /// The filter values to use when searching for a job.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchJobsFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request to continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        filters: [BraketClientTypes.SearchJobsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [BraketClientTypes.SearchJobsFilter]?
}

extension SearchJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([BraketClientTypes.SearchJobsFilter?].self, forKey: .filters)
        var filtersDecoded0:[BraketClientTypes.SearchJobsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [BraketClientTypes.SearchJobsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct SearchJobsOutput: Swift.Equatable {
    /// An array of JobSummary objects for devices that match the specified filter values.
    /// This member is required.
    public var jobs: [BraketClientTypes.JobSummary]?
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        jobs: [BraketClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct SearchJobsOutputBody: Swift.Equatable {
    let jobs: [BraketClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension SearchJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([BraketClientTypes.JobSummary?].self, forKey: .jobs)
        var jobsDecoded0:[BraketClientTypes.JobSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [BraketClientTypes.JobSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BraketClientTypes.SearchQuantumTasksFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string2560 in values {
                try valuesContainer.encode(string2560)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(BraketClientTypes.SearchQuantumTasksFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension BraketClientTypes {
    /// A filter to use to search for tasks.
    public struct SearchQuantumTasksFilter: Swift.Equatable {
        /// The name of the device used for the task.
        /// This member is required.
        public var name: Swift.String?
        /// An operator to use in the filter.
        /// This member is required.
        public var `operator`: BraketClientTypes.SearchQuantumTasksFilterOperator?
        /// The values to use for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            `operator`: BraketClientTypes.SearchQuantumTasksFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension BraketClientTypes {
    public enum SearchQuantumTasksFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case equal
        case gt
        case gte
        case lt
        case lte
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchQuantumTasksFilterOperator] {
            return [
                .between,
                .equal,
                .gt,
                .gte,
                .lt,
                .lte,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .equal: return "EQUAL"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .lt: return "LT"
            case .lte: return "LTE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchQuantumTasksFilterOperator(rawValue: rawValue) ?? SearchQuantumTasksFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension SearchQuantumTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchquantumtasksfilter0 in filters {
                try filtersContainer.encode(searchquantumtasksfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchQuantumTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/quantum-tasks"
    }
}

public struct SearchQuantumTasksInput: Swift.Equatable {
    /// Array of SearchQuantumTasksFilter objects.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchQuantumTasksFilter]?
    /// Maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init(
        filters: [BraketClientTypes.SearchQuantumTasksFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchQuantumTasksInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [BraketClientTypes.SearchQuantumTasksFilter]?
}

extension SearchQuantumTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([BraketClientTypes.SearchQuantumTasksFilter?].self, forKey: .filters)
        var filtersDecoded0:[BraketClientTypes.SearchQuantumTasksFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [BraketClientTypes.SearchQuantumTasksFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchQuantumTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchQuantumTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quantumTasks = output.quantumTasks
        } else {
            self.nextToken = nil
            self.quantumTasks = nil
        }
    }
}

public struct SearchQuantumTasksOutput: Swift.Equatable {
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.
    public var nextToken: Swift.String?
    /// An array of QuantumTaskSummary objects for tasks that match the specified filters.
    /// This member is required.
    public var quantumTasks: [BraketClientTypes.QuantumTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        quantumTasks: [BraketClientTypes.QuantumTaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quantumTasks = quantumTasks
    }
}

struct SearchQuantumTasksOutputBody: Swift.Equatable {
    let quantumTasks: [BraketClientTypes.QuantumTaskSummary]?
    let nextToken: Swift.String?
}

extension SearchQuantumTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case quantumTasks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTasksContainer = try containerValues.decodeIfPresent([BraketClientTypes.QuantumTaskSummary?].self, forKey: .quantumTasks)
        var quantumTasksDecoded0:[BraketClientTypes.QuantumTaskSummary]? = nil
        if let quantumTasksContainer = quantumTasksContainer {
            quantumTasksDecoded0 = [BraketClientTypes.QuantumTaskSummary]()
            for structure0 in quantumTasksContainer {
                if let structure0 = structure0 {
                    quantumTasksDecoded0?.append(structure0)
                }
            }
        }
        quantumTasks = quantumTasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchQuantumTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because a service quota is exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Specify the resourceArn of the resource to which a tag will be added.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specify the tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The throttling rate limit is met.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Specify the resourceArn for the resource from which to remove the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specify the keys for the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
