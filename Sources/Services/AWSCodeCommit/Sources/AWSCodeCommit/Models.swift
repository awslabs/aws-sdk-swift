//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox


public struct AssociateApprovalRuleTemplateWithRepositoryOutput: Swift.Sendable {

    public init() { }
}

public struct CreateBranchOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateApprovalRuleTemplateFromRepositoryOutput: Swift.Sendable {

    public init() { }
}

public struct OverridePullRequestApprovalRulesOutput: Swift.Sendable {

    public init() { }
}

public struct PutCommentReactionOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDefaultBranchOutput: Swift.Sendable {

    public init() { }
}

public struct UpdatePullRequestApprovalStateOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateRepositoryDescriptionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateRepositoryNameOutput: Swift.Sendable {

    public init() { }
}

/// The specified Amazon Resource Name (ARN) does not exist in the Amazon Web Services account.
public struct ActorDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ActorDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    public enum ApprovalState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approve
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [ApprovalState] {
            return [
                .approve,
                .revoke
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approve: return "APPROVE"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a specific approval on a pull request.
    public struct Approval: Swift.Sendable {
        /// The state of the approval, APPROVE or REVOKE. REVOKE states are not stored.
        public var approvalState: CodeCommitClientTypes.ApprovalState?
        /// The Amazon Resource Name (ARN) of the user.
        public var userArn: Swift.String?

        public init(
            approvalState: CodeCommitClientTypes.ApprovalState? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.approvalState = approvalState
            self.userArn = userArn
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about the template that created the approval rule for a pull request.
    public struct OriginApprovalRuleTemplate: Swift.Sendable {
        /// The ID of the template that created the approval rule.
        public var approvalRuleTemplateId: Swift.String?
        /// The name of the template that created the approval rule.
        public var approvalRuleTemplateName: Swift.String?

        public init(
            approvalRuleTemplateId: Swift.String? = nil,
            approvalRuleTemplateName: Swift.String? = nil
        )
        {
            self.approvalRuleTemplateId = approvalRuleTemplateId
            self.approvalRuleTemplateName = approvalRuleTemplateName
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about an approval rule.
    public struct ApprovalRule: Swift.Sendable {
        /// The content of the approval rule.
        public var approvalRuleContent: Swift.String?
        /// The system-generated ID of the approval rule.
        public var approvalRuleId: Swift.String?
        /// The name of the approval rule.
        public var approvalRuleName: Swift.String?
        /// The date the approval rule was created, in timestamp format.
        public var creationDate: Foundation.Date?
        /// The date the approval rule was most recently changed, in timestamp format.
        public var lastModifiedDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the user who made the most recent changes to the approval rule.
        public var lastModifiedUser: Swift.String?
        /// The approval rule template used to create the rule.
        public var originApprovalRuleTemplate: CodeCommitClientTypes.OriginApprovalRuleTemplate?
        /// The SHA-256 hash signature for the content of the approval rule.
        public var ruleContentSha256: Swift.String?

        public init(
            approvalRuleContent: Swift.String? = nil,
            approvalRuleId: Swift.String? = nil,
            approvalRuleName: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            originApprovalRuleTemplate: CodeCommitClientTypes.OriginApprovalRuleTemplate? = nil,
            ruleContentSha256: Swift.String? = nil
        )
        {
            self.approvalRuleContent = approvalRuleContent
            self.approvalRuleId = approvalRuleId
            self.approvalRuleName = approvalRuleName
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.originApprovalRuleTemplate = originApprovalRuleTemplate
            self.ruleContentSha256 = ruleContentSha256
        }
    }
}

/// The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.
public struct ApprovalRuleContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleContentRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified approval rule does not exist.
public struct ApprovalRuleDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    /// Returns information about an event for an approval rule.
    public struct ApprovalRuleEventMetadata: Swift.Sendable {
        /// The content of the approval rule.
        public var approvalRuleContent: Swift.String?
        /// The system-generated ID of the approval rule.
        public var approvalRuleId: Swift.String?
        /// The name of the approval rule.
        public var approvalRuleName: Swift.String?

        public init(
            approvalRuleContent: Swift.String? = nil,
            approvalRuleId: Swift.String? = nil,
            approvalRuleName: Swift.String? = nil
        )
        {
            self.approvalRuleContent = approvalRuleContent
            self.approvalRuleId = approvalRuleId
            self.approvalRuleName = approvalRuleName
        }
    }
}

/// An approval rule with that name already exists. Approval rule names must be unique within the scope of a pull request.
public struct ApprovalRuleNameAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleNameAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An approval rule name is required, but was not specified.
public struct ApprovalRuleNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleNameRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    public enum OverrideStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `override`
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [OverrideStatus] {
            return [
                .override,
                .revoke
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .override: return "OVERRIDE"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about an override event for approval rules for a pull request.
    public struct ApprovalRuleOverriddenEventMetadata: Swift.Sendable {
        /// The status of the override event.
        public var overrideStatus: CodeCommitClientTypes.OverrideStatus?
        /// The revision ID of the pull request when the override event occurred.
        public var revisionId: Swift.String?

        public init(
            overrideStatus: CodeCommitClientTypes.OverrideStatus? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.overrideStatus = overrideStatus
            self.revisionId = revisionId
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about an approval rule template.
    public struct ApprovalRuleTemplate: Swift.Sendable {
        /// The content of the approval rule template.
        public var approvalRuleTemplateContent: Swift.String?
        /// The description of the approval rule template.
        public var approvalRuleTemplateDescription: Swift.String?
        /// The system-generated ID of the approval rule template.
        public var approvalRuleTemplateId: Swift.String?
        /// The name of the approval rule template.
        public var approvalRuleTemplateName: Swift.String?
        /// The date the approval rule template was created, in timestamp format.
        public var creationDate: Foundation.Date?
        /// The date the approval rule template was most recently changed, in timestamp format.
        public var lastModifiedDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the user who made the most recent changes to the approval rule template.
        public var lastModifiedUser: Swift.String?
        /// The SHA-256 hash signature for the content of the approval rule template.
        public var ruleContentSha256: Swift.String?

        public init(
            approvalRuleTemplateContent: Swift.String? = nil,
            approvalRuleTemplateDescription: Swift.String? = nil,
            approvalRuleTemplateId: Swift.String? = nil,
            approvalRuleTemplateName: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            ruleContentSha256: Swift.String? = nil
        )
        {
            self.approvalRuleTemplateContent = approvalRuleTemplateContent
            self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
            self.approvalRuleTemplateId = approvalRuleTemplateId
            self.approvalRuleTemplateName = approvalRuleTemplateName
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.ruleContentSha256 = ruleContentSha256
        }
    }
}

/// The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.
public struct ApprovalRuleTemplateContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleTemplateContentRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the Amazon Web Services Region where the template was created, and then try again.
public struct ApprovalRuleTemplateDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleTemplateDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove all associations, and then try again.
public struct ApprovalRuleTemplateInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleTemplateInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You cannot create an approval rule template with that name because a template with that name already exists in this Amazon Web Services Region for your Amazon Web Services account. Approval rule template names must be unique.
public struct ApprovalRuleTemplateNameAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleTemplateNameAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An approval rule template name is required, but was not specified.
public struct ApprovalRuleTemplateNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleTemplateNameRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a change in the approval state for a pull request.
    public struct ApprovalStateChangedEventMetadata: Swift.Sendable {
        /// The approval status for the pull request.
        public var approvalStatus: CodeCommitClientTypes.ApprovalState?
        /// The revision ID of the pull request when the approval state changed.
        public var revisionId: Swift.String?

        public init(
            approvalStatus: CodeCommitClientTypes.ApprovalState? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.approvalStatus = approvalStatus
            self.revisionId = revisionId
        }
    }
}

/// An approval state is required, but was not specified.
public struct ApprovalStateRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalStateRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An encryption integrity check failed.
public struct EncryptionIntegrityChecksFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionIntegrityChecksFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An encryption key could not be accessed.
public struct EncryptionKeyAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyAccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The encryption key is disabled.
public struct EncryptionKeyDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyDisabledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// No encryption key was found.
public struct EncryptionKeyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The encryption key is not available.
public struct EncryptionKeyUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in CodeCommit, see [Quotas](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html) in the CodeCommit User Guide.
public struct InvalidApprovalRuleTemplateNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalRuleTemplateNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A specified repository name is not valid. This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.
public struct InvalidRepositoryNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25 approval rule templates with a repository.
public struct MaximumRuleTemplatesAssociatedWithRepositoryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumRuleTemplatesAssociatedWithRepositoryException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified repository does not exist.
public struct RepositoryDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A repository name is required, but was not specified.
public struct RepositoryNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryNameRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateApprovalRuleTemplateWithRepositoryInput: Swift.Sendable {
    /// The name for the approval rule template.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The name of the repository that you want to associate with the template.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryName = repositoryName
    }
}

/// The specified Amazon Resource Name (ARN) does not exist in the Amazon Web Services account.
public struct AuthorDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of allowed repository names was exceeded. Currently, this number is 100.
public struct MaximumRepositoryNamesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumRepositoryNamesExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// At least one repository name object is required, but was not specified.
public struct RepositoryNamesRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryNamesRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesInput: Swift.Sendable {
    /// The name of the template you want to associate with one or more repositories.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The names of the repositories you want to associate with the template. The length constraint limit is for each string in the array. The array itself can be empty.
    /// This member is required.
    public var repositoryNames: [Swift.String]?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryNames = repositoryNames
    }
}

extension CodeCommitClientTypes {

    /// Returns information about errors in a BatchAssociateApprovalRuleTemplateWithRepositories operation.
    public struct BatchAssociateApprovalRuleTemplateWithRepositoriesError: Swift.Sendable {
        /// An error code that specifies whether the repository name was not valid or not found.
        public var errorCode: Swift.String?
        /// An error message that provides details about why the repository name was not found or not valid.
        public var errorMessage: Swift.String?
        /// The name of the repository where the association was not made.
        public var repositoryName: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.repositoryName = repositoryName
        }
    }
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesOutput: Swift.Sendable {
    /// A list of names of the repositories that have been associated with the template.
    /// This member is required.
    public var associatedRepositoryNames: [Swift.String]?
    /// A list of any errors that might have occurred while attempting to create the association between the template and the repositories.
    /// This member is required.
    public var errors: [CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]?

    public init(
        associatedRepositoryNames: [Swift.String]? = nil,
        errors: [CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]? = nil
    )
    {
        self.associatedRepositoryNames = associatedRepositoryNames
        self.errors = errors
    }
}

/// The specified commit does not exist or no commit was specified, and the specified repository has no default branch.
public struct CommitDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A commit was not specified.
public struct CommitRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified commit is not valid.
public struct InvalidCommitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCommitException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified conflict detail level is not valid.
public struct InvalidConflictDetailLevelException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConflictDetailLevelException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified conflict resolution strategy is not valid.
public struct InvalidConflictResolutionStrategyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConflictResolutionStrategyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified continuation token is not valid.
public struct InvalidContinuationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidContinuationTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified value for the number of conflict files to return is not valid.
public struct InvalidMaxConflictFilesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMaxConflictFilesException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified value for the number of merge hunks to return is not valid.
public struct InvalidMaxMergeHunksException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMaxMergeHunksException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.
public struct InvalidMergeOptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMergeOptionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of files to load exceeds the allowed limit.
public struct MaximumFileContentToLoadExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumFileContentToLoadExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.
public struct MaximumItemsToCompareExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumItemsToCompareExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A merge option or stategy is required, and none was provided.
public struct MergeOptionRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MergeOptionRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using git diff or a diff tool.
public struct TipsDivergenceExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TipsDivergenceExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    public enum ConflictDetailLevelTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fileLevel
        case lineLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictDetailLevelTypeEnum] {
            return [
                .fileLevel,
                .lineLevel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fileLevel: return "FILE_LEVEL"
            case .lineLevel: return "LINE_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    public enum ConflictResolutionStrategyTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acceptDestination
        case acceptSource
        case automerge
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictResolutionStrategyTypeEnum] {
            return [
                .acceptDestination,
                .acceptSource,
                .automerge,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acceptDestination: return "ACCEPT_DESTINATION"
            case .acceptSource: return "ACCEPT_SOURCE"
            case .automerge: return "AUTOMERGE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    public enum MergeOptionTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fastForwardMerge
        case squashMerge
        case threeWayMerge
        case sdkUnknown(Swift.String)

        public static var allCases: [MergeOptionTypeEnum] {
            return [
                .fastForwardMerge,
                .squashMerge,
                .threeWayMerge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fastForwardMerge: return "FAST_FORWARD_MERGE"
            case .squashMerge: return "SQUASH_MERGE"
            case .threeWayMerge: return "THREE_WAY_MERGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct BatchDescribeMergeConflictsInput: Swift.Sendable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The path of the target files used to describe the conflicts. If not specified, the default is all conflict files.
    public var filePaths: [Swift.String]?
    /// The maximum number of files to include in the output.
    public var maxConflictFiles: Swift.Int?
    /// The maximum number of merge hunks to include in the output.
    public var maxMergeHunks: Swift.Int?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository that contains the merge conflicts you want to review.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        filePaths: [Swift.String]? = nil,
        maxConflictFiles: Swift.Int? = nil,
        maxMergeHunks: Swift.Int? = nil,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.filePaths = filePaths
        self.maxConflictFiles = maxConflictFiles
        self.maxMergeHunks = maxMergeHunks
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

extension CodeCommitClientTypes {

    public enum FileModeTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case executable
        case normal
        case symlink
        case sdkUnknown(Swift.String)

        public static var allCases: [FileModeTypeEnum] {
            return [
                .executable,
                .normal,
                .symlink
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .executable: return "EXECUTABLE"
            case .normal: return "NORMAL"
            case .symlink: return "SYMLINK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about file modes in a merge or pull request.
    public struct FileModes: Swift.Sendable {
        /// The file mode of a file in the base of a merge or pull request.
        public var base: CodeCommitClientTypes.FileModeTypeEnum?
        /// The file mode of a file in the destination of a merge or pull request.
        public var destination: CodeCommitClientTypes.FileModeTypeEnum?
        /// The file mode of a file in the source of a merge or pull request.
        public var source: CodeCommitClientTypes.FileModeTypeEnum?

        public init(
            base: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            destination: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            source: CodeCommitClientTypes.FileModeTypeEnum? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about the size of files in a merge or pull request.
    public struct FileSizes: Swift.Sendable {
        /// The size of a file in the base of a merge or pull request.
        public var base: Swift.Int
        /// The size of a file in the destination of a merge or pull request.
        public var destination: Swift.Int
        /// The size of a file in the source of a merge or pull request.
        public var source: Swift.Int

        public init(
            base: Swift.Int = 0,
            destination: Swift.Int = 0,
            source: Swift.Int = 0
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about whether a file is binary or textual in a merge or pull request operation.
    public struct IsBinaryFile: Swift.Sendable {
        /// The binary or non-binary status of a file in the base of a merge or pull request.
        public var base: Swift.Bool?
        /// The binary or non-binary status of a file in the destination of a merge or pull request.
        public var destination: Swift.Bool?
        /// The binary or non-binary status of file in the source of a merge or pull request.
        public var source: Swift.Bool?

        public init(
            base: Swift.Bool? = nil,
            destination: Swift.Bool? = nil,
            source: Swift.Bool? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }
}

extension CodeCommitClientTypes {

    public enum ChangeTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case added
        case deleted
        case modified
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeTypeEnum] {
            return [
                .added,
                .deleted,
                .modified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .added: return "A"
            case .deleted: return "D"
            case .modified: return "M"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about the file operation conflicts in a merge operation.
    public struct MergeOperations: Swift.Sendable {
        /// The operation on a file in the destination of a merge or pull request.
        public var destination: CodeCommitClientTypes.ChangeTypeEnum?
        /// The operation (add, modify, or delete) on a file in the source of a merge or pull request.
        public var source: CodeCommitClientTypes.ChangeTypeEnum?

        public init(
            destination: CodeCommitClientTypes.ChangeTypeEnum? = nil,
            source: CodeCommitClientTypes.ChangeTypeEnum? = nil
        )
        {
            self.destination = destination
            self.source = source
        }
    }
}

extension CodeCommitClientTypes {

    public enum ObjectTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case directory
        case file
        case gitLink
        case symbolicLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectTypeEnum] {
            return [
                .directory,
                .file,
                .gitLink,
                .symbolicLink
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .directory: return "DIRECTORY"
            case .file: return "FILE"
            case .gitLink: return "GIT_LINK"
            case .symbolicLink: return "SYMBOLIC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about the type of an object in a merge operation.
    public struct ObjectTypes: Swift.Sendable {
        /// The type of the object in the base commit of the merge.
        public var base: CodeCommitClientTypes.ObjectTypeEnum?
        /// The type of the object in the destination branch.
        public var destination: CodeCommitClientTypes.ObjectTypeEnum?
        /// The type of the object in the source branch.
        public var source: CodeCommitClientTypes.ObjectTypeEnum?

        public init(
            base: CodeCommitClientTypes.ObjectTypeEnum? = nil,
            destination: CodeCommitClientTypes.ObjectTypeEnum? = nil,
            source: CodeCommitClientTypes.ObjectTypeEnum? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about the metadata for a conflict in a merge operation.
    public struct ConflictMetadata: Swift.Sendable {
        /// A boolean value indicating whether there are conflicts in the content of a file.
        public var contentConflict: Swift.Bool
        /// A boolean value indicating whether there are conflicts in the file mode of a file.
        public var fileModeConflict: Swift.Bool
        /// The file modes of the file in the source, destination, and base of the merge.
        public var fileModes: CodeCommitClientTypes.FileModes?
        /// The path of the file that contains conflicts.
        public var filePath: Swift.String?
        /// The file sizes of the file in the source, destination, and base of the merge.
        public var fileSizes: CodeCommitClientTypes.FileSizes?
        /// A boolean value (true or false) indicating whether the file is binary or textual in the source, destination, and base of the merge.
        public var isBinaryFile: CodeCommitClientTypes.IsBinaryFile?
        /// Whether an add, modify, or delete operation caused the conflict between the source and destination of the merge.
        public var mergeOperations: CodeCommitClientTypes.MergeOperations?
        /// The number of conflicts, including both hunk conflicts and metadata conflicts.
        public var numberOfConflicts: Swift.Int
        /// A boolean value (true or false) indicating whether there are conflicts between the branches in the object type of a file, folder, or submodule.
        public var objectTypeConflict: Swift.Bool
        /// Information about any object type conflicts in a merge operation.
        public var objectTypes: CodeCommitClientTypes.ObjectTypes?

        public init(
            contentConflict: Swift.Bool = false,
            fileModeConflict: Swift.Bool = false,
            fileModes: CodeCommitClientTypes.FileModes? = nil,
            filePath: Swift.String? = nil,
            fileSizes: CodeCommitClientTypes.FileSizes? = nil,
            isBinaryFile: CodeCommitClientTypes.IsBinaryFile? = nil,
            mergeOperations: CodeCommitClientTypes.MergeOperations? = nil,
            numberOfConflicts: Swift.Int = 0,
            objectTypeConflict: Swift.Bool = false,
            objectTypes: CodeCommitClientTypes.ObjectTypes? = nil
        )
        {
            self.contentConflict = contentConflict
            self.fileModeConflict = fileModeConflict
            self.fileModes = fileModes
            self.filePath = filePath
            self.fileSizes = fileSizes
            self.isBinaryFile = isBinaryFile
            self.mergeOperations = mergeOperations
            self.numberOfConflicts = numberOfConflicts
            self.objectTypeConflict = objectTypeConflict
            self.objectTypes = objectTypes
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about the details of a merge hunk that contains a conflict in a merge or pull request operation.
    public struct MergeHunkDetail: Swift.Sendable {
        /// The end position of the hunk in the merge result.
        public var endLine: Swift.Int?
        /// The base-64 encoded content of the hunk merged region that might contain a conflict.
        public var hunkContent: Swift.String?
        /// The start position of the hunk in the merge result.
        public var startLine: Swift.Int?

        public init(
            endLine: Swift.Int? = nil,
            hunkContent: Swift.String? = nil,
            startLine: Swift.Int? = nil
        )
        {
            self.endLine = endLine
            self.hunkContent = hunkContent
            self.startLine = startLine
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about merge hunks in a merge or pull request operation.
    public struct MergeHunk: Swift.Sendable {
        /// Information about the merge hunk in the base of a merge or pull request.
        public var base: CodeCommitClientTypes.MergeHunkDetail?
        /// Information about the merge hunk in the destination of a merge or pull request.
        public var destination: CodeCommitClientTypes.MergeHunkDetail?
        /// A Boolean value indicating whether a combination of hunks contains a conflict. Conflicts occur when the same file or the same lines in a file were modified in both the source and destination of a merge or pull request. Valid values include true, false, and null. True when the hunk represents a conflict and one or more files contains a line conflict. File mode conflicts in a merge do not set this to true.
        public var isConflict: Swift.Bool
        /// Information about the merge hunk in the source of a merge or pull request.
        public var source: CodeCommitClientTypes.MergeHunkDetail?

        public init(
            base: CodeCommitClientTypes.MergeHunkDetail? = nil,
            destination: CodeCommitClientTypes.MergeHunkDetail? = nil,
            isConflict: Swift.Bool = false,
            source: CodeCommitClientTypes.MergeHunkDetail? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.isConflict = isConflict
            self.source = source
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about conflicts in a merge operation.
    public struct Conflict: Swift.Sendable {
        /// Metadata about a conflict in a merge operation.
        public var conflictMetadata: CodeCommitClientTypes.ConflictMetadata?
        /// A list of hunks that contain the differences between files or lines causing the conflict.
        public var mergeHunks: [CodeCommitClientTypes.MergeHunk]?

        public init(
            conflictMetadata: CodeCommitClientTypes.ConflictMetadata? = nil,
            mergeHunks: [CodeCommitClientTypes.MergeHunk]? = nil
        )
        {
            self.conflictMetadata = conflictMetadata
            self.mergeHunks = mergeHunks
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about errors in a BatchDescribeMergeConflicts operation.
    public struct BatchDescribeMergeConflictsError: Swift.Sendable {
        /// The name of the exception.
        /// This member is required.
        public var exceptionName: Swift.String?
        /// The path to the file.
        /// This member is required.
        public var filePath: Swift.String?
        /// The message provided by the exception.
        /// This member is required.
        public var message: Swift.String?

        public init(
            exceptionName: Swift.String? = nil,
            filePath: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.exceptionName = exceptionName
            self.filePath = filePath
            self.message = message
        }
    }
}

public struct BatchDescribeMergeConflictsOutput: Swift.Sendable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// A list of conflicts for each file, including the conflict metadata and the hunks of the differences between the files.
    /// This member is required.
    public var conflicts: [CodeCommitClientTypes.Conflict]?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// A list of any errors returned while describing the merge conflicts for each file.
    public var errors: [CodeCommitClientTypes.BatchDescribeMergeConflictsError]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init(
        baseCommitId: Swift.String? = nil,
        conflicts: [CodeCommitClientTypes.Conflict]? = nil,
        destinationCommitId: Swift.String? = nil,
        errors: [CodeCommitClientTypes.BatchDescribeMergeConflictsError]? = nil,
        nextToken: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflicts = conflicts
        self.destinationCommitId = destinationCommitId
        self.errors = errors
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesInput: Swift.Sendable {
    /// The name of the template that you want to disassociate from one or more repositories.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The repository names that you want to disassociate from the approval rule template. The length constraint limit is for each string in the array. The array itself can be empty.
    /// This member is required.
    public var repositoryNames: [Swift.String]?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryNames = repositoryNames
    }
}

extension CodeCommitClientTypes {

    /// Returns information about errors in a BatchDisassociateApprovalRuleTemplateFromRepositories operation.
    public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesError: Swift.Sendable {
        /// An error code that specifies whether the repository name was not valid or not found.
        public var errorCode: Swift.String?
        /// An error message that provides details about why the repository name was either not found or not valid.
        public var errorMessage: Swift.String?
        /// The name of the repository where the association with the template was not able to be removed.
        public var repositoryName: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.repositoryName = repositoryName
        }
    }
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput: Swift.Sendable {
    /// A list of repository names that have had their association with the template removed.
    /// This member is required.
    public var disassociatedRepositoryNames: [Swift.String]?
    /// A list of any errors that might have occurred while attempting to remove the association between the template and the repositories.
    /// This member is required.
    public var errors: [CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]?

    public init(
        disassociatedRepositoryNames: [Swift.String]? = nil,
        errors: [CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]? = nil
    )
    {
        self.disassociatedRepositoryNames = disassociatedRepositoryNames
        self.errors = errors
    }
}

/// The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.
public struct CommitIdsLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitIdsLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A list of commit IDs is required, but was either not specified or the list was empty.
public struct CommitIdsListRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitIdsListRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchGetCommitsInput: Swift.Sendable {
    /// The full commit IDs of the commits to get information about. You must supply the full SHA IDs of each commit. You cannot use shortened SHA IDs.
    /// This member is required.
    public var commitIds: [Swift.String]?
    /// The name of the repository that contains the commits.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        commitIds: [Swift.String]? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitIds = commitIds
        self.repositoryName = repositoryName
    }
}

extension CodeCommitClientTypes {

    /// Information about the user who made a specified commit.
    public struct UserInfo: Swift.Sendable {
        /// The date when the specified commit was commited, in timestamp format with GMT offset.
        public var date: Swift.String?
        /// The email address associated with the user who made the commit, if any.
        public var email: Swift.String?
        /// The name of the user who made the specified commit.
        public var name: Swift.String?

        public init(
            date: Swift.String? = nil,
            email: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.date = date
            self.email = email
            self.name = name
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a specific commit.
    public struct Commit: Swift.Sendable {
        /// Any other data associated with the specified commit.
        public var additionalData: Swift.String?
        /// Information about the author of the specified commit. Information includes the date in timestamp format with GMT offset, the name of the author, and the email address for the author, as configured in Git.
        public var author: CodeCommitClientTypes.UserInfo?
        /// The full SHA ID of the specified commit.
        public var commitId: Swift.String?
        /// Information about the person who committed the specified commit, also known as the committer. Information includes the date in timestamp format with GMT offset, the name of the committer, and the email address for the committer, as configured in Git. For more information about the difference between an author and a committer in Git, see [Viewing the Commit History](http://git-scm.com/book/ch2-3.html) in Pro Git by Scott Chacon and Ben Straub.
        public var committer: CodeCommitClientTypes.UserInfo?
        /// The commit message associated with the specified commit.
        public var message: Swift.String?
        /// A list of parent commits for the specified commit. Each parent commit ID is the full commit ID.
        public var parents: [Swift.String]?
        /// Tree information for the specified commit.
        public var treeId: Swift.String?

        public init(
            additionalData: Swift.String? = nil,
            author: CodeCommitClientTypes.UserInfo? = nil,
            commitId: Swift.String? = nil,
            committer: CodeCommitClientTypes.UserInfo? = nil,
            message: Swift.String? = nil,
            parents: [Swift.String]? = nil,
            treeId: Swift.String? = nil
        )
        {
            self.additionalData = additionalData
            self.author = author
            self.commitId = commitId
            self.committer = committer
            self.message = message
            self.parents = parents
            self.treeId = treeId
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about errors in a BatchGetCommits operation.
    public struct BatchGetCommitsError: Swift.Sendable {
        /// A commit ID that either could not be found or was not in a valid format.
        public var commitId: Swift.String?
        /// An error code that specifies whether the commit ID was not valid or not found.
        public var errorCode: Swift.String?
        /// An error message that provides detail about why the commit ID either was not found or was not valid.
        public var errorMessage: Swift.String?

        public init(
            commitId: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.commitId = commitId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

public struct BatchGetCommitsOutput: Swift.Sendable {
    /// An array of commit data type objects, each of which contains information about a specified commit.
    public var commits: [CodeCommitClientTypes.Commit]?
    /// Returns any commit IDs for which information could not be found. For example, if one of the commit IDs was a shortened SHA ID or that commit was not found in the specified repository, the ID returns an error object with more information.
    public var errors: [CodeCommitClientTypes.BatchGetCommitsError]?

    public init(
        commits: [CodeCommitClientTypes.Commit]? = nil,
        errors: [CodeCommitClientTypes.BatchGetCommitsError]? = nil
    )
    {
        self.commits = commits
        self.errors = errors
    }
}

/// Represents the input of a batch get repositories operation.
public struct BatchGetRepositoriesInput: Swift.Sendable {
    /// The names of the repositories to get information about. The length constraint limit is for each string in the array. The array itself can be empty.
    /// This member is required.
    public var repositoryNames: [Swift.String]?

    public init(
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.repositoryNames = repositoryNames
    }
}

extension CodeCommitClientTypes {

    public enum BatchGetRepositoriesErrorCodeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case encryptionIntegrityChecksFailedException
        case encryptionKeyAccessDeniedException
        case encryptionKeyDisabledException
        case encryptionKeyNotFoundException
        case encryptionKeyUnavailableException
        case repositoryDoesNotExistException
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchGetRepositoriesErrorCodeEnum] {
            return [
                .encryptionIntegrityChecksFailedException,
                .encryptionKeyAccessDeniedException,
                .encryptionKeyDisabledException,
                .encryptionKeyNotFoundException,
                .encryptionKeyUnavailableException,
                .repositoryDoesNotExistException
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .encryptionIntegrityChecksFailedException: return "EncryptionIntegrityChecksFailedException"
            case .encryptionKeyAccessDeniedException: return "EncryptionKeyAccessDeniedException"
            case .encryptionKeyDisabledException: return "EncryptionKeyDisabledException"
            case .encryptionKeyNotFoundException: return "EncryptionKeyNotFoundException"
            case .encryptionKeyUnavailableException: return "EncryptionKeyUnavailableException"
            case .repositoryDoesNotExistException: return "RepositoryDoesNotExistException"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about errors in a BatchGetRepositories operation.
    public struct BatchGetRepositoriesError: Swift.Sendable {
        /// An error code that specifies the type of failure.
        public var errorCode: CodeCommitClientTypes.BatchGetRepositoriesErrorCodeEnum?
        /// An error message that provides detail about why the repository either was not found or was not in a valid state.
        public var errorMessage: Swift.String?
        /// The ID of a repository that either could not be found or was not in a valid state.
        public var repositoryId: Swift.String?
        /// The name of a repository that either could not be found or was not in a valid state.
        public var repositoryName: Swift.String?

        public init(
            errorCode: CodeCommitClientTypes.BatchGetRepositoriesErrorCodeEnum? = nil,
            errorMessage: Swift.String? = nil,
            repositoryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.repositoryId = repositoryId
            self.repositoryName = repositoryName
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about a repository.
    public struct RepositoryMetadata: Swift.Sendable {
        /// The ID of the Amazon Web Services account associated with the repository.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the repository.
        public var arn: Swift.String?
        /// The URL to use for cloning the repository over HTTPS.
        public var cloneUrlHttp: Swift.String?
        /// The URL to use for cloning the repository over SSH.
        public var cloneUrlSsh: Swift.String?
        /// The date and time the repository was created, in timestamp format.
        public var creationDate: Foundation.Date?
        /// The repository's default branch name.
        public var defaultBranch: Swift.String?
        /// The ID of the Key Management Service encryption key used to encrypt and decrypt the repository.
        public var kmsKeyId: Swift.String?
        /// The date and time the repository was last modified, in timestamp format.
        public var lastModifiedDate: Foundation.Date?
        /// A comment or description about the repository.
        public var repositoryDescription: Swift.String?
        /// The ID of the repository.
        public var repositoryId: Swift.String?
        /// The repository's name.
        public var repositoryName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            cloneUrlHttp: Swift.String? = nil,
            cloneUrlSsh: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            defaultBranch: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            repositoryDescription: Swift.String? = nil,
            repositoryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.cloneUrlHttp = cloneUrlHttp
            self.cloneUrlSsh = cloneUrlSsh
            self.creationDate = creationDate
            self.defaultBranch = defaultBranch
            self.kmsKeyId = kmsKeyId
            self.lastModifiedDate = lastModifiedDate
            self.repositoryDescription = repositoryDescription
            self.repositoryId = repositoryId
            self.repositoryName = repositoryName
        }
    }
}

/// Represents the output of a batch get repositories operation.
public struct BatchGetRepositoriesOutput: Swift.Sendable {
    /// Returns information about any errors returned when attempting to retrieve information about the repositories.
    public var errors: [CodeCommitClientTypes.BatchGetRepositoriesError]?
    /// A list of repositories returned by the batch get repositories operation.
    public var repositories: [CodeCommitClientTypes.RepositoryMetadata]?
    /// Returns a list of repository names for which information could not be found.
    public var repositoriesNotFound: [Swift.String]?

    public init(
        errors: [CodeCommitClientTypes.BatchGetRepositoriesError]? = nil,
        repositories: [CodeCommitClientTypes.RepositoryMetadata]? = nil,
        repositoriesNotFound: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.repositories = repositories
        self.repositoriesNotFound = repositoriesNotFound
    }
}

/// The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.
public struct BeforeCommitIdAndAfterCommitIdAreSameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BeforeCommitIdAndAfterCommitIdAreSameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified blob does not exist.
public struct BlobIdDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BlobIdDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A blob ID is required, but was not specified.
public struct BlobIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BlobIdRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a specific Git blob object.
    public struct BlobMetadata: Swift.Sendable {
        /// The full ID of the blob.
        public var blobId: Swift.String?
        /// The file mode permissions of the blob. File mode permission codes include:
        ///
        /// * 100644 indicates read/write
        ///
        /// * 100755 indicates read/write/execute
        ///
        /// * 160000 indicates a submodule
        ///
        /// * 120000 indicates a symlink
        public var mode: Swift.String?
        /// The path to the blob and associated file name, if any.
        public var path: Swift.String?

        public init(
            blobId: Swift.String? = nil,
            mode: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.blobId = blobId
            self.mode = mode
            self.path = path
        }
    }
}

/// The specified branch does not exist.
public struct BranchDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BranchDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a branch.
    public struct BranchInfo: Swift.Sendable {
        /// The name of the branch.
        public var branchName: Swift.String?
        /// The ID of the last commit made to the branch.
        public var commitId: Swift.String?

        public init(
            branchName: Swift.String? = nil,
            commitId: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.commitId = commitId
        }
    }
}

/// Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name. Branch names must be unique.
public struct BranchNameExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BranchNameExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use [ListBranches].
public struct BranchNameIsTagNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BranchNameIsTagNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A branch name is required, but was not specified.
public struct BranchNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BranchNameRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The approval rule cannot be deleted from the pull request because it was created by an approval rule template and applied to the pull request automatically.
public struct CannotDeleteApprovalRuleFromTemplateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotDeleteApprovalRuleFromTemplateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The approval rule cannot be modified for the pull request because it was created by an approval rule template and applied to the pull request automatically.
public struct CannotModifyApprovalRuleFromTemplateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotModifyApprovalRuleFromTemplateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
public struct ClientRequestTokenRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClientRequestTokenRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The content of the approval rule template is not valid.
public struct InvalidApprovalRuleTemplateContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalRuleTemplateContentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in CodeCommit, see [Quotas](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html) in the CodeCommit User Guide.
public struct InvalidApprovalRuleTemplateDescriptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalRuleTemplateDescriptionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of approval rule templates has been exceeded for this Amazon Web Services Region.
public struct NumberOfRuleTemplatesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NumberOfRuleTemplatesExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateApprovalRuleTemplateInput: Swift.Sendable {
    /// The content of the approval rule that is created on pull requests in associated repositories. If you specify one or more destination references (branches), approval rules are created in an associated repository only if their destination references (branches) match those specified in the template. When you create the content of the approval rule template, you can specify approvers in an approval pool in one of two ways:
    ///
    /// * CodeCommitApprovers: This option only requires an Amazon Web Services account and a resource. It can be used for both IAM users and federated access users whose name matches the provided resource name. This is a very powerful option that offers a great deal of flexibility. For example, if you specify the Amazon Web Services account 123456789012 and Mary_Major, all of the following are counted as approvals coming from that user:
    ///
    /// * An IAM user in the account (arn:aws:iam::123456789012:user/Mary_Major)
    ///
    /// * A federated user identified in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
    ///
    ///
    /// This option does not recognize an active session of someone assuming the role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major) unless you include a wildcard (*Mary_Major).
    ///
    /// * Fully qualified ARN: This option allows you to specify the fully qualified Amazon Resource Name (ARN) of the IAM user or role.
    ///
    ///
    /// For more information about IAM ARNs, wildcards, and formats, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var approvalRuleTemplateContent: Swift.String?
    /// The description of the approval rule template. Consider providing a description that explains what this template does and when it might be appropriate to associate it with repositories.
    public var approvalRuleTemplateDescription: Swift.String?
    /// The name of the approval rule template. Provide descriptive names, because this name is applied to the approval rules created automatically in associated repositories.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init(
        approvalRuleTemplateContent: Swift.String? = nil,
        approvalRuleTemplateDescription: Swift.String? = nil,
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateContent = approvalRuleTemplateContent
        self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

public struct CreateApprovalRuleTemplateOutput: Swift.Sendable {
    /// The content and structure of the created approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init(
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

/// A commit ID was not specified.
public struct CommitIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitIdRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified reference name is not valid.
public struct InvalidBranchNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidBranchNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified commit ID is not valid.
public struct InvalidCommitIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCommitIdException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Represents the input of a create branch operation.
public struct CreateBranchInput: Swift.Sendable {
    /// The name of the new branch to create.
    /// This member is required.
    public var branchName: Swift.String?
    /// The ID of the commit to point the new branch to.
    /// This member is required.
    public var commitId: Swift.String?
    /// The name of the repository in which you want to create the new branch.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        commitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.commitId = commitId
        self.repositoryName = repositoryName
    }
}

/// The commit message is too long. Provide a shorter string.
public struct CommitMessageLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitMessageLengthExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.
public struct DirectoryNameConflictsWithFileNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryNameConflictsWithFileNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The commit cannot be created because both a source file and file content have been specified for the same file. You cannot provide both. Either specify a source file or provide the file content directly.
public struct FileContentAndSourceFileSpecifiedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileContentAndSourceFileSpecifiedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.
public struct FileContentSizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileContentSizeLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified file does not exist. Verify that you have used the correct file name, full path, and extension.
public struct FileDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.
public struct FileEntryRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileEntryRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.
public struct FileModeRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileModeRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.
public struct FileNameConflictsWithDirectoryNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileNameConflictsWithDirectoryNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.
public struct FilePathConflictsWithSubmodulePathException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FilePathConflictsWithSubmodulePathException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.
public struct FolderContentSizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FolderContentSizeLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified deletion parameter is not valid.
public struct InvalidDeletionParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDeletionParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.
public struct InvalidEmailException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEmailException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified file mode permission is not valid. For a list of valid file mode permissions, see [PutFile].
public struct InvalidFileModeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFileModeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.
public struct InvalidParentCommitIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParentCommitIdException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified path is not valid.
public struct InvalidPathException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPathException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of specified files to change as part of this commit exceeds the maximum number of files that can be changed in a single commit. Consider using a Git client for these changes.
public struct MaximumFileEntriesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumFileEntriesExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The user name is not valid because it has exceeded the character limit for author names.
public struct NameLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NameLengthExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.
public struct NoChangeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoChangeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.
public struct ParentCommitDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParentCommitDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use [GetBranch].
public struct ParentCommitIdOutdatedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParentCommitIdOutdatedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A parent commit ID is required. To view the full commit ID of a branch in a repository, use [GetBranch] or a Git command (for example, git pull or git log).
public struct ParentCommitIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParentCommitIdRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The folderPath for a location cannot be null.
public struct PathRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PathRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The commit cannot be created because one or more files specified in the commit reference both a file and a folder.
public struct PutFileEntryConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PutFileEntryConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.
public struct RestrictedSourceFileException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RestrictedSourceFileException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example, you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same file as part of the same commit.
public struct SamePathRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SamePathRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The commit cannot be created because no source files or file content have been specified for the commit.
public struct SourceFileOrContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SourceFileOrContentRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    /// A file that is deleted as part of a commit.
    public struct DeleteFileEntry: Swift.Sendable {
        /// The full path of the file to be deleted, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?

        public init(
            filePath: Swift.String? = nil
        )
        {
            self.filePath = filePath
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about a source file that is part of changes made in a commit.
    public struct SourceFileSpecifier: Swift.Sendable {
        /// The full path to the file, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?
        /// Whether to remove the source file from the parent commit.
        public var isMove: Swift.Bool

        public init(
            filePath: Swift.String? = nil,
            isMove: Swift.Bool = false
        )
        {
            self.filePath = filePath
            self.isMove = isMove
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about a file added or updated as part of a commit.
    public struct PutFileEntry: Swift.Sendable {
        /// The content of the file, if a source file is not specified.
        public var fileContent: Foundation.Data?
        /// The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The full path to the file in the repository, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?
        /// The name and full path of the file that contains the changes you want to make as part of the commit, if you are not providing the file content directly.
        public var sourceFile: CodeCommitClientTypes.SourceFileSpecifier?

        public init(
            fileContent: Foundation.Data? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            filePath: Swift.String? = nil,
            sourceFile: CodeCommitClientTypes.SourceFileSpecifier? = nil
        )
        {
            self.fileContent = fileContent
            self.fileMode = fileMode
            self.filePath = filePath
            self.sourceFile = sourceFile
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about the file mode changes.
    public struct SetFileModeEntry: Swift.Sendable {
        /// The file mode for the file.
        /// This member is required.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The full path to the file, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?

        public init(
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            filePath: Swift.String? = nil
        )
        {
            self.fileMode = fileMode
            self.filePath = filePath
        }
    }
}

public struct CreateCommitInput: Swift.Sendable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The name of the branch where you create the commit.
    /// This member is required.
    public var branchName: Swift.String?
    /// The commit message you want to include in the commit. Commit messages are limited to 256 KB. If no message is specified, a default message is used.
    public var commitMessage: Swift.String?
    /// The files to delete in this commit. These files still exist in earlier commits.
    public var deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]?
    /// The email address of the person who created the commit.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a ..gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The ID of the commit that is the parent of the commit you create. Not required if this is an empty repository.
    public var parentCommitId: Swift.String?
    /// The files to add or update in this commit.
    public var putFiles: [CodeCommitClientTypes.PutFileEntry]?
    /// The name of the repository where you create the commit.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The file modes to update for files in this commit.
    public var setFileModes: [CodeCommitClientTypes.SetFileModeEntry]?

    public init(
        authorName: Swift.String? = nil,
        branchName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = false,
        parentCommitId: Swift.String? = nil,
        putFiles: [CodeCommitClientTypes.PutFileEntry]? = nil,
        repositoryName: Swift.String? = nil,
        setFileModes: [CodeCommitClientTypes.SetFileModeEntry]? = nil
    )
    {
        self.authorName = authorName
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.deleteFiles = deleteFiles
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.parentCommitId = parentCommitId
        self.putFiles = putFiles
        self.repositoryName = repositoryName
        self.setFileModes = setFileModes
    }
}

extension CodeCommitClientTypes {

    /// A file to be added, updated, or deleted as part of a commit.
    public struct FileMetadata: Swift.Sendable {
        /// The full path to the file to be added or updated, including the name of the file.
        public var absolutePath: Swift.String?
        /// The blob ID that contains the file information.
        public var blobId: Swift.String?
        /// The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?

        public init(
            absolutePath: Swift.String? = nil,
            blobId: Swift.String? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil
        )
        {
            self.absolutePath = absolutePath
            self.blobId = blobId
            self.fileMode = fileMode
        }
    }
}

public struct CreateCommitOutput: Swift.Sendable {
    /// The full commit ID of the commit that contains your committed file changes.
    public var commitId: Swift.String?
    /// The files added as part of the committed file changes.
    public var filesAdded: [CodeCommitClientTypes.FileMetadata]?
    /// The files deleted as part of the committed file changes.
    public var filesDeleted: [CodeCommitClientTypes.FileMetadata]?
    /// The files updated as part of the commited file changes.
    public var filesUpdated: [CodeCommitClientTypes.FileMetadata]?
    /// The full SHA-1 pointer of the tree information for the commit that contains the commited file changes.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        filesAdded: [CodeCommitClientTypes.FileMetadata]? = nil,
        filesDeleted: [CodeCommitClientTypes.FileMetadata]? = nil,
        filesUpdated: [CodeCommitClientTypes.FileMetadata]? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.filesAdded = filesAdded
        self.filesDeleted = filesDeleted
        self.filesUpdated = filesUpdated
        self.treeId = treeId
    }
}

/// The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.
public struct IdempotencyParameterMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotencyParameterMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The client request token is not valid.
public struct InvalidClientRequestTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClientRequestTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The pull request description is not valid. Descriptions cannot be more than 1,000 characters.
public struct InvalidDescriptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDescriptionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified reference name format is not valid. Reference names must conform to the Git references format (for example, refs/heads/main). For more information, see [Git Internals - Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References) or consult your Git documentation.
public struct InvalidReferenceNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidReferenceNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.
public struct InvalidTargetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTargetException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for the repository name, source branch, and destination branch for a pull request.
public struct InvalidTargetsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTargetsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.
public struct InvalidTitleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTitleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You cannot create the pull request because the repository has too many open pull requests. The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.
public struct MaximumOpenPullRequestsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumOpenPullRequestsExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.
public struct MultipleRepositoriesInPullRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MultipleRepositoriesInPullRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified reference does not exist. You must provide a full commit ID.
public struct ReferenceDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReferenceDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A reference name is required, but none was provided.
public struct ReferenceNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReferenceNameRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified reference is not a supported type.
public struct ReferenceTypeNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReferenceTypeNotSupportedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The source branch and destination branch for the pull request are the same. You must specify different branches for the source and destination.
public struct SourceAndDestinationAreSameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SourceAndDestinationAreSameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.
public struct TargetRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TargetRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An array of target objects is required. It cannot be empty or null.
public struct TargetsRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TargetsRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A pull request title is required. It cannot be empty or null.
public struct TitleRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TitleRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a target for a pull request.
    public struct Target: Swift.Sendable {
        /// The branch of the repository where the pull request changes are merged. Also known as the destination branch.
        public var destinationReference: Swift.String?
        /// The name of the repository that contains the pull request.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// The branch of the repository that contains the changes for the pull request. Also known as the source branch.
        /// This member is required.
        public var sourceReference: Swift.String?

        public init(
            destinationReference: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            sourceReference: Swift.String? = nil
        )
        {
            self.destinationReference = destinationReference
            self.repositoryName = repositoryName
            self.sourceReference = sourceReference
        }
    }
}

public struct CreatePullRequestInput: Swift.Sendable {
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token. The Amazon Web ServicesSDKs prepopulate client request tokens. If you are using an Amazon Web ServicesSDK, an idempotency token is created for you.
    public var clientRequestToken: Swift.String?
    /// A description of the pull request.
    public var description: Swift.String?
    /// The targets for the pull request, including the source of the code to be reviewed (the source branch) and the destination where the creator of the pull request intends the code to be merged after the pull request is closed (the destination branch).
    /// This member is required.
    public var targets: [CodeCommitClientTypes.Target]?
    /// The title of the pull request. This title is used to identify the pull request to other users in the repository.
    /// This member is required.
    public var title: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        targets: [CodeCommitClientTypes.Target]? = nil,
        title: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.targets = targets
        self.title = title
    }
}

extension CodeCommitClientTypes {

    public enum PullRequestStatusEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [PullRequestStatusEnum] {
            return [
                .closed,
                .open
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .open: return "OPEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a merge or potential merge between a source reference and a destination reference in a pull request.
    public struct MergeMetadata: Swift.Sendable {
        /// A Boolean value indicating whether the merge has been made.
        public var isMerged: Swift.Bool
        /// The commit ID for the merge commit, if any.
        public var mergeCommitId: Swift.String?
        /// The merge strategy used in the merge.
        public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
        /// The Amazon Resource Name (ARN) of the user who merged the branches.
        public var mergedBy: Swift.String?

        public init(
            isMerged: Swift.Bool = false,
            mergeCommitId: Swift.String? = nil,
            mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
            mergedBy: Swift.String? = nil
        )
        {
            self.isMerged = isMerged
            self.mergeCommitId = mergeCommitId
            self.mergeOption = mergeOption
            self.mergedBy = mergedBy
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a pull request target.
    public struct PullRequestTarget: Swift.Sendable {
        /// The full commit ID that is the tip of the destination branch. This is the commit where the pull request was or will be merged.
        public var destinationCommit: Swift.String?
        /// The branch of the repository where the pull request changes are merged. Also known as the destination branch.
        public var destinationReference: Swift.String?
        /// The commit ID of the most recent commit that the source branch and the destination branch have in common.
        public var mergeBase: Swift.String?
        /// Returns metadata about the state of the merge, including whether the merge has been made.
        public var mergeMetadata: CodeCommitClientTypes.MergeMetadata?
        /// The name of the repository that contains the pull request source and destination branches.
        public var repositoryName: Swift.String?
        /// The full commit ID of the tip of the source branch used to create the pull request. If the pull request branch is updated by a push while the pull request is open, the commit ID changes to reflect the new tip of the branch.
        public var sourceCommit: Swift.String?
        /// The branch of the repository that contains the changes for the pull request. Also known as the source branch.
        public var sourceReference: Swift.String?

        public init(
            destinationCommit: Swift.String? = nil,
            destinationReference: Swift.String? = nil,
            mergeBase: Swift.String? = nil,
            mergeMetadata: CodeCommitClientTypes.MergeMetadata? = nil,
            repositoryName: Swift.String? = nil,
            sourceCommit: Swift.String? = nil,
            sourceReference: Swift.String? = nil
        )
        {
            self.destinationCommit = destinationCommit
            self.destinationReference = destinationReference
            self.mergeBase = mergeBase
            self.mergeMetadata = mergeMetadata
            self.repositoryName = repositoryName
            self.sourceCommit = sourceCommit
            self.sourceReference = sourceReference
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a pull request.
    public struct PullRequest: Swift.Sendable {
        /// The approval rules applied to the pull request.
        public var approvalRules: [CodeCommitClientTypes.ApprovalRule]?
        /// The Amazon Resource Name (ARN) of the user who created the pull request.
        public var authorArn: Swift.String?
        /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
        public var clientRequestToken: Swift.String?
        /// The date and time the pull request was originally created, in timestamp format.
        public var creationDate: Foundation.Date?
        /// The user-defined description of the pull request. This description can be used to clarify what should be reviewed and other details of the request.
        public var description: Swift.String?
        /// The day and time of the last user or system activity on the pull request, in timestamp format.
        public var lastActivityDate: Foundation.Date?
        /// The system-generated ID of the pull request.
        public var pullRequestId: Swift.String?
        /// The status of the pull request. Pull request status can only change from OPEN to CLOSED.
        public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?
        /// The targets of the pull request, including the source branch and destination branch for the pull request.
        public var pullRequestTargets: [CodeCommitClientTypes.PullRequestTarget]?
        /// The system-generated revision ID for the pull request.
        public var revisionId: Swift.String?
        /// The user-defined title of the pull request. This title is displayed in the list of pull requests to other repository users.
        public var title: Swift.String?

        public init(
            approvalRules: [CodeCommitClientTypes.ApprovalRule]? = nil,
            authorArn: Swift.String? = nil,
            clientRequestToken: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastActivityDate: Foundation.Date? = nil,
            pullRequestId: Swift.String? = nil,
            pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil,
            pullRequestTargets: [CodeCommitClientTypes.PullRequestTarget]? = nil,
            revisionId: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.approvalRules = approvalRules
            self.authorArn = authorArn
            self.clientRequestToken = clientRequestToken
            self.creationDate = creationDate
            self.description = description
            self.lastActivityDate = lastActivityDate
            self.pullRequestId = pullRequestId
            self.pullRequestStatus = pullRequestStatus
            self.pullRequestTargets = pullRequestTargets
            self.revisionId = revisionId
            self.title = title
        }
    }
}

public struct CreatePullRequestOutput: Swift.Sendable {
    /// Information about the newly created pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

/// The content for the approval rule is not valid.
public struct InvalidApprovalRuleContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalRuleContentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The name for the approval rule is not valid.
public struct InvalidApprovalRuleNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalRuleNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.
public struct InvalidPullRequestIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPullRequestIdException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.
public struct NumberOfRulesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NumberOfRulesExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The pull request status cannot be updated because it is already closed.
public struct PullRequestAlreadyClosedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestAlreadyClosedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.
public struct PullRequestDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A pull request ID is required, but none was provided.
public struct PullRequestIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestIdRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreatePullRequestApprovalRuleInput: Swift.Sendable {
    /// The content of the approval rule, including the number of approvals needed and the structure of an approval pool defined for approvals, if any. For more information about approval pools, see the CodeCommit User Guide. When you create the content of the approval rule, you can specify approvers in an approval pool in one of two ways:
    ///
    /// * CodeCommitApprovers: This option only requires an Amazon Web Services account and a resource. It can be used for both IAM users and federated access users whose name matches the provided resource name. This is a very powerful option that offers a great deal of flexibility. For example, if you specify the Amazon Web Services account 123456789012 and Mary_Major, all of the following would be counted as approvals coming from that user:
    ///
    /// * An IAM user in the account (arn:aws:iam::123456789012:user/Mary_Major)
    ///
    /// * A federated user identified in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
    ///
    ///
    /// This option does not recognize an active session of someone assuming the role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major) unless you include a wildcard (*Mary_Major).
    ///
    /// * Fully qualified ARN: This option allows you to specify the fully qualified Amazon Resource Name (ARN) of the IAM user or role.
    ///
    ///
    /// For more information about IAM ARNs, wildcards, and formats, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var approvalRuleContent: Swift.String?
    /// The name for the approval rule.
    /// This member is required.
    public var approvalRuleName: Swift.String?
    /// The system-generated ID of the pull request for which you want to create the approval rule.
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        approvalRuleContent: Swift.String? = nil,
        approvalRuleName: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.approvalRuleContent = approvalRuleContent
        self.approvalRuleName = approvalRuleName
        self.pullRequestId = pullRequestId
    }
}

public struct CreatePullRequestApprovalRuleOutput: Swift.Sendable {
    /// Information about the created approval rule.
    /// This member is required.
    public var approvalRule: CodeCommitClientTypes.ApprovalRule?

    public init(
        approvalRule: CodeCommitClientTypes.ApprovalRule? = nil
    )
    {
        self.approvalRule = approvalRule
    }
}

/// The Key Management Service encryption key is not valid.
public struct EncryptionKeyInvalidIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyInvalidIdException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A KMS encryption key was used to try and encrypt or decrypt a repository, but either the repository or the key was not in a valid state to support the operation.
public struct EncryptionKeyInvalidUsageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyInvalidUsageException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified repository description is not valid.
public struct InvalidRepositoryDescriptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryDescriptionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified tag is not valid. Key names cannot be prefixed with aws:.
public struct InvalidSystemTagUsageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSystemTagUsageException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The map of tags is not valid.
public struct InvalidTagsMapException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagsMapException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested action is not allowed.
public struct OperationNotAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotAllowedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A repository resource limit was exceeded.
public struct RepositoryLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified repository name already exists.
public struct RepositoryNameExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryNameExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The tag policy is not valid.
public struct TagPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of tags for an CodeCommit resource has been exceeded.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Represents the input of a create repository operation.
public struct CreateRepositoryInput: Swift.Sendable {
    /// The ID of the encryption key. You can view the ID of an encryption key in the KMS console, or use the KMS APIs to programmatically retrieve a key ID. For more information about acceptable values for kmsKeyID, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html#KMS-Decrypt-request-KeyId) in the Decrypt API description in the Key Management Service API Reference. If no key is specified, the default aws/codecommit Amazon Web Services managed key is used.
    public var kmsKeyId: Swift.String?
    /// A comment or description about the new repository. The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a webpage can expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a webpage.
    public var repositoryDescription: Swift.String?
    /// The name of the new repository to be created. The repository name must be unique across the calling Amazon Web Services account. Repository names are limited to 100 alphanumeric, dash, and underscore characters, and cannot include certain characters. For more information about the limits on repository names, see [Quotas](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html) in the CodeCommit User Guide. The suffix .git is prohibited.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// One or more tag key-value pairs to use when tagging this repository.
    public var tags: [Swift.String: Swift.String]?

    public init(
        kmsKeyId: Swift.String? = nil,
        repositoryDescription: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.repositoryDescription = repositoryDescription
        self.repositoryName = repositoryName
        self.tags = tags
    }
}

/// Represents the output of a create repository operation.
public struct CreateRepositoryOutput: Swift.Sendable {
    /// Information about the newly created repository.
    public var repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata?

    public init(
        repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata? = nil
    )
    {
        self.repositoryMetadata = repositoryMetadata
    }
}

/// The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.
public struct ConcurrentReferenceUpdateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentReferenceUpdateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified conflict resolution list is not valid.
public struct InvalidConflictResolutionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConflictResolutionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing.
public struct InvalidReplacementContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidReplacementContentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Automerge was specified for resolving the conflict, but the specified replacement type is not valid.
public struct InvalidReplacementTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidReplacementTypeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.
public struct ManualMergeRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ManualMergeRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of allowed conflict resolution entries was exceeded.
public struct MaximumConflictResolutionEntriesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumConflictResolutionEntriesExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.
public struct MultipleConflictResolutionEntriesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MultipleConflictResolutionEntriesException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// USE_NEW_CONTENT was specified, but no replacement content has been provided.
public struct ReplacementContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplacementContentRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A replacement type is required.
public struct ReplacementTypeRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplacementTypeRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    public enum ReplacementTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case keepBase
        case keepDestination
        case keepSource
        case useNewContent
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplacementTypeEnum] {
            return [
                .keepBase,
                .keepDestination,
                .keepSource,
                .useNewContent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .keepBase: return "KEEP_BASE"
            case .keepDestination: return "KEEP_DESTINATION"
            case .keepSource: return "KEEP_SOURCE"
            case .useNewContent: return "USE_NEW_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about a replacement content entry in the conflict of a merge or pull request operation.
    public struct ReplaceContentEntry: Swift.Sendable {
        /// The base-64 encoded content to use when the replacement type is USE_NEW_CONTENT.
        public var content: Foundation.Data?
        /// The file mode to apply during conflict resoltion.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The path of the conflicting file.
        /// This member is required.
        public var filePath: Swift.String?
        /// The replacement type to use when determining how to resolve the conflict.
        /// This member is required.
        public var replacementType: CodeCommitClientTypes.ReplacementTypeEnum?

        public init(
            content: Foundation.Data? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            filePath: Swift.String? = nil,
            replacementType: CodeCommitClientTypes.ReplacementTypeEnum? = nil
        )
        {
            self.content = content
            self.fileMode = fileMode
            self.filePath = filePath
            self.replacementType = replacementType
        }
    }
}

extension CodeCommitClientTypes {

    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public struct ConflictResolution: Swift.Sendable {
        /// Files to be deleted as part of the merge conflict resolution.
        public var deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]?
        /// Files to have content replaced as part of the merge conflict resolution.
        public var replaceContents: [CodeCommitClientTypes.ReplaceContentEntry]?
        /// File modes that are set as part of the merge conflict resolution.
        public var setFileModes: [CodeCommitClientTypes.SetFileModeEntry]?

        public init(
            deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]? = nil,
            replaceContents: [CodeCommitClientTypes.ReplaceContentEntry]? = nil,
            setFileModes: [CodeCommitClientTypes.SetFileModeEntry]? = nil
        )
        {
            self.deleteFiles = deleteFiles
            self.replaceContents = replaceContents
            self.setFileModes = setFileModes
        }
    }
}

public struct CreateUnreferencedMergeCommitInput: Swift.Sendable {
    /// The name of the author who created the unreferenced commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message for the unreferenced commit.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The email address for the person who created the unreferenced commit.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If this is specified as true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// The name of the repository where you want to create the unreferenced merge commit.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = false,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.mergeOption = mergeOption
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

public struct CreateUnreferencedMergeCommitOutput: Swift.Sendable {
    /// The full commit ID of the commit that contains your merge results.
    public var commitId: Swift.String?
    /// The full SHA-1 pointer of the tree information for the commit that contains the merge results.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

public struct DeleteApprovalRuleTemplateInput: Swift.Sendable {
    /// The name of the approval rule template to delete.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

public struct DeleteApprovalRuleTemplateOutput: Swift.Sendable {
    /// The system-generated ID of the deleted approval rule template. If the template has been previously deleted, the only response is a 200 OK.
    /// This member is required.
    public var approvalRuleTemplateId: Swift.String?

    public init(
        approvalRuleTemplateId: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateId = approvalRuleTemplateId
    }
}

/// The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.
public struct DefaultBranchCannotBeDeletedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DefaultBranchCannotBeDeletedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Represents the input of a delete branch operation.
public struct DeleteBranchInput: Swift.Sendable {
    /// The name of the branch to delete.
    /// This member is required.
    public var branchName: Swift.String?
    /// The name of the repository that contains the branch to be deleted.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.repositoryName = repositoryName
    }
}

/// Represents the output of a delete branch operation.
public struct DeleteBranchOutput: Swift.Sendable {
    /// Information about the branch deleted by the operation, including the branch name and the commit ID that was the tip of the branch.
    public var deletedBranch: CodeCommitClientTypes.BranchInfo?

    public init(
        deletedBranch: CodeCommitClientTypes.BranchInfo? = nil
    )
    {
        self.deletedBranch = deletedBranch
    }
}

/// This comment has already been deleted. You cannot edit or delete a deleted comment.
public struct CommentDeletedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentDeletedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.
public struct CommentDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The comment ID is missing or null. A comment ID is required.
public struct CommentIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentIdRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The comment ID is not in a valid format. Make sure that you have provided the full comment ID.
public struct InvalidCommentIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCommentIdException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteCommentContentInput: Swift.Sendable {
    /// The unique, system-generated ID of the comment. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var commentId: Swift.String?

    public init(
        commentId: Swift.String? = nil
    )
    {
        self.commentId = commentId
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a specific comment.
    public struct Comment: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the person who posted the comment.
        public var authorArn: Swift.String?
        /// The emoji reactions to a comment, if any, submitted by the user whose credentials are associated with the call to the API.
        public var callerReactions: [Swift.String]?
        /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
        public var clientRequestToken: Swift.String?
        /// The system-generated comment ID.
        public var commentId: Swift.String?
        /// The content of the comment.
        public var content: Swift.String?
        /// The date and time the comment was created, in timestamp format.
        public var creationDate: Foundation.Date?
        /// A Boolean value indicating whether the comment has been deleted.
        public var deleted: Swift.Bool
        /// The ID of the comment for which this comment is a reply, if any.
        public var inReplyTo: Swift.String?
        /// The date and time the comment was most recently modified, in timestamp format.
        public var lastModifiedDate: Foundation.Date?
        /// A string to integer map that represents the number of individual users who have responded to a comment with the specified reactions.
        public var reactionCounts: [Swift.String: Swift.Int]?

        public init(
            authorArn: Swift.String? = nil,
            callerReactions: [Swift.String]? = nil,
            clientRequestToken: Swift.String? = nil,
            commentId: Swift.String? = nil,
            content: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            deleted: Swift.Bool = false,
            inReplyTo: Swift.String? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            reactionCounts: [Swift.String: Swift.Int]? = nil
        )
        {
            self.authorArn = authorArn
            self.callerReactions = callerReactions
            self.clientRequestToken = clientRequestToken
            self.commentId = commentId
            self.content = content
            self.creationDate = creationDate
            self.deleted = deleted
            self.inReplyTo = inReplyTo
            self.lastModifiedDate = lastModifiedDate
            self.reactionCounts = reactionCounts
        }
    }
}

public struct DeleteCommentContentOutput: Swift.Sendable {
    /// Information about the comment you just deleted.
    public var comment: CodeCommitClientTypes.Comment?

    public init(
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

public struct DeleteFileInput: Swift.Sendable {
    /// The name of the branch where the commit that deletes the file is made.
    /// This member is required.
    public var branchName: Swift.String?
    /// The commit message you want to include as part of deleting the file. Commit messages are limited to 256 KB. If no message is specified, a default message is used.
    public var commitMessage: Swift.String?
    /// The email address for the commit that deletes the file. If no email address is specified, the email address is left blank.
    public var email: Swift.String?
    /// The fully qualified path to the file that to be deleted, including the full name and extension of that file. For example, /examples/file.md is a fully qualified path to a file named file.md in a folder named examples.
    /// This member is required.
    public var filePath: Swift.String?
    /// If a file is the only object in the folder or directory, specifies whether to delete the folder or directory that contains the file. By default, empty folders are deleted. This includes empty folders that are part of the directory structure. For example, if the path to a file is dir1/dir2/dir3/dir4, and dir2 and dir3 are empty, deleting the last file in dir4 also deletes the empty folders dir4, dir3, and dir2.
    public var keepEmptyFolders: Swift.Bool?
    /// The name of the author of the commit that deletes the file. If no name is specified, the user's ARN is used as the author name and committer name.
    public var name: Swift.String?
    /// The ID of the commit that is the tip of the branch where you want to create the commit that deletes the file. This must be the HEAD commit for the branch. The commit that deletes the file is created from this commit ID.
    /// This member is required.
    public var parentCommitId: Swift.String?
    /// The name of the repository that contains the file to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        email: Swift.String? = nil,
        filePath: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = false,
        name: Swift.String? = nil,
        parentCommitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.email = email
        self.filePath = filePath
        self.keepEmptyFolders = keepEmptyFolders
        self.name = name
        self.parentCommitId = parentCommitId
        self.repositoryName = repositoryName
    }
}

public struct DeleteFileOutput: Swift.Sendable {
    /// The blob ID removed from the tree as part of deleting the file.
    /// This member is required.
    public var blobId: Swift.String?
    /// The full commit ID of the commit that contains the change that deletes the file.
    /// This member is required.
    public var commitId: Swift.String?
    /// The fully qualified path to the file to be deleted, including the full name and extension of that file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The full SHA-1 pointer of the tree information for the commit that contains the delete file change.
    /// This member is required.
    public var treeId: Swift.String?

    public init(
        blobId: Swift.String? = nil,
        commitId: Swift.String? = nil,
        filePath: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.filePath = filePath
        self.treeId = treeId
    }
}

public struct DeletePullRequestApprovalRuleInput: Swift.Sendable {
    /// The name of the approval rule you want to delete.
    /// This member is required.
    public var approvalRuleName: Swift.String?
    /// The system-generated ID of the pull request that contains the approval rule you want to delete.
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        approvalRuleName: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.approvalRuleName = approvalRuleName
        self.pullRequestId = pullRequestId
    }
}

public struct DeletePullRequestApprovalRuleOutput: Swift.Sendable {
    /// The ID of the deleted approval rule. If the approval rule was deleted in an earlier API call, the response is 200 OK without content.
    /// This member is required.
    public var approvalRuleId: Swift.String?

    public init(
        approvalRuleId: Swift.String? = nil
    )
    {
        self.approvalRuleId = approvalRuleId
    }
}

/// Represents the input of a delete repository operation.
public struct DeleteRepositoryInput: Swift.Sendable {
    /// The name of the repository to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

/// Represents the output of a delete repository operation.
public struct DeleteRepositoryOutput: Swift.Sendable {
    /// The ID of the repository that was deleted.
    public var repositoryId: Swift.String?

    public init(
        repositoryId: Swift.String? = nil
    )
    {
        self.repositoryId = repositoryId
    }
}

public struct DescribeMergeConflictsInput: Swift.Sendable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The path of the target files used to describe the conflicts.
    /// This member is required.
    public var filePath: Swift.String?
    /// The maximum number of merge hunks to include in the output.
    public var maxMergeHunks: Swift.Int?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where you want to get information about a merge conflict.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        filePath: Swift.String? = nil,
        maxMergeHunks: Swift.Int? = nil,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.filePath = filePath
        self.maxMergeHunks = maxMergeHunks
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

public struct DescribeMergeConflictsOutput: Swift.Sendable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// Contains metadata about the conflicts found in the merge.
    /// This member is required.
    public var conflictMetadata: CodeCommitClientTypes.ConflictMetadata?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// A list of merge hunks of the differences between the files or lines.
    /// This member is required.
    public var mergeHunks: [CodeCommitClientTypes.MergeHunk]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init(
        baseCommitId: Swift.String? = nil,
        conflictMetadata: CodeCommitClientTypes.ConflictMetadata? = nil,
        destinationCommitId: Swift.String? = nil,
        mergeHunks: [CodeCommitClientTypes.MergeHunk]? = nil,
        nextToken: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflictMetadata = conflictMetadata
        self.destinationCommitId = destinationCommitId
        self.mergeHunks = mergeHunks
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

/// The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request, and then try again.
public struct InvalidActorArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidActorArnException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified number of maximum results is not valid.
public struct InvalidMaxResultsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMaxResultsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The pull request event type is not valid.
public struct InvalidPullRequestEventTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPullRequestEventTypeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    public enum PullRequestEventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pullRequestApprovalRuleCreated
        case pullRequestApprovalRuleDeleted
        case pullRequestApprovalRuleOverridden
        case pullRequestApprovalRuleUpdated
        case pullRequestApprovalStateChanged
        case pullRequestCreated
        case pullRequestMergeStateChanged
        case pullRequestSourceReferenceUpdated
        case pullRequestStatusChanged
        case sdkUnknown(Swift.String)

        public static var allCases: [PullRequestEventType] {
            return [
                .pullRequestApprovalRuleCreated,
                .pullRequestApprovalRuleDeleted,
                .pullRequestApprovalRuleOverridden,
                .pullRequestApprovalRuleUpdated,
                .pullRequestApprovalStateChanged,
                .pullRequestCreated,
                .pullRequestMergeStateChanged,
                .pullRequestSourceReferenceUpdated,
                .pullRequestStatusChanged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pullRequestApprovalRuleCreated: return "PULL_REQUEST_APPROVAL_RULE_CREATED"
            case .pullRequestApprovalRuleDeleted: return "PULL_REQUEST_APPROVAL_RULE_DELETED"
            case .pullRequestApprovalRuleOverridden: return "PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN"
            case .pullRequestApprovalRuleUpdated: return "PULL_REQUEST_APPROVAL_RULE_UPDATED"
            case .pullRequestApprovalStateChanged: return "PULL_REQUEST_APPROVAL_STATE_CHANGED"
            case .pullRequestCreated: return "PULL_REQUEST_CREATED"
            case .pullRequestMergeStateChanged: return "PULL_REQUEST_MERGE_STATE_CHANGED"
            case .pullRequestSourceReferenceUpdated: return "PULL_REQUEST_SOURCE_REFERENCE_UPDATED"
            case .pullRequestStatusChanged: return "PULL_REQUEST_STATUS_CHANGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribePullRequestEventsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the user whose actions resulted in the event. Examples include updating the pull request with more commits or changing the status of a pull request.
    public var actorArn: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is 100 events, which is also the maximum number of events that can be returned in a result.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// Optional. The pull request event type about which you want to return information.
    public var pullRequestEventType: CodeCommitClientTypes.PullRequestEventType?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        actorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pullRequestEventType: CodeCommitClientTypes.PullRequestEventType? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.actorArn = actorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestEventType = pullRequestEventType
        self.pullRequestId = pullRequestId
    }
}

extension CodeCommitClientTypes {

    /// Metadata about the pull request that is used when comparing the pull request source with its destination.
    public struct PullRequestCreatedEventMetadata: Swift.Sendable {
        /// The commit ID of the tip of the branch specified as the destination branch when the pull request was created.
        public var destinationCommitId: Swift.String?
        /// The commit ID of the most recent commit that the source branch and the destination branch have in common.
        public var mergeBase: Swift.String?
        /// The name of the repository where the pull request was created.
        public var repositoryName: Swift.String?
        /// The commit ID on the source branch used when the pull request was created.
        public var sourceCommitId: Swift.String?

        public init(
            destinationCommitId: Swift.String? = nil,
            mergeBase: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            sourceCommitId: Swift.String? = nil
        )
        {
            self.destinationCommitId = destinationCommitId
            self.mergeBase = mergeBase
            self.repositoryName = repositoryName
            self.sourceCommitId = sourceCommitId
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about the change in the merge state for a pull request event.
    public struct PullRequestMergedStateChangedEventMetadata: Swift.Sendable {
        /// The name of the branch that the pull request is merged into.
        public var destinationReference: Swift.String?
        /// Information about the merge state change event.
        public var mergeMetadata: CodeCommitClientTypes.MergeMetadata?
        /// The name of the repository where the pull request was created.
        public var repositoryName: Swift.String?

        public init(
            destinationReference: Swift.String? = nil,
            mergeMetadata: CodeCommitClientTypes.MergeMetadata? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.destinationReference = destinationReference
            self.mergeMetadata = mergeMetadata
            self.repositoryName = repositoryName
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about an update to the source branch of a pull request.
    public struct PullRequestSourceReferenceUpdatedEventMetadata: Swift.Sendable {
        /// The full commit ID of the commit in the source branch that was the tip of the branch at the time the pull request was updated.
        public var afterCommitId: Swift.String?
        /// The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was updated.
        public var beforeCommitId: Swift.String?
        /// The commit ID of the most recent commit that the source branch and the destination branch have in common.
        public var mergeBase: Swift.String?
        /// The name of the repository where the pull request was updated.
        public var repositoryName: Swift.String?

        public init(
            afterCommitId: Swift.String? = nil,
            beforeCommitId: Swift.String? = nil,
            mergeBase: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.afterCommitId = afterCommitId
            self.beforeCommitId = beforeCommitId
            self.mergeBase = mergeBase
            self.repositoryName = repositoryName
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about a change to the status of a pull request.
    public struct PullRequestStatusChangedEventMetadata: Swift.Sendable {
        /// The changed status of the pull request.
        public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?

        public init(
            pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil
        )
        {
            self.pullRequestStatus = pullRequestStatus
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a pull request event.
    public struct PullRequestEvent: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the user whose actions resulted in the event. Examples include updating the pull request with more commits or changing the status of a pull request.
        public var actorArn: Swift.String?
        /// Information about a pull request event.
        public var approvalRuleEventMetadata: CodeCommitClientTypes.ApprovalRuleEventMetadata?
        /// Information about an approval rule override event for a pull request.
        public var approvalRuleOverriddenEventMetadata: CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata?
        /// Information about an approval state change for a pull request.
        public var approvalStateChangedEventMetadata: CodeCommitClientTypes.ApprovalStateChangedEventMetadata?
        /// The day and time of the pull request event, in timestamp format.
        public var eventDate: Foundation.Date?
        /// Information about the source and destination branches for the pull request.
        public var pullRequestCreatedEventMetadata: CodeCommitClientTypes.PullRequestCreatedEventMetadata?
        /// The type of the pull request event (for example, a status change event (PULL_REQUEST_STATUS_CHANGED) or update event (PULL_REQUEST_SOURCE_REFERENCE_UPDATED)).
        public var pullRequestEventType: CodeCommitClientTypes.PullRequestEventType?
        /// The system-generated ID of the pull request.
        public var pullRequestId: Swift.String?
        /// Information about the change in mergability state for the pull request event.
        public var pullRequestMergedStateChangedEventMetadata: CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata?
        /// Information about the updated source branch for the pull request event.
        public var pullRequestSourceReferenceUpdatedEventMetadata: CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata?
        /// Information about the change in status for the pull request event.
        public var pullRequestStatusChangedEventMetadata: CodeCommitClientTypes.PullRequestStatusChangedEventMetadata?

        public init(
            actorArn: Swift.String? = nil,
            approvalRuleEventMetadata: CodeCommitClientTypes.ApprovalRuleEventMetadata? = nil,
            approvalRuleOverriddenEventMetadata: CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata? = nil,
            approvalStateChangedEventMetadata: CodeCommitClientTypes.ApprovalStateChangedEventMetadata? = nil,
            eventDate: Foundation.Date? = nil,
            pullRequestCreatedEventMetadata: CodeCommitClientTypes.PullRequestCreatedEventMetadata? = nil,
            pullRequestEventType: CodeCommitClientTypes.PullRequestEventType? = nil,
            pullRequestId: Swift.String? = nil,
            pullRequestMergedStateChangedEventMetadata: CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata? = nil,
            pullRequestSourceReferenceUpdatedEventMetadata: CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata? = nil,
            pullRequestStatusChangedEventMetadata: CodeCommitClientTypes.PullRequestStatusChangedEventMetadata? = nil
        )
        {
            self.actorArn = actorArn
            self.approvalRuleEventMetadata = approvalRuleEventMetadata
            self.approvalRuleOverriddenEventMetadata = approvalRuleOverriddenEventMetadata
            self.approvalStateChangedEventMetadata = approvalStateChangedEventMetadata
            self.eventDate = eventDate
            self.pullRequestCreatedEventMetadata = pullRequestCreatedEventMetadata
            self.pullRequestEventType = pullRequestEventType
            self.pullRequestId = pullRequestId
            self.pullRequestMergedStateChangedEventMetadata = pullRequestMergedStateChangedEventMetadata
            self.pullRequestSourceReferenceUpdatedEventMetadata = pullRequestSourceReferenceUpdatedEventMetadata
            self.pullRequestStatusChangedEventMetadata = pullRequestStatusChangedEventMetadata
        }
    }
}

public struct DescribePullRequestEventsOutput: Swift.Sendable {
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// Information about the pull request events.
    /// This member is required.
    public var pullRequestEvents: [CodeCommitClientTypes.PullRequestEvent]?

    public init(
        nextToken: Swift.String? = nil,
        pullRequestEvents: [CodeCommitClientTypes.PullRequestEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.pullRequestEvents = pullRequestEvents
    }
}

public struct DisassociateApprovalRuleTemplateFromRepositoryInput: Swift.Sendable {
    /// The name of the approval rule template to disassociate from a specified repository.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The name of the repository you want to disassociate from the template.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryName = repositoryName
    }
}

/// The revision ID is not valid. Use GetPullRequest to determine the value.
public struct InvalidRevisionIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRevisionIdException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A revision ID is required, but was not provided.
public struct RevisionIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RevisionIdRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.
public struct RevisionNotCurrentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RevisionNotCurrentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct EvaluatePullRequestApprovalRulesInput: Swift.Sendable {
    /// The system-generated ID of the pull request you want to evaluate.
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID for the pull request revision. To retrieve the most recent revision ID for a pull request, use [GetPullRequest].
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

extension CodeCommitClientTypes {

    /// Returns information about the approval rules applied to a pull request and whether conditions have been met.
    public struct Evaluation: Swift.Sendable {
        /// The names of the approval rules that have not had their conditions met.
        public var approvalRulesNotSatisfied: [Swift.String]?
        /// The names of the approval rules that have had their conditions met.
        public var approvalRulesSatisfied: [Swift.String]?
        /// Whether the state of the pull request is approved.
        public var approved: Swift.Bool
        /// Whether the approval rule requirements for the pull request have been overridden and no longer need to be met.
        public var overridden: Swift.Bool

        public init(
            approvalRulesNotSatisfied: [Swift.String]? = nil,
            approvalRulesSatisfied: [Swift.String]? = nil,
            approved: Swift.Bool = false,
            overridden: Swift.Bool = false
        )
        {
            self.approvalRulesNotSatisfied = approvalRulesNotSatisfied
            self.approvalRulesSatisfied = approvalRulesSatisfied
            self.approved = approved
            self.overridden = overridden
        }
    }
}

public struct EvaluatePullRequestApprovalRulesOutput: Swift.Sendable {
    /// The result of the evaluation, including the names of the rules whose conditions have been met (if any), the names of the rules whose conditions have not been met (if any), whether the pull request is in the approved state, and whether the pull request approval rule has been set aside by an override.
    /// This member is required.
    public var evaluation: CodeCommitClientTypes.Evaluation?

    public init(
        evaluation: CodeCommitClientTypes.Evaluation? = nil
    )
    {
        self.evaluation = evaluation
    }
}

public struct GetApprovalRuleTemplateInput: Swift.Sendable {
    /// The name of the approval rule template for which you want to get information.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

public struct GetApprovalRuleTemplateOutput: Swift.Sendable {
    /// The content and structure of the approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init(
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

/// The specified file exceeds the file size limit for CodeCommit. For more information about limits in CodeCommit, see [Quotas](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html) in the CodeCommit User Guide.
public struct FileTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileTooLargeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified blob is not valid.
public struct InvalidBlobIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidBlobIdException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Represents the input of a get blob operation.
public struct GetBlobInput: Swift.Sendable {
    /// The ID of the blob, which is its SHA-1 pointer.
    /// This member is required.
    public var blobId: Swift.String?
    /// The name of the repository that contains the blob.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        blobId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.blobId = blobId
        self.repositoryName = repositoryName
    }
}

/// Represents the output of a get blob operation.
public struct GetBlobOutput: Swift.Sendable {
    /// The content of the blob, usually a file.
    /// This member is required.
    public var content: Foundation.Data?

    public init(
        content: Foundation.Data? = nil
    )
    {
        self.content = content
    }
}

/// Represents the input of a get branch operation.
public struct GetBranchInput: Swift.Sendable {
    /// The name of the branch for which you want to retrieve information.
    public var branchName: Swift.String?
    /// The name of the repository that contains the branch for which you want to retrieve information.
    public var repositoryName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.repositoryName = repositoryName
    }
}

/// Represents the output of a get branch operation.
public struct GetBranchOutput: Swift.Sendable {
    /// The name of the branch.
    public var branch: CodeCommitClientTypes.BranchInfo?

    public init(
        branch: CodeCommitClientTypes.BranchInfo? = nil
    )
    {
        self.branch = branch
    }
}

public struct GetCommentInput: Swift.Sendable {
    /// The unique, system-generated ID of the comment. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var commentId: Swift.String?

    public init(
        commentId: Swift.String? = nil
    )
    {
        self.commentId = commentId
    }
}

public struct GetCommentOutput: Swift.Sendable {
    /// The contents of the comment.
    public var comment: CodeCommitClientTypes.Comment?

    public init(
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

/// The Amazon Resource Name (ARN) of the user or identity is not valid.
public struct InvalidReactionUserArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidReactionUserArnException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetCommentReactionsInput: Swift.Sendable {
    /// The ID of the comment for which you want to get reactions information.
    /// This member is required.
    public var commentId: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is the same as the allowed maximum, 1,000.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// Optional. The Amazon Resource Name (ARN) of the user or identity for which you want to get reaction information.
    public var reactionUserArn: Swift.String?

    public init(
        commentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reactionUserArn: Swift.String? = nil
    )
    {
        self.commentId = commentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reactionUserArn = reactionUserArn
    }
}

extension CodeCommitClientTypes {

    /// Information about the values for reactions to a comment. CodeCommit supports a limited set of reactions.
    public struct ReactionValueFormats: Swift.Sendable {
        /// The Emoji Version 1.0 graphic of the reaction. These graphics are interpreted slightly differently on different operating systems.
        public var emoji: Swift.String?
        /// The emoji short code for the reaction. Short codes are interpreted slightly differently on different operating systems.
        public var shortCode: Swift.String?
        /// The Unicode codepoint for the reaction.
        public var unicode: Swift.String?

        public init(
            emoji: Swift.String? = nil,
            shortCode: Swift.String? = nil,
            unicode: Swift.String? = nil
        )
        {
            self.emoji = emoji
            self.shortCode = shortCode
            self.unicode = unicode
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about the reaction values provided by users on a comment.
    public struct ReactionForComment: Swift.Sendable {
        /// The reaction for a specified comment.
        public var reaction: CodeCommitClientTypes.ReactionValueFormats?
        /// The Amazon Resource Names (ARNs) of users who have provided reactions to the comment.
        public var reactionUsers: [Swift.String]?
        /// A numerical count of users who reacted with the specified emoji whose identities have been subsequently deleted from IAM. While these IAM users or roles no longer exist, the reactions might still appear in total reaction counts.
        public var reactionsFromDeletedUsersCount: Swift.Int?

        public init(
            reaction: CodeCommitClientTypes.ReactionValueFormats? = nil,
            reactionUsers: [Swift.String]? = nil,
            reactionsFromDeletedUsersCount: Swift.Int? = nil
        )
        {
            self.reaction = reaction
            self.reactionUsers = reactionUsers
            self.reactionsFromDeletedUsersCount = reactionsFromDeletedUsersCount
        }
    }
}

public struct GetCommentReactionsOutput: Swift.Sendable {
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// An array of reactions to the specified comment.
    /// This member is required.
    public var reactionsForComment: [CodeCommitClientTypes.ReactionForComment]?

    public init(
        nextToken: Swift.String? = nil,
        reactionsForComment: [CodeCommitClientTypes.ReactionForComment]? = nil
    )
    {
        self.nextToken = nextToken
        self.reactionsForComment = reactionsForComment
    }
}

public struct GetCommentsForComparedCommitInput: Swift.Sendable {
    /// To establish the directionality of the comparison, the full commit ID of the after commit.
    /// This member is required.
    public var afterCommitId: Swift.String?
    /// To establish the directionality of the comparison, the full commit ID of the before commit.
    public var beforeCommitId: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is 100 comments, but you can configure up to 500.
    public var maxResults: Swift.Int?
    /// An enumeration token that when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where you want to compare commits.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

extension CodeCommitClientTypes {

    public enum RelativeFileVersionEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case after
        case before
        case sdkUnknown(Swift.String)

        public static var allCases: [RelativeFileVersionEnum] {
            return [
                .after,
                .before
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .after: return "AFTER"
            case .before: return "BEFORE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about the location of a change or comment in the comparison between two commits or a pull request.
    public struct Location: Swift.Sendable {
        /// The name of the file being compared, including its extension and subdirectory, if any.
        public var filePath: Swift.String?
        /// The position of a change in a compared file, in line number format.
        public var filePosition: Swift.Int?
        /// In a comparison of commits or a pull request, whether the change is in the before or after of that comparison.
        public var relativeFileVersion: CodeCommitClientTypes.RelativeFileVersionEnum?

        public init(
            filePath: Swift.String? = nil,
            filePosition: Swift.Int? = nil,
            relativeFileVersion: CodeCommitClientTypes.RelativeFileVersionEnum? = nil
        )
        {
            self.filePath = filePath
            self.filePosition = filePosition
            self.relativeFileVersion = relativeFileVersion
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about comments on the comparison between two commits.
    public struct CommentsForComparedCommit: Swift.Sendable {
        /// The full blob ID of the commit used to establish the after of the comparison.
        public var afterBlobId: Swift.String?
        /// The full commit ID of the commit used to establish the after of the comparison.
        public var afterCommitId: Swift.String?
        /// The full blob ID of the commit used to establish the before of the comparison.
        public var beforeBlobId: Swift.String?
        /// The full commit ID of the commit used to establish the before of the comparison.
        public var beforeCommitId: Swift.String?
        /// An array of comment objects. Each comment object contains information about a comment on the comparison between commits.
        public var comments: [CodeCommitClientTypes.Comment]?
        /// Location information about the comment on the comparison, including the file name, line number, and whether the version of the file where the comment was made is BEFORE or AFTER.
        public var location: CodeCommitClientTypes.Location?
        /// The name of the repository that contains the compared commits.
        public var repositoryName: Swift.String?

        public init(
            afterBlobId: Swift.String? = nil,
            afterCommitId: Swift.String? = nil,
            beforeBlobId: Swift.String? = nil,
            beforeCommitId: Swift.String? = nil,
            comments: [CodeCommitClientTypes.Comment]? = nil,
            location: CodeCommitClientTypes.Location? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.afterBlobId = afterBlobId
            self.afterCommitId = afterCommitId
            self.beforeBlobId = beforeBlobId
            self.beforeCommitId = beforeCommitId
            self.comments = comments
            self.location = location
            self.repositoryName = repositoryName
        }
    }
}

public struct GetCommentsForComparedCommitOutput: Swift.Sendable {
    /// A list of comment objects on the compared commit.
    public var commentsForComparedCommitData: [CodeCommitClientTypes.CommentsForComparedCommit]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        commentsForComparedCommitData: [CodeCommitClientTypes.CommentsForComparedCommit]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commentsForComparedCommitData = commentsForComparedCommitData
        self.nextToken = nextToken
    }
}

/// The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.
public struct RepositoryNotAssociatedWithPullRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryNotAssociatedWithPullRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetCommentsForPullRequestInput: Swift.Sendable {
    /// The full commit ID of the commit in the source branch that was the tip of the branch at the time the comment was made. Requirement is conditional: afterCommitId must be specified when repositoryName is included.
    public var afterCommitId: Swift.String?
    /// The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was created. Requirement is conditional: beforeCommitId must be specified when repositoryName is included.
    public var beforeCommitId: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is 100 comments. You can return up to 500 comments with a single request.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository that contains the pull request. Requirement is conditional: repositoryName must be specified when beforeCommitId and afterCommitId are included.
    public var repositoryName: Swift.String?

    public init(
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

extension CodeCommitClientTypes {

    /// Returns information about comments on a pull request.
    public struct CommentsForPullRequest: Swift.Sendable {
        /// The full blob ID of the file on which you want to comment on the source commit.
        public var afterBlobId: Swift.String?
        /// The full commit ID of the commit that was the tip of the source branch at the time the comment was made.
        public var afterCommitId: Swift.String?
        /// The full blob ID of the file on which you want to comment on the destination commit.
        public var beforeBlobId: Swift.String?
        /// The full commit ID of the commit that was the tip of the destination branch when the pull request was created. This commit is superceded by the after commit in the source branch when and if you merge the source branch into the destination branch.
        public var beforeCommitId: Swift.String?
        /// An array of comment objects. Each comment object contains information about a comment on the pull request.
        public var comments: [CodeCommitClientTypes.Comment]?
        /// Location information about the comment on the pull request, including the file name, line number, and whether the version of the file where the comment was made is BEFORE (destination branch) or AFTER (source branch).
        public var location: CodeCommitClientTypes.Location?
        /// The system-generated ID of the pull request.
        public var pullRequestId: Swift.String?
        /// The name of the repository that contains the pull request.
        public var repositoryName: Swift.String?

        public init(
            afterBlobId: Swift.String? = nil,
            afterCommitId: Swift.String? = nil,
            beforeBlobId: Swift.String? = nil,
            beforeCommitId: Swift.String? = nil,
            comments: [CodeCommitClientTypes.Comment]? = nil,
            location: CodeCommitClientTypes.Location? = nil,
            pullRequestId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.afterBlobId = afterBlobId
            self.afterCommitId = afterCommitId
            self.beforeBlobId = beforeBlobId
            self.beforeCommitId = beforeCommitId
            self.comments = comments
            self.location = location
            self.pullRequestId = pullRequestId
            self.repositoryName = repositoryName
        }
    }
}

public struct GetCommentsForPullRequestOutput: Swift.Sendable {
    /// An array of comment objects on the pull request.
    public var commentsForPullRequestData: [CodeCommitClientTypes.CommentsForPullRequest]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        commentsForPullRequestData: [CodeCommitClientTypes.CommentsForPullRequest]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commentsForPullRequestData = commentsForPullRequestData
        self.nextToken = nextToken
    }
}

/// The specified commit ID does not exist.
public struct CommitIdDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitIdDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Represents the input of a get commit operation.
public struct GetCommitInput: Swift.Sendable {
    /// The commit ID. Commit IDs are the full SHA ID of the commit.
    /// This member is required.
    public var commitId: Swift.String?
    /// The name of the repository to which the commit was made.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.repositoryName = repositoryName
    }
}

/// Represents the output of a get commit operation.
public struct GetCommitOutput: Swift.Sendable {
    /// A commit data type object that contains information about the specified commit.
    /// This member is required.
    public var commit: CodeCommitClientTypes.Commit?

    public init(
        commit: CodeCommitClientTypes.Commit? = nil
    )
    {
        self.commit = commit
    }
}

/// The specified path does not exist.
public struct PathDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PathDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetDifferencesInput: Swift.Sendable {
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit.
    /// This member is required.
    public var afterCommitSpecifier: Swift.String?
    /// The file path in which to check differences. Limits the results to this path. Can also be used to specify the changed name of a directory or folder, if it has changed. If not specified, differences are shown for all paths.
    public var afterPath: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, the full commit ID). Optional. If not specified, all changes before the afterCommitSpecifier value are shown. If you do not use beforeCommitSpecifier in your request, consider limiting the results with maxResults.
    public var beforeCommitSpecifier: Swift.String?
    /// The file path in which to check for differences. Limits the results to this path. Can also be used to specify the previous name of a directory or folder. If beforePath and afterPath are not specified, differences are shown for all paths.
    public var beforePath: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where you want to get differences.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        afterCommitSpecifier: Swift.String? = nil,
        afterPath: Swift.String? = nil,
        beforeCommitSpecifier: Swift.String? = nil,
        beforePath: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitSpecifier = afterCommitSpecifier
        self.afterPath = afterPath
        self.beforeCommitSpecifier = beforeCommitSpecifier
        self.beforePath = beforePath
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a set of differences for a commit specifier.
    public struct Difference: Swift.Sendable {
        /// Information about an afterBlob data type object, including the ID, the file mode permission code, and the path.
        public var afterBlob: CodeCommitClientTypes.BlobMetadata?
        /// Information about a beforeBlob data type object, including the ID, the file mode permission code, and the path.
        public var beforeBlob: CodeCommitClientTypes.BlobMetadata?
        /// Whether the change type of the difference is an addition (A), deletion (D), or modification (M).
        public var changeType: CodeCommitClientTypes.ChangeTypeEnum?

        public init(
            afterBlob: CodeCommitClientTypes.BlobMetadata? = nil,
            beforeBlob: CodeCommitClientTypes.BlobMetadata? = nil,
            changeType: CodeCommitClientTypes.ChangeTypeEnum? = nil
        )
        {
            self.afterBlob = afterBlob
            self.beforeBlob = beforeBlob
            self.changeType = changeType
        }
    }
}

public struct GetDifferencesOutput: Swift.Sendable {
    /// A data type object that contains information about the differences, including whether the difference is added, modified, or deleted (A, D, M).
    public var differences: [CodeCommitClientTypes.Difference]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        differences: [CodeCommitClientTypes.Difference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.differences = differences
        self.nextToken = nextToken
    }
}

public struct GetFileInput: Swift.Sendable {
    /// The fully quaified reference that identifies the commit that contains the file. For example, you can specify a full commit ID, a tag, a branch name, or a reference such as refs/heads/main. If none is provided, the head commit is used.
    public var commitSpecifier: Swift.String?
    /// The fully qualified path to the file, including the full name and extension of the file. For example, /examples/file.md is the fully qualified path to a file named file.md in a folder named examples.
    /// This member is required.
    public var filePath: Swift.String?
    /// The name of the repository that contains the file.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        commitSpecifier: Swift.String? = nil,
        filePath: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitSpecifier = commitSpecifier
        self.filePath = filePath
        self.repositoryName = repositoryName
    }
}

public struct GetFileOutput: Swift.Sendable {
    /// The blob ID of the object that represents the file content.
    /// This member is required.
    public var blobId: Swift.String?
    /// The full commit ID of the commit that contains the content returned by GetFile.
    /// This member is required.
    public var commitId: Swift.String?
    /// The base-64 encoded binary data object that represents the content of the file.
    /// This member is required.
    public var fileContent: Foundation.Data?
    /// The extrapolated file mode permissions of the blob. Valid values include strings such as EXECUTABLE and not numeric values. The file mode permissions returned by this API are not the standard file mode permission values, such as 100644, but rather extrapolated values. See the supported return values.
    /// This member is required.
    public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
    /// The fully qualified path to the specified file. Returns the name and extension of the file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The size of the contents of the file, in bytes.
    /// This member is required.
    public var fileSize: Swift.Int

    public init(
        blobId: Swift.String? = nil,
        commitId: Swift.String? = nil,
        fileContent: Foundation.Data? = nil,
        fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
        filePath: Swift.String? = nil,
        fileSize: Swift.Int = 0
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.fileContent = fileContent
        self.fileMode = fileMode
        self.filePath = filePath
        self.fileSize = fileSize
    }
}

/// The specified folder does not exist. Either the folder name is not correct, or you did not enter the full path to the folder.
public struct FolderDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FolderDoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetFolderInput: Swift.Sendable {
    /// A fully qualified reference used to identify a commit that contains the version of the folder's content to return. A fully qualified reference can be a commit ID, branch name, tag, or reference such as HEAD. If no specifier is provided, the folder content is returned as it exists in the HEAD commit.
    public var commitSpecifier: Swift.String?
    /// The fully qualified path to the folder whose contents are returned, including the folder name. For example, /examples is a fully-qualified path to a folder named examples that was created off of the root directory (/) of a repository.
    /// This member is required.
    public var folderPath: Swift.String?
    /// The name of the repository.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        commitSpecifier: Swift.String? = nil,
        folderPath: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitSpecifier = commitSpecifier
        self.folderPath = folderPath
        self.repositoryName = repositoryName
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a file in a repository.
    public struct File: Swift.Sendable {
        /// The fully qualified path to the file in the repository.
        public var absolutePath: Swift.String?
        /// The blob ID that contains the file information.
        public var blobId: Swift.String?
        /// The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The relative path of the file from the folder where the query originated.
        public var relativePath: Swift.String?

        public init(
            absolutePath: Swift.String? = nil,
            blobId: Swift.String? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            relativePath: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.blobId = blobId
            self.fileMode = fileMode
            self.relativePath = relativePath
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a folder in a repository.
    public struct Folder: Swift.Sendable {
        /// The fully qualified path of the folder in the repository.
        public var absolutePath: Swift.String?
        /// The relative path of the specified folder from the folder where the query originated.
        public var relativePath: Swift.String?
        /// The full SHA-1 pointer of the tree information for the commit that contains the folder.
        public var treeId: Swift.String?

        public init(
            absolutePath: Swift.String? = nil,
            relativePath: Swift.String? = nil,
            treeId: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.relativePath = relativePath
            self.treeId = treeId
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a submodule reference in a repository folder.
    public struct SubModule: Swift.Sendable {
        /// The fully qualified path to the folder that contains the reference to the submodule.
        public var absolutePath: Swift.String?
        /// The commit ID that contains the reference to the submodule.
        public var commitId: Swift.String?
        /// The relative path of the submodule from the folder where the query originated.
        public var relativePath: Swift.String?

        public init(
            absolutePath: Swift.String? = nil,
            commitId: Swift.String? = nil,
            relativePath: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.commitId = commitId
            self.relativePath = relativePath
        }
    }
}

extension CodeCommitClientTypes {

    /// Returns information about a symbolic link in a repository folder.
    public struct SymbolicLink: Swift.Sendable {
        /// The fully qualified path to the folder that contains the symbolic link.
        public var absolutePath: Swift.String?
        /// The blob ID that contains the information about the symbolic link.
        public var blobId: Swift.String?
        /// The file mode permissions of the blob that cotains information about the symbolic link.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The relative path of the symbolic link from the folder where the query originated.
        public var relativePath: Swift.String?

        public init(
            absolutePath: Swift.String? = nil,
            blobId: Swift.String? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            relativePath: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.blobId = blobId
            self.fileMode = fileMode
            self.relativePath = relativePath
        }
    }
}

public struct GetFolderOutput: Swift.Sendable {
    /// The full commit ID used as a reference for the returned version of the folder content.
    /// This member is required.
    public var commitId: Swift.String?
    /// The list of files in the specified folder, if any.
    public var files: [CodeCommitClientTypes.File]?
    /// The fully qualified path of the folder whose contents are returned.
    /// This member is required.
    public var folderPath: Swift.String?
    /// The list of folders that exist under the specified folder, if any.
    public var subFolders: [CodeCommitClientTypes.Folder]?
    /// The list of submodules in the specified folder, if any.
    public var subModules: [CodeCommitClientTypes.SubModule]?
    /// The list of symbolic links to other files and folders in the specified folder, if any.
    public var symbolicLinks: [CodeCommitClientTypes.SymbolicLink]?
    /// The full SHA-1 pointer of the tree information for the commit that contains the folder.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        files: [CodeCommitClientTypes.File]? = nil,
        folderPath: Swift.String? = nil,
        subFolders: [CodeCommitClientTypes.Folder]? = nil,
        subModules: [CodeCommitClientTypes.SubModule]? = nil,
        symbolicLinks: [CodeCommitClientTypes.SymbolicLink]? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.files = files
        self.folderPath = folderPath
        self.subFolders = subFolders
        self.subModules = subModules
        self.symbolicLinks = symbolicLinks
        self.treeId = treeId
    }
}

public struct GetMergeCommitInput: Swift.Sendable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The name of the repository that contains the merge commit about which you want to get information.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

public struct GetMergeCommitOutput: Swift.Sendable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    public var destinationCommitId: Swift.String?
    /// The commit ID for the merge commit created when the source branch was merged into the destination branch. If the fast-forward merge strategy was used, there is no merge commit.
    public var mergedCommitId: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    public var sourceCommitId: Swift.String?

    public init(
        baseCommitId: Swift.String? = nil,
        destinationCommitId: Swift.String? = nil,
        mergedCommitId: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.destinationCommitId = destinationCommitId
        self.mergedCommitId = mergedCommitId
        self.sourceCommitId = sourceCommitId
    }
}

/// The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.
public struct InvalidDestinationCommitSpecifierException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDestinationCommitSpecifierException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.
public struct InvalidSourceCommitSpecifierException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSourceCommitSpecifierException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetMergeConflictsInput: Swift.Sendable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The maximum number of files to include in the output.
    public var maxConflictFiles: Swift.Int?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        maxConflictFiles: Swift.Int? = nil,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.maxConflictFiles = maxConflictFiles
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

public struct GetMergeConflictsOutput: Swift.Sendable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// A list of metadata for any conflicting files. If the specified merge strategy is FAST_FORWARD_MERGE, this list is always empty.
    /// This member is required.
    public var conflictMetadataList: [CodeCommitClientTypes.ConflictMetadata]?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// A Boolean value that indicates whether the code is mergeable by the specified merge option.
    /// This member is required.
    public var mergeable: Swift.Bool
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init(
        baseCommitId: Swift.String? = nil,
        conflictMetadataList: [CodeCommitClientTypes.ConflictMetadata]? = nil,
        destinationCommitId: Swift.String? = nil,
        mergeable: Swift.Bool = false,
        nextToken: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflictMetadataList = conflictMetadataList
        self.destinationCommitId = destinationCommitId
        self.mergeable = mergeable
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

public struct GetMergeOptionsInput: Swift.Sendable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The name of the repository that contains the commits about which you want to get merge options.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

public struct GetMergeOptionsOutput: Swift.Sendable {
    /// The commit ID of the merge base.
    /// This member is required.
    public var baseCommitId: Swift.String?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// The merge option or strategy used to merge the code.
    /// This member is required.
    public var mergeOptions: [CodeCommitClientTypes.MergeOptionTypeEnum]?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init(
        baseCommitId: Swift.String? = nil,
        destinationCommitId: Swift.String? = nil,
        mergeOptions: [CodeCommitClientTypes.MergeOptionTypeEnum]? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.destinationCommitId = destinationCommitId
        self.mergeOptions = mergeOptions
        self.sourceCommitId = sourceCommitId
    }
}

public struct GetPullRequestInput: Swift.Sendable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
    }
}

public struct GetPullRequestOutput: Swift.Sendable {
    /// Information about the specified pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

public struct GetPullRequestApprovalStatesInput: Swift.Sendable {
    /// The system-generated ID for the pull request.
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID for the pull request revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

public struct GetPullRequestApprovalStatesOutput: Swift.Sendable {
    /// Information about users who have approved the pull request.
    public var approvals: [CodeCommitClientTypes.Approval]?

    public init(
        approvals: [CodeCommitClientTypes.Approval]? = nil
    )
    {
        self.approvals = approvals
    }
}

public struct GetPullRequestOverrideStateInput: Swift.Sendable {
    /// The ID of the pull request for which you want to get information about whether approval rules have been set aside (overridden).
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID of the revision for the pull request. To retrieve the most recent revision ID, use [GetPullRequest].
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

public struct GetPullRequestOverrideStateOutput: Swift.Sendable {
    /// A Boolean value that indicates whether a pull request has had its rules set aside (TRUE) or whether all approval rules still apply (FALSE).
    public var overridden: Swift.Bool
    /// The Amazon Resource Name (ARN) of the user or identity that overrode the rules and their requirements for the pull request.
    public var overrider: Swift.String?

    public init(
        overridden: Swift.Bool = false,
        overrider: Swift.String? = nil
    )
    {
        self.overridden = overridden
        self.overrider = overrider
    }
}

/// Represents the input of a get repository operation.
public struct GetRepositoryInput: Swift.Sendable {
    /// The name of the repository to get information about.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

/// Represents the output of a get repository operation.
public struct GetRepositoryOutput: Swift.Sendable {
    /// Information about the repository.
    public var repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata?

    public init(
        repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata? = nil
    )
    {
        self.repositoryMetadata = repositoryMetadata
    }
}

/// Represents the input of a get repository triggers operation.
public struct GetRepositoryTriggersInput: Swift.Sendable {
    /// The name of the repository for which the trigger is configured.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

extension CodeCommitClientTypes {

    public enum RepositoryTriggerEventEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case createReference
        case deleteReference
        case updateReference
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositoryTriggerEventEnum] {
            return [
                .all,
                .createReference,
                .deleteReference,
                .updateReference
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .createReference: return "createReference"
            case .deleteReference: return "deleteReference"
            case .updateReference: return "updateReference"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    /// Information about a trigger for a repository. If you want to receive notifications about repository events, consider using notifications instead of triggers. For more information, see [Configuring notifications for repository events](https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-repository-email.html).
    public struct RepositoryTrigger: Swift.Sendable {
        /// The branches to be included in the trigger configuration. If you specify an empty array, the trigger applies to all branches. Although no content is required in the array, you must include the array itself.
        public var branches: [Swift.String]?
        /// Any custom data associated with the trigger to be included in the information sent to the target of the trigger.
        public var customData: Swift.String?
        /// The ARN of the resource that is the target for a trigger (for example, the ARN of a topic in Amazon SNS).
        /// This member is required.
        public var destinationArn: Swift.String?
        /// The repository events that cause the trigger to run actions in another service, such as sending a notification through Amazon SNS. The valid value "all" cannot be used with any other values.
        /// This member is required.
        public var events: [CodeCommitClientTypes.RepositoryTriggerEventEnum]?
        /// The name of the trigger.
        /// This member is required.
        public var name: Swift.String?

        public init(
            branches: [Swift.String]? = nil,
            customData: Swift.String? = nil,
            destinationArn: Swift.String? = nil,
            events: [CodeCommitClientTypes.RepositoryTriggerEventEnum]? = nil,
            name: Swift.String? = nil
        )
        {
            self.branches = branches
            self.customData = customData
            self.destinationArn = destinationArn
            self.events = events
            self.name = name
        }
    }
}

/// Represents the output of a get repository triggers operation.
public struct GetRepositoryTriggersOutput: Swift.Sendable {
    /// The system-generated unique ID for the trigger.
    public var configurationId: Swift.String?
    /// The JSON block of configuration information for each trigger.
    public var triggers: [CodeCommitClientTypes.RepositoryTrigger]?

    public init(
        configurationId: Swift.String? = nil,
        triggers: [CodeCommitClientTypes.RepositoryTrigger]? = nil
    )
    {
        self.configurationId = configurationId
        self.triggers = triggers
    }
}

public struct ListApprovalRuleTemplatesInput: Swift.Sendable {
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApprovalRuleTemplatesOutput: Swift.Sendable {
    /// The names of all the approval rule templates found in the Amazon Web Services Region for your Amazon Web Services account.
    public var approvalRuleTemplateNames: [Swift.String]?
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?

    public init(
        approvalRuleTemplateNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateNames = approvalRuleTemplateNames
        self.nextToken = nextToken
    }
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryInput: Swift.Sendable {
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository for which you want to list all associated approval rule templates.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryOutput: Swift.Sendable {
    /// The names of all approval rule templates associated with the repository.
    public var approvalRuleTemplateNames: [Swift.String]?
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?

    public init(
        approvalRuleTemplateNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateNames = approvalRuleTemplateNames
        self.nextToken = nextToken
    }
}

/// Represents the input of a list branches operation.
public struct ListBranchesInput: Swift.Sendable {
    /// An enumeration token that allows the operation to batch the results.
    public var nextToken: Swift.String?
    /// The name of the repository that contains the branches.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

/// Represents the output of a list branches operation.
public struct ListBranchesOutput: Swift.Sendable {
    /// The list of branch names.
    public var branches: [Swift.String]?
    /// An enumeration token that returns the batch of the results.
    public var nextToken: Swift.String?

    public init(
        branches: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.branches = branches
        self.nextToken = nextToken
    }
}

public struct ListFileCommitHistoryInput: Swift.Sendable {
    /// The fully quaified reference that identifies the commit that contains the file. For example, you can specify a full commit ID, a tag, a branch name, or a reference such as refs/heads/main. If none is provided, the head commit is used.
    public var commitSpecifier: Swift.String?
    /// The full path of the file whose history you want to retrieve, including the name of the file.
    /// This member is required.
    public var filePath: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that allows the operation to batch the results.
    public var nextToken: Swift.String?
    /// The name of the repository that contains the file.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        commitSpecifier: Swift.String? = nil,
        filePath: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitSpecifier = commitSpecifier
        self.filePath = filePath
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

extension CodeCommitClientTypes {

    /// Information about a version of a file.
    public struct FileVersion: Swift.Sendable {
        /// The blob ID of the object that represents the content of the file in this version.
        public var blobId: Swift.String?
        /// Returns information about a specific commit.
        public var commit: CodeCommitClientTypes.Commit?
        /// The name and path of the file at which this blob is indexed which contains the data for this version of the file. This value will vary between file versions if a file is renamed or if its path changes.
        public var path: Swift.String?
        /// An array of commit IDs that contain more recent versions of this file. If there are no additional versions of the file, this array will be empty.
        public var revisionChildren: [Swift.String]?

        public init(
            blobId: Swift.String? = nil,
            commit: CodeCommitClientTypes.Commit? = nil,
            path: Swift.String? = nil,
            revisionChildren: [Swift.String]? = nil
        )
        {
            self.blobId = blobId
            self.commit = commit
            self.path = path
            self.revisionChildren = revisionChildren
        }
    }
}

public struct ListFileCommitHistoryOutput: Swift.Sendable {
    /// An enumeration token that can be used to return the next batch of results.
    public var nextToken: Swift.String?
    /// An array of FileVersion objects that form a directed acyclic graph (DAG) of the changes to the file made by the commits that changed the file.
    /// This member is required.
    public var revisionDag: [CodeCommitClientTypes.FileVersion]?

    public init(
        nextToken: Swift.String? = nil,
        revisionDag: [CodeCommitClientTypes.FileVersion]? = nil
    )
    {
        self.nextToken = nextToken
        self.revisionDag = revisionDag
    }
}

/// The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.
public struct InvalidAuthorArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAuthorArnException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The pull request status is not valid. The only valid values are OPEN and CLOSED.
public struct InvalidPullRequestStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPullRequestStatusException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListPullRequestsInput: Swift.Sendable {
    /// Optional. The Amazon Resource Name (ARN) of the user who created the pull request. If used, this filters the results to pull requests created by that user.
    public var authorArn: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// Optional. The status of the pull request. If used, this refines the results to the pull requests that match the specified status.
    public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?
    /// The name of the repository for which you want to list pull requests.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        authorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.authorArn = authorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestStatus = pullRequestStatus
        self.repositoryName = repositoryName
    }
}

public struct ListPullRequestsOutput: Swift.Sendable {
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?
    /// The system-generated IDs of the pull requests.
    /// This member is required.
    public var pullRequestIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        pullRequestIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.pullRequestIds = pullRequestIds
    }
}

/// The specified sort order is not valid.
public struct InvalidOrderException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOrderException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified sort by value is not valid.
public struct InvalidSortByException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSortByException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeCommitClientTypes {

    public enum OrderEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderEnum] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ascending"
            case .descending: return "descending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeCommitClientTypes {

    public enum SortByEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case modifiedDate
        case repositoryName
        case sdkUnknown(Swift.String)

        public static var allCases: [SortByEnum] {
            return [
                .modifiedDate,
                .repositoryName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .modifiedDate: return "lastModifiedDate"
            case .repositoryName: return "repositoryName"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Represents the input of a list repositories operation.
public struct ListRepositoriesInput: Swift.Sendable {
    /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to CodeCommit, another page of 1,000 records is retrieved.
    public var nextToken: Swift.String?
    /// The order in which to sort the results of a list repositories operation.
    public var order: CodeCommitClientTypes.OrderEnum?
    /// The criteria used to sort the results of a list repositories operation.
    public var sortBy: CodeCommitClientTypes.SortByEnum?

    public init(
        nextToken: Swift.String? = nil,
        order: CodeCommitClientTypes.OrderEnum? = nil,
        sortBy: CodeCommitClientTypes.SortByEnum? = nil
    )
    {
        self.nextToken = nextToken
        self.order = order
        self.sortBy = sortBy
    }
}

extension CodeCommitClientTypes {

    /// Information about a repository name and ID.
    public struct RepositoryNameIdPair: Swift.Sendable {
        /// The ID associated with the repository.
        public var repositoryId: Swift.String?
        /// The name associated with the repository.
        public var repositoryName: Swift.String?

        public init(
            repositoryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.repositoryId = repositoryId
            self.repositoryName = repositoryName
        }
    }
}

/// Represents the output of a list repositories operation.
public struct ListRepositoriesOutput: Swift.Sendable {
    /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to CodeCommit, another page of 1,000 records is retrieved.
    public var nextToken: Swift.String?
    /// Lists the repositories called by the list repositories operation.
    public var repositories: [CodeCommitClientTypes.RepositoryNameIdPair]?

    public init(
        nextToken: Swift.String? = nil,
        repositories: [CodeCommitClientTypes.RepositoryNameIdPair]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

public struct ListRepositoriesForApprovalRuleTemplateInput: Swift.Sendable {
    /// The name of the approval rule template for which you want to list repositories that are associated with that template.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListRepositoriesForApprovalRuleTemplateOutput: Swift.Sendable {
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?
    /// A list of repository names that are associated with the specified approval rule template.
    public var repositoryNames: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryNames = repositoryNames
    }
}

/// The value for the resource ARN is not valid. For more information about resources in CodeCommit, see [CodeCommit Resources and Operations](https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats) in the CodeCommit User Guide.
public struct InvalidResourceArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceArnException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A valid Amazon Resource Name (ARN) for an CodeCommit resource is required. For a list of valid resources in CodeCommit, see [CodeCommit Resources and Operations](https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats) in the CodeCommit User Guide.
public struct ResourceArnRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceArnRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to get information about tags, if any.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?
    /// A list of tag key and value pairs associated with the specified resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

/// The specified target branch is not valid.
public struct InvalidTargetBranchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTargetBranchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct MergeBranchesByFastForwardInput: Swift.Sendable {
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The name of the repository where you want to merge two branches.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?
    /// The branch where the merge is applied.
    public var targetBranch: Swift.String?

    public init(
        destinationCommitSpecifier: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil,
        targetBranch: Swift.String? = nil
    )
    {
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

public struct MergeBranchesByFastForwardOutput: Swift.Sendable {
    /// The commit ID of the merge in the destination or target branch.
    public var commitId: Swift.String?
    /// The tree ID of the merge in the destination or target branch.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

public struct MergeBranchesBySquashInput: Swift.Sendable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If this is specified as true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The name of the repository where you want to merge two branches.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?
    /// The branch where the merge is applied.
    public var targetBranch: Swift.String?

    public init(
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = false,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil,
        targetBranch: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

public struct MergeBranchesBySquashOutput: Swift.Sendable {
    /// The commit ID of the merge in the destination or target branch.
    public var commitId: Swift.String?
    /// The tree ID of the merge in the destination or target branch.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

public struct MergeBranchesByThreeWayInput: Swift.Sendable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message to include in the commit information for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The name of the repository where you want to merge two branches.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?
    /// The branch where the merge is applied.
    public var targetBranch: Swift.String?

    public init(
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = false,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil,
        targetBranch: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

public struct MergeBranchesByThreeWayOutput: Swift.Sendable {
    /// The commit ID of the merge in the destination or target branch.
    public var commitId: Swift.String?
    /// The tree ID of the merge in the destination or target branch.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

/// The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.
public struct PullRequestApprovalRulesNotSatisfiedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestApprovalRulesNotSatisfiedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.
public struct TipOfSourceReferenceIsDifferentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TipOfSourceReferenceIsDifferentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct MergePullRequestByFastForwardInput: Swift.Sendable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.
    public var sourceCommitId: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

public struct MergePullRequestByFastForwardOutput: Swift.Sendable {
    /// Information about the specified pull request, including the merge.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

public struct MergePullRequestBySquashInput: Swift.Sendable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message to include in the commit information for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.
    public var sourceCommitId: Swift.String?

    public init(
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = false,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

public struct MergePullRequestBySquashOutput: Swift.Sendable {
    /// Returns information about a pull request.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

public struct MergePullRequestByThreeWayInput: Swift.Sendable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message to include in the commit information for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.
    public var sourceCommitId: Swift.String?

    public init(
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = false,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

public struct MergePullRequestByThreeWayOutput: Swift.Sendable {
    /// Returns information about a pull request.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

/// The override status is not valid. Valid statuses are OVERRIDE and REVOKE.
public struct InvalidOverrideStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOverrideStatusException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The pull request has already had its approval rules set to override.
public struct OverrideAlreadySetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OverrideAlreadySetException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.
public struct OverrideStatusRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OverrideStatusRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct OverridePullRequestApprovalRulesInput: Swift.Sendable {
    /// Whether you want to set aside approval rule requirements for the pull request (OVERRIDE) or revoke a previous override and apply approval rule requirements (REVOKE). REVOKE status is not stored.
    /// This member is required.
    public var overrideStatus: CodeCommitClientTypes.OverrideStatus?
    /// The system-generated ID of the pull request for which you want to override all approval rule requirements. To get this information, use [GetPullRequest].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID of the most recent revision of the pull request. You cannot override approval rules for anything but the most recent revision of a pull request. To get the revision ID, use GetPullRequest.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        overrideStatus: CodeCommitClientTypes.OverrideStatus? = nil,
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.overrideStatus = overrideStatus
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

/// The comment is empty. You must provide some content for a comment. The content cannot be null.
public struct CommentContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentContentRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The comment is too large. Comments are limited to 10,240 characters.
public struct CommentContentSizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentContentSizeLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The location of the file is not valid. Make sure that you include the file name and extension.
public struct InvalidFileLocationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFileLocationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.
public struct InvalidFilePositionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFilePositionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.
public struct InvalidRelativeFileVersionEnumException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRelativeFileVersionEnumException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PostCommentForComparedCommitInput: Swift.Sendable {
    /// To establish the directionality of the comparison, the full commit ID of the after commit.
    /// This member is required.
    public var afterCommitId: Swift.String?
    /// To establish the directionality of the comparison, the full commit ID of the before commit. Required for commenting on any commit unless that commit is the initial commit.
    public var beforeCommitId: Swift.String?
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
    public var clientRequestToken: Swift.String?
    /// The content of the comment you want to make.
    /// This member is required.
    public var content: Swift.String?
    /// The location of the comparison where you want to comment.
    public var location: CodeCommitClientTypes.Location?
    /// The name of the repository where you want to post a comment on the comparison between commits.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.location = location
        self.repositoryName = repositoryName
    }
}

public struct PostCommentForComparedCommitOutput: Swift.Sendable {
    /// In the directionality you established, the blob ID of the after blob.
    public var afterBlobId: Swift.String?
    /// In the directionality you established, the full commit ID of the after commit.
    public var afterCommitId: Swift.String?
    /// In the directionality you established, the blob ID of the before blob.
    public var beforeBlobId: Swift.String?
    /// In the directionality you established, the full commit ID of the before commit.
    public var beforeCommitId: Swift.String?
    /// The content of the comment you posted.
    public var comment: CodeCommitClientTypes.Comment?
    /// The location of the comment in the comparison between the two commits.
    public var location: CodeCommitClientTypes.Location?
    /// The name of the repository where you posted a comment on the comparison between commits.
    public var repositoryName: Swift.String?

    public init(
        afterBlobId: Swift.String? = nil,
        afterCommitId: Swift.String? = nil,
        beforeBlobId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        comment: CodeCommitClientTypes.Comment? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterBlobId = afterBlobId
        self.afterCommitId = afterCommitId
        self.beforeBlobId = beforeBlobId
        self.beforeCommitId = beforeCommitId
        self.comment = comment
        self.location = location
        self.repositoryName = repositoryName
    }
}

public struct PostCommentForPullRequestInput: Swift.Sendable {
    /// The full commit ID of the commit in the source branch that is the current tip of the branch for the pull request when you post the comment.
    /// This member is required.
    public var afterCommitId: Swift.String?
    /// The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was created.
    /// This member is required.
    public var beforeCommitId: Swift.String?
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
    public var clientRequestToken: Swift.String?
    /// The content of your comment on the change.
    /// This member is required.
    public var content: Swift.String?
    /// The location of the change where you want to post your comment. If no location is provided, the comment is posted as a general comment on the pull request difference between the before commit ID and the after commit ID.
    public var location: CodeCommitClientTypes.Location?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where you want to post a comment on a pull request.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.location = location
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

public struct PostCommentForPullRequestOutput: Swift.Sendable {
    /// In the directionality of the pull request, the blob ID of the after blob.
    public var afterBlobId: Swift.String?
    /// The full commit ID of the commit in the destination branch where the pull request is merged.
    public var afterCommitId: Swift.String?
    /// In the directionality of the pull request, the blob ID of the before blob.
    public var beforeBlobId: Swift.String?
    /// The full commit ID of the commit in the source branch used to create the pull request, or in the case of an updated pull request, the full commit ID of the commit used to update the pull request.
    public var beforeCommitId: Swift.String?
    /// The content of the comment you posted.
    public var comment: CodeCommitClientTypes.Comment?
    /// The location of the change where you posted your comment.
    public var location: CodeCommitClientTypes.Location?
    /// The system-generated ID of the pull request.
    public var pullRequestId: Swift.String?
    /// The name of the repository where you posted a comment on a pull request.
    public var repositoryName: Swift.String?

    public init(
        afterBlobId: Swift.String? = nil,
        afterCommitId: Swift.String? = nil,
        beforeBlobId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        comment: CodeCommitClientTypes.Comment? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterBlobId = afterBlobId
        self.afterCommitId = afterCommitId
        self.beforeBlobId = beforeBlobId
        self.beforeCommitId = beforeCommitId
        self.comment = comment
        self.location = location
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

public struct PostCommentReplyInput: Swift.Sendable {
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
    public var clientRequestToken: Swift.String?
    /// The contents of your reply to a comment.
    /// This member is required.
    public var content: Swift.String?
    /// The system-generated ID of the comment to which you want to reply. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var inReplyTo: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        inReplyTo: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.inReplyTo = inReplyTo
    }
}

public struct PostCommentReplyOutput: Swift.Sendable {
    /// Information about the reply to a comment.
    public var comment: CodeCommitClientTypes.Comment?

    public init(
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

/// The value of the reaction is not valid. For more information, see the [CodeCommit User Guide](https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html).
public struct InvalidReactionValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidReactionValueException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.
public struct ReactionLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReactionLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A reaction value is required.
public struct ReactionValueRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReactionValueRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutCommentReactionInput: Swift.Sendable {
    /// The ID of the comment to which you want to add or update a reaction.
    /// This member is required.
    public var commentId: Swift.String?
    /// The emoji reaction you want to add or update. To remove a reaction, provide a value of blank or null. You can also provide the value of none. For information about emoji reaction values supported in CodeCommit, see the [CodeCommit User Guide](https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-commit-comment.html#emoji-reaction-table).
    /// This member is required.
    public var reactionValue: Swift.String?

    public init(
        commentId: Swift.String? = nil,
        reactionValue: Swift.String? = nil
    )
    {
        self.commentId = commentId
        self.reactionValue = reactionValue
    }
}

/// The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.
public struct FileContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileContentRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch that you specified.
public struct SameFileContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SameFileContentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutFileInput: Swift.Sendable {
    /// The name of the branch where you want to add or update the file. If this is an empty repository, this branch is created.
    /// This member is required.
    public var branchName: Swift.String?
    /// A message about why this file was added or updated. Although it is optional, a message makes the commit history for your repository more useful.
    public var commitMessage: Swift.String?
    /// An email address for the person adding or updating the file.
    public var email: Swift.String?
    /// The content of the file, in binary object format.
    /// This member is required.
    public var fileContent: Foundation.Data?
    /// The file mode permissions of the blob. Valid file mode permissions are listed here.
    public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
    /// The name of the file you want to add or update, including the relative path to the file in the repository. If the path does not currently exist in the repository, the path is created as part of adding the file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The name of the person adding or updating the file. Although it is optional, a name makes the commit history for your repository more useful.
    public var name: Swift.String?
    /// The full commit ID of the head commit in the branch where you want to add or update the file. If this is an empty repository, no commit ID is required. If this is not an empty repository, a commit ID is required. The commit ID must match the ID of the head commit at the time of the operation. Otherwise, an error occurs, and the file is not added or updated.
    public var parentCommitId: Swift.String?
    /// The name of the repository where you want to add or update the file.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        email: Swift.String? = nil,
        fileContent: Foundation.Data? = nil,
        fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
        filePath: Swift.String? = nil,
        name: Swift.String? = nil,
        parentCommitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.email = email
        self.fileContent = fileContent
        self.fileMode = fileMode
        self.filePath = filePath
        self.name = name
        self.parentCommitId = parentCommitId
        self.repositoryName = repositoryName
    }
}

public struct PutFileOutput: Swift.Sendable {
    /// The ID of the blob, which is its SHA-1 pointer.
    /// This member is required.
    public var blobId: Swift.String?
    /// The full SHA ID of the commit that contains this file change.
    /// This member is required.
    public var commitId: Swift.String?
    /// The full SHA-1 pointer of the tree information for the commit that contains this file change.
    /// This member is required.
    public var treeId: Swift.String?

    public init(
        blobId: Swift.String? = nil,
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.treeId = treeId
    }
}

/// One or more branch names specified for the trigger is not valid.
public struct InvalidRepositoryTriggerBranchNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerBranchNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The custom data provided for the trigger is not valid.
public struct InvalidRepositoryTriggerCustomDataException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerCustomDataException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.
public struct InvalidRepositoryTriggerDestinationArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerDestinationArnException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.
public struct InvalidRepositoryTriggerEventsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerEventsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The name of the trigger is not valid.
public struct InvalidRepositoryTriggerNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Amazon Web Services Region for the trigger target does not match the Amazon Web Services Region for the repository. Triggers must be created in the same Amazon Web Services Region as the target for the trigger.
public struct InvalidRepositoryTriggerRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerRegionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of branches for the trigger was exceeded.
public struct MaximumBranchesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumBranchesExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of triggers allowed for the repository was exceeded.
public struct MaximumRepositoryTriggersExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumRepositoryTriggersExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// At least one branch name is required, but was not specified in the trigger configuration.
public struct RepositoryTriggerBranchNameListRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryTriggerBranchNameListRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A destination ARN for the target service for the trigger is required, but was not specified.
public struct RepositoryTriggerDestinationArnRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryTriggerDestinationArnRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// At least one event for the trigger is required, but was not specified.
public struct RepositoryTriggerEventsListRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryTriggerEventsListRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A name for the trigger is required, but was not specified.
public struct RepositoryTriggerNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryTriggerNameRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The list of triggers for the repository is required, but was not specified.
public struct RepositoryTriggersListRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryTriggersListRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Represents the input of a put repository triggers operation.
public struct PutRepositoryTriggersInput: Swift.Sendable {
    /// The name of the repository where you want to create or update the trigger.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The JSON block of configuration information for each trigger.
    /// This member is required.
    public var triggers: [CodeCommitClientTypes.RepositoryTrigger]?

    public init(
        repositoryName: Swift.String? = nil,
        triggers: [CodeCommitClientTypes.RepositoryTrigger]? = nil
    )
    {
        self.repositoryName = repositoryName
        self.triggers = triggers
    }
}

/// Represents the output of a put repository triggers operation.
public struct PutRepositoryTriggersOutput: Swift.Sendable {
    /// The system-generated unique ID for the create or update operation.
    public var configurationId: Swift.String?

    public init(
        configurationId: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

/// A map of tags is required.
public struct TagsMapRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagsMapRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to which you want to add or update tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair to use when tagging this repository.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

/// Represents the input of a test repository triggers operation.
public struct TestRepositoryTriggersInput: Swift.Sendable {
    /// The name of the repository in which to test the triggers.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The list of triggers to test.
    /// This member is required.
    public var triggers: [CodeCommitClientTypes.RepositoryTrigger]?

    public init(
        repositoryName: Swift.String? = nil,
        triggers: [CodeCommitClientTypes.RepositoryTrigger]? = nil
    )
    {
        self.repositoryName = repositoryName
        self.triggers = triggers
    }
}

extension CodeCommitClientTypes {

    /// A trigger failed to run.
    public struct RepositoryTriggerExecutionFailure: Swift.Sendable {
        /// Message information about the trigger that did not run.
        public var failureMessage: Swift.String?
        /// The name of the trigger that did not run.
        public var trigger: Swift.String?

        public init(
            failureMessage: Swift.String? = nil,
            trigger: Swift.String? = nil
        )
        {
            self.failureMessage = failureMessage
            self.trigger = trigger
        }
    }
}

/// Represents the output of a test repository triggers operation.
public struct TestRepositoryTriggersOutput: Swift.Sendable {
    /// The list of triggers that were not tested. This list provides the names of the triggers that could not be tested, separated by commas.
    public var failedExecutions: [CodeCommitClientTypes.RepositoryTriggerExecutionFailure]?
    /// The list of triggers that were successfully tested. This list provides the names of the triggers that were successfully tested, separated by commas.
    public var successfulExecutions: [Swift.String]?

    public init(
        failedExecutions: [CodeCommitClientTypes.RepositoryTriggerExecutionFailure]? = nil,
        successfulExecutions: [Swift.String]? = nil
    )
    {
        self.failedExecutions = failedExecutions
        self.successfulExecutions = successfulExecutions
    }
}

/// The list of tags is not valid.
public struct InvalidTagKeysListException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagKeysListException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A list of tag keys is required. The list cannot be empty or null.
public struct TagKeysListRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagKeysListRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to which you want to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key for each tag that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

/// The SHA-256 hash signature for the rule content is not valid.
public struct InvalidRuleContentSha256Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRuleContentSha256Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateApprovalRuleTemplateContentInput: Swift.Sendable {
    /// The name of the approval rule template where you want to update the content of the rule.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The SHA-256 hash signature for the content of the approval rule. You can retrieve this information by using [GetPullRequest].
    public var existingRuleContentSha256: Swift.String?
    /// The content that replaces the existing content of the rule. Content statements must be complete. You cannot provide only the changes.
    /// This member is required.
    public var newRuleContent: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        existingRuleContentSha256: Swift.String? = nil,
        newRuleContent: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.existingRuleContentSha256 = existingRuleContentSha256
        self.newRuleContent = newRuleContent
    }
}

public struct UpdateApprovalRuleTemplateContentOutput: Swift.Sendable {
    /// Returns information about an approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init(
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

public struct UpdateApprovalRuleTemplateDescriptionInput: Swift.Sendable {
    /// The updated description of the approval rule template.
    /// This member is required.
    public var approvalRuleTemplateDescription: Swift.String?
    /// The name of the template for which you want to update the description.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init(
        approvalRuleTemplateDescription: Swift.String? = nil,
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

public struct UpdateApprovalRuleTemplateDescriptionOutput: Swift.Sendable {
    /// The structure and content of the updated approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init(
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

public struct UpdateApprovalRuleTemplateNameInput: Swift.Sendable {
    /// The new name you want to apply to the approval rule template.
    /// This member is required.
    public var newApprovalRuleTemplateName: Swift.String?
    /// The current name of the approval rule template.
    /// This member is required.
    public var oldApprovalRuleTemplateName: Swift.String?

    public init(
        newApprovalRuleTemplateName: Swift.String? = nil,
        oldApprovalRuleTemplateName: Swift.String? = nil
    )
    {
        self.newApprovalRuleTemplateName = newApprovalRuleTemplateName
        self.oldApprovalRuleTemplateName = oldApprovalRuleTemplateName
    }
}

public struct UpdateApprovalRuleTemplateNameOutput: Swift.Sendable {
    /// The structure and content of the updated approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init(
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

/// You cannot modify or delete this comment. Only comment authors can modify or delete their comments.
public struct CommentNotCreatedByCallerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentNotCreatedByCallerException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateCommentInput: Swift.Sendable {
    /// The system-generated ID of the comment you want to update. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var commentId: Swift.String?
    /// The updated content to replace the existing content of the comment.
    /// This member is required.
    public var content: Swift.String?

    public init(
        commentId: Swift.String? = nil,
        content: Swift.String? = nil
    )
    {
        self.commentId = commentId
        self.content = content
    }
}

public struct UpdateCommentOutput: Swift.Sendable {
    /// Information about the updated comment.
    public var comment: CodeCommitClientTypes.Comment?

    public init(
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

/// Represents the input of an update default branch operation.
public struct UpdateDefaultBranchInput: Swift.Sendable {
    /// The name of the branch to set as the default branch.
    /// This member is required.
    public var defaultBranchName: Swift.String?
    /// The name of the repository for which you want to set or change the default branch.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        defaultBranchName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.defaultBranchName = defaultBranchName
        self.repositoryName = repositoryName
    }
}

public struct UpdatePullRequestApprovalRuleContentInput: Swift.Sendable {
    /// The name of the approval rule you want to update.
    /// This member is required.
    public var approvalRuleName: Swift.String?
    /// The SHA-256 hash signature for the content of the approval rule. You can retrieve this information by using [GetPullRequest].
    public var existingRuleContentSha256: Swift.String?
    /// The updated content for the approval rule. When you update the content of the approval rule, you can specify approvers in an approval pool in one of two ways:
    ///
    /// * CodeCommitApprovers: This option only requires an Amazon Web Services account and a resource. It can be used for both IAM users and federated access users whose name matches the provided resource name. This is a very powerful option that offers a great deal of flexibility. For example, if you specify the Amazon Web Services account 123456789012 and Mary_Major, all of the following are counted as approvals coming from that user:
    ///
    /// * An IAM user in the account (arn:aws:iam::123456789012:user/Mary_Major)
    ///
    /// * A federated user identified in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
    ///
    ///
    /// This option does not recognize an active session of someone assuming the role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major) unless you include a wildcard (*Mary_Major).
    ///
    /// * Fully qualified ARN: This option allows you to specify the fully qualified Amazon Resource Name (ARN) of the IAM user or role.
    ///
    ///
    /// For more information about IAM ARNs, wildcards, and formats, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var newRuleContent: Swift.String?
    /// The system-generated ID of the pull request.
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        approvalRuleName: Swift.String? = nil,
        existingRuleContentSha256: Swift.String? = nil,
        newRuleContent: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.approvalRuleName = approvalRuleName
        self.existingRuleContentSha256 = existingRuleContentSha256
        self.newRuleContent = newRuleContent
        self.pullRequestId = pullRequestId
    }
}

public struct UpdatePullRequestApprovalRuleContentOutput: Swift.Sendable {
    /// Information about the updated approval rule.
    /// This member is required.
    public var approvalRule: CodeCommitClientTypes.ApprovalRule?

    public init(
        approvalRule: CodeCommitClientTypes.ApprovalRule? = nil
    )
    {
        self.approvalRule = approvalRule
    }
}

/// The state for the approval is not valid. Valid values include APPROVE and REVOKE.
public struct InvalidApprovalStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of approvals required for the approval rule exceeds the maximum number allowed.
public struct MaximumNumberOfApprovalsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumNumberOfApprovalsExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull request that you created.
public struct PullRequestCannotBeApprovedByAuthorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestCannotBeApprovedByAuthorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdatePullRequestApprovalStateInput: Swift.Sendable {
    /// The approval state to associate with the user on the pull request.
    /// This member is required.
    public var approvalState: CodeCommitClientTypes.ApprovalState?
    /// The system-generated ID of the pull request.
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID of the revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        approvalState: CodeCommitClientTypes.ApprovalState? = nil,
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.approvalState = approvalState
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

public struct UpdatePullRequestDescriptionInput: Swift.Sendable {
    /// The updated content of the description for the pull request. This content replaces the existing description.
    /// This member is required.
    public var description: Swift.String?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        description: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.description = description
        self.pullRequestId = pullRequestId
    }
}

public struct UpdatePullRequestDescriptionOutput: Swift.Sendable {
    /// Information about the updated pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

/// The pull request status update is not valid. The only valid update is from OPEN to CLOSED.
public struct InvalidPullRequestStatusUpdateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPullRequestStatusUpdateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A pull request status is required, but none was provided.
public struct PullRequestStatusRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestStatusRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdatePullRequestStatusInput: Swift.Sendable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The status of the pull request. The only valid operations are to update the status from OPEN to OPEN, OPEN to CLOSED or from CLOSED to CLOSED.
    /// This member is required.
    public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?

    public init(
        pullRequestId: Swift.String? = nil,
        pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.pullRequestStatus = pullRequestStatus
    }
}

public struct UpdatePullRequestStatusOutput: Swift.Sendable {
    /// Information about the pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

public struct UpdatePullRequestTitleInput: Swift.Sendable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The updated title of the pull request. This replaces the existing title.
    /// This member is required.
    public var title: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil,
        title: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.title = title
    }
}

public struct UpdatePullRequestTitleOutput: Swift.Sendable {
    /// Information about the updated pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

/// Represents the input of an update repository description operation.
public struct UpdateRepositoryDescriptionInput: Swift.Sendable {
    /// The new comment or description for the specified repository. Repository descriptions are limited to 1,000 characters.
    public var repositoryDescription: Swift.String?
    /// The name of the repository to set or change the comment or description for.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        repositoryDescription: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryDescription = repositoryDescription
        self.repositoryName = repositoryName
    }
}

/// A KMS encryption key ID is required but was not specified.
public struct EncryptionKeyRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateRepositoryEncryptionKeyInput: Swift.Sendable {
    /// The ID of the encryption key. You can view the ID of an encryption key in the KMS console, or use the KMS APIs to programmatically retrieve a key ID. For more information about acceptable values for keyID, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_Decrypt.html#KMS-Decrypt-request-KeyId) in the Decrypt API description in the Key Management Service API Reference.
    /// This member is required.
    public var kmsKeyId: Swift.String?
    /// The name of the repository for which you want to update the KMS encryption key used to encrypt and decrypt the repository.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        kmsKeyId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.repositoryName = repositoryName
    }
}

public struct UpdateRepositoryEncryptionKeyOutput: Swift.Sendable {
    /// The ID of the encryption key.
    public var kmsKeyId: Swift.String?
    /// The ID of the encryption key formerly used to encrypt and decrypt the repository.
    public var originalKmsKeyId: Swift.String?
    /// The ID of the repository.
    public var repositoryId: Swift.String?

    public init(
        kmsKeyId: Swift.String? = nil,
        originalKmsKeyId: Swift.String? = nil,
        repositoryId: Swift.String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.originalKmsKeyId = originalKmsKeyId
        self.repositoryId = repositoryId
    }
}

/// Represents the input of an update repository description operation.
public struct UpdateRepositoryNameInput: Swift.Sendable {
    /// The new name for the repository.
    /// This member is required.
    public var newName: Swift.String?
    /// The current name of the repository.
    /// This member is required.
    public var oldName: Swift.String?

    public init(
        newName: Swift.String? = nil,
        oldName: Swift.String? = nil
    )
    {
        self.newName = newName
        self.oldName = oldName
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryInput {

    static func urlPathProvider(_ value: AssociateApprovalRuleTemplateWithRepositoryInput) -> Swift.String? {
        return "/"
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInput {

    static func urlPathProvider(_ value: BatchAssociateApprovalRuleTemplateWithRepositoriesInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDescribeMergeConflictsInput {

    static func urlPathProvider(_ value: BatchDescribeMergeConflictsInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInput {

    static func urlPathProvider(_ value: BatchDisassociateApprovalRuleTemplateFromRepositoriesInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetCommitsInput {

    static func urlPathProvider(_ value: BatchGetCommitsInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetRepositoriesInput {

    static func urlPathProvider(_ value: BatchGetRepositoriesInput) -> Swift.String? {
        return "/"
    }
}

extension CreateApprovalRuleTemplateInput {

    static func urlPathProvider(_ value: CreateApprovalRuleTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBranchInput {

    static func urlPathProvider(_ value: CreateBranchInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCommitInput {

    static func urlPathProvider(_ value: CreateCommitInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePullRequestInput {

    static func urlPathProvider(_ value: CreatePullRequestInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePullRequestApprovalRuleInput {

    static func urlPathProvider(_ value: CreatePullRequestApprovalRuleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRepositoryInput {

    static func urlPathProvider(_ value: CreateRepositoryInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUnreferencedMergeCommitInput {

    static func urlPathProvider(_ value: CreateUnreferencedMergeCommitInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApprovalRuleTemplateInput {

    static func urlPathProvider(_ value: DeleteApprovalRuleTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBranchInput {

    static func urlPathProvider(_ value: DeleteBranchInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCommentContentInput {

    static func urlPathProvider(_ value: DeleteCommentContentInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFileInput {

    static func urlPathProvider(_ value: DeleteFileInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePullRequestApprovalRuleInput {

    static func urlPathProvider(_ value: DeletePullRequestApprovalRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRepositoryInput {

    static func urlPathProvider(_ value: DeleteRepositoryInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMergeConflictsInput {

    static func urlPathProvider(_ value: DescribeMergeConflictsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePullRequestEventsInput {

    static func urlPathProvider(_ value: DescribePullRequestEventsInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryInput {

    static func urlPathProvider(_ value: DisassociateApprovalRuleTemplateFromRepositoryInput) -> Swift.String? {
        return "/"
    }
}

extension EvaluatePullRequestApprovalRulesInput {

    static func urlPathProvider(_ value: EvaluatePullRequestApprovalRulesInput) -> Swift.String? {
        return "/"
    }
}

extension GetApprovalRuleTemplateInput {

    static func urlPathProvider(_ value: GetApprovalRuleTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension GetBlobInput {

    static func urlPathProvider(_ value: GetBlobInput) -> Swift.String? {
        return "/"
    }
}

extension GetBranchInput {

    static func urlPathProvider(_ value: GetBranchInput) -> Swift.String? {
        return "/"
    }
}

extension GetCommentInput {

    static func urlPathProvider(_ value: GetCommentInput) -> Swift.String? {
        return "/"
    }
}

extension GetCommentReactionsInput {

    static func urlPathProvider(_ value: GetCommentReactionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetCommentsForComparedCommitInput {

    static func urlPathProvider(_ value: GetCommentsForComparedCommitInput) -> Swift.String? {
        return "/"
    }
}

extension GetCommentsForPullRequestInput {

    static func urlPathProvider(_ value: GetCommentsForPullRequestInput) -> Swift.String? {
        return "/"
    }
}

extension GetCommitInput {

    static func urlPathProvider(_ value: GetCommitInput) -> Swift.String? {
        return "/"
    }
}

extension GetDifferencesInput {

    static func urlPathProvider(_ value: GetDifferencesInput) -> Swift.String? {
        return "/"
    }
}

extension GetFileInput {

    static func urlPathProvider(_ value: GetFileInput) -> Swift.String? {
        return "/"
    }
}

extension GetFolderInput {

    static func urlPathProvider(_ value: GetFolderInput) -> Swift.String? {
        return "/"
    }
}

extension GetMergeCommitInput {

    static func urlPathProvider(_ value: GetMergeCommitInput) -> Swift.String? {
        return "/"
    }
}

extension GetMergeConflictsInput {

    static func urlPathProvider(_ value: GetMergeConflictsInput) -> Swift.String? {
        return "/"
    }
}

extension GetMergeOptionsInput {

    static func urlPathProvider(_ value: GetMergeOptionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetPullRequestInput {

    static func urlPathProvider(_ value: GetPullRequestInput) -> Swift.String? {
        return "/"
    }
}

extension GetPullRequestApprovalStatesInput {

    static func urlPathProvider(_ value: GetPullRequestApprovalStatesInput) -> Swift.String? {
        return "/"
    }
}

extension GetPullRequestOverrideStateInput {

    static func urlPathProvider(_ value: GetPullRequestOverrideStateInput) -> Swift.String? {
        return "/"
    }
}

extension GetRepositoryInput {

    static func urlPathProvider(_ value: GetRepositoryInput) -> Swift.String? {
        return "/"
    }
}

extension GetRepositoryTriggersInput {

    static func urlPathProvider(_ value: GetRepositoryTriggersInput) -> Swift.String? {
        return "/"
    }
}

extension ListApprovalRuleTemplatesInput {

    static func urlPathProvider(_ value: ListApprovalRuleTemplatesInput) -> Swift.String? {
        return "/"
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInput {

    static func urlPathProvider(_ value: ListAssociatedApprovalRuleTemplatesForRepositoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListBranchesInput {

    static func urlPathProvider(_ value: ListBranchesInput) -> Swift.String? {
        return "/"
    }
}

extension ListFileCommitHistoryInput {

    static func urlPathProvider(_ value: ListFileCommitHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListPullRequestsInput {

    static func urlPathProvider(_ value: ListPullRequestsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRepositoriesInput {

    static func urlPathProvider(_ value: ListRepositoriesInput) -> Swift.String? {
        return "/"
    }
}

extension ListRepositoriesForApprovalRuleTemplateInput {

    static func urlPathProvider(_ value: ListRepositoriesForApprovalRuleTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension MergeBranchesByFastForwardInput {

    static func urlPathProvider(_ value: MergeBranchesByFastForwardInput) -> Swift.String? {
        return "/"
    }
}

extension MergeBranchesBySquashInput {

    static func urlPathProvider(_ value: MergeBranchesBySquashInput) -> Swift.String? {
        return "/"
    }
}

extension MergeBranchesByThreeWayInput {

    static func urlPathProvider(_ value: MergeBranchesByThreeWayInput) -> Swift.String? {
        return "/"
    }
}

extension MergePullRequestByFastForwardInput {

    static func urlPathProvider(_ value: MergePullRequestByFastForwardInput) -> Swift.String? {
        return "/"
    }
}

extension MergePullRequestBySquashInput {

    static func urlPathProvider(_ value: MergePullRequestBySquashInput) -> Swift.String? {
        return "/"
    }
}

extension MergePullRequestByThreeWayInput {

    static func urlPathProvider(_ value: MergePullRequestByThreeWayInput) -> Swift.String? {
        return "/"
    }
}

extension OverridePullRequestApprovalRulesInput {

    static func urlPathProvider(_ value: OverridePullRequestApprovalRulesInput) -> Swift.String? {
        return "/"
    }
}

extension PostCommentForComparedCommitInput {

    static func urlPathProvider(_ value: PostCommentForComparedCommitInput) -> Swift.String? {
        return "/"
    }
}

extension PostCommentForPullRequestInput {

    static func urlPathProvider(_ value: PostCommentForPullRequestInput) -> Swift.String? {
        return "/"
    }
}

extension PostCommentReplyInput {

    static func urlPathProvider(_ value: PostCommentReplyInput) -> Swift.String? {
        return "/"
    }
}

extension PutCommentReactionInput {

    static func urlPathProvider(_ value: PutCommentReactionInput) -> Swift.String? {
        return "/"
    }
}

extension PutFileInput {

    static func urlPathProvider(_ value: PutFileInput) -> Swift.String? {
        return "/"
    }
}

extension PutRepositoryTriggersInput {

    static func urlPathProvider(_ value: PutRepositoryTriggersInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TestRepositoryTriggersInput {

    static func urlPathProvider(_ value: TestRepositoryTriggersInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApprovalRuleTemplateContentInput {

    static func urlPathProvider(_ value: UpdateApprovalRuleTemplateContentInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApprovalRuleTemplateDescriptionInput {

    static func urlPathProvider(_ value: UpdateApprovalRuleTemplateDescriptionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApprovalRuleTemplateNameInput {

    static func urlPathProvider(_ value: UpdateApprovalRuleTemplateNameInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCommentInput {

    static func urlPathProvider(_ value: UpdateCommentInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDefaultBranchInput {

    static func urlPathProvider(_ value: UpdateDefaultBranchInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePullRequestApprovalRuleContentInput {

    static func urlPathProvider(_ value: UpdatePullRequestApprovalRuleContentInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePullRequestApprovalStateInput {

    static func urlPathProvider(_ value: UpdatePullRequestApprovalStateInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePullRequestDescriptionInput {

    static func urlPathProvider(_ value: UpdatePullRequestDescriptionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePullRequestStatusInput {

    static func urlPathProvider(_ value: UpdatePullRequestStatusInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePullRequestTitleInput {

    static func urlPathProvider(_ value: UpdatePullRequestTitleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRepositoryDescriptionInput {

    static func urlPathProvider(_ value: UpdateRepositoryDescriptionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRepositoryEncryptionKeyInput {

    static func urlPathProvider(_ value: UpdateRepositoryEncryptionKeyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRepositoryNameInput {

    static func urlPathProvider(_ value: UpdateRepositoryNameInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryInput {

    static func write(value: AssociateApprovalRuleTemplateWithRepositoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleTemplateName"].write(value.approvalRuleTemplateName)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInput {

    static func write(value: BatchAssociateApprovalRuleTemplateWithRepositoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleTemplateName"].write(value.approvalRuleTemplateName)
        try writer["repositoryNames"].writeList(value.repositoryNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDescribeMergeConflictsInput {

    static func write(value: BatchDescribeMergeConflictsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["conflictDetailLevel"].write(value.conflictDetailLevel)
        try writer["conflictResolutionStrategy"].write(value.conflictResolutionStrategy)
        try writer["destinationCommitSpecifier"].write(value.destinationCommitSpecifier)
        try writer["filePaths"].writeList(value.filePaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxConflictFiles"].write(value.maxConflictFiles)
        try writer["maxMergeHunks"].write(value.maxMergeHunks)
        try writer["mergeOption"].write(value.mergeOption)
        try writer["nextToken"].write(value.nextToken)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitSpecifier"].write(value.sourceCommitSpecifier)
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInput {

    static func write(value: BatchDisassociateApprovalRuleTemplateFromRepositoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleTemplateName"].write(value.approvalRuleTemplateName)
        try writer["repositoryNames"].writeList(value.repositoryNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetCommitsInput {

    static func write(value: BatchGetCommitsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commitIds"].writeList(value.commitIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension BatchGetRepositoriesInput {

    static func write(value: BatchGetRepositoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["repositoryNames"].writeList(value.repositoryNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateApprovalRuleTemplateInput {

    static func write(value: CreateApprovalRuleTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleTemplateContent"].write(value.approvalRuleTemplateContent)
        try writer["approvalRuleTemplateDescription"].write(value.approvalRuleTemplateDescription)
        try writer["approvalRuleTemplateName"].write(value.approvalRuleTemplateName)
    }
}

extension CreateBranchInput {

    static func write(value: CreateBranchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branchName"].write(value.branchName)
        try writer["commitId"].write(value.commitId)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension CreateCommitInput {

    static func write(value: CreateCommitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorName"].write(value.authorName)
        try writer["branchName"].write(value.branchName)
        try writer["commitMessage"].write(value.commitMessage)
        try writer["deleteFiles"].writeList(value.deleteFiles, memberWritingClosure: CodeCommitClientTypes.DeleteFileEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["email"].write(value.email)
        try writer["keepEmptyFolders"].write(value.keepEmptyFolders)
        try writer["parentCommitId"].write(value.parentCommitId)
        try writer["putFiles"].writeList(value.putFiles, memberWritingClosure: CodeCommitClientTypes.PutFileEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["setFileModes"].writeList(value.setFileModes, memberWritingClosure: CodeCommitClientTypes.SetFileModeEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePullRequestInput {

    static func write(value: CreatePullRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
        try writer["targets"].writeList(value.targets, memberWritingClosure: CodeCommitClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["title"].write(value.title)
    }
}

extension CreatePullRequestApprovalRuleInput {

    static func write(value: CreatePullRequestApprovalRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleContent"].write(value.approvalRuleContent)
        try writer["approvalRuleName"].write(value.approvalRuleName)
        try writer["pullRequestId"].write(value.pullRequestId)
    }
}

extension CreateRepositoryInput {

    static func write(value: CreateRepositoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["repositoryDescription"].write(value.repositoryDescription)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateUnreferencedMergeCommitInput {

    static func write(value: CreateUnreferencedMergeCommitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorName"].write(value.authorName)
        try writer["commitMessage"].write(value.commitMessage)
        try writer["conflictDetailLevel"].write(value.conflictDetailLevel)
        try writer["conflictResolution"].write(value.conflictResolution, with: CodeCommitClientTypes.ConflictResolution.write(value:to:))
        try writer["conflictResolutionStrategy"].write(value.conflictResolutionStrategy)
        try writer["destinationCommitSpecifier"].write(value.destinationCommitSpecifier)
        try writer["email"].write(value.email)
        try writer["keepEmptyFolders"].write(value.keepEmptyFolders)
        try writer["mergeOption"].write(value.mergeOption)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitSpecifier"].write(value.sourceCommitSpecifier)
    }
}

extension DeleteApprovalRuleTemplateInput {

    static func write(value: DeleteApprovalRuleTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleTemplateName"].write(value.approvalRuleTemplateName)
    }
}

extension DeleteBranchInput {

    static func write(value: DeleteBranchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branchName"].write(value.branchName)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension DeleteCommentContentInput {

    static func write(value: DeleteCommentContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commentId"].write(value.commentId)
    }
}

extension DeleteFileInput {

    static func write(value: DeleteFileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branchName"].write(value.branchName)
        try writer["commitMessage"].write(value.commitMessage)
        try writer["email"].write(value.email)
        try writer["filePath"].write(value.filePath)
        try writer["keepEmptyFolders"].write(value.keepEmptyFolders)
        try writer["name"].write(value.name)
        try writer["parentCommitId"].write(value.parentCommitId)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension DeletePullRequestApprovalRuleInput {

    static func write(value: DeletePullRequestApprovalRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleName"].write(value.approvalRuleName)
        try writer["pullRequestId"].write(value.pullRequestId)
    }
}

extension DeleteRepositoryInput {

    static func write(value: DeleteRepositoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension DescribeMergeConflictsInput {

    static func write(value: DescribeMergeConflictsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["conflictDetailLevel"].write(value.conflictDetailLevel)
        try writer["conflictResolutionStrategy"].write(value.conflictResolutionStrategy)
        try writer["destinationCommitSpecifier"].write(value.destinationCommitSpecifier)
        try writer["filePath"].write(value.filePath)
        try writer["maxMergeHunks"].write(value.maxMergeHunks)
        try writer["mergeOption"].write(value.mergeOption)
        try writer["nextToken"].write(value.nextToken)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitSpecifier"].write(value.sourceCommitSpecifier)
    }
}

extension DescribePullRequestEventsInput {

    static func write(value: DescribePullRequestEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actorArn"].write(value.actorArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["pullRequestEventType"].write(value.pullRequestEventType)
        try writer["pullRequestId"].write(value.pullRequestId)
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryInput {

    static func write(value: DisassociateApprovalRuleTemplateFromRepositoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleTemplateName"].write(value.approvalRuleTemplateName)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension EvaluatePullRequestApprovalRulesInput {

    static func write(value: EvaluatePullRequestApprovalRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["revisionId"].write(value.revisionId)
    }
}

extension GetApprovalRuleTemplateInput {

    static func write(value: GetApprovalRuleTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleTemplateName"].write(value.approvalRuleTemplateName)
    }
}

extension GetBlobInput {

    static func write(value: GetBlobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blobId"].write(value.blobId)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension GetBranchInput {

    static func write(value: GetBranchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branchName"].write(value.branchName)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension GetCommentInput {

    static func write(value: GetCommentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commentId"].write(value.commentId)
    }
}

extension GetCommentReactionsInput {

    static func write(value: GetCommentReactionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commentId"].write(value.commentId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["reactionUserArn"].write(value.reactionUserArn)
    }
}

extension GetCommentsForComparedCommitInput {

    static func write(value: GetCommentsForComparedCommitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["afterCommitId"].write(value.afterCommitId)
        try writer["beforeCommitId"].write(value.beforeCommitId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension GetCommentsForPullRequestInput {

    static func write(value: GetCommentsForPullRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["afterCommitId"].write(value.afterCommitId)
        try writer["beforeCommitId"].write(value.beforeCommitId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension GetCommitInput {

    static func write(value: GetCommitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commitId"].write(value.commitId)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension GetDifferencesInput {

    static func write(value: GetDifferencesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["afterCommitSpecifier"].write(value.afterCommitSpecifier)
        try writer["afterPath"].write(value.afterPath)
        try writer["beforeCommitSpecifier"].write(value.beforeCommitSpecifier)
        try writer["beforePath"].write(value.beforePath)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension GetFileInput {

    static func write(value: GetFileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commitSpecifier"].write(value.commitSpecifier)
        try writer["filePath"].write(value.filePath)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension GetFolderInput {

    static func write(value: GetFolderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commitSpecifier"].write(value.commitSpecifier)
        try writer["folderPath"].write(value.folderPath)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension GetMergeCommitInput {

    static func write(value: GetMergeCommitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["conflictDetailLevel"].write(value.conflictDetailLevel)
        try writer["conflictResolutionStrategy"].write(value.conflictResolutionStrategy)
        try writer["destinationCommitSpecifier"].write(value.destinationCommitSpecifier)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitSpecifier"].write(value.sourceCommitSpecifier)
    }
}

extension GetMergeConflictsInput {

    static func write(value: GetMergeConflictsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["conflictDetailLevel"].write(value.conflictDetailLevel)
        try writer["conflictResolutionStrategy"].write(value.conflictResolutionStrategy)
        try writer["destinationCommitSpecifier"].write(value.destinationCommitSpecifier)
        try writer["maxConflictFiles"].write(value.maxConflictFiles)
        try writer["mergeOption"].write(value.mergeOption)
        try writer["nextToken"].write(value.nextToken)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitSpecifier"].write(value.sourceCommitSpecifier)
    }
}

extension GetMergeOptionsInput {

    static func write(value: GetMergeOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["conflictDetailLevel"].write(value.conflictDetailLevel)
        try writer["conflictResolutionStrategy"].write(value.conflictResolutionStrategy)
        try writer["destinationCommitSpecifier"].write(value.destinationCommitSpecifier)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitSpecifier"].write(value.sourceCommitSpecifier)
    }
}

extension GetPullRequestInput {

    static func write(value: GetPullRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pullRequestId"].write(value.pullRequestId)
    }
}

extension GetPullRequestApprovalStatesInput {

    static func write(value: GetPullRequestApprovalStatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["revisionId"].write(value.revisionId)
    }
}

extension GetPullRequestOverrideStateInput {

    static func write(value: GetPullRequestOverrideStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["revisionId"].write(value.revisionId)
    }
}

extension GetRepositoryInput {

    static func write(value: GetRepositoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension GetRepositoryTriggersInput {

    static func write(value: GetRepositoryTriggersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension ListApprovalRuleTemplatesInput {

    static func write(value: ListApprovalRuleTemplatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInput {

    static func write(value: ListAssociatedApprovalRuleTemplatesForRepositoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension ListBranchesInput {

    static func write(value: ListBranchesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nextToken"].write(value.nextToken)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension ListFileCommitHistoryInput {

    static func write(value: ListFileCommitHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commitSpecifier"].write(value.commitSpecifier)
        try writer["filePath"].write(value.filePath)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension ListPullRequestsInput {

    static func write(value: ListPullRequestsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorArn"].write(value.authorArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["pullRequestStatus"].write(value.pullRequestStatus)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension ListRepositoriesInput {

    static func write(value: ListRepositoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nextToken"].write(value.nextToken)
        try writer["order"].write(value.order)
        try writer["sortBy"].write(value.sortBy)
    }
}

extension ListRepositoriesForApprovalRuleTemplateInput {

    static func write(value: ListRepositoriesForApprovalRuleTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleTemplateName"].write(value.approvalRuleTemplateName)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension MergeBranchesByFastForwardInput {

    static func write(value: MergeBranchesByFastForwardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationCommitSpecifier"].write(value.destinationCommitSpecifier)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitSpecifier"].write(value.sourceCommitSpecifier)
        try writer["targetBranch"].write(value.targetBranch)
    }
}

extension MergeBranchesBySquashInput {

    static func write(value: MergeBranchesBySquashInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorName"].write(value.authorName)
        try writer["commitMessage"].write(value.commitMessage)
        try writer["conflictDetailLevel"].write(value.conflictDetailLevel)
        try writer["conflictResolution"].write(value.conflictResolution, with: CodeCommitClientTypes.ConflictResolution.write(value:to:))
        try writer["conflictResolutionStrategy"].write(value.conflictResolutionStrategy)
        try writer["destinationCommitSpecifier"].write(value.destinationCommitSpecifier)
        try writer["email"].write(value.email)
        try writer["keepEmptyFolders"].write(value.keepEmptyFolders)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitSpecifier"].write(value.sourceCommitSpecifier)
        try writer["targetBranch"].write(value.targetBranch)
    }
}

extension MergeBranchesByThreeWayInput {

    static func write(value: MergeBranchesByThreeWayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorName"].write(value.authorName)
        try writer["commitMessage"].write(value.commitMessage)
        try writer["conflictDetailLevel"].write(value.conflictDetailLevel)
        try writer["conflictResolution"].write(value.conflictResolution, with: CodeCommitClientTypes.ConflictResolution.write(value:to:))
        try writer["conflictResolutionStrategy"].write(value.conflictResolutionStrategy)
        try writer["destinationCommitSpecifier"].write(value.destinationCommitSpecifier)
        try writer["email"].write(value.email)
        try writer["keepEmptyFolders"].write(value.keepEmptyFolders)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitSpecifier"].write(value.sourceCommitSpecifier)
        try writer["targetBranch"].write(value.targetBranch)
    }
}

extension MergePullRequestByFastForwardInput {

    static func write(value: MergePullRequestByFastForwardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitId"].write(value.sourceCommitId)
    }
}

extension MergePullRequestBySquashInput {

    static func write(value: MergePullRequestBySquashInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorName"].write(value.authorName)
        try writer["commitMessage"].write(value.commitMessage)
        try writer["conflictDetailLevel"].write(value.conflictDetailLevel)
        try writer["conflictResolution"].write(value.conflictResolution, with: CodeCommitClientTypes.ConflictResolution.write(value:to:))
        try writer["conflictResolutionStrategy"].write(value.conflictResolutionStrategy)
        try writer["email"].write(value.email)
        try writer["keepEmptyFolders"].write(value.keepEmptyFolders)
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitId"].write(value.sourceCommitId)
    }
}

extension MergePullRequestByThreeWayInput {

    static func write(value: MergePullRequestByThreeWayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorName"].write(value.authorName)
        try writer["commitMessage"].write(value.commitMessage)
        try writer["conflictDetailLevel"].write(value.conflictDetailLevel)
        try writer["conflictResolution"].write(value.conflictResolution, with: CodeCommitClientTypes.ConflictResolution.write(value:to:))
        try writer["conflictResolutionStrategy"].write(value.conflictResolutionStrategy)
        try writer["email"].write(value.email)
        try writer["keepEmptyFolders"].write(value.keepEmptyFolders)
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceCommitId"].write(value.sourceCommitId)
    }
}

extension OverridePullRequestApprovalRulesInput {

    static func write(value: OverridePullRequestApprovalRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["overrideStatus"].write(value.overrideStatus)
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["revisionId"].write(value.revisionId)
    }
}

extension PostCommentForComparedCommitInput {

    static func write(value: PostCommentForComparedCommitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["afterCommitId"].write(value.afterCommitId)
        try writer["beforeCommitId"].write(value.beforeCommitId)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["content"].write(value.content)
        try writer["location"].write(value.location, with: CodeCommitClientTypes.Location.write(value:to:))
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension PostCommentForPullRequestInput {

    static func write(value: PostCommentForPullRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["afterCommitId"].write(value.afterCommitId)
        try writer["beforeCommitId"].write(value.beforeCommitId)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["content"].write(value.content)
        try writer["location"].write(value.location, with: CodeCommitClientTypes.Location.write(value:to:))
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension PostCommentReplyInput {

    static func write(value: PostCommentReplyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["content"].write(value.content)
        try writer["inReplyTo"].write(value.inReplyTo)
    }
}

extension PutCommentReactionInput {

    static func write(value: PutCommentReactionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commentId"].write(value.commentId)
        try writer["reactionValue"].write(value.reactionValue)
    }
}

extension PutFileInput {

    static func write(value: PutFileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branchName"].write(value.branchName)
        try writer["commitMessage"].write(value.commitMessage)
        try writer["email"].write(value.email)
        try writer["fileContent"].write(value.fileContent)
        try writer["fileMode"].write(value.fileMode)
        try writer["filePath"].write(value.filePath)
        try writer["name"].write(value.name)
        try writer["parentCommitId"].write(value.parentCommitId)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension PutRepositoryTriggersInput {

    static func write(value: PutRepositoryTriggersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["repositoryName"].write(value.repositoryName)
        try writer["triggers"].writeList(value.triggers, memberWritingClosure: CodeCommitClientTypes.RepositoryTrigger.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TestRepositoryTriggersInput {

    static func write(value: TestRepositoryTriggersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["repositoryName"].write(value.repositoryName)
        try writer["triggers"].writeList(value.triggers, memberWritingClosure: CodeCommitClientTypes.RepositoryTrigger.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateApprovalRuleTemplateContentInput {

    static func write(value: UpdateApprovalRuleTemplateContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleTemplateName"].write(value.approvalRuleTemplateName)
        try writer["existingRuleContentSha256"].write(value.existingRuleContentSha256)
        try writer["newRuleContent"].write(value.newRuleContent)
    }
}

extension UpdateApprovalRuleTemplateDescriptionInput {

    static func write(value: UpdateApprovalRuleTemplateDescriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleTemplateDescription"].write(value.approvalRuleTemplateDescription)
        try writer["approvalRuleTemplateName"].write(value.approvalRuleTemplateName)
    }
}

extension UpdateApprovalRuleTemplateNameInput {

    static func write(value: UpdateApprovalRuleTemplateNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["newApprovalRuleTemplateName"].write(value.newApprovalRuleTemplateName)
        try writer["oldApprovalRuleTemplateName"].write(value.oldApprovalRuleTemplateName)
    }
}

extension UpdateCommentInput {

    static func write(value: UpdateCommentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commentId"].write(value.commentId)
        try writer["content"].write(value.content)
    }
}

extension UpdateDefaultBranchInput {

    static func write(value: UpdateDefaultBranchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultBranchName"].write(value.defaultBranchName)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension UpdatePullRequestApprovalRuleContentInput {

    static func write(value: UpdatePullRequestApprovalRuleContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalRuleName"].write(value.approvalRuleName)
        try writer["existingRuleContentSha256"].write(value.existingRuleContentSha256)
        try writer["newRuleContent"].write(value.newRuleContent)
        try writer["pullRequestId"].write(value.pullRequestId)
    }
}

extension UpdatePullRequestApprovalStateInput {

    static func write(value: UpdatePullRequestApprovalStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["approvalState"].write(value.approvalState)
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["revisionId"].write(value.revisionId)
    }
}

extension UpdatePullRequestDescriptionInput {

    static func write(value: UpdatePullRequestDescriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["pullRequestId"].write(value.pullRequestId)
    }
}

extension UpdatePullRequestStatusInput {

    static func write(value: UpdatePullRequestStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["pullRequestStatus"].write(value.pullRequestStatus)
    }
}

extension UpdatePullRequestTitleInput {

    static func write(value: UpdatePullRequestTitleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pullRequestId"].write(value.pullRequestId)
        try writer["title"].write(value.title)
    }
}

extension UpdateRepositoryDescriptionInput {

    static func write(value: UpdateRepositoryDescriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["repositoryDescription"].write(value.repositoryDescription)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension UpdateRepositoryEncryptionKeyInput {

    static func write(value: UpdateRepositoryEncryptionKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["repositoryName"].write(value.repositoryName)
    }
}

extension UpdateRepositoryNameInput {

    static func write(value: UpdateRepositoryNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["newName"].write(value.newName)
        try writer["oldName"].write(value.oldName)
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateApprovalRuleTemplateWithRepositoryOutput {
        return AssociateApprovalRuleTemplateWithRepositoryOutput()
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchAssociateApprovalRuleTemplateWithRepositoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAssociateApprovalRuleTemplateWithRepositoriesOutput()
        value.associatedRepositoryNames = try reader["associatedRepositoryNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchDescribeMergeConflictsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDescribeMergeConflictsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDescribeMergeConflictsOutput()
        value.baseCommitId = try reader["baseCommitId"].readIfPresent()
        value.conflicts = try reader["conflicts"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.Conflict.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.destinationCommitId = try reader["destinationCommitId"].readIfPresent() ?? ""
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.BatchDescribeMergeConflictsError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sourceCommitId = try reader["sourceCommitId"].readIfPresent() ?? ""
        return value
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput()
        value.disassociatedRepositoryNames = try reader["disassociatedRepositoryNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchGetCommitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetCommitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetCommitsOutput()
        value.commits = try reader["commits"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.Commit.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.BatchGetCommitsError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetRepositoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetRepositoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetRepositoriesOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.BatchGetRepositoriesError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.repositories = try reader["repositories"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.RepositoryMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.repositoriesNotFound = try reader["repositoriesNotFound"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateApprovalRuleTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApprovalRuleTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApprovalRuleTemplateOutput()
        value.approvalRuleTemplate = try reader["approvalRuleTemplate"].readIfPresent(with: CodeCommitClientTypes.ApprovalRuleTemplate.read(from:))
        return value
    }
}

extension CreateBranchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBranchOutput {
        return CreateBranchOutput()
    }
}

extension CreateCommitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCommitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCommitOutput()
        value.commitId = try reader["commitId"].readIfPresent()
        value.filesAdded = try reader["filesAdded"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.FileMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filesDeleted = try reader["filesDeleted"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.FileMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filesUpdated = try reader["filesUpdated"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.FileMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.treeId = try reader["treeId"].readIfPresent()
        return value
    }
}

extension CreatePullRequestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePullRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePullRequestOutput()
        value.pullRequest = try reader["pullRequest"].readIfPresent(with: CodeCommitClientTypes.PullRequest.read(from:))
        return value
    }
}

extension CreatePullRequestApprovalRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePullRequestApprovalRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePullRequestApprovalRuleOutput()
        value.approvalRule = try reader["approvalRule"].readIfPresent(with: CodeCommitClientTypes.ApprovalRule.read(from:))
        return value
    }
}

extension CreateRepositoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRepositoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRepositoryOutput()
        value.repositoryMetadata = try reader["repositoryMetadata"].readIfPresent(with: CodeCommitClientTypes.RepositoryMetadata.read(from:))
        return value
    }
}

extension CreateUnreferencedMergeCommitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUnreferencedMergeCommitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUnreferencedMergeCommitOutput()
        value.commitId = try reader["commitId"].readIfPresent()
        value.treeId = try reader["treeId"].readIfPresent()
        return value
    }
}

extension DeleteApprovalRuleTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApprovalRuleTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteApprovalRuleTemplateOutput()
        value.approvalRuleTemplateId = try reader["approvalRuleTemplateId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteBranchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBranchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBranchOutput()
        value.deletedBranch = try reader["deletedBranch"].readIfPresent(with: CodeCommitClientTypes.BranchInfo.read(from:))
        return value
    }
}

extension DeleteCommentContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCommentContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCommentContentOutput()
        value.comment = try reader["comment"].readIfPresent(with: CodeCommitClientTypes.Comment.read(from:))
        return value
    }
}

extension DeleteFileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFileOutput()
        value.blobId = try reader["blobId"].readIfPresent() ?? ""
        value.commitId = try reader["commitId"].readIfPresent() ?? ""
        value.filePath = try reader["filePath"].readIfPresent() ?? ""
        value.treeId = try reader["treeId"].readIfPresent() ?? ""
        return value
    }
}

extension DeletePullRequestApprovalRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePullRequestApprovalRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePullRequestApprovalRuleOutput()
        value.approvalRuleId = try reader["approvalRuleId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteRepositoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRepositoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRepositoryOutput()
        value.repositoryId = try reader["repositoryId"].readIfPresent()
        return value
    }
}

extension DescribeMergeConflictsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMergeConflictsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMergeConflictsOutput()
        value.baseCommitId = try reader["baseCommitId"].readIfPresent()
        value.conflictMetadata = try reader["conflictMetadata"].readIfPresent(with: CodeCommitClientTypes.ConflictMetadata.read(from:))
        value.destinationCommitId = try reader["destinationCommitId"].readIfPresent() ?? ""
        value.mergeHunks = try reader["mergeHunks"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.MergeHunk.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sourceCommitId = try reader["sourceCommitId"].readIfPresent() ?? ""
        return value
    }
}

extension DescribePullRequestEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePullRequestEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePullRequestEventsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.pullRequestEvents = try reader["pullRequestEvents"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.PullRequestEvent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateApprovalRuleTemplateFromRepositoryOutput {
        return DisassociateApprovalRuleTemplateFromRepositoryOutput()
    }
}

extension EvaluatePullRequestApprovalRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EvaluatePullRequestApprovalRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EvaluatePullRequestApprovalRulesOutput()
        value.evaluation = try reader["evaluation"].readIfPresent(with: CodeCommitClientTypes.Evaluation.read(from:))
        return value
    }
}

extension GetApprovalRuleTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApprovalRuleTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApprovalRuleTemplateOutput()
        value.approvalRuleTemplate = try reader["approvalRuleTemplate"].readIfPresent(with: CodeCommitClientTypes.ApprovalRuleTemplate.read(from:))
        return value
    }
}

extension GetBlobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBlobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBlobOutput()
        value.content = try reader["content"].readIfPresent() ?? Foundation.Data("".utf8)
        return value
    }
}

extension GetBranchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBranchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBranchOutput()
        value.branch = try reader["branch"].readIfPresent(with: CodeCommitClientTypes.BranchInfo.read(from:))
        return value
    }
}

extension GetCommentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCommentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCommentOutput()
        value.comment = try reader["comment"].readIfPresent(with: CodeCommitClientTypes.Comment.read(from:))
        return value
    }
}

extension GetCommentReactionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCommentReactionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCommentReactionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.reactionsForComment = try reader["reactionsForComment"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.ReactionForComment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetCommentsForComparedCommitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCommentsForComparedCommitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCommentsForComparedCommitOutput()
        value.commentsForComparedCommitData = try reader["commentsForComparedCommitData"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.CommentsForComparedCommit.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetCommentsForPullRequestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCommentsForPullRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCommentsForPullRequestOutput()
        value.commentsForPullRequestData = try reader["commentsForPullRequestData"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.CommentsForPullRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetCommitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCommitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCommitOutput()
        value.commit = try reader["commit"].readIfPresent(with: CodeCommitClientTypes.Commit.read(from:))
        return value
    }
}

extension GetDifferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDifferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDifferencesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.differences = try reader["differences"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.Difference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetFileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFileOutput()
        value.blobId = try reader["blobId"].readIfPresent() ?? ""
        value.commitId = try reader["commitId"].readIfPresent() ?? ""
        value.fileContent = try reader["fileContent"].readIfPresent() ?? Foundation.Data("".utf8)
        value.fileMode = try reader["fileMode"].readIfPresent() ?? .sdkUnknown("")
        value.filePath = try reader["filePath"].readIfPresent() ?? ""
        value.fileSize = try reader["fileSize"].readIfPresent() ?? 0
        return value
    }
}

extension GetFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFolderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFolderOutput()
        value.commitId = try reader["commitId"].readIfPresent() ?? ""
        value.files = try reader["files"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.File.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.folderPath = try reader["folderPath"].readIfPresent() ?? ""
        value.subFolders = try reader["subFolders"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.Folder.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subModules = try reader["subModules"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.SubModule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.symbolicLinks = try reader["symbolicLinks"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.SymbolicLink.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.treeId = try reader["treeId"].readIfPresent()
        return value
    }
}

extension GetMergeCommitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMergeCommitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMergeCommitOutput()
        value.baseCommitId = try reader["baseCommitId"].readIfPresent()
        value.destinationCommitId = try reader["destinationCommitId"].readIfPresent()
        value.mergedCommitId = try reader["mergedCommitId"].readIfPresent()
        value.sourceCommitId = try reader["sourceCommitId"].readIfPresent()
        return value
    }
}

extension GetMergeConflictsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMergeConflictsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMergeConflictsOutput()
        value.baseCommitId = try reader["baseCommitId"].readIfPresent()
        value.conflictMetadataList = try reader["conflictMetadataList"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.ConflictMetadata.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.destinationCommitId = try reader["destinationCommitId"].readIfPresent() ?? ""
        value.mergeable = try reader["mergeable"].readIfPresent() ?? false
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sourceCommitId = try reader["sourceCommitId"].readIfPresent() ?? ""
        return value
    }
}

extension GetMergeOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMergeOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMergeOptionsOutput()
        value.baseCommitId = try reader["baseCommitId"].readIfPresent() ?? ""
        value.destinationCommitId = try reader["destinationCommitId"].readIfPresent() ?? ""
        value.mergeOptions = try reader["mergeOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CodeCommitClientTypes.MergeOptionTypeEnum>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sourceCommitId = try reader["sourceCommitId"].readIfPresent() ?? ""
        return value
    }
}

extension GetPullRequestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPullRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPullRequestOutput()
        value.pullRequest = try reader["pullRequest"].readIfPresent(with: CodeCommitClientTypes.PullRequest.read(from:))
        return value
    }
}

extension GetPullRequestApprovalStatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPullRequestApprovalStatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPullRequestApprovalStatesOutput()
        value.approvals = try reader["approvals"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.Approval.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPullRequestOverrideStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPullRequestOverrideStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPullRequestOverrideStateOutput()
        value.overridden = try reader["overridden"].readIfPresent() ?? false
        value.overrider = try reader["overrider"].readIfPresent()
        return value
    }
}

extension GetRepositoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRepositoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRepositoryOutput()
        value.repositoryMetadata = try reader["repositoryMetadata"].readIfPresent(with: CodeCommitClientTypes.RepositoryMetadata.read(from:))
        return value
    }
}

extension GetRepositoryTriggersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRepositoryTriggersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRepositoryTriggersOutput()
        value.configurationId = try reader["configurationId"].readIfPresent()
        value.triggers = try reader["triggers"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.RepositoryTrigger.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListApprovalRuleTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApprovalRuleTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApprovalRuleTemplatesOutput()
        value.approvalRuleTemplateNames = try reader["approvalRuleTemplateNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssociatedApprovalRuleTemplatesForRepositoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssociatedApprovalRuleTemplatesForRepositoryOutput()
        value.approvalRuleTemplateNames = try reader["approvalRuleTemplateNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBranchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBranchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBranchesOutput()
        value.branches = try reader["branches"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFileCommitHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFileCommitHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFileCommitHistoryOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.revisionDag = try reader["revisionDag"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.FileVersion.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPullRequestsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPullRequestsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPullRequestsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.pullRequestIds = try reader["pullRequestIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListRepositoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRepositoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRepositoriesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.repositories = try reader["repositories"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.RepositoryNameIdPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRepositoriesForApprovalRuleTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRepositoriesForApprovalRuleTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRepositoriesForApprovalRuleTemplateOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.repositoryNames = try reader["repositoryNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension MergeBranchesByFastForwardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MergeBranchesByFastForwardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MergeBranchesByFastForwardOutput()
        value.commitId = try reader["commitId"].readIfPresent()
        value.treeId = try reader["treeId"].readIfPresent()
        return value
    }
}

extension MergeBranchesBySquashOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MergeBranchesBySquashOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MergeBranchesBySquashOutput()
        value.commitId = try reader["commitId"].readIfPresent()
        value.treeId = try reader["treeId"].readIfPresent()
        return value
    }
}

extension MergeBranchesByThreeWayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MergeBranchesByThreeWayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MergeBranchesByThreeWayOutput()
        value.commitId = try reader["commitId"].readIfPresent()
        value.treeId = try reader["treeId"].readIfPresent()
        return value
    }
}

extension MergePullRequestByFastForwardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MergePullRequestByFastForwardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MergePullRequestByFastForwardOutput()
        value.pullRequest = try reader["pullRequest"].readIfPresent(with: CodeCommitClientTypes.PullRequest.read(from:))
        return value
    }
}

extension MergePullRequestBySquashOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MergePullRequestBySquashOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MergePullRequestBySquashOutput()
        value.pullRequest = try reader["pullRequest"].readIfPresent(with: CodeCommitClientTypes.PullRequest.read(from:))
        return value
    }
}

extension MergePullRequestByThreeWayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MergePullRequestByThreeWayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MergePullRequestByThreeWayOutput()
        value.pullRequest = try reader["pullRequest"].readIfPresent(with: CodeCommitClientTypes.PullRequest.read(from:))
        return value
    }
}

extension OverridePullRequestApprovalRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> OverridePullRequestApprovalRulesOutput {
        return OverridePullRequestApprovalRulesOutput()
    }
}

extension PostCommentForComparedCommitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PostCommentForComparedCommitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PostCommentForComparedCommitOutput()
        value.afterBlobId = try reader["afterBlobId"].readIfPresent()
        value.afterCommitId = try reader["afterCommitId"].readIfPresent()
        value.beforeBlobId = try reader["beforeBlobId"].readIfPresent()
        value.beforeCommitId = try reader["beforeCommitId"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent(with: CodeCommitClientTypes.Comment.read(from:))
        value.location = try reader["location"].readIfPresent(with: CodeCommitClientTypes.Location.read(from:))
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        return value
    }
}

extension PostCommentForPullRequestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PostCommentForPullRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PostCommentForPullRequestOutput()
        value.afterBlobId = try reader["afterBlobId"].readIfPresent()
        value.afterCommitId = try reader["afterCommitId"].readIfPresent()
        value.beforeBlobId = try reader["beforeBlobId"].readIfPresent()
        value.beforeCommitId = try reader["beforeCommitId"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent(with: CodeCommitClientTypes.Comment.read(from:))
        value.location = try reader["location"].readIfPresent(with: CodeCommitClientTypes.Location.read(from:))
        value.pullRequestId = try reader["pullRequestId"].readIfPresent()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        return value
    }
}

extension PostCommentReplyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PostCommentReplyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PostCommentReplyOutput()
        value.comment = try reader["comment"].readIfPresent(with: CodeCommitClientTypes.Comment.read(from:))
        return value
    }
}

extension PutCommentReactionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutCommentReactionOutput {
        return PutCommentReactionOutput()
    }
}

extension PutFileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFileOutput()
        value.blobId = try reader["blobId"].readIfPresent() ?? ""
        value.commitId = try reader["commitId"].readIfPresent() ?? ""
        value.treeId = try reader["treeId"].readIfPresent() ?? ""
        return value
    }
}

extension PutRepositoryTriggersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRepositoryTriggersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRepositoryTriggersOutput()
        value.configurationId = try reader["configurationId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestRepositoryTriggersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestRepositoryTriggersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestRepositoryTriggersOutput()
        value.failedExecutions = try reader["failedExecutions"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.RepositoryTriggerExecutionFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successfulExecutions = try reader["successfulExecutions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApprovalRuleTemplateContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApprovalRuleTemplateContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApprovalRuleTemplateContentOutput()
        value.approvalRuleTemplate = try reader["approvalRuleTemplate"].readIfPresent(with: CodeCommitClientTypes.ApprovalRuleTemplate.read(from:))
        return value
    }
}

extension UpdateApprovalRuleTemplateDescriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApprovalRuleTemplateDescriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApprovalRuleTemplateDescriptionOutput()
        value.approvalRuleTemplate = try reader["approvalRuleTemplate"].readIfPresent(with: CodeCommitClientTypes.ApprovalRuleTemplate.read(from:))
        return value
    }
}

extension UpdateApprovalRuleTemplateNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApprovalRuleTemplateNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApprovalRuleTemplateNameOutput()
        value.approvalRuleTemplate = try reader["approvalRuleTemplate"].readIfPresent(with: CodeCommitClientTypes.ApprovalRuleTemplate.read(from:))
        return value
    }
}

extension UpdateCommentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCommentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCommentOutput()
        value.comment = try reader["comment"].readIfPresent(with: CodeCommitClientTypes.Comment.read(from:))
        return value
    }
}

extension UpdateDefaultBranchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDefaultBranchOutput {
        return UpdateDefaultBranchOutput()
    }
}

extension UpdatePullRequestApprovalRuleContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePullRequestApprovalRuleContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePullRequestApprovalRuleContentOutput()
        value.approvalRule = try reader["approvalRule"].readIfPresent(with: CodeCommitClientTypes.ApprovalRule.read(from:))
        return value
    }
}

extension UpdatePullRequestApprovalStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePullRequestApprovalStateOutput {
        return UpdatePullRequestApprovalStateOutput()
    }
}

extension UpdatePullRequestDescriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePullRequestDescriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePullRequestDescriptionOutput()
        value.pullRequest = try reader["pullRequest"].readIfPresent(with: CodeCommitClientTypes.PullRequest.read(from:))
        return value
    }
}

extension UpdatePullRequestStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePullRequestStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePullRequestStatusOutput()
        value.pullRequest = try reader["pullRequest"].readIfPresent(with: CodeCommitClientTypes.PullRequest.read(from:))
        return value
    }
}

extension UpdatePullRequestTitleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePullRequestTitleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePullRequestTitleOutput()
        value.pullRequest = try reader["pullRequest"].readIfPresent(with: CodeCommitClientTypes.PullRequest.read(from:))
        return value
    }
}

extension UpdateRepositoryDescriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRepositoryDescriptionOutput {
        return UpdateRepositoryDescriptionOutput()
    }
}

extension UpdateRepositoryEncryptionKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRepositoryEncryptionKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRepositoryEncryptionKeyOutput()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.originalKmsKeyId = try reader["originalKmsKeyId"].readIfPresent()
        value.repositoryId = try reader["repositoryId"].readIfPresent()
        return value
    }
}

extension UpdateRepositoryNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRepositoryNameOutput {
        return UpdateRepositoryNameOutput()
    }
}

enum AssociateApprovalRuleTemplateWithRepositoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateDoesNotExistException": return try ApprovalRuleTemplateDoesNotExistException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "MaximumRuleTemplatesAssociatedWithRepositoryException": return try MaximumRuleTemplatesAssociatedWithRepositoryException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateDoesNotExistException": return try ApprovalRuleTemplateDoesNotExistException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            case "MaximumRepositoryNamesExceededException": return try MaximumRepositoryNamesExceededException.makeError(baseError: baseError)
            case "RepositoryNamesRequiredException": return try RepositoryNamesRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDescribeMergeConflictsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidConflictDetailLevelException": return try InvalidConflictDetailLevelException.makeError(baseError: baseError)
            case "InvalidConflictResolutionStrategyException": return try InvalidConflictResolutionStrategyException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxConflictFilesException": return try InvalidMaxConflictFilesException.makeError(baseError: baseError)
            case "InvalidMaxMergeHunksException": return try InvalidMaxMergeHunksException.makeError(baseError: baseError)
            case "InvalidMergeOptionException": return try InvalidMergeOptionException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "MaximumFileContentToLoadExceededException": return try MaximumFileContentToLoadExceededException.makeError(baseError: baseError)
            case "MaximumItemsToCompareExceededException": return try MaximumItemsToCompareExceededException.makeError(baseError: baseError)
            case "MergeOptionRequiredException": return try MergeOptionRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateDoesNotExistException": return try ApprovalRuleTemplateDoesNotExistException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            case "MaximumRepositoryNamesExceededException": return try MaximumRepositoryNamesExceededException.makeError(baseError: baseError)
            case "RepositoryNamesRequiredException": return try RepositoryNamesRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetCommitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitIdsLimitExceededException": return try CommitIdsLimitExceededException.makeError(baseError: baseError)
            case "CommitIdsListRequiredException": return try CommitIdsListRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetRepositoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "MaximumRepositoryNamesExceededException": return try MaximumRepositoryNamesExceededException.makeError(baseError: baseError)
            case "RepositoryNamesRequiredException": return try RepositoryNamesRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApprovalRuleTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateContentRequiredException": return try ApprovalRuleTemplateContentRequiredException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameAlreadyExistsException": return try ApprovalRuleTemplateNameAlreadyExistsException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateContentException": return try InvalidApprovalRuleTemplateContentException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateDescriptionException": return try InvalidApprovalRuleTemplateDescriptionException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            case "NumberOfRuleTemplatesExceededException": return try NumberOfRuleTemplatesExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBranchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BranchNameExistsException": return try BranchNameExistsException.makeError(baseError: baseError)
            case "BranchNameRequiredException": return try BranchNameRequiredException.makeError(baseError: baseError)
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitIdRequiredException": return try CommitIdRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidBranchNameException": return try InvalidBranchNameException.makeError(baseError: baseError)
            case "InvalidCommitIdException": return try InvalidCommitIdException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCommitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BranchDoesNotExistException": return try BranchDoesNotExistException.makeError(baseError: baseError)
            case "BranchNameIsTagNameException": return try BranchNameIsTagNameException.makeError(baseError: baseError)
            case "BranchNameRequiredException": return try BranchNameRequiredException.makeError(baseError: baseError)
            case "CommitMessageLengthExceededException": return try CommitMessageLengthExceededException.makeError(baseError: baseError)
            case "DirectoryNameConflictsWithFileNameException": return try DirectoryNameConflictsWithFileNameException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileContentAndSourceFileSpecifiedException": return try FileContentAndSourceFileSpecifiedException.makeError(baseError: baseError)
            case "FileContentSizeLimitExceededException": return try FileContentSizeLimitExceededException.makeError(baseError: baseError)
            case "FileDoesNotExistException": return try FileDoesNotExistException.makeError(baseError: baseError)
            case "FileEntryRequiredException": return try FileEntryRequiredException.makeError(baseError: baseError)
            case "FileModeRequiredException": return try FileModeRequiredException.makeError(baseError: baseError)
            case "FileNameConflictsWithDirectoryNameException": return try FileNameConflictsWithDirectoryNameException.makeError(baseError: baseError)
            case "FilePathConflictsWithSubmodulePathException": return try FilePathConflictsWithSubmodulePathException.makeError(baseError: baseError)
            case "FolderContentSizeLimitExceededException": return try FolderContentSizeLimitExceededException.makeError(baseError: baseError)
            case "InvalidBranchNameException": return try InvalidBranchNameException.makeError(baseError: baseError)
            case "InvalidDeletionParameterException": return try InvalidDeletionParameterException.makeError(baseError: baseError)
            case "InvalidEmailException": return try InvalidEmailException.makeError(baseError: baseError)
            case "InvalidFileModeException": return try InvalidFileModeException.makeError(baseError: baseError)
            case "InvalidParentCommitIdException": return try InvalidParentCommitIdException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "MaximumFileEntriesExceededException": return try MaximumFileEntriesExceededException.makeError(baseError: baseError)
            case "NameLengthExceededException": return try NameLengthExceededException.makeError(baseError: baseError)
            case "NoChangeException": return try NoChangeException.makeError(baseError: baseError)
            case "ParentCommitDoesNotExistException": return try ParentCommitDoesNotExistException.makeError(baseError: baseError)
            case "ParentCommitIdOutdatedException": return try ParentCommitIdOutdatedException.makeError(baseError: baseError)
            case "ParentCommitIdRequiredException": return try ParentCommitIdRequiredException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "PutFileEntryConflictException": return try PutFileEntryConflictException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "RestrictedSourceFileException": return try RestrictedSourceFileException.makeError(baseError: baseError)
            case "SamePathRequestException": return try SamePathRequestException.makeError(baseError: baseError)
            case "SourceFileOrContentRequiredException": return try SourceFileOrContentRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePullRequestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientRequestTokenRequiredException": return try ClientRequestTokenRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "IdempotencyParameterMismatchException": return try IdempotencyParameterMismatchException.makeError(baseError: baseError)
            case "InvalidClientRequestTokenException": return try InvalidClientRequestTokenException.makeError(baseError: baseError)
            case "InvalidDescriptionException": return try InvalidDescriptionException.makeError(baseError: baseError)
            case "InvalidReferenceNameException": return try InvalidReferenceNameException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidTargetException": return try InvalidTargetException.makeError(baseError: baseError)
            case "InvalidTargetsException": return try InvalidTargetsException.makeError(baseError: baseError)
            case "InvalidTitleException": return try InvalidTitleException.makeError(baseError: baseError)
            case "MaximumOpenPullRequestsExceededException": return try MaximumOpenPullRequestsExceededException.makeError(baseError: baseError)
            case "MultipleRepositoriesInPullRequestException": return try MultipleRepositoriesInPullRequestException.makeError(baseError: baseError)
            case "ReferenceDoesNotExistException": return try ReferenceDoesNotExistException.makeError(baseError: baseError)
            case "ReferenceNameRequiredException": return try ReferenceNameRequiredException.makeError(baseError: baseError)
            case "ReferenceTypeNotSupportedException": return try ReferenceTypeNotSupportedException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "SourceAndDestinationAreSameException": return try SourceAndDestinationAreSameException.makeError(baseError: baseError)
            case "TargetRequiredException": return try TargetRequiredException.makeError(baseError: baseError)
            case "TargetsRequiredException": return try TargetsRequiredException.makeError(baseError: baseError)
            case "TitleRequiredException": return try TitleRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePullRequestApprovalRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleContentRequiredException": return try ApprovalRuleContentRequiredException.makeError(baseError: baseError)
            case "ApprovalRuleNameAlreadyExistsException": return try ApprovalRuleNameAlreadyExistsException.makeError(baseError: baseError)
            case "ApprovalRuleNameRequiredException": return try ApprovalRuleNameRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidApprovalRuleContentException": return try InvalidApprovalRuleContentException.makeError(baseError: baseError)
            case "InvalidApprovalRuleNameException": return try InvalidApprovalRuleNameException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "NumberOfRulesExceededException": return try NumberOfRulesExceededException.makeError(baseError: baseError)
            case "PullRequestAlreadyClosedException": return try PullRequestAlreadyClosedException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRepositoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyInvalidIdException": return try EncryptionKeyInvalidIdException.makeError(baseError: baseError)
            case "EncryptionKeyInvalidUsageException": return try EncryptionKeyInvalidUsageException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidRepositoryDescriptionException": return try InvalidRepositoryDescriptionException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidSystemTagUsageException": return try InvalidSystemTagUsageException.makeError(baseError: baseError)
            case "InvalidTagsMapException": return try InvalidTagsMapException.makeError(baseError: baseError)
            case "OperationNotAllowedException": return try OperationNotAllowedException.makeError(baseError: baseError)
            case "RepositoryLimitExceededException": return try RepositoryLimitExceededException.makeError(baseError: baseError)
            case "RepositoryNameExistsException": return try RepositoryNameExistsException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "TagPolicyException": return try TagPolicyException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUnreferencedMergeCommitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitMessageLengthExceededException": return try CommitMessageLengthExceededException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "ConcurrentReferenceUpdateException": return try ConcurrentReferenceUpdateException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileContentSizeLimitExceededException": return try FileContentSizeLimitExceededException.makeError(baseError: baseError)
            case "FileModeRequiredException": return try FileModeRequiredException.makeError(baseError: baseError)
            case "FolderContentSizeLimitExceededException": return try FolderContentSizeLimitExceededException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidConflictDetailLevelException": return try InvalidConflictDetailLevelException.makeError(baseError: baseError)
            case "InvalidConflictResolutionException": return try InvalidConflictResolutionException.makeError(baseError: baseError)
            case "InvalidConflictResolutionStrategyException": return try InvalidConflictResolutionStrategyException.makeError(baseError: baseError)
            case "InvalidEmailException": return try InvalidEmailException.makeError(baseError: baseError)
            case "InvalidFileModeException": return try InvalidFileModeException.makeError(baseError: baseError)
            case "InvalidMergeOptionException": return try InvalidMergeOptionException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidReplacementContentException": return try InvalidReplacementContentException.makeError(baseError: baseError)
            case "InvalidReplacementTypeException": return try InvalidReplacementTypeException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "ManualMergeRequiredException": return try ManualMergeRequiredException.makeError(baseError: baseError)
            case "MaximumConflictResolutionEntriesExceededException": return try MaximumConflictResolutionEntriesExceededException.makeError(baseError: baseError)
            case "MaximumFileContentToLoadExceededException": return try MaximumFileContentToLoadExceededException.makeError(baseError: baseError)
            case "MaximumItemsToCompareExceededException": return try MaximumItemsToCompareExceededException.makeError(baseError: baseError)
            case "MergeOptionRequiredException": return try MergeOptionRequiredException.makeError(baseError: baseError)
            case "MultipleConflictResolutionEntriesException": return try MultipleConflictResolutionEntriesException.makeError(baseError: baseError)
            case "NameLengthExceededException": return try NameLengthExceededException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "ReplacementContentRequiredException": return try ReplacementContentRequiredException.makeError(baseError: baseError)
            case "ReplacementTypeRequiredException": return try ReplacementTypeRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApprovalRuleTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateInUseException": return try ApprovalRuleTemplateInUseException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBranchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BranchNameRequiredException": return try BranchNameRequiredException.makeError(baseError: baseError)
            case "DefaultBranchCannotBeDeletedException": return try DefaultBranchCannotBeDeletedException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidBranchNameException": return try InvalidBranchNameException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCommentContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommentDeletedException": return try CommentDeletedException.makeError(baseError: baseError)
            case "CommentDoesNotExistException": return try CommentDoesNotExistException.makeError(baseError: baseError)
            case "CommentIdRequiredException": return try CommentIdRequiredException.makeError(baseError: baseError)
            case "InvalidCommentIdException": return try InvalidCommentIdException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BranchDoesNotExistException": return try BranchDoesNotExistException.makeError(baseError: baseError)
            case "BranchNameIsTagNameException": return try BranchNameIsTagNameException.makeError(baseError: baseError)
            case "BranchNameRequiredException": return try BranchNameRequiredException.makeError(baseError: baseError)
            case "CommitMessageLengthExceededException": return try CommitMessageLengthExceededException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileDoesNotExistException": return try FileDoesNotExistException.makeError(baseError: baseError)
            case "InvalidBranchNameException": return try InvalidBranchNameException.makeError(baseError: baseError)
            case "InvalidEmailException": return try InvalidEmailException.makeError(baseError: baseError)
            case "InvalidParentCommitIdException": return try InvalidParentCommitIdException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "NameLengthExceededException": return try NameLengthExceededException.makeError(baseError: baseError)
            case "ParentCommitDoesNotExistException": return try ParentCommitDoesNotExistException.makeError(baseError: baseError)
            case "ParentCommitIdOutdatedException": return try ParentCommitIdOutdatedException.makeError(baseError: baseError)
            case "ParentCommitIdRequiredException": return try ParentCommitIdRequiredException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePullRequestApprovalRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleNameRequiredException": return try ApprovalRuleNameRequiredException.makeError(baseError: baseError)
            case "CannotDeleteApprovalRuleFromTemplateException": return try CannotDeleteApprovalRuleFromTemplateException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidApprovalRuleNameException": return try InvalidApprovalRuleNameException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "PullRequestAlreadyClosedException": return try PullRequestAlreadyClosedException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRepositoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMergeConflictsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileDoesNotExistException": return try FileDoesNotExistException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidConflictDetailLevelException": return try InvalidConflictDetailLevelException.makeError(baseError: baseError)
            case "InvalidConflictResolutionStrategyException": return try InvalidConflictResolutionStrategyException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxMergeHunksException": return try InvalidMaxMergeHunksException.makeError(baseError: baseError)
            case "InvalidMergeOptionException": return try InvalidMergeOptionException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "MaximumFileContentToLoadExceededException": return try MaximumFileContentToLoadExceededException.makeError(baseError: baseError)
            case "MaximumItemsToCompareExceededException": return try MaximumItemsToCompareExceededException.makeError(baseError: baseError)
            case "MergeOptionRequiredException": return try MergeOptionRequiredException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePullRequestEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ActorDoesNotExistException": return try ActorDoesNotExistException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidActorArnException": return try InvalidActorArnException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxResultsException": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidPullRequestEventTypeException": return try InvalidPullRequestEventTypeException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateApprovalRuleTemplateFromRepositoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateDoesNotExistException": return try ApprovalRuleTemplateDoesNotExistException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EvaluatePullRequestApprovalRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidRevisionIdException": return try InvalidRevisionIdException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "RevisionIdRequiredException": return try RevisionIdRequiredException.makeError(baseError: baseError)
            case "RevisionNotCurrentException": return try RevisionNotCurrentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApprovalRuleTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateDoesNotExistException": return try ApprovalRuleTemplateDoesNotExistException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBlobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BlobIdDoesNotExistException": return try BlobIdDoesNotExistException.makeError(baseError: baseError)
            case "BlobIdRequiredException": return try BlobIdRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileTooLargeException": return try FileTooLargeException.makeError(baseError: baseError)
            case "InvalidBlobIdException": return try InvalidBlobIdException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBranchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BranchDoesNotExistException": return try BranchDoesNotExistException.makeError(baseError: baseError)
            case "BranchNameRequiredException": return try BranchNameRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidBranchNameException": return try InvalidBranchNameException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCommentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommentDeletedException": return try CommentDeletedException.makeError(baseError: baseError)
            case "CommentDoesNotExistException": return try CommentDoesNotExistException.makeError(baseError: baseError)
            case "CommentIdRequiredException": return try CommentIdRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommentIdException": return try InvalidCommentIdException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCommentReactionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommentDeletedException": return try CommentDeletedException.makeError(baseError: baseError)
            case "CommentDoesNotExistException": return try CommentDoesNotExistException.makeError(baseError: baseError)
            case "CommentIdRequiredException": return try CommentIdRequiredException.makeError(baseError: baseError)
            case "InvalidCommentIdException": return try InvalidCommentIdException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxResultsException": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidReactionUserArnException": return try InvalidReactionUserArnException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCommentsForComparedCommitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitIdRequiredException": return try CommitIdRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommitIdException": return try InvalidCommitIdException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxResultsException": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCommentsForPullRequestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitIdRequiredException": return try CommitIdRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommitIdException": return try InvalidCommitIdException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxResultsException": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "RepositoryNotAssociatedWithPullRequestException": return try RepositoryNotAssociatedWithPullRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCommitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitIdDoesNotExistException": return try CommitIdDoesNotExistException.makeError(baseError: baseError)
            case "CommitIdRequiredException": return try CommitIdRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommitIdException": return try InvalidCommitIdException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDifferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidCommitIdException": return try InvalidCommitIdException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxResultsException": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "PathDoesNotExistException": return try PathDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileDoesNotExistException": return try FileDoesNotExistException.makeError(baseError: baseError)
            case "FileTooLargeException": return try FileTooLargeException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FolderDoesNotExistException": return try FolderDoesNotExistException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMergeCommitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidConflictDetailLevelException": return try InvalidConflictDetailLevelException.makeError(baseError: baseError)
            case "InvalidConflictResolutionStrategyException": return try InvalidConflictResolutionStrategyException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMergeConflictsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidConflictDetailLevelException": return try InvalidConflictDetailLevelException.makeError(baseError: baseError)
            case "InvalidConflictResolutionStrategyException": return try InvalidConflictResolutionStrategyException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidDestinationCommitSpecifierException": return try InvalidDestinationCommitSpecifierException.makeError(baseError: baseError)
            case "InvalidMaxConflictFilesException": return try InvalidMaxConflictFilesException.makeError(baseError: baseError)
            case "InvalidMergeOptionException": return try InvalidMergeOptionException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidSourceCommitSpecifierException": return try InvalidSourceCommitSpecifierException.makeError(baseError: baseError)
            case "MaximumFileContentToLoadExceededException": return try MaximumFileContentToLoadExceededException.makeError(baseError: baseError)
            case "MaximumItemsToCompareExceededException": return try MaximumItemsToCompareExceededException.makeError(baseError: baseError)
            case "MergeOptionRequiredException": return try MergeOptionRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMergeOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidConflictDetailLevelException": return try InvalidConflictDetailLevelException.makeError(baseError: baseError)
            case "InvalidConflictResolutionStrategyException": return try InvalidConflictResolutionStrategyException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "MaximumFileContentToLoadExceededException": return try MaximumFileContentToLoadExceededException.makeError(baseError: baseError)
            case "MaximumItemsToCompareExceededException": return try MaximumItemsToCompareExceededException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPullRequestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPullRequestApprovalStatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidRevisionIdException": return try InvalidRevisionIdException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "RevisionIdRequiredException": return try RevisionIdRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPullRequestOverrideStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidRevisionIdException": return try InvalidRevisionIdException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "RevisionIdRequiredException": return try RevisionIdRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRepositoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRepositoryTriggersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApprovalRuleTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxResultsException": return try InvalidMaxResultsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssociatedApprovalRuleTemplatesForRepositoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxResultsException": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBranchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFileCommitHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxResultsException": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPullRequestsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorDoesNotExistException": return try AuthorDoesNotExistException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidAuthorArnException": return try InvalidAuthorArnException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxResultsException": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidPullRequestStatusException": return try InvalidPullRequestStatusException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRepositoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidOrderException": return try InvalidOrderException.makeError(baseError: baseError)
            case "InvalidSortByException": return try InvalidSortByException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRepositoriesForApprovalRuleTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateDoesNotExistException": return try ApprovalRuleTemplateDoesNotExistException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            case "InvalidContinuationTokenException": return try InvalidContinuationTokenException.makeError(baseError: baseError)
            case "InvalidMaxResultsException": return try InvalidMaxResultsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidResourceArnException": return try InvalidResourceArnException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "ResourceArnRequiredException": return try ResourceArnRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MergeBranchesByFastForwardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BranchDoesNotExistException": return try BranchDoesNotExistException.makeError(baseError: baseError)
            case "BranchNameIsTagNameException": return try BranchNameIsTagNameException.makeError(baseError: baseError)
            case "BranchNameRequiredException": return try BranchNameRequiredException.makeError(baseError: baseError)
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "ConcurrentReferenceUpdateException": return try ConcurrentReferenceUpdateException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidBranchNameException": return try InvalidBranchNameException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidTargetBranchException": return try InvalidTargetBranchException.makeError(baseError: baseError)
            case "ManualMergeRequiredException": return try ManualMergeRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MergeBranchesBySquashOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BranchDoesNotExistException": return try BranchDoesNotExistException.makeError(baseError: baseError)
            case "BranchNameIsTagNameException": return try BranchNameIsTagNameException.makeError(baseError: baseError)
            case "BranchNameRequiredException": return try BranchNameRequiredException.makeError(baseError: baseError)
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitMessageLengthExceededException": return try CommitMessageLengthExceededException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "ConcurrentReferenceUpdateException": return try ConcurrentReferenceUpdateException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileContentSizeLimitExceededException": return try FileContentSizeLimitExceededException.makeError(baseError: baseError)
            case "FileModeRequiredException": return try FileModeRequiredException.makeError(baseError: baseError)
            case "FolderContentSizeLimitExceededException": return try FolderContentSizeLimitExceededException.makeError(baseError: baseError)
            case "InvalidBranchNameException": return try InvalidBranchNameException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidConflictDetailLevelException": return try InvalidConflictDetailLevelException.makeError(baseError: baseError)
            case "InvalidConflictResolutionException": return try InvalidConflictResolutionException.makeError(baseError: baseError)
            case "InvalidConflictResolutionStrategyException": return try InvalidConflictResolutionStrategyException.makeError(baseError: baseError)
            case "InvalidEmailException": return try InvalidEmailException.makeError(baseError: baseError)
            case "InvalidFileModeException": return try InvalidFileModeException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidReplacementContentException": return try InvalidReplacementContentException.makeError(baseError: baseError)
            case "InvalidReplacementTypeException": return try InvalidReplacementTypeException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidTargetBranchException": return try InvalidTargetBranchException.makeError(baseError: baseError)
            case "ManualMergeRequiredException": return try ManualMergeRequiredException.makeError(baseError: baseError)
            case "MaximumConflictResolutionEntriesExceededException": return try MaximumConflictResolutionEntriesExceededException.makeError(baseError: baseError)
            case "MaximumFileContentToLoadExceededException": return try MaximumFileContentToLoadExceededException.makeError(baseError: baseError)
            case "MaximumItemsToCompareExceededException": return try MaximumItemsToCompareExceededException.makeError(baseError: baseError)
            case "MultipleConflictResolutionEntriesException": return try MultipleConflictResolutionEntriesException.makeError(baseError: baseError)
            case "NameLengthExceededException": return try NameLengthExceededException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "ReplacementContentRequiredException": return try ReplacementContentRequiredException.makeError(baseError: baseError)
            case "ReplacementTypeRequiredException": return try ReplacementTypeRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MergeBranchesByThreeWayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BranchDoesNotExistException": return try BranchDoesNotExistException.makeError(baseError: baseError)
            case "BranchNameIsTagNameException": return try BranchNameIsTagNameException.makeError(baseError: baseError)
            case "BranchNameRequiredException": return try BranchNameRequiredException.makeError(baseError: baseError)
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitMessageLengthExceededException": return try CommitMessageLengthExceededException.makeError(baseError: baseError)
            case "CommitRequiredException": return try CommitRequiredException.makeError(baseError: baseError)
            case "ConcurrentReferenceUpdateException": return try ConcurrentReferenceUpdateException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileContentSizeLimitExceededException": return try FileContentSizeLimitExceededException.makeError(baseError: baseError)
            case "FileModeRequiredException": return try FileModeRequiredException.makeError(baseError: baseError)
            case "FolderContentSizeLimitExceededException": return try FolderContentSizeLimitExceededException.makeError(baseError: baseError)
            case "InvalidBranchNameException": return try InvalidBranchNameException.makeError(baseError: baseError)
            case "InvalidCommitException": return try InvalidCommitException.makeError(baseError: baseError)
            case "InvalidConflictDetailLevelException": return try InvalidConflictDetailLevelException.makeError(baseError: baseError)
            case "InvalidConflictResolutionException": return try InvalidConflictResolutionException.makeError(baseError: baseError)
            case "InvalidConflictResolutionStrategyException": return try InvalidConflictResolutionStrategyException.makeError(baseError: baseError)
            case "InvalidEmailException": return try InvalidEmailException.makeError(baseError: baseError)
            case "InvalidFileModeException": return try InvalidFileModeException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidReplacementContentException": return try InvalidReplacementContentException.makeError(baseError: baseError)
            case "InvalidReplacementTypeException": return try InvalidReplacementTypeException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidTargetBranchException": return try InvalidTargetBranchException.makeError(baseError: baseError)
            case "ManualMergeRequiredException": return try ManualMergeRequiredException.makeError(baseError: baseError)
            case "MaximumConflictResolutionEntriesExceededException": return try MaximumConflictResolutionEntriesExceededException.makeError(baseError: baseError)
            case "MaximumFileContentToLoadExceededException": return try MaximumFileContentToLoadExceededException.makeError(baseError: baseError)
            case "MaximumItemsToCompareExceededException": return try MaximumItemsToCompareExceededException.makeError(baseError: baseError)
            case "MultipleConflictResolutionEntriesException": return try MultipleConflictResolutionEntriesException.makeError(baseError: baseError)
            case "NameLengthExceededException": return try NameLengthExceededException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "ReplacementContentRequiredException": return try ReplacementContentRequiredException.makeError(baseError: baseError)
            case "ReplacementTypeRequiredException": return try ReplacementTypeRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MergePullRequestByFastForwardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentReferenceUpdateException": return try ConcurrentReferenceUpdateException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidCommitIdException": return try InvalidCommitIdException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "ManualMergeRequiredException": return try ManualMergeRequiredException.makeError(baseError: baseError)
            case "PullRequestAlreadyClosedException": return try PullRequestAlreadyClosedException.makeError(baseError: baseError)
            case "PullRequestApprovalRulesNotSatisfiedException": return try PullRequestApprovalRulesNotSatisfiedException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "ReferenceDoesNotExistException": return try ReferenceDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "RepositoryNotAssociatedWithPullRequestException": return try RepositoryNotAssociatedWithPullRequestException.makeError(baseError: baseError)
            case "TipOfSourceReferenceIsDifferentException": return try TipOfSourceReferenceIsDifferentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MergePullRequestBySquashOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitMessageLengthExceededException": return try CommitMessageLengthExceededException.makeError(baseError: baseError)
            case "ConcurrentReferenceUpdateException": return try ConcurrentReferenceUpdateException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileContentSizeLimitExceededException": return try FileContentSizeLimitExceededException.makeError(baseError: baseError)
            case "FolderContentSizeLimitExceededException": return try FolderContentSizeLimitExceededException.makeError(baseError: baseError)
            case "InvalidCommitIdException": return try InvalidCommitIdException.makeError(baseError: baseError)
            case "InvalidConflictDetailLevelException": return try InvalidConflictDetailLevelException.makeError(baseError: baseError)
            case "InvalidConflictResolutionException": return try InvalidConflictResolutionException.makeError(baseError: baseError)
            case "InvalidConflictResolutionStrategyException": return try InvalidConflictResolutionStrategyException.makeError(baseError: baseError)
            case "InvalidEmailException": return try InvalidEmailException.makeError(baseError: baseError)
            case "InvalidFileModeException": return try InvalidFileModeException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidReplacementContentException": return try InvalidReplacementContentException.makeError(baseError: baseError)
            case "InvalidReplacementTypeException": return try InvalidReplacementTypeException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "ManualMergeRequiredException": return try ManualMergeRequiredException.makeError(baseError: baseError)
            case "MaximumConflictResolutionEntriesExceededException": return try MaximumConflictResolutionEntriesExceededException.makeError(baseError: baseError)
            case "MaximumFileContentToLoadExceededException": return try MaximumFileContentToLoadExceededException.makeError(baseError: baseError)
            case "MaximumItemsToCompareExceededException": return try MaximumItemsToCompareExceededException.makeError(baseError: baseError)
            case "MultipleConflictResolutionEntriesException": return try MultipleConflictResolutionEntriesException.makeError(baseError: baseError)
            case "NameLengthExceededException": return try NameLengthExceededException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "PullRequestAlreadyClosedException": return try PullRequestAlreadyClosedException.makeError(baseError: baseError)
            case "PullRequestApprovalRulesNotSatisfiedException": return try PullRequestApprovalRulesNotSatisfiedException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "ReplacementContentRequiredException": return try ReplacementContentRequiredException.makeError(baseError: baseError)
            case "ReplacementTypeRequiredException": return try ReplacementTypeRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "RepositoryNotAssociatedWithPullRequestException": return try RepositoryNotAssociatedWithPullRequestException.makeError(baseError: baseError)
            case "TipOfSourceReferenceIsDifferentException": return try TipOfSourceReferenceIsDifferentException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MergePullRequestByThreeWayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommitMessageLengthExceededException": return try CommitMessageLengthExceededException.makeError(baseError: baseError)
            case "ConcurrentReferenceUpdateException": return try ConcurrentReferenceUpdateException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileContentSizeLimitExceededException": return try FileContentSizeLimitExceededException.makeError(baseError: baseError)
            case "FolderContentSizeLimitExceededException": return try FolderContentSizeLimitExceededException.makeError(baseError: baseError)
            case "InvalidCommitIdException": return try InvalidCommitIdException.makeError(baseError: baseError)
            case "InvalidConflictDetailLevelException": return try InvalidConflictDetailLevelException.makeError(baseError: baseError)
            case "InvalidConflictResolutionException": return try InvalidConflictResolutionException.makeError(baseError: baseError)
            case "InvalidConflictResolutionStrategyException": return try InvalidConflictResolutionStrategyException.makeError(baseError: baseError)
            case "InvalidEmailException": return try InvalidEmailException.makeError(baseError: baseError)
            case "InvalidFileModeException": return try InvalidFileModeException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidReplacementContentException": return try InvalidReplacementContentException.makeError(baseError: baseError)
            case "InvalidReplacementTypeException": return try InvalidReplacementTypeException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "ManualMergeRequiredException": return try ManualMergeRequiredException.makeError(baseError: baseError)
            case "MaximumConflictResolutionEntriesExceededException": return try MaximumConflictResolutionEntriesExceededException.makeError(baseError: baseError)
            case "MaximumFileContentToLoadExceededException": return try MaximumFileContentToLoadExceededException.makeError(baseError: baseError)
            case "MaximumItemsToCompareExceededException": return try MaximumItemsToCompareExceededException.makeError(baseError: baseError)
            case "MultipleConflictResolutionEntriesException": return try MultipleConflictResolutionEntriesException.makeError(baseError: baseError)
            case "NameLengthExceededException": return try NameLengthExceededException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "PullRequestAlreadyClosedException": return try PullRequestAlreadyClosedException.makeError(baseError: baseError)
            case "PullRequestApprovalRulesNotSatisfiedException": return try PullRequestApprovalRulesNotSatisfiedException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "ReplacementContentRequiredException": return try ReplacementContentRequiredException.makeError(baseError: baseError)
            case "ReplacementTypeRequiredException": return try ReplacementTypeRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "RepositoryNotAssociatedWithPullRequestException": return try RepositoryNotAssociatedWithPullRequestException.makeError(baseError: baseError)
            case "TipOfSourceReferenceIsDifferentException": return try TipOfSourceReferenceIsDifferentException.makeError(baseError: baseError)
            case "TipsDivergenceExceededException": return try TipsDivergenceExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum OverridePullRequestApprovalRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidOverrideStatusException": return try InvalidOverrideStatusException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidRevisionIdException": return try InvalidRevisionIdException.makeError(baseError: baseError)
            case "OverrideAlreadySetException": return try OverrideAlreadySetException.makeError(baseError: baseError)
            case "OverrideStatusRequiredException": return try OverrideStatusRequiredException.makeError(baseError: baseError)
            case "PullRequestAlreadyClosedException": return try PullRequestAlreadyClosedException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "RevisionIdRequiredException": return try RevisionIdRequiredException.makeError(baseError: baseError)
            case "RevisionNotCurrentException": return try RevisionNotCurrentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PostCommentForComparedCommitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BeforeCommitIdAndAfterCommitIdAreSameException": return try BeforeCommitIdAndAfterCommitIdAreSameException.makeError(baseError: baseError)
            case "ClientRequestTokenRequiredException": return try ClientRequestTokenRequiredException.makeError(baseError: baseError)
            case "CommentContentRequiredException": return try CommentContentRequiredException.makeError(baseError: baseError)
            case "CommentContentSizeLimitExceededException": return try CommentContentSizeLimitExceededException.makeError(baseError: baseError)
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitIdRequiredException": return try CommitIdRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "IdempotencyParameterMismatchException": return try IdempotencyParameterMismatchException.makeError(baseError: baseError)
            case "InvalidClientRequestTokenException": return try InvalidClientRequestTokenException.makeError(baseError: baseError)
            case "InvalidCommitIdException": return try InvalidCommitIdException.makeError(baseError: baseError)
            case "InvalidFileLocationException": return try InvalidFileLocationException.makeError(baseError: baseError)
            case "InvalidFilePositionException": return try InvalidFilePositionException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidRelativeFileVersionEnumException": return try InvalidRelativeFileVersionEnumException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "PathDoesNotExistException": return try PathDoesNotExistException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PostCommentForPullRequestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BeforeCommitIdAndAfterCommitIdAreSameException": return try BeforeCommitIdAndAfterCommitIdAreSameException.makeError(baseError: baseError)
            case "ClientRequestTokenRequiredException": return try ClientRequestTokenRequiredException.makeError(baseError: baseError)
            case "CommentContentRequiredException": return try CommentContentRequiredException.makeError(baseError: baseError)
            case "CommentContentSizeLimitExceededException": return try CommentContentSizeLimitExceededException.makeError(baseError: baseError)
            case "CommitDoesNotExistException": return try CommitDoesNotExistException.makeError(baseError: baseError)
            case "CommitIdRequiredException": return try CommitIdRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "IdempotencyParameterMismatchException": return try IdempotencyParameterMismatchException.makeError(baseError: baseError)
            case "InvalidClientRequestTokenException": return try InvalidClientRequestTokenException.makeError(baseError: baseError)
            case "InvalidCommitIdException": return try InvalidCommitIdException.makeError(baseError: baseError)
            case "InvalidFileLocationException": return try InvalidFileLocationException.makeError(baseError: baseError)
            case "InvalidFilePositionException": return try InvalidFilePositionException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidRelativeFileVersionEnumException": return try InvalidRelativeFileVersionEnumException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "PathDoesNotExistException": return try PathDoesNotExistException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "RepositoryNotAssociatedWithPullRequestException": return try RepositoryNotAssociatedWithPullRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PostCommentReplyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientRequestTokenRequiredException": return try ClientRequestTokenRequiredException.makeError(baseError: baseError)
            case "CommentContentRequiredException": return try CommentContentRequiredException.makeError(baseError: baseError)
            case "CommentContentSizeLimitExceededException": return try CommentContentSizeLimitExceededException.makeError(baseError: baseError)
            case "CommentDoesNotExistException": return try CommentDoesNotExistException.makeError(baseError: baseError)
            case "CommentIdRequiredException": return try CommentIdRequiredException.makeError(baseError: baseError)
            case "IdempotencyParameterMismatchException": return try IdempotencyParameterMismatchException.makeError(baseError: baseError)
            case "InvalidClientRequestTokenException": return try InvalidClientRequestTokenException.makeError(baseError: baseError)
            case "InvalidCommentIdException": return try InvalidCommentIdException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutCommentReactionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommentDeletedException": return try CommentDeletedException.makeError(baseError: baseError)
            case "CommentDoesNotExistException": return try CommentDoesNotExistException.makeError(baseError: baseError)
            case "CommentIdRequiredException": return try CommentIdRequiredException.makeError(baseError: baseError)
            case "InvalidCommentIdException": return try InvalidCommentIdException.makeError(baseError: baseError)
            case "InvalidReactionValueException": return try InvalidReactionValueException.makeError(baseError: baseError)
            case "ReactionLimitExceededException": return try ReactionLimitExceededException.makeError(baseError: baseError)
            case "ReactionValueRequiredException": return try ReactionValueRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BranchDoesNotExistException": return try BranchDoesNotExistException.makeError(baseError: baseError)
            case "BranchNameIsTagNameException": return try BranchNameIsTagNameException.makeError(baseError: baseError)
            case "BranchNameRequiredException": return try BranchNameRequiredException.makeError(baseError: baseError)
            case "CommitMessageLengthExceededException": return try CommitMessageLengthExceededException.makeError(baseError: baseError)
            case "DirectoryNameConflictsWithFileNameException": return try DirectoryNameConflictsWithFileNameException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "FileContentRequiredException": return try FileContentRequiredException.makeError(baseError: baseError)
            case "FileContentSizeLimitExceededException": return try FileContentSizeLimitExceededException.makeError(baseError: baseError)
            case "FileNameConflictsWithDirectoryNameException": return try FileNameConflictsWithDirectoryNameException.makeError(baseError: baseError)
            case "FilePathConflictsWithSubmodulePathException": return try FilePathConflictsWithSubmodulePathException.makeError(baseError: baseError)
            case "FolderContentSizeLimitExceededException": return try FolderContentSizeLimitExceededException.makeError(baseError: baseError)
            case "InvalidBranchNameException": return try InvalidBranchNameException.makeError(baseError: baseError)
            case "InvalidDeletionParameterException": return try InvalidDeletionParameterException.makeError(baseError: baseError)
            case "InvalidEmailException": return try InvalidEmailException.makeError(baseError: baseError)
            case "InvalidFileModeException": return try InvalidFileModeException.makeError(baseError: baseError)
            case "InvalidParentCommitIdException": return try InvalidParentCommitIdException.makeError(baseError: baseError)
            case "InvalidPathException": return try InvalidPathException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "NameLengthExceededException": return try NameLengthExceededException.makeError(baseError: baseError)
            case "ParentCommitDoesNotExistException": return try ParentCommitDoesNotExistException.makeError(baseError: baseError)
            case "ParentCommitIdOutdatedException": return try ParentCommitIdOutdatedException.makeError(baseError: baseError)
            case "ParentCommitIdRequiredException": return try ParentCommitIdRequiredException.makeError(baseError: baseError)
            case "PathRequiredException": return try PathRequiredException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "SameFileContentException": return try SameFileContentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRepositoryTriggersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerBranchNameException": return try InvalidRepositoryTriggerBranchNameException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerCustomDataException": return try InvalidRepositoryTriggerCustomDataException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerDestinationArnException": return try InvalidRepositoryTriggerDestinationArnException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerEventsException": return try InvalidRepositoryTriggerEventsException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerNameException": return try InvalidRepositoryTriggerNameException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerRegionException": return try InvalidRepositoryTriggerRegionException.makeError(baseError: baseError)
            case "MaximumBranchesExceededException": return try MaximumBranchesExceededException.makeError(baseError: baseError)
            case "MaximumRepositoryTriggersExceededException": return try MaximumRepositoryTriggersExceededException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "RepositoryTriggerBranchNameListRequiredException": return try RepositoryTriggerBranchNameListRequiredException.makeError(baseError: baseError)
            case "RepositoryTriggerDestinationArnRequiredException": return try RepositoryTriggerDestinationArnRequiredException.makeError(baseError: baseError)
            case "RepositoryTriggerEventsListRequiredException": return try RepositoryTriggerEventsListRequiredException.makeError(baseError: baseError)
            case "RepositoryTriggerNameRequiredException": return try RepositoryTriggerNameRequiredException.makeError(baseError: baseError)
            case "RepositoryTriggersListRequiredException": return try RepositoryTriggersListRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidResourceArnException": return try InvalidResourceArnException.makeError(baseError: baseError)
            case "InvalidSystemTagUsageException": return try InvalidSystemTagUsageException.makeError(baseError: baseError)
            case "InvalidTagsMapException": return try InvalidTagsMapException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "ResourceArnRequiredException": return try ResourceArnRequiredException.makeError(baseError: baseError)
            case "TagPolicyException": return try TagPolicyException.makeError(baseError: baseError)
            case "TagsMapRequiredException": return try TagsMapRequiredException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestRepositoryTriggersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerBranchNameException": return try InvalidRepositoryTriggerBranchNameException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerCustomDataException": return try InvalidRepositoryTriggerCustomDataException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerDestinationArnException": return try InvalidRepositoryTriggerDestinationArnException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerEventsException": return try InvalidRepositoryTriggerEventsException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerNameException": return try InvalidRepositoryTriggerNameException.makeError(baseError: baseError)
            case "InvalidRepositoryTriggerRegionException": return try InvalidRepositoryTriggerRegionException.makeError(baseError: baseError)
            case "MaximumBranchesExceededException": return try MaximumBranchesExceededException.makeError(baseError: baseError)
            case "MaximumRepositoryTriggersExceededException": return try MaximumRepositoryTriggersExceededException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            case "RepositoryTriggerBranchNameListRequiredException": return try RepositoryTriggerBranchNameListRequiredException.makeError(baseError: baseError)
            case "RepositoryTriggerDestinationArnRequiredException": return try RepositoryTriggerDestinationArnRequiredException.makeError(baseError: baseError)
            case "RepositoryTriggerEventsListRequiredException": return try RepositoryTriggerEventsListRequiredException.makeError(baseError: baseError)
            case "RepositoryTriggerNameRequiredException": return try RepositoryTriggerNameRequiredException.makeError(baseError: baseError)
            case "RepositoryTriggersListRequiredException": return try RepositoryTriggersListRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "InvalidResourceArnException": return try InvalidResourceArnException.makeError(baseError: baseError)
            case "InvalidSystemTagUsageException": return try InvalidSystemTagUsageException.makeError(baseError: baseError)
            case "InvalidTagKeysListException": return try InvalidTagKeysListException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "ResourceArnRequiredException": return try ResourceArnRequiredException.makeError(baseError: baseError)
            case "TagKeysListRequiredException": return try TagKeysListRequiredException.makeError(baseError: baseError)
            case "TagPolicyException": return try TagPolicyException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApprovalRuleTemplateContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateContentRequiredException": return try ApprovalRuleTemplateContentRequiredException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateDoesNotExistException": return try ApprovalRuleTemplateDoesNotExistException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateContentException": return try InvalidApprovalRuleTemplateContentException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            case "InvalidRuleContentSha256Exception": return try InvalidRuleContentSha256Exception.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApprovalRuleTemplateDescriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateDoesNotExistException": return try ApprovalRuleTemplateDoesNotExistException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateDescriptionException": return try InvalidApprovalRuleTemplateDescriptionException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApprovalRuleTemplateNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleTemplateDoesNotExistException": return try ApprovalRuleTemplateDoesNotExistException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameAlreadyExistsException": return try ApprovalRuleTemplateNameAlreadyExistsException.makeError(baseError: baseError)
            case "ApprovalRuleTemplateNameRequiredException": return try ApprovalRuleTemplateNameRequiredException.makeError(baseError: baseError)
            case "InvalidApprovalRuleTemplateNameException": return try InvalidApprovalRuleTemplateNameException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCommentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CommentContentRequiredException": return try CommentContentRequiredException.makeError(baseError: baseError)
            case "CommentContentSizeLimitExceededException": return try CommentContentSizeLimitExceededException.makeError(baseError: baseError)
            case "CommentDeletedException": return try CommentDeletedException.makeError(baseError: baseError)
            case "CommentDoesNotExistException": return try CommentDoesNotExistException.makeError(baseError: baseError)
            case "CommentIdRequiredException": return try CommentIdRequiredException.makeError(baseError: baseError)
            case "CommentNotCreatedByCallerException": return try CommentNotCreatedByCallerException.makeError(baseError: baseError)
            case "InvalidCommentIdException": return try InvalidCommentIdException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDefaultBranchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BranchDoesNotExistException": return try BranchDoesNotExistException.makeError(baseError: baseError)
            case "BranchNameRequiredException": return try BranchNameRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidBranchNameException": return try InvalidBranchNameException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePullRequestApprovalRuleContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalRuleContentRequiredException": return try ApprovalRuleContentRequiredException.makeError(baseError: baseError)
            case "ApprovalRuleDoesNotExistException": return try ApprovalRuleDoesNotExistException.makeError(baseError: baseError)
            case "ApprovalRuleNameRequiredException": return try ApprovalRuleNameRequiredException.makeError(baseError: baseError)
            case "CannotModifyApprovalRuleFromTemplateException": return try CannotModifyApprovalRuleFromTemplateException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidApprovalRuleContentException": return try InvalidApprovalRuleContentException.makeError(baseError: baseError)
            case "InvalidApprovalRuleNameException": return try InvalidApprovalRuleNameException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidRuleContentSha256Exception": return try InvalidRuleContentSha256Exception.makeError(baseError: baseError)
            case "PullRequestAlreadyClosedException": return try PullRequestAlreadyClosedException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePullRequestApprovalStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApprovalStateRequiredException": return try ApprovalStateRequiredException.makeError(baseError: baseError)
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidApprovalStateException": return try InvalidApprovalStateException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidRevisionIdException": return try InvalidRevisionIdException.makeError(baseError: baseError)
            case "MaximumNumberOfApprovalsExceededException": return try MaximumNumberOfApprovalsExceededException.makeError(baseError: baseError)
            case "PullRequestAlreadyClosedException": return try PullRequestAlreadyClosedException.makeError(baseError: baseError)
            case "PullRequestCannotBeApprovedByAuthorException": return try PullRequestCannotBeApprovedByAuthorException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "RevisionIdRequiredException": return try RevisionIdRequiredException.makeError(baseError: baseError)
            case "RevisionNotCurrentException": return try RevisionNotCurrentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePullRequestDescriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidDescriptionException": return try InvalidDescriptionException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "PullRequestAlreadyClosedException": return try PullRequestAlreadyClosedException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePullRequestStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidPullRequestStatusException": return try InvalidPullRequestStatusException.makeError(baseError: baseError)
            case "InvalidPullRequestStatusUpdateException": return try InvalidPullRequestStatusUpdateException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "PullRequestStatusRequiredException": return try PullRequestStatusRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePullRequestTitleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPullRequestIdException": return try InvalidPullRequestIdException.makeError(baseError: baseError)
            case "InvalidTitleException": return try InvalidTitleException.makeError(baseError: baseError)
            case "PullRequestAlreadyClosedException": return try PullRequestAlreadyClosedException.makeError(baseError: baseError)
            case "PullRequestDoesNotExistException": return try PullRequestDoesNotExistException.makeError(baseError: baseError)
            case "PullRequestIdRequiredException": return try PullRequestIdRequiredException.makeError(baseError: baseError)
            case "TitleRequiredException": return try TitleRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRepositoryDescriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidRepositoryDescriptionException": return try InvalidRepositoryDescriptionException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRepositoryEncryptionKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EncryptionIntegrityChecksFailedException": return try EncryptionIntegrityChecksFailedException.makeError(baseError: baseError)
            case "EncryptionKeyAccessDeniedException": return try EncryptionKeyAccessDeniedException.makeError(baseError: baseError)
            case "EncryptionKeyDisabledException": return try EncryptionKeyDisabledException.makeError(baseError: baseError)
            case "EncryptionKeyInvalidIdException": return try EncryptionKeyInvalidIdException.makeError(baseError: baseError)
            case "EncryptionKeyInvalidUsageException": return try EncryptionKeyInvalidUsageException.makeError(baseError: baseError)
            case "EncryptionKeyNotFoundException": return try EncryptionKeyNotFoundException.makeError(baseError: baseError)
            case "EncryptionKeyRequiredException": return try EncryptionKeyRequiredException.makeError(baseError: baseError)
            case "EncryptionKeyUnavailableException": return try EncryptionKeyUnavailableException.makeError(baseError: baseError)
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRepositoryNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRepositoryNameException": return try InvalidRepositoryNameException.makeError(baseError: baseError)
            case "RepositoryDoesNotExistException": return try RepositoryDoesNotExistException.makeError(baseError: baseError)
            case "RepositoryNameExistsException": return try RepositoryNameExistsException.makeError(baseError: baseError)
            case "RepositoryNameRequiredException": return try RepositoryNameRequiredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension EncryptionIntegrityChecksFailedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EncryptionIntegrityChecksFailedException {
        let reader = baseError.errorBodyReader
        var value = EncryptionIntegrityChecksFailedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EncryptionKeyAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EncryptionKeyAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = EncryptionKeyAccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryNameRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryNameRequiredException {
        let reader = baseError.errorBodyReader
        var value = RepositoryNameRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EncryptionKeyUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EncryptionKeyUnavailableException {
        let reader = baseError.errorBodyReader
        var value = EncryptionKeyUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EncryptionKeyNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EncryptionKeyNotFoundException {
        let reader = baseError.errorBodyReader
        var value = EncryptionKeyNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRepositoryNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRepositoryNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidRepositoryNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApprovalRuleTemplateDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApprovalRuleTemplateDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = ApprovalRuleTemplateDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EncryptionKeyDisabledException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EncryptionKeyDisabledException {
        let reader = baseError.errorBodyReader
        var value = EncryptionKeyDisabledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApprovalRuleTemplateNameRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApprovalRuleTemplateNameRequiredException {
        let reader = baseError.errorBodyReader
        var value = ApprovalRuleTemplateNameRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumRuleTemplatesAssociatedWithRepositoryException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumRuleTemplatesAssociatedWithRepositoryException {
        let reader = baseError.errorBodyReader
        var value = MaximumRuleTemplatesAssociatedWithRepositoryException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = RepositoryDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidApprovalRuleTemplateNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidApprovalRuleTemplateNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidApprovalRuleTemplateNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumRepositoryNamesExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumRepositoryNamesExceededException {
        let reader = baseError.errorBodyReader
        var value = MaximumRepositoryNamesExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryNamesRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryNamesRequiredException {
        let reader = baseError.errorBodyReader
        var value = RepositoryNamesRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumItemsToCompareExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumItemsToCompareExceededException {
        let reader = baseError.errorBodyReader
        var value = MaximumItemsToCompareExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MergeOptionRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MergeOptionRequiredException {
        let reader = baseError.errorBodyReader
        var value = MergeOptionRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidMergeOptionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidMergeOptionException {
        let reader = baseError.errorBodyReader
        var value = InvalidMergeOptionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidMaxConflictFilesException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidMaxConflictFilesException {
        let reader = baseError.errorBodyReader
        var value = InvalidMaxConflictFilesException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCommitException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCommitException {
        let reader = baseError.errorBodyReader
        var value = InvalidCommitException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidContinuationTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidContinuationTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidContinuationTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumFileContentToLoadExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumFileContentToLoadExceededException {
        let reader = baseError.errorBodyReader
        var value = MaximumFileContentToLoadExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidMaxMergeHunksException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidMaxMergeHunksException {
        let reader = baseError.errorBodyReader
        var value = InvalidMaxMergeHunksException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidConflictResolutionStrategyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidConflictResolutionStrategyException {
        let reader = baseError.errorBodyReader
        var value = InvalidConflictResolutionStrategyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TipsDivergenceExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TipsDivergenceExceededException {
        let reader = baseError.errorBodyReader
        var value = TipsDivergenceExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommitRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommitRequiredException {
        let reader = baseError.errorBodyReader
        var value = CommitRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommitDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommitDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = CommitDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidConflictDetailLevelException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidConflictDetailLevelException {
        let reader = baseError.errorBodyReader
        var value = InvalidConflictDetailLevelException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommitIdsLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommitIdsLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = CommitIdsLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommitIdsListRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommitIdsListRequiredException {
        let reader = baseError.errorBodyReader
        var value = CommitIdsListRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NumberOfRuleTemplatesExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NumberOfRuleTemplatesExceededException {
        let reader = baseError.errorBodyReader
        var value = NumberOfRuleTemplatesExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidApprovalRuleTemplateContentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidApprovalRuleTemplateContentException {
        let reader = baseError.errorBodyReader
        var value = InvalidApprovalRuleTemplateContentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApprovalRuleTemplateContentRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApprovalRuleTemplateContentRequiredException {
        let reader = baseError.errorBodyReader
        var value = ApprovalRuleTemplateContentRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidApprovalRuleTemplateDescriptionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidApprovalRuleTemplateDescriptionException {
        let reader = baseError.errorBodyReader
        var value = InvalidApprovalRuleTemplateDescriptionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApprovalRuleTemplateNameAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApprovalRuleTemplateNameAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ApprovalRuleTemplateNameAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommitIdRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommitIdRequiredException {
        let reader = baseError.errorBodyReader
        var value = CommitIdRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BranchNameRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BranchNameRequiredException {
        let reader = baseError.errorBodyReader
        var value = BranchNameRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCommitIdException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCommitIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidCommitIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BranchNameExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BranchNameExistsException {
        let reader = baseError.errorBodyReader
        var value = BranchNameExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidBranchNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidBranchNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidBranchNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FileDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FileDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = FileDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FolderContentSizeLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FolderContentSizeLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = FolderContentSizeLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoChangeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoChangeException {
        let reader = baseError.errorBodyReader
        var value = NoChangeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FilePathConflictsWithSubmodulePathException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FilePathConflictsWithSubmodulePathException {
        let reader = baseError.errorBodyReader
        var value = FilePathConflictsWithSubmodulePathException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RestrictedSourceFileException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RestrictedSourceFileException {
        let reader = baseError.errorBodyReader
        var value = RestrictedSourceFileException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BranchNameIsTagNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BranchNameIsTagNameException {
        let reader = baseError.errorBodyReader
        var value = BranchNameIsTagNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParentCommitIdException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParentCommitIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidParentCommitIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PutFileEntryConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PutFileEntryConflictException {
        let reader = baseError.errorBodyReader
        var value = PutFileEntryConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DirectoryNameConflictsWithFileNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DirectoryNameConflictsWithFileNameException {
        let reader = baseError.errorBodyReader
        var value = DirectoryNameConflictsWithFileNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FileContentSizeLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FileContentSizeLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = FileContentSizeLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParentCommitDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParentCommitDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = ParentCommitDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParentCommitIdOutdatedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParentCommitIdOutdatedException {
        let reader = baseError.errorBodyReader
        var value = ParentCommitIdOutdatedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NameLengthExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NameLengthExceededException {
        let reader = baseError.errorBodyReader
        var value = NameLengthExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PathRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PathRequiredException {
        let reader = baseError.errorBodyReader
        var value = PathRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BranchDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BranchDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = BranchDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SamePathRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SamePathRequestException {
        let reader = baseError.errorBodyReader
        var value = SamePathRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommitMessageLengthExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommitMessageLengthExceededException {
        let reader = baseError.errorBodyReader
        var value = CommitMessageLengthExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDeletionParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDeletionParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidDeletionParameterException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FileNameConflictsWithDirectoryNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FileNameConflictsWithDirectoryNameException {
        let reader = baseError.errorBodyReader
        var value = FileNameConflictsWithDirectoryNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumFileEntriesExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumFileEntriesExceededException {
        let reader = baseError.errorBodyReader
        var value = MaximumFileEntriesExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParentCommitIdRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParentCommitIdRequiredException {
        let reader = baseError.errorBodyReader
        var value = ParentCommitIdRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidFileModeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidFileModeException {
        let reader = baseError.errorBodyReader
        var value = InvalidFileModeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPathException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPathException {
        let reader = baseError.errorBodyReader
        var value = InvalidPathException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidEmailException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidEmailException {
        let reader = baseError.errorBodyReader
        var value = InvalidEmailException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FileContentAndSourceFileSpecifiedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FileContentAndSourceFileSpecifiedException {
        let reader = baseError.errorBodyReader
        var value = FileContentAndSourceFileSpecifiedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FileEntryRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FileEntryRequiredException {
        let reader = baseError.errorBodyReader
        var value = FileEntryRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FileModeRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FileModeRequiredException {
        let reader = baseError.errorBodyReader
        var value = FileModeRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SourceFileOrContentRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SourceFileOrContentRequiredException {
        let reader = baseError.errorBodyReader
        var value = SourceFileOrContentRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReferenceNameRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReferenceNameRequiredException {
        let reader = baseError.errorBodyReader
        var value = ReferenceNameRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TargetRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TargetRequiredException {
        let reader = baseError.errorBodyReader
        var value = TargetRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumOpenPullRequestsExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumOpenPullRequestsExceededException {
        let reader = baseError.errorBodyReader
        var value = MaximumOpenPullRequestsExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MultipleRepositoriesInPullRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MultipleRepositoriesInPullRequestException {
        let reader = baseError.errorBodyReader
        var value = MultipleRepositoriesInPullRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SourceAndDestinationAreSameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SourceAndDestinationAreSameException {
        let reader = baseError.errorBodyReader
        var value = SourceAndDestinationAreSameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ClientRequestTokenRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ClientRequestTokenRequiredException {
        let reader = baseError.errorBodyReader
        var value = ClientRequestTokenRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReferenceDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReferenceDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = ReferenceDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDescriptionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDescriptionException {
        let reader = baseError.errorBodyReader
        var value = InvalidDescriptionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTitleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTitleException {
        let reader = baseError.errorBodyReader
        var value = InvalidTitleException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTargetException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTargetException {
        let reader = baseError.errorBodyReader
        var value = InvalidTargetException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidClientRequestTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidClientRequestTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidClientRequestTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdempotencyParameterMismatchException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IdempotencyParameterMismatchException {
        let reader = baseError.errorBodyReader
        var value = IdempotencyParameterMismatchException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReferenceTypeNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReferenceTypeNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = ReferenceTypeNotSupportedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TitleRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TitleRequiredException {
        let reader = baseError.errorBodyReader
        var value = TitleRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTargetsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTargetsException {
        let reader = baseError.errorBodyReader
        var value = InvalidTargetsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidReferenceNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidReferenceNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidReferenceNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TargetsRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TargetsRequiredException {
        let reader = baseError.errorBodyReader
        var value = TargetsRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NumberOfRulesExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NumberOfRulesExceededException {
        let reader = baseError.errorBodyReader
        var value = NumberOfRulesExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPullRequestIdException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPullRequestIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidPullRequestIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApprovalRuleNameRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApprovalRuleNameRequiredException {
        let reader = baseError.errorBodyReader
        var value = ApprovalRuleNameRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PullRequestAlreadyClosedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PullRequestAlreadyClosedException {
        let reader = baseError.errorBodyReader
        var value = PullRequestAlreadyClosedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidApprovalRuleNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidApprovalRuleNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidApprovalRuleNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidApprovalRuleContentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidApprovalRuleContentException {
        let reader = baseError.errorBodyReader
        var value = InvalidApprovalRuleContentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApprovalRuleContentRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApprovalRuleContentRequiredException {
        let reader = baseError.errorBodyReader
        var value = ApprovalRuleContentRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PullRequestDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PullRequestDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = PullRequestDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApprovalRuleNameAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApprovalRuleNameAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ApprovalRuleNameAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PullRequestIdRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PullRequestIdRequiredException {
        let reader = baseError.errorBodyReader
        var value = PullRequestIdRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSystemTagUsageException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSystemTagUsageException {
        let reader = baseError.errorBodyReader
        var value = InvalidSystemTagUsageException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationNotAllowedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationNotAllowedException {
        let reader = baseError.errorBodyReader
        var value = OperationNotAllowedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagPolicyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagPolicyException {
        let reader = baseError.errorBodyReader
        var value = TagPolicyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EncryptionKeyInvalidIdException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EncryptionKeyInvalidIdException {
        let reader = baseError.errorBodyReader
        var value = EncryptionKeyInvalidIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTagsMapException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTagsMapException {
        let reader = baseError.errorBodyReader
        var value = InvalidTagsMapException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = RepositoryLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryNameExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryNameExistsException {
        let reader = baseError.errorBodyReader
        var value = RepositoryNameExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRepositoryDescriptionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRepositoryDescriptionException {
        let reader = baseError.errorBodyReader
        var value = InvalidRepositoryDescriptionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EncryptionKeyInvalidUsageException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EncryptionKeyInvalidUsageException {
        let reader = baseError.errorBodyReader
        var value = EncryptionKeyInvalidUsageException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumConflictResolutionEntriesExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumConflictResolutionEntriesExceededException {
        let reader = baseError.errorBodyReader
        var value = MaximumConflictResolutionEntriesExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidReplacementTypeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidReplacementTypeException {
        let reader = baseError.errorBodyReader
        var value = InvalidReplacementTypeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentReferenceUpdateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConcurrentReferenceUpdateException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentReferenceUpdateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ManualMergeRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ManualMergeRequiredException {
        let reader = baseError.errorBodyReader
        var value = ManualMergeRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidReplacementContentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidReplacementContentException {
        let reader = baseError.errorBodyReader
        var value = InvalidReplacementContentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReplacementTypeRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReplacementTypeRequiredException {
        let reader = baseError.errorBodyReader
        var value = ReplacementTypeRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MultipleConflictResolutionEntriesException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MultipleConflictResolutionEntriesException {
        let reader = baseError.errorBodyReader
        var value = MultipleConflictResolutionEntriesException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReplacementContentRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReplacementContentRequiredException {
        let reader = baseError.errorBodyReader
        var value = ReplacementContentRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidConflictResolutionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidConflictResolutionException {
        let reader = baseError.errorBodyReader
        var value = InvalidConflictResolutionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApprovalRuleTemplateInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApprovalRuleTemplateInUseException {
        let reader = baseError.errorBodyReader
        var value = ApprovalRuleTemplateInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DefaultBranchCannotBeDeletedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DefaultBranchCannotBeDeletedException {
        let reader = baseError.errorBodyReader
        var value = DefaultBranchCannotBeDeletedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCommentIdException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCommentIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidCommentIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommentIdRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommentIdRequiredException {
        let reader = baseError.errorBodyReader
        var value = CommentIdRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommentDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommentDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = CommentDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommentDeletedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommentDeletedException {
        let reader = baseError.errorBodyReader
        var value = CommentDeletedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CannotDeleteApprovalRuleFromTemplateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CannotDeleteApprovalRuleFromTemplateException {
        let reader = baseError.errorBodyReader
        var value = CannotDeleteApprovalRuleFromTemplateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidMaxResultsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidMaxResultsException {
        let reader = baseError.errorBodyReader
        var value = InvalidMaxResultsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidActorArnException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidActorArnException {
        let reader = baseError.errorBodyReader
        var value = InvalidActorArnException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ActorDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ActorDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = ActorDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPullRequestEventTypeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPullRequestEventTypeException {
        let reader = baseError.errorBodyReader
        var value = InvalidPullRequestEventTypeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RevisionIdRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RevisionIdRequiredException {
        let reader = baseError.errorBodyReader
        var value = RevisionIdRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRevisionIdException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRevisionIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidRevisionIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RevisionNotCurrentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RevisionNotCurrentException {
        let reader = baseError.errorBodyReader
        var value = RevisionNotCurrentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BlobIdRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BlobIdRequiredException {
        let reader = baseError.errorBodyReader
        var value = BlobIdRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FileTooLargeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FileTooLargeException {
        let reader = baseError.errorBodyReader
        var value = FileTooLargeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BlobIdDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BlobIdDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = BlobIdDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidBlobIdException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidBlobIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidBlobIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidReactionUserArnException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidReactionUserArnException {
        let reader = baseError.errorBodyReader
        var value = InvalidReactionUserArnException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryNotAssociatedWithPullRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryNotAssociatedWithPullRequestException {
        let reader = baseError.errorBodyReader
        var value = RepositoryNotAssociatedWithPullRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommitIdDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommitIdDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = CommitIdDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PathDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PathDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = PathDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FolderDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FolderDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = FolderDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSourceCommitSpecifierException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSourceCommitSpecifierException {
        let reader = baseError.errorBodyReader
        var value = InvalidSourceCommitSpecifierException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDestinationCommitSpecifierException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDestinationCommitSpecifierException {
        let reader = baseError.errorBodyReader
        var value = InvalidDestinationCommitSpecifierException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAuthorArnException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidAuthorArnException {
        let reader = baseError.errorBodyReader
        var value = InvalidAuthorArnException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPullRequestStatusException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPullRequestStatusException {
        let reader = baseError.errorBodyReader
        var value = InvalidPullRequestStatusException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AuthorDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AuthorDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = AuthorDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOrderException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidOrderException {
        let reader = baseError.errorBodyReader
        var value = InvalidOrderException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSortByException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSortByException {
        let reader = baseError.errorBodyReader
        var value = InvalidSortByException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceArnRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceArnRequiredException {
        let reader = baseError.errorBodyReader
        var value = ResourceArnRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceArnException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResourceArnException {
        let reader = baseError.errorBodyReader
        var value = InvalidResourceArnException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTargetBranchException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTargetBranchException {
        let reader = baseError.errorBodyReader
        var value = InvalidTargetBranchException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PullRequestApprovalRulesNotSatisfiedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PullRequestApprovalRulesNotSatisfiedException {
        let reader = baseError.errorBodyReader
        var value = PullRequestApprovalRulesNotSatisfiedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TipOfSourceReferenceIsDifferentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TipOfSourceReferenceIsDifferentException {
        let reader = baseError.errorBodyReader
        var value = TipOfSourceReferenceIsDifferentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOverrideStatusException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidOverrideStatusException {
        let reader = baseError.errorBodyReader
        var value = InvalidOverrideStatusException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OverrideStatusRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OverrideStatusRequiredException {
        let reader = baseError.errorBodyReader
        var value = OverrideStatusRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OverrideAlreadySetException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OverrideAlreadySetException {
        let reader = baseError.errorBodyReader
        var value = OverrideAlreadySetException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommentContentRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommentContentRequiredException {
        let reader = baseError.errorBodyReader
        var value = CommentContentRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRelativeFileVersionEnumException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRelativeFileVersionEnumException {
        let reader = baseError.errorBodyReader
        var value = InvalidRelativeFileVersionEnumException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BeforeCommitIdAndAfterCommitIdAreSameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BeforeCommitIdAndAfterCommitIdAreSameException {
        let reader = baseError.errorBodyReader
        var value = BeforeCommitIdAndAfterCommitIdAreSameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommentContentSizeLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommentContentSizeLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = CommentContentSizeLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidFileLocationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidFileLocationException {
        let reader = baseError.errorBodyReader
        var value = InvalidFileLocationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidFilePositionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidFilePositionException {
        let reader = baseError.errorBodyReader
        var value = InvalidFilePositionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReactionLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReactionLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ReactionLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidReactionValueException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidReactionValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidReactionValueException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReactionValueRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReactionValueRequiredException {
        let reader = baseError.errorBodyReader
        var value = ReactionValueRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FileContentRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FileContentRequiredException {
        let reader = baseError.errorBodyReader
        var value = FileContentRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SameFileContentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SameFileContentException {
        let reader = baseError.errorBodyReader
        var value = SameFileContentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRepositoryTriggerBranchNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRepositoryTriggerBranchNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidRepositoryTriggerBranchNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumBranchesExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumBranchesExceededException {
        let reader = baseError.errorBodyReader
        var value = MaximumBranchesExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRepositoryTriggerCustomDataException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRepositoryTriggerCustomDataException {
        let reader = baseError.errorBodyReader
        var value = InvalidRepositoryTriggerCustomDataException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRepositoryTriggerNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRepositoryTriggerNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidRepositoryTriggerNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryTriggersListRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryTriggersListRequiredException {
        let reader = baseError.errorBodyReader
        var value = RepositoryTriggersListRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryTriggerNameRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryTriggerNameRequiredException {
        let reader = baseError.errorBodyReader
        var value = RepositoryTriggerNameRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryTriggerBranchNameListRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryTriggerBranchNameListRequiredException {
        let reader = baseError.errorBodyReader
        var value = RepositoryTriggerBranchNameListRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryTriggerEventsListRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryTriggerEventsListRequiredException {
        let reader = baseError.errorBodyReader
        var value = RepositoryTriggerEventsListRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRepositoryTriggerDestinationArnException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRepositoryTriggerDestinationArnException {
        let reader = baseError.errorBodyReader
        var value = InvalidRepositoryTriggerDestinationArnException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRepositoryTriggerEventsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRepositoryTriggerEventsException {
        let reader = baseError.errorBodyReader
        var value = InvalidRepositoryTriggerEventsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RepositoryTriggerDestinationArnRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RepositoryTriggerDestinationArnRequiredException {
        let reader = baseError.errorBodyReader
        var value = RepositoryTriggerDestinationArnRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRepositoryTriggerRegionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRepositoryTriggerRegionException {
        let reader = baseError.errorBodyReader
        var value = InvalidRepositoryTriggerRegionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumRepositoryTriggersExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumRepositoryTriggersExceededException {
        let reader = baseError.errorBodyReader
        var value = MaximumRepositoryTriggersExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagsMapRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagsMapRequiredException {
        let reader = baseError.errorBodyReader
        var value = TagsMapRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTagKeysListException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTagKeysListException {
        let reader = baseError.errorBodyReader
        var value = InvalidTagKeysListException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagKeysListRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagKeysListRequiredException {
        let reader = baseError.errorBodyReader
        var value = TagKeysListRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRuleContentSha256Exception {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRuleContentSha256Exception {
        let reader = baseError.errorBodyReader
        var value = InvalidRuleContentSha256Exception()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CommentNotCreatedByCallerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CommentNotCreatedByCallerException {
        let reader = baseError.errorBodyReader
        var value = CommentNotCreatedByCallerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApprovalRuleDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApprovalRuleDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = ApprovalRuleDoesNotExistException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CannotModifyApprovalRuleFromTemplateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CannotModifyApprovalRuleFromTemplateException {
        let reader = baseError.errorBodyReader
        var value = CannotModifyApprovalRuleFromTemplateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumNumberOfApprovalsExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumNumberOfApprovalsExceededException {
        let reader = baseError.errorBodyReader
        var value = MaximumNumberOfApprovalsExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidApprovalStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidApprovalStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidApprovalStateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PullRequestCannotBeApprovedByAuthorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PullRequestCannotBeApprovedByAuthorException {
        let reader = baseError.errorBodyReader
        var value = PullRequestCannotBeApprovedByAuthorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApprovalStateRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApprovalStateRequiredException {
        let reader = baseError.errorBodyReader
        var value = ApprovalStateRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPullRequestStatusUpdateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPullRequestStatusUpdateException {
        let reader = baseError.errorBodyReader
        var value = InvalidPullRequestStatusUpdateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PullRequestStatusRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PullRequestStatusRequiredException {
        let reader = baseError.errorBodyReader
        var value = PullRequestStatusRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EncryptionKeyRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EncryptionKeyRequiredException {
        let reader = baseError.errorBodyReader
        var value = EncryptionKeyRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.Conflict {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.Conflict {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.Conflict()
        value.conflictMetadata = try reader["conflictMetadata"].readIfPresent(with: CodeCommitClientTypes.ConflictMetadata.read(from:))
        value.mergeHunks = try reader["mergeHunks"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.MergeHunk.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CodeCommitClientTypes.MergeHunk {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.MergeHunk {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.MergeHunk()
        value.isConflict = try reader["isConflict"].readIfPresent() ?? false
        value.source = try reader["source"].readIfPresent(with: CodeCommitClientTypes.MergeHunkDetail.read(from:))
        value.destination = try reader["destination"].readIfPresent(with: CodeCommitClientTypes.MergeHunkDetail.read(from:))
        value.base = try reader["base"].readIfPresent(with: CodeCommitClientTypes.MergeHunkDetail.read(from:))
        return value
    }
}

extension CodeCommitClientTypes.MergeHunkDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.MergeHunkDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.MergeHunkDetail()
        value.startLine = try reader["startLine"].readIfPresent()
        value.endLine = try reader["endLine"].readIfPresent()
        value.hunkContent = try reader["hunkContent"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.ConflictMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.ConflictMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.ConflictMetadata()
        value.filePath = try reader["filePath"].readIfPresent()
        value.fileSizes = try reader["fileSizes"].readIfPresent(with: CodeCommitClientTypes.FileSizes.read(from:))
        value.fileModes = try reader["fileModes"].readIfPresent(with: CodeCommitClientTypes.FileModes.read(from:))
        value.objectTypes = try reader["objectTypes"].readIfPresent(with: CodeCommitClientTypes.ObjectTypes.read(from:))
        value.numberOfConflicts = try reader["numberOfConflicts"].readIfPresent() ?? 0
        value.isBinaryFile = try reader["isBinaryFile"].readIfPresent(with: CodeCommitClientTypes.IsBinaryFile.read(from:))
        value.contentConflict = try reader["contentConflict"].readIfPresent() ?? false
        value.fileModeConflict = try reader["fileModeConflict"].readIfPresent() ?? false
        value.objectTypeConflict = try reader["objectTypeConflict"].readIfPresent() ?? false
        value.mergeOperations = try reader["mergeOperations"].readIfPresent(with: CodeCommitClientTypes.MergeOperations.read(from:))
        return value
    }
}

extension CodeCommitClientTypes.MergeOperations {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.MergeOperations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.MergeOperations()
        value.source = try reader["source"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.IsBinaryFile {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.IsBinaryFile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.IsBinaryFile()
        value.source = try reader["source"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        value.base = try reader["base"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.ObjectTypes {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.ObjectTypes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.ObjectTypes()
        value.source = try reader["source"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        value.base = try reader["base"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.FileModes {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.FileModes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.FileModes()
        value.source = try reader["source"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        value.base = try reader["base"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.FileSizes {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.FileSizes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.FileSizes()
        value.source = try reader["source"].readIfPresent() ?? 0
        value.destination = try reader["destination"].readIfPresent() ?? 0
        value.base = try reader["base"].readIfPresent() ?? 0
        return value
    }
}

extension CodeCommitClientTypes.BatchDescribeMergeConflictsError {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.BatchDescribeMergeConflictsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.BatchDescribeMergeConflictsError()
        value.filePath = try reader["filePath"].readIfPresent() ?? ""
        value.exceptionName = try reader["exceptionName"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.Commit {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.Commit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.Commit()
        value.commitId = try reader["commitId"].readIfPresent()
        value.treeId = try reader["treeId"].readIfPresent()
        value.parents = try reader["parents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["message"].readIfPresent()
        value.author = try reader["author"].readIfPresent(with: CodeCommitClientTypes.UserInfo.read(from:))
        value.committer = try reader["committer"].readIfPresent(with: CodeCommitClientTypes.UserInfo.read(from:))
        value.additionalData = try reader["additionalData"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.UserInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.UserInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.UserInfo()
        value.name = try reader["name"].readIfPresent()
        value.email = try reader["email"].readIfPresent()
        value.date = try reader["date"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.BatchGetCommitsError {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.BatchGetCommitsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.BatchGetCommitsError()
        value.commitId = try reader["commitId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.RepositoryMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.RepositoryMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.RepositoryMetadata()
        value.accountId = try reader["accountId"].readIfPresent()
        value.repositoryId = try reader["repositoryId"].readIfPresent()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.repositoryDescription = try reader["repositoryDescription"].readIfPresent()
        value.defaultBranch = try reader["defaultBranch"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.cloneUrlHttp = try reader["cloneUrlHttp"].readIfPresent()
        value.cloneUrlSsh = try reader["cloneUrlSsh"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.BatchGetRepositoriesError {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.BatchGetRepositoriesError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.BatchGetRepositoriesError()
        value.repositoryId = try reader["repositoryId"].readIfPresent()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.ApprovalRuleTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.ApprovalRuleTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.ApprovalRuleTemplate()
        value.approvalRuleTemplateId = try reader["approvalRuleTemplateId"].readIfPresent()
        value.approvalRuleTemplateName = try reader["approvalRuleTemplateName"].readIfPresent()
        value.approvalRuleTemplateDescription = try reader["approvalRuleTemplateDescription"].readIfPresent()
        value.approvalRuleTemplateContent = try reader["approvalRuleTemplateContent"].readIfPresent()
        value.ruleContentSha256 = try reader["ruleContentSha256"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedUser = try reader["lastModifiedUser"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.FileMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.FileMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.FileMetadata()
        value.absolutePath = try reader["absolutePath"].readIfPresent()
        value.blobId = try reader["blobId"].readIfPresent()
        value.fileMode = try reader["fileMode"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.PullRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.PullRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.PullRequest()
        value.pullRequestId = try reader["pullRequestId"].readIfPresent()
        value.title = try reader["title"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastActivityDate = try reader["lastActivityDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pullRequestStatus = try reader["pullRequestStatus"].readIfPresent()
        value.authorArn = try reader["authorArn"].readIfPresent()
        value.pullRequestTargets = try reader["pullRequestTargets"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.PullRequestTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.approvalRules = try reader["approvalRules"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.ApprovalRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CodeCommitClientTypes.ApprovalRule {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.ApprovalRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.ApprovalRule()
        value.approvalRuleId = try reader["approvalRuleId"].readIfPresent()
        value.approvalRuleName = try reader["approvalRuleName"].readIfPresent()
        value.approvalRuleContent = try reader["approvalRuleContent"].readIfPresent()
        value.ruleContentSha256 = try reader["ruleContentSha256"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedUser = try reader["lastModifiedUser"].readIfPresent()
        value.originApprovalRuleTemplate = try reader["originApprovalRuleTemplate"].readIfPresent(with: CodeCommitClientTypes.OriginApprovalRuleTemplate.read(from:))
        return value
    }
}

extension CodeCommitClientTypes.OriginApprovalRuleTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.OriginApprovalRuleTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.OriginApprovalRuleTemplate()
        value.approvalRuleTemplateId = try reader["approvalRuleTemplateId"].readIfPresent()
        value.approvalRuleTemplateName = try reader["approvalRuleTemplateName"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.PullRequestTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.PullRequestTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.PullRequestTarget()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.sourceReference = try reader["sourceReference"].readIfPresent()
        value.destinationReference = try reader["destinationReference"].readIfPresent()
        value.destinationCommit = try reader["destinationCommit"].readIfPresent()
        value.sourceCommit = try reader["sourceCommit"].readIfPresent()
        value.mergeBase = try reader["mergeBase"].readIfPresent()
        value.mergeMetadata = try reader["mergeMetadata"].readIfPresent(with: CodeCommitClientTypes.MergeMetadata.read(from:))
        return value
    }
}

extension CodeCommitClientTypes.MergeMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.MergeMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.MergeMetadata()
        value.isMerged = try reader["isMerged"].readIfPresent() ?? false
        value.mergedBy = try reader["mergedBy"].readIfPresent()
        value.mergeCommitId = try reader["mergeCommitId"].readIfPresent()
        value.mergeOption = try reader["mergeOption"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.BranchInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.BranchInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.BranchInfo()
        value.branchName = try reader["branchName"].readIfPresent()
        value.commitId = try reader["commitId"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.Comment {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.Comment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.Comment()
        value.commentId = try reader["commentId"].readIfPresent()
        value.content = try reader["content"].readIfPresent()
        value.inReplyTo = try reader["inReplyTo"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.authorArn = try reader["authorArn"].readIfPresent()
        value.deleted = try reader["deleted"].readIfPresent() ?? false
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.callerReactions = try reader["callerReactions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.reactionCounts = try reader["reactionCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CodeCommitClientTypes.PullRequestEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.PullRequestEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.PullRequestEvent()
        value.pullRequestId = try reader["pullRequestId"].readIfPresent()
        value.eventDate = try reader["eventDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pullRequestEventType = try reader["pullRequestEventType"].readIfPresent()
        value.actorArn = try reader["actorArn"].readIfPresent()
        value.pullRequestCreatedEventMetadata = try reader["pullRequestCreatedEventMetadata"].readIfPresent(with: CodeCommitClientTypes.PullRequestCreatedEventMetadata.read(from:))
        value.pullRequestStatusChangedEventMetadata = try reader["pullRequestStatusChangedEventMetadata"].readIfPresent(with: CodeCommitClientTypes.PullRequestStatusChangedEventMetadata.read(from:))
        value.pullRequestSourceReferenceUpdatedEventMetadata = try reader["pullRequestSourceReferenceUpdatedEventMetadata"].readIfPresent(with: CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata.read(from:))
        value.pullRequestMergedStateChangedEventMetadata = try reader["pullRequestMergedStateChangedEventMetadata"].readIfPresent(with: CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata.read(from:))
        value.approvalRuleEventMetadata = try reader["approvalRuleEventMetadata"].readIfPresent(with: CodeCommitClientTypes.ApprovalRuleEventMetadata.read(from:))
        value.approvalStateChangedEventMetadata = try reader["approvalStateChangedEventMetadata"].readIfPresent(with: CodeCommitClientTypes.ApprovalStateChangedEventMetadata.read(from:))
        value.approvalRuleOverriddenEventMetadata = try reader["approvalRuleOverriddenEventMetadata"].readIfPresent(with: CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata.read(from:))
        return value
    }
}

extension CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata()
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.overrideStatus = try reader["overrideStatus"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.ApprovalStateChangedEventMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.ApprovalStateChangedEventMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.ApprovalStateChangedEventMetadata()
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.approvalStatus = try reader["approvalStatus"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.ApprovalRuleEventMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.ApprovalRuleEventMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.ApprovalRuleEventMetadata()
        value.approvalRuleName = try reader["approvalRuleName"].readIfPresent()
        value.approvalRuleId = try reader["approvalRuleId"].readIfPresent()
        value.approvalRuleContent = try reader["approvalRuleContent"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.destinationReference = try reader["destinationReference"].readIfPresent()
        value.mergeMetadata = try reader["mergeMetadata"].readIfPresent(with: CodeCommitClientTypes.MergeMetadata.read(from:))
        return value
    }
}

extension CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.beforeCommitId = try reader["beforeCommitId"].readIfPresent()
        value.afterCommitId = try reader["afterCommitId"].readIfPresent()
        value.mergeBase = try reader["mergeBase"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.PullRequestStatusChangedEventMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.PullRequestStatusChangedEventMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.PullRequestStatusChangedEventMetadata()
        value.pullRequestStatus = try reader["pullRequestStatus"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.PullRequestCreatedEventMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.PullRequestCreatedEventMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.PullRequestCreatedEventMetadata()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.sourceCommitId = try reader["sourceCommitId"].readIfPresent()
        value.destinationCommitId = try reader["destinationCommitId"].readIfPresent()
        value.mergeBase = try reader["mergeBase"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.Evaluation {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.Evaluation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.Evaluation()
        value.approved = try reader["approved"].readIfPresent() ?? false
        value.overridden = try reader["overridden"].readIfPresent() ?? false
        value.approvalRulesSatisfied = try reader["approvalRulesSatisfied"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.approvalRulesNotSatisfied = try reader["approvalRulesNotSatisfied"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CodeCommitClientTypes.ReactionForComment {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.ReactionForComment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.ReactionForComment()
        value.reaction = try reader["reaction"].readIfPresent(with: CodeCommitClientTypes.ReactionValueFormats.read(from:))
        value.reactionUsers = try reader["reactionUsers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.reactionsFromDeletedUsersCount = try reader["reactionsFromDeletedUsersCount"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.ReactionValueFormats {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.ReactionValueFormats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.ReactionValueFormats()
        value.emoji = try reader["emoji"].readIfPresent()
        value.shortCode = try reader["shortCode"].readIfPresent()
        value.unicode = try reader["unicode"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.CommentsForComparedCommit {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.CommentsForComparedCommit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.CommentsForComparedCommit()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.beforeCommitId = try reader["beforeCommitId"].readIfPresent()
        value.afterCommitId = try reader["afterCommitId"].readIfPresent()
        value.beforeBlobId = try reader["beforeBlobId"].readIfPresent()
        value.afterBlobId = try reader["afterBlobId"].readIfPresent()
        value.location = try reader["location"].readIfPresent(with: CodeCommitClientTypes.Location.read(from:))
        value.comments = try reader["comments"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.Comment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CodeCommitClientTypes.Location {

    static func write(value: CodeCommitClientTypes.Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filePath"].write(value.filePath)
        try writer["filePosition"].write(value.filePosition)
        try writer["relativeFileVersion"].write(value.relativeFileVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.Location()
        value.filePath = try reader["filePath"].readIfPresent()
        value.filePosition = try reader["filePosition"].readIfPresent()
        value.relativeFileVersion = try reader["relativeFileVersion"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.CommentsForPullRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.CommentsForPullRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.CommentsForPullRequest()
        value.pullRequestId = try reader["pullRequestId"].readIfPresent()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.beforeCommitId = try reader["beforeCommitId"].readIfPresent()
        value.afterCommitId = try reader["afterCommitId"].readIfPresent()
        value.beforeBlobId = try reader["beforeBlobId"].readIfPresent()
        value.afterBlobId = try reader["afterBlobId"].readIfPresent()
        value.location = try reader["location"].readIfPresent(with: CodeCommitClientTypes.Location.read(from:))
        value.comments = try reader["comments"].readListIfPresent(memberReadingClosure: CodeCommitClientTypes.Comment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CodeCommitClientTypes.Difference {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.Difference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.Difference()
        value.beforeBlob = try reader["beforeBlob"].readIfPresent(with: CodeCommitClientTypes.BlobMetadata.read(from:))
        value.afterBlob = try reader["afterBlob"].readIfPresent(with: CodeCommitClientTypes.BlobMetadata.read(from:))
        value.changeType = try reader["changeType"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.BlobMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.BlobMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.BlobMetadata()
        value.blobId = try reader["blobId"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.mode = try reader["mode"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.Folder {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.Folder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.Folder()
        value.treeId = try reader["treeId"].readIfPresent()
        value.absolutePath = try reader["absolutePath"].readIfPresent()
        value.relativePath = try reader["relativePath"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.File {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.File {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.File()
        value.blobId = try reader["blobId"].readIfPresent()
        value.absolutePath = try reader["absolutePath"].readIfPresent()
        value.relativePath = try reader["relativePath"].readIfPresent()
        value.fileMode = try reader["fileMode"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.SymbolicLink {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.SymbolicLink {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.SymbolicLink()
        value.blobId = try reader["blobId"].readIfPresent()
        value.absolutePath = try reader["absolutePath"].readIfPresent()
        value.relativePath = try reader["relativePath"].readIfPresent()
        value.fileMode = try reader["fileMode"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.SubModule {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.SubModule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.SubModule()
        value.commitId = try reader["commitId"].readIfPresent()
        value.absolutePath = try reader["absolutePath"].readIfPresent()
        value.relativePath = try reader["relativePath"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.Approval {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.Approval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.Approval()
        value.userArn = try reader["userArn"].readIfPresent()
        value.approvalState = try reader["approvalState"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.RepositoryTrigger {

    static func write(value: CodeCommitClientTypes.RepositoryTrigger?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branches"].writeList(value.branches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["customData"].write(value.customData)
        try writer["destinationArn"].write(value.destinationArn)
        try writer["events"].writeList(value.events, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CodeCommitClientTypes.RepositoryTriggerEventEnum>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.RepositoryTrigger {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.RepositoryTrigger()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.destinationArn = try reader["destinationArn"].readIfPresent() ?? ""
        value.customData = try reader["customData"].readIfPresent()
        value.branches = try reader["branches"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CodeCommitClientTypes.RepositoryTriggerEventEnum>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CodeCommitClientTypes.FileVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.FileVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.FileVersion()
        value.commit = try reader["commit"].readIfPresent(with: CodeCommitClientTypes.Commit.read(from:))
        value.blobId = try reader["blobId"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.revisionChildren = try reader["revisionChildren"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CodeCommitClientTypes.RepositoryNameIdPair {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.RepositoryNameIdPair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.RepositoryNameIdPair()
        value.repositoryName = try reader["repositoryName"].readIfPresent()
        value.repositoryId = try reader["repositoryId"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.RepositoryTriggerExecutionFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeCommitClientTypes.RepositoryTriggerExecutionFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeCommitClientTypes.RepositoryTriggerExecutionFailure()
        value.trigger = try reader["trigger"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension CodeCommitClientTypes.PutFileEntry {

    static func write(value: CodeCommitClientTypes.PutFileEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileContent"].write(value.fileContent)
        try writer["fileMode"].write(value.fileMode)
        try writer["filePath"].write(value.filePath)
        try writer["sourceFile"].write(value.sourceFile, with: CodeCommitClientTypes.SourceFileSpecifier.write(value:to:))
    }
}

extension CodeCommitClientTypes.SourceFileSpecifier {

    static func write(value: CodeCommitClientTypes.SourceFileSpecifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filePath"].write(value.filePath)
        try writer["isMove"].write(value.isMove)
    }
}

extension CodeCommitClientTypes.DeleteFileEntry {

    static func write(value: CodeCommitClientTypes.DeleteFileEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filePath"].write(value.filePath)
    }
}

extension CodeCommitClientTypes.SetFileModeEntry {

    static func write(value: CodeCommitClientTypes.SetFileModeEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileMode"].write(value.fileMode)
        try writer["filePath"].write(value.filePath)
    }
}

extension CodeCommitClientTypes.Target {

    static func write(value: CodeCommitClientTypes.Target?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationReference"].write(value.destinationReference)
        try writer["repositoryName"].write(value.repositoryName)
        try writer["sourceReference"].write(value.sourceReference)
    }
}

extension CodeCommitClientTypes.ConflictResolution {

    static func write(value: CodeCommitClientTypes.ConflictResolution?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deleteFiles"].writeList(value.deleteFiles, memberWritingClosure: CodeCommitClientTypes.DeleteFileEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["replaceContents"].writeList(value.replaceContents, memberWritingClosure: CodeCommitClientTypes.ReplaceContentEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["setFileModes"].writeList(value.setFileModes, memberWritingClosure: CodeCommitClientTypes.SetFileModeEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CodeCommitClientTypes.ReplaceContentEntry {

    static func write(value: CodeCommitClientTypes.ReplaceContentEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content)
        try writer["fileMode"].write(value.fileMode)
        try writer["filePath"].write(value.filePath)
        try writer["replacementType"].write(value.replacementType)
    }
}

public enum CodeCommitClientTypes {}
