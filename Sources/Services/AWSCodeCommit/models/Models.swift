// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActorDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ActorDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified Amazon Resource Name (ARN) does not exist in the Amazon Web Services account.
public struct ActorDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ActorDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ActorDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ActorDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.Approval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalState
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalState = self.approvalState {
            try encodeContainer.encode(approvalState.rawValue, forKey: .approvalState)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let approvalStateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalState.self, forKey: .approvalState)
        approvalState = approvalStateDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a specific approval on a pull request.
    public struct Approval: Swift.Equatable {
        /// The state of the approval, APPROVE or REVOKE. REVOKE states are not stored.
        public var approvalState: CodeCommitClientTypes.ApprovalState?
        /// The Amazon Resource Name (ARN) of the user.
        public var userArn: Swift.String?

        public init(
            approvalState: CodeCommitClientTypes.ApprovalState? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.approvalState = approvalState
            self.userArn = userArn
        }
    }

}

extension CodeCommitClientTypes.ApprovalRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleContent
        case approvalRuleId
        case approvalRuleName
        case creationDate
        case lastModifiedDate
        case lastModifiedUser
        case originApprovalRuleTemplate
        case ruleContentSha256
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleContent = self.approvalRuleContent {
            try encodeContainer.encode(approvalRuleContent, forKey: .approvalRuleContent)
        }
        if let approvalRuleId = self.approvalRuleId {
            try encodeContainer.encode(approvalRuleId, forKey: .approvalRuleId)
        }
        if let approvalRuleName = self.approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = self.lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let originApprovalRuleTemplate = self.originApprovalRuleTemplate {
            try encodeContainer.encode(originApprovalRuleTemplate, forKey: .originApprovalRuleTemplate)
        }
        if let ruleContentSha256 = self.ruleContentSha256 {
            try encodeContainer.encode(ruleContentSha256, forKey: .ruleContentSha256)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleId)
        approvalRuleId = approvalRuleIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let approvalRuleContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleContent)
        approvalRuleContent = approvalRuleContentDecoded
        let ruleContentSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleContentSha256)
        ruleContentSha256 = ruleContentSha256Decoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let originApprovalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.OriginApprovalRuleTemplate.self, forKey: .originApprovalRuleTemplate)
        originApprovalRuleTemplate = originApprovalRuleTemplateDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about an approval rule.
    public struct ApprovalRule: Swift.Equatable {
        /// The content of the approval rule.
        public var approvalRuleContent: Swift.String?
        /// The system-generated ID of the approval rule.
        public var approvalRuleId: Swift.String?
        /// The name of the approval rule.
        public var approvalRuleName: Swift.String?
        /// The date the approval rule was created, in timestamp format.
        public var creationDate: ClientRuntime.Date?
        /// The date the approval rule was most recently changed, in timestamp format.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who made the most recent changes to the approval rule.
        public var lastModifiedUser: Swift.String?
        /// The approval rule template used to create the rule.
        public var originApprovalRuleTemplate: CodeCommitClientTypes.OriginApprovalRuleTemplate?
        /// The SHA-256 hash signature for the content of the approval rule.
        public var ruleContentSha256: Swift.String?

        public init(
            approvalRuleContent: Swift.String? = nil,
            approvalRuleId: Swift.String? = nil,
            approvalRuleName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            originApprovalRuleTemplate: CodeCommitClientTypes.OriginApprovalRuleTemplate? = nil,
            ruleContentSha256: Swift.String? = nil
        )
        {
            self.approvalRuleContent = approvalRuleContent
            self.approvalRuleId = approvalRuleId
            self.approvalRuleName = approvalRuleName
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.originApprovalRuleTemplate = originApprovalRuleTemplate
            self.ruleContentSha256 = ruleContentSha256
        }
    }

}

extension ApprovalRuleContentRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApprovalRuleContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.
public struct ApprovalRuleContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleContentRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApprovalRuleContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApprovalRuleDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified approval rule does not exist.
public struct ApprovalRuleDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApprovalRuleDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.ApprovalRuleEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleContent
        case approvalRuleId
        case approvalRuleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleContent = self.approvalRuleContent {
            try encodeContainer.encode(approvalRuleContent, forKey: .approvalRuleContent)
        }
        if let approvalRuleId = self.approvalRuleId {
            try encodeContainer.encode(approvalRuleId, forKey: .approvalRuleId)
        }
        if let approvalRuleName = self.approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let approvalRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleId)
        approvalRuleId = approvalRuleIdDecoded
        let approvalRuleContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleContent)
        approvalRuleContent = approvalRuleContentDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about an event for an approval rule.
    public struct ApprovalRuleEventMetadata: Swift.Equatable {
        /// The content of the approval rule.
        public var approvalRuleContent: Swift.String?
        /// The system-generated ID of the approval rule.
        public var approvalRuleId: Swift.String?
        /// The name of the approval rule.
        public var approvalRuleName: Swift.String?

        public init(
            approvalRuleContent: Swift.String? = nil,
            approvalRuleId: Swift.String? = nil,
            approvalRuleName: Swift.String? = nil
        )
        {
            self.approvalRuleContent = approvalRuleContent
            self.approvalRuleId = approvalRuleId
            self.approvalRuleName = approvalRuleName
        }
    }

}

extension ApprovalRuleNameAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApprovalRuleNameAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An approval rule with that name already exists. Approval rule names must be unique within the scope of a pull request.
public struct ApprovalRuleNameAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleNameAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApprovalRuleNameAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleNameAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleNameRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApprovalRuleNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An approval rule name is required, but was not specified.
public struct ApprovalRuleNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleNameRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApprovalRuleNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideStatus
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideStatus = self.overrideStatus {
            try encodeContainer.encode(overrideStatus.rawValue, forKey: .overrideStatus)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let overrideStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.OverrideStatus.self, forKey: .overrideStatus)
        overrideStatus = overrideStatusDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about an override event for approval rules for a pull request.
    public struct ApprovalRuleOverriddenEventMetadata: Swift.Equatable {
        /// The status of the override event.
        public var overrideStatus: CodeCommitClientTypes.OverrideStatus?
        /// The revision ID of the pull request when the override event occurred.
        public var revisionId: Swift.String?

        public init(
            overrideStatus: CodeCommitClientTypes.OverrideStatus? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.overrideStatus = overrideStatus
            self.revisionId = revisionId
        }
    }

}

extension CodeCommitClientTypes.ApprovalRuleTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateContent
        case approvalRuleTemplateDescription
        case approvalRuleTemplateId
        case approvalRuleTemplateName
        case creationDate
        case lastModifiedDate
        case lastModifiedUser
        case ruleContentSha256
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateContent = self.approvalRuleTemplateContent {
            try encodeContainer.encode(approvalRuleTemplateContent, forKey: .approvalRuleTemplateContent)
        }
        if let approvalRuleTemplateDescription = self.approvalRuleTemplateDescription {
            try encodeContainer.encode(approvalRuleTemplateDescription, forKey: .approvalRuleTemplateDescription)
        }
        if let approvalRuleTemplateId = self.approvalRuleTemplateId {
            try encodeContainer.encode(approvalRuleTemplateId, forKey: .approvalRuleTemplateId)
        }
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = self.lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let ruleContentSha256 = self.ruleContentSha256 {
            try encodeContainer.encode(ruleContentSha256, forKey: .ruleContentSha256)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateId)
        approvalRuleTemplateId = approvalRuleTemplateIdDecoded
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let approvalRuleTemplateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateDescription)
        approvalRuleTemplateDescription = approvalRuleTemplateDescriptionDecoded
        let approvalRuleTemplateContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateContent)
        approvalRuleTemplateContent = approvalRuleTemplateContentDecoded
        let ruleContentSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleContentSha256)
        ruleContentSha256 = ruleContentSha256Decoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about an approval rule template.
    public struct ApprovalRuleTemplate: Swift.Equatable {
        /// The content of the approval rule template.
        public var approvalRuleTemplateContent: Swift.String?
        /// The description of the approval rule template.
        public var approvalRuleTemplateDescription: Swift.String?
        /// The system-generated ID of the approval rule template.
        public var approvalRuleTemplateId: Swift.String?
        /// The name of the approval rule template.
        public var approvalRuleTemplateName: Swift.String?
        /// The date the approval rule template was created, in timestamp format.
        public var creationDate: ClientRuntime.Date?
        /// The date the approval rule template was most recently changed, in timestamp format.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who made the most recent changes to the approval rule template.
        public var lastModifiedUser: Swift.String?
        /// The SHA-256 hash signature for the content of the approval rule template.
        public var ruleContentSha256: Swift.String?

        public init(
            approvalRuleTemplateContent: Swift.String? = nil,
            approvalRuleTemplateDescription: Swift.String? = nil,
            approvalRuleTemplateId: Swift.String? = nil,
            approvalRuleTemplateName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            ruleContentSha256: Swift.String? = nil
        )
        {
            self.approvalRuleTemplateContent = approvalRuleTemplateContent
            self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
            self.approvalRuleTemplateId = approvalRuleTemplateId
            self.approvalRuleTemplateName = approvalRuleTemplateName
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.ruleContentSha256 = ruleContentSha256
        }
    }

}

extension ApprovalRuleTemplateContentRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApprovalRuleTemplateContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.
public struct ApprovalRuleTemplateContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleTemplateContentRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApprovalRuleTemplateContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleTemplateContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApprovalRuleTemplateDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the Amazon Web Services Region where the template was created, and then try again.
public struct ApprovalRuleTemplateDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleTemplateDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApprovalRuleTemplateDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleTemplateDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApprovalRuleTemplateInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove all associations, and then try again.
public struct ApprovalRuleTemplateInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleTemplateInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApprovalRuleTemplateInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleTemplateInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateNameAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApprovalRuleTemplateNameAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot create an approval rule template with that name because a template with that name already exists in this Amazon Web Services Region for your Amazon Web Services account. Approval rule template names must be unique.
public struct ApprovalRuleTemplateNameAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleTemplateNameAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApprovalRuleTemplateNameAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleTemplateNameAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateNameRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApprovalRuleTemplateNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An approval rule template name is required, but was not specified.
public struct ApprovalRuleTemplateNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalRuleTemplateNameRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApprovalRuleTemplateNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleTemplateNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum ApprovalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approve
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [ApprovalState] {
            return [
                .approve,
                .revoke,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approve: return "APPROVE"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApprovalState(rawValue: rawValue) ?? ApprovalState.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.ApprovalStateChangedEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalStatus
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalStatus = self.approvalStatus {
            try encodeContainer.encode(approvalStatus.rawValue, forKey: .approvalStatus)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let approvalStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalState.self, forKey: .approvalStatus)
        approvalStatus = approvalStatusDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a change in the approval state for a pull request.
    public struct ApprovalStateChangedEventMetadata: Swift.Equatable {
        /// The approval status for the pull request.
        public var approvalStatus: CodeCommitClientTypes.ApprovalState?
        /// The revision ID of the pull request when the approval state changed.
        public var revisionId: Swift.String?

        public init(
            approvalStatus: CodeCommitClientTypes.ApprovalState? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.approvalStatus = approvalStatus
            self.revisionId = revisionId
        }
    }

}

extension ApprovalStateRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApprovalStateRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An approval state is required, but was not specified.
public struct ApprovalStateRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApprovalStateRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApprovalStateRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalStateRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateApprovalRuleTemplateWithRepositoryInput: Swift.Equatable {
    /// The name for the approval rule template.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The name of the repository that you want to associate with the template.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryName = repositoryName
    }
}

struct AssociateApprovalRuleTemplateWithRepositoryInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let repositoryName: Swift.String?
}

extension AssociateApprovalRuleTemplateWithRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateApprovalRuleTemplateWithRepositoryOutput: Swift.Equatable {

    public init() { }
}

enum AssociateApprovalRuleTemplateWithRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateDoesNotExistException": return try await ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumRuleTemplatesAssociatedWithRepositoryException": return try await MaximumRuleTemplatesAssociatedWithRepositoryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuthorDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AuthorDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified Amazon Resource Name (ARN) does not exist in the Amazon Web Services account.
public struct AuthorDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AuthorDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AuthorDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about errors in a BatchAssociateApprovalRuleTemplateWithRepositories operation.
    public struct BatchAssociateApprovalRuleTemplateWithRepositoriesError: Swift.Equatable {
        /// An error code that specifies whether the repository name was not valid or not found.
        public var errorCode: Swift.String?
        /// An error message that provides details about why the repository name was not found or not valid.
        public var errorMessage: Swift.String?
        /// The name of the repository where the association was not made.
        public var repositoryName: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.repositoryName = repositoryName
        }
    }

}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositoryname0 in repositoryNames {
                try repositoryNamesContainer.encode(repositoryname0)
            }
        }
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesInput: Swift.Equatable {
    /// The name of the template you want to associate with one or more repositories.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The names of the repositories you want to associate with the template. The length constraint limit is for each string in the array. The array itself can be empty.
    /// This member is required.
    public var repositoryNames: [Swift.String]?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryNames = repositoryNames
    }
}

struct BatchAssociateApprovalRuleTemplateWithRepositoriesInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let repositoryNames: [Swift.String]?
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchAssociateApprovalRuleTemplateWithRepositoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.associatedRepositoryNames = output.associatedRepositoryNames
            self.errors = output.errors
        } else {
            self.associatedRepositoryNames = nil
            self.errors = nil
        }
    }
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesOutput: Swift.Equatable {
    /// A list of names of the repositories that have been associated with the template.
    /// This member is required.
    public var associatedRepositoryNames: [Swift.String]?
    /// A list of any errors that might have occurred while attempting to create the association between the template and the repositories.
    /// This member is required.
    public var errors: [CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]?

    public init(
        associatedRepositoryNames: [Swift.String]? = nil,
        errors: [CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]? = nil
    )
    {
        self.associatedRepositoryNames = associatedRepositoryNames
        self.errors = errors
    }
}

struct BatchAssociateApprovalRuleTemplateWithRepositoriesOutputBody: Swift.Equatable {
    let associatedRepositoryNames: [Swift.String]?
    let errors: [CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]?
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedRepositoryNames
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedRepositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedRepositoryNames)
        var associatedRepositoryNamesDecoded0:[Swift.String]? = nil
        if let associatedRepositoryNamesContainer = associatedRepositoryNamesContainer {
            associatedRepositoryNamesDecoded0 = [Swift.String]()
            for string0 in associatedRepositoryNamesContainer {
                if let string0 = string0 {
                    associatedRepositoryNamesDecoded0?.append(string0)
                }
            }
        }
        associatedRepositoryNames = associatedRepositoryNamesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError?].self, forKey: .errors)
        var errorsDecoded0:[CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateDoesNotExistException": return try await ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumRepositoryNamesExceededException": return try await MaximumRepositoryNamesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNamesRequiredException": return try await RepositoryNamesRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.BatchDescribeMergeConflictsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionName
        case filePath
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptionName = self.exceptionName {
            try encodeContainer.encode(exceptionName, forKey: .exceptionName)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let exceptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionName)
        exceptionName = exceptionNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about errors in a BatchDescribeMergeConflicts operation.
    public struct BatchDescribeMergeConflictsError: Swift.Equatable {
        /// The name of the exception.
        /// This member is required.
        public var exceptionName: Swift.String?
        /// The path to the file.
        /// This member is required.
        public var filePath: Swift.String?
        /// The message provided by the exception.
        /// This member is required.
        public var message: Swift.String?

        public init(
            exceptionName: Swift.String? = nil,
            filePath: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.exceptionName = exceptionName
            self.filePath = filePath
            self.message = message
        }
    }

}

extension BatchDescribeMergeConflictsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePaths
        case maxConflictFiles
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let filePaths = filePaths {
            var filePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filePaths)
            for path0 in filePaths {
                try filePathsContainer.encode(path0)
            }
        }
        if let maxConflictFiles = self.maxConflictFiles {
            try encodeContainer.encode(maxConflictFiles, forKey: .maxConflictFiles)
        }
        if let maxMergeHunks = self.maxMergeHunks {
            try encodeContainer.encode(maxMergeHunks, forKey: .maxMergeHunks)
        }
        if let mergeOption = self.mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension BatchDescribeMergeConflictsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDescribeMergeConflictsInput: Swift.Equatable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The path of the target files used to describe the conflicts. If not specified, the default is all conflict files.
    public var filePaths: [Swift.String]?
    /// The maximum number of files to include in the output.
    public var maxConflictFiles: Swift.Int?
    /// The maximum number of merge hunks to include in the output.
    public var maxMergeHunks: Swift.Int?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository that contains the merge conflicts you want to review.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        filePaths: [Swift.String]? = nil,
        maxConflictFiles: Swift.Int? = nil,
        maxMergeHunks: Swift.Int? = nil,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.filePaths = filePaths
        self.maxConflictFiles = maxConflictFiles
        self.maxMergeHunks = maxMergeHunks
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct BatchDescribeMergeConflictsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    let maxMergeHunks: Swift.Int?
    let maxConflictFiles: Swift.Int?
    let filePaths: [Swift.String]?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let nextToken: Swift.String?
}

extension BatchDescribeMergeConflictsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePaths
        case maxConflictFiles
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let maxMergeHunksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxMergeHunks)
        maxMergeHunks = maxMergeHunksDecoded
        let maxConflictFilesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConflictFiles)
        maxConflictFiles = maxConflictFilesDecoded
        let filePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filePaths)
        var filePathsDecoded0:[Swift.String]? = nil
        if let filePathsContainer = filePathsContainer {
            filePathsDecoded0 = [Swift.String]()
            for string0 in filePathsContainer {
                if let string0 = string0 {
                    filePathsDecoded0?.append(string0)
                }
            }
        }
        filePaths = filePathsDecoded0
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchDescribeMergeConflictsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDescribeMergeConflictsOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseCommitId = output.baseCommitId
            self.conflicts = output.conflicts
            self.destinationCommitId = output.destinationCommitId
            self.errors = output.errors
            self.nextToken = output.nextToken
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.conflicts = nil
            self.destinationCommitId = nil
            self.errors = nil
            self.nextToken = nil
            self.sourceCommitId = nil
        }
    }
}

public struct BatchDescribeMergeConflictsOutput: Swift.Equatable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// A list of conflicts for each file, including the conflict metadata and the hunks of the differences between the files.
    /// This member is required.
    public var conflicts: [CodeCommitClientTypes.Conflict]?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// A list of any errors returned while describing the merge conflicts for each file.
    public var errors: [CodeCommitClientTypes.BatchDescribeMergeConflictsError]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init(
        baseCommitId: Swift.String? = nil,
        conflicts: [CodeCommitClientTypes.Conflict]? = nil,
        destinationCommitId: Swift.String? = nil,
        errors: [CodeCommitClientTypes.BatchDescribeMergeConflictsError]? = nil,
        nextToken: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflicts = conflicts
        self.destinationCommitId = destinationCommitId
        self.errors = errors
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

struct BatchDescribeMergeConflictsOutputBody: Swift.Equatable {
    let conflicts: [CodeCommitClientTypes.Conflict]?
    let nextToken: Swift.String?
    let errors: [CodeCommitClientTypes.BatchDescribeMergeConflictsError]?
    let destinationCommitId: Swift.String?
    let sourceCommitId: Swift.String?
    let baseCommitId: Swift.String?
}

extension BatchDescribeMergeConflictsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCommitId
        case conflicts
        case destinationCommitId
        case errors
        case nextToken
        case sourceCommitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Conflict?].self, forKey: .conflicts)
        var conflictsDecoded0:[CodeCommitClientTypes.Conflict]? = nil
        if let conflictsContainer = conflictsContainer {
            conflictsDecoded0 = [CodeCommitClientTypes.Conflict]()
            for structure0 in conflictsContainer {
                if let structure0 = structure0 {
                    conflictsDecoded0?.append(structure0)
                }
            }
        }
        conflicts = conflictsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let errorsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.BatchDescribeMergeConflictsError?].self, forKey: .errors)
        var errorsDecoded0:[CodeCommitClientTypes.BatchDescribeMergeConflictsError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CodeCommitClientTypes.BatchDescribeMergeConflictsError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
    }
}

enum BatchDescribeMergeConflictsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictDetailLevelException": return try await InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionStrategyException": return try await InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxConflictFilesException": return try await InvalidMaxConflictFilesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxMergeHunksException": return try await InvalidMaxMergeHunksException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMergeOptionException": return try await InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumFileContentToLoadExceededException": return try await MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumItemsToCompareExceededException": return try await MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MergeOptionRequiredException": return try await MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about errors in a BatchDisassociateApprovalRuleTemplateFromRepositories operation.
    public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesError: Swift.Equatable {
        /// An error code that specifies whether the repository name was not valid or not found.
        public var errorCode: Swift.String?
        /// An error message that provides details about why the repository name was either not found or not valid.
        public var errorMessage: Swift.String?
        /// The name of the repository where the association with the template was not able to be removed.
        public var repositoryName: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.repositoryName = repositoryName
        }
    }

}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositoryname0 in repositoryNames {
                try repositoryNamesContainer.encode(repositoryname0)
            }
        }
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesInput: Swift.Equatable {
    /// The name of the template that you want to disassociate from one or more repositories.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The repository names that you want to disassociate from the approval rule template. The length constraint limit is for each string in the array. The array itself can be empty.
    /// This member is required.
    public var repositoryNames: [Swift.String]?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryNames = repositoryNames
    }
}

struct BatchDisassociateApprovalRuleTemplateFromRepositoriesInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let repositoryNames: [Swift.String]?
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.disassociatedRepositoryNames = output.disassociatedRepositoryNames
            self.errors = output.errors
        } else {
            self.disassociatedRepositoryNames = nil
            self.errors = nil
        }
    }
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput: Swift.Equatable {
    /// A list of repository names that have had their association with the template removed.
    /// This member is required.
    public var disassociatedRepositoryNames: [Swift.String]?
    /// A list of any errors that might have occurred while attempting to remove the association between the template and the repositories.
    /// This member is required.
    public var errors: [CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]?

    public init(
        disassociatedRepositoryNames: [Swift.String]? = nil,
        errors: [CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]? = nil
    )
    {
        self.disassociatedRepositoryNames = disassociatedRepositoryNames
        self.errors = errors
    }
}

struct BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputBody: Swift.Equatable {
    let disassociatedRepositoryNames: [Swift.String]?
    let errors: [CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]?
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedRepositoryNames
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disassociatedRepositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .disassociatedRepositoryNames)
        var disassociatedRepositoryNamesDecoded0:[Swift.String]? = nil
        if let disassociatedRepositoryNamesContainer = disassociatedRepositoryNamesContainer {
            disassociatedRepositoryNamesDecoded0 = [Swift.String]()
            for string0 in disassociatedRepositoryNamesContainer {
                if let string0 = string0 {
                    disassociatedRepositoryNamesDecoded0?.append(string0)
                }
            }
        }
        disassociatedRepositoryNames = disassociatedRepositoryNamesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError?].self, forKey: .errors)
        var errorsDecoded0:[CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateDoesNotExistException": return try await ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumRepositoryNamesExceededException": return try await MaximumRepositoryNamesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNamesRequiredException": return try await RepositoryNamesRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.BatchGetCommitsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about errors in a BatchGetCommits operation.
    public struct BatchGetCommitsError: Swift.Equatable {
        /// A commit ID that either could not be found or was not in a valid format.
        public var commitId: Swift.String?
        /// An error code that specifies whether the commit ID was not valid or not found.
        public var errorCode: Swift.String?
        /// An error message that provides detail about why the commit ID either was not found or was not valid.
        public var errorMessage: Swift.String?

        public init(
            commitId: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.commitId = commitId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension BatchGetCommitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitIds
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitIds = commitIds {
            var commitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commitIds)
            for objectid0 in commitIds {
                try commitIdsContainer.encode(objectid0)
            }
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension BatchGetCommitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetCommitsInput: Swift.Equatable {
    /// The full commit IDs of the commits to get information about. You must supply the full SHA IDs of each commit. You cannot use shortened SHA IDs.
    /// This member is required.
    public var commitIds: [Swift.String]?
    /// The name of the repository that contains the commits.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        commitIds: [Swift.String]? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitIds = commitIds
        self.repositoryName = repositoryName
    }
}

struct BatchGetCommitsInputBody: Swift.Equatable {
    let commitIds: [Swift.String]?
    let repositoryName: Swift.String?
}

extension BatchGetCommitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitIds
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .commitIds)
        var commitIdsDecoded0:[Swift.String]? = nil
        if let commitIdsContainer = commitIdsContainer {
            commitIdsDecoded0 = [Swift.String]()
            for string0 in commitIdsContainer {
                if let string0 = string0 {
                    commitIdsDecoded0?.append(string0)
                }
            }
        }
        commitIds = commitIdsDecoded0
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension BatchGetCommitsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetCommitsOutputBody = try responseDecoder.decode(responseBody: data)
            self.commits = output.commits
            self.errors = output.errors
        } else {
            self.commits = nil
            self.errors = nil
        }
    }
}

public struct BatchGetCommitsOutput: Swift.Equatable {
    /// An array of commit data type objects, each of which contains information about a specified commit.
    public var commits: [CodeCommitClientTypes.Commit]?
    /// Returns any commit IDs for which information could not be found. For example, if one of the commit IDs was a shortened SHA ID or that commit was not found in the specified repository, the ID returns an error object with more information.
    public var errors: [CodeCommitClientTypes.BatchGetCommitsError]?

    public init(
        commits: [CodeCommitClientTypes.Commit]? = nil,
        errors: [CodeCommitClientTypes.BatchGetCommitsError]? = nil
    )
    {
        self.commits = commits
        self.errors = errors
    }
}

struct BatchGetCommitsOutputBody: Swift.Equatable {
    let commits: [CodeCommitClientTypes.Commit]?
    let errors: [CodeCommitClientTypes.BatchGetCommitsError]?
}

extension BatchGetCommitsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commits
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Commit?].self, forKey: .commits)
        var commitsDecoded0:[CodeCommitClientTypes.Commit]? = nil
        if let commitsContainer = commitsContainer {
            commitsDecoded0 = [CodeCommitClientTypes.Commit]()
            for structure0 in commitsContainer {
                if let structure0 = structure0 {
                    commitsDecoded0?.append(structure0)
                }
            }
        }
        commits = commitsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.BatchGetCommitsError?].self, forKey: .errors)
        var errorsDecoded0:[CodeCommitClientTypes.BatchGetCommitsError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CodeCommitClientTypes.BatchGetCommitsError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchGetCommitsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitIdsLimitExceededException": return try await CommitIdsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitIdsListRequiredException": return try await CommitIdsListRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositoryname0 in repositoryNames {
                try repositoryNamesContainer.encode(repositoryname0)
            }
        }
    }
}

extension BatchGetRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a batch get repositories operation.
public struct BatchGetRepositoriesInput: Swift.Equatable {
    /// The names of the repositories to get information about. The length constraint limit is for each string in the array. The array itself can be empty.
    /// This member is required.
    public var repositoryNames: [Swift.String]?

    public init(
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.repositoryNames = repositoryNames
    }
}

struct BatchGetRepositoriesInputBody: Swift.Equatable {
    let repositoryNames: [Swift.String]?
}

extension BatchGetRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
    }
}

extension BatchGetRepositoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetRepositoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.repositories = output.repositories
            self.repositoriesNotFound = output.repositoriesNotFound
        } else {
            self.repositories = nil
            self.repositoriesNotFound = nil
        }
    }
}

/// Represents the output of a batch get repositories operation.
public struct BatchGetRepositoriesOutput: Swift.Equatable {
    /// A list of repositories returned by the batch get repositories operation.
    public var repositories: [CodeCommitClientTypes.RepositoryMetadata]?
    /// Returns a list of repository names for which information could not be found.
    public var repositoriesNotFound: [Swift.String]?

    public init(
        repositories: [CodeCommitClientTypes.RepositoryMetadata]? = nil,
        repositoriesNotFound: [Swift.String]? = nil
    )
    {
        self.repositories = repositories
        self.repositoriesNotFound = repositoriesNotFound
    }
}

struct BatchGetRepositoriesOutputBody: Swift.Equatable {
    let repositories: [CodeCommitClientTypes.RepositoryMetadata]?
    let repositoriesNotFound: [Swift.String]?
}

extension BatchGetRepositoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositories
        case repositoriesNotFound
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryMetadata?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeCommitClientTypes.RepositoryMetadata]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeCommitClientTypes.RepositoryMetadata]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let repositoriesNotFoundContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoriesNotFound)
        var repositoriesNotFoundDecoded0:[Swift.String]? = nil
        if let repositoriesNotFoundContainer = repositoriesNotFoundContainer {
            repositoriesNotFoundDecoded0 = [Swift.String]()
            for string0 in repositoriesNotFoundContainer {
                if let string0 = string0 {
                    repositoriesNotFoundDecoded0?.append(string0)
                }
            }
        }
        repositoriesNotFound = repositoriesNotFoundDecoded0
    }
}

enum BatchGetRepositoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumRepositoryNamesExceededException": return try await MaximumRepositoryNamesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNamesRequiredException": return try await RepositoryNamesRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BeforeCommitIdAndAfterCommitIdAreSameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BeforeCommitIdAndAfterCommitIdAreSameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.
public struct BeforeCommitIdAndAfterCommitIdAreSameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BeforeCommitIdAndAfterCommitIdAreSameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BeforeCommitIdAndAfterCommitIdAreSameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BeforeCommitIdAndAfterCommitIdAreSameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BlobIdDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BlobIdDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified blob does not exist.
public struct BlobIdDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BlobIdDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BlobIdDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BlobIdDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BlobIdRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BlobIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A blob ID is required, but was not specified.
public struct BlobIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BlobIdRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BlobIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BlobIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.BlobMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case mode
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode, forKey: .mode)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let modeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a specific Git blob object.
    public struct BlobMetadata: Swift.Equatable {
        /// The full ID of the blob.
        public var blobId: Swift.String?
        /// The file mode permissions of the blob. File mode permission codes include:
        ///
        /// * 100644 indicates read/write
        ///
        /// * 100755 indicates read/write/execute
        ///
        /// * 160000 indicates a submodule
        ///
        /// * 120000 indicates a symlink
        public var mode: Swift.String?
        /// The path to the blob and associated file name, if any.
        public var path: Swift.String?

        public init(
            blobId: Swift.String? = nil,
            mode: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.blobId = blobId
            self.mode = mode
            self.path = path
        }
    }

}

extension BranchDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BranchDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified branch does not exist.
public struct BranchDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BranchDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BranchDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BranchDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.BranchInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a branch.
    public struct BranchInfo: Swift.Equatable {
        /// The name of the branch.
        public var branchName: Swift.String?
        /// The ID of the last commit made to the branch.
        public var commitId: Swift.String?

        public init(
            branchName: Swift.String? = nil,
            commitId: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.commitId = commitId
        }
    }

}

extension BranchNameExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BranchNameExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name. Branch names must be unique.
public struct BranchNameExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BranchNameExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BranchNameExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BranchNameExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BranchNameIsTagNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BranchNameIsTagNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use [ListBranches].
public struct BranchNameIsTagNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BranchNameIsTagNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BranchNameIsTagNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BranchNameIsTagNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BranchNameRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BranchNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A branch name is required, but was not specified.
public struct BranchNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BranchNameRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BranchNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BranchNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CannotDeleteApprovalRuleFromTemplateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CannotDeleteApprovalRuleFromTemplateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The approval rule cannot be deleted from the pull request because it was created by an approval rule template and applied to the pull request automatically.
public struct CannotDeleteApprovalRuleFromTemplateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotDeleteApprovalRuleFromTemplateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CannotDeleteApprovalRuleFromTemplateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CannotDeleteApprovalRuleFromTemplateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CannotModifyApprovalRuleFromTemplateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CannotModifyApprovalRuleFromTemplateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The approval rule cannot be modified for the pull request because it was created by an approval rule template and applied to the pull request automatically.
public struct CannotModifyApprovalRuleFromTemplateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotModifyApprovalRuleFromTemplateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CannotModifyApprovalRuleFromTemplateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CannotModifyApprovalRuleFromTemplateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum ChangeTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case added
        case deleted
        case modified
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeTypeEnum] {
            return [
                .added,
                .deleted,
                .modified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .added: return "A"
            case .deleted: return "D"
            case .modified: return "M"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeTypeEnum(rawValue: rawValue) ?? ChangeTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension ClientRequestTokenRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ClientRequestTokenRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
public struct ClientRequestTokenRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClientRequestTokenRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ClientRequestTokenRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClientRequestTokenRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.Comment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorArn
        case callerReactions
        case clientRequestToken
        case commentId
        case content
        case creationDate
        case deleted
        case inReplyTo
        case lastModifiedDate
        case reactionCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorArn = self.authorArn {
            try encodeContainer.encode(authorArn, forKey: .authorArn)
        }
        if let callerReactions = callerReactions {
            var callerReactionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callerReactions)
            for reactionvalue0 in callerReactions {
                try callerReactionsContainer.encode(reactionvalue0)
            }
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if deleted != false {
            try encodeContainer.encode(deleted, forKey: .deleted)
        }
        if let inReplyTo = self.inReplyTo {
            try encodeContainer.encode(inReplyTo, forKey: .inReplyTo)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let reactionCounts = reactionCounts {
            var reactionCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .reactionCounts)
            for (dictKey0, reactionCountsMap0) in reactionCounts {
                try reactionCountsContainer.encode(reactionCountsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let inReplyToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inReplyTo)
        inReplyTo = inReplyToDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let authorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorArn)
        authorArn = authorArnDecoded
        let deletedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleted) ?? false
        deleted = deletedDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let callerReactionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .callerReactions)
        var callerReactionsDecoded0:[Swift.String]? = nil
        if let callerReactionsContainer = callerReactionsContainer {
            callerReactionsDecoded0 = [Swift.String]()
            for string0 in callerReactionsContainer {
                if let string0 = string0 {
                    callerReactionsDecoded0?.append(string0)
                }
            }
        }
        callerReactions = callerReactionsDecoded0
        let reactionCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .reactionCounts)
        var reactionCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let reactionCountsContainer = reactionCountsContainer {
            reactionCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in reactionCountsContainer {
                if let count0 = count0 {
                    reactionCountsDecoded0?[key0] = count0
                }
            }
        }
        reactionCounts = reactionCountsDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a specific comment.
    public struct Comment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the person who posted the comment.
        public var authorArn: Swift.String?
        /// The emoji reactions to a comment, if any, submitted by the user whose credentials are associated with the call to the API.
        public var callerReactions: [Swift.String]?
        /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
        public var clientRequestToken: Swift.String?
        /// The system-generated comment ID.
        public var commentId: Swift.String?
        /// The content of the comment.
        public var content: Swift.String?
        /// The date and time the comment was created, in timestamp format.
        public var creationDate: ClientRuntime.Date?
        /// A Boolean value indicating whether the comment has been deleted.
        public var deleted: Swift.Bool
        /// The ID of the comment for which this comment is a reply, if any.
        public var inReplyTo: Swift.String?
        /// The date and time the comment was most recently modified, in timestamp format.
        public var lastModifiedDate: ClientRuntime.Date?
        /// A string to integer map that represents the number of individual users who have responded to a comment with the specified reactions.
        public var reactionCounts: [Swift.String:Swift.Int]?

        public init(
            authorArn: Swift.String? = nil,
            callerReactions: [Swift.String]? = nil,
            clientRequestToken: Swift.String? = nil,
            commentId: Swift.String? = nil,
            content: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            deleted: Swift.Bool = false,
            inReplyTo: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            reactionCounts: [Swift.String:Swift.Int]? = nil
        )
        {
            self.authorArn = authorArn
            self.callerReactions = callerReactions
            self.clientRequestToken = clientRequestToken
            self.commentId = commentId
            self.content = content
            self.creationDate = creationDate
            self.deleted = deleted
            self.inReplyTo = inReplyTo
            self.lastModifiedDate = lastModifiedDate
            self.reactionCounts = reactionCounts
        }
    }

}

extension CommentContentRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommentContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The comment is empty. You must provide some content for a comment. The content cannot be null.
public struct CommentContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentContentRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommentContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentContentSizeLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommentContentSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The comment is too large. Comments are limited to 10,240 characters.
public struct CommentContentSizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentContentSizeLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommentContentSizeLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentContentSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentDeletedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommentDeletedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This comment has already been deleted. You cannot edit or delete a deleted comment.
public struct CommentDeletedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentDeletedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommentDeletedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentDeletedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommentDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.
public struct CommentDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommentDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentIdRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommentIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The comment ID is missing or null. A comment ID is required.
public struct CommentIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentIdRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommentIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentNotCreatedByCallerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommentNotCreatedByCallerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot modify or delete this comment. Only comment authors can modify or delete their comments.
public struct CommentNotCreatedByCallerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommentNotCreatedByCallerException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommentNotCreatedByCallerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentNotCreatedByCallerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.CommentsForComparedCommit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comments
        case location
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterBlobId = self.afterBlobId {
            try encodeContainer.encode(afterBlobId, forKey: .afterBlobId)
        }
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeBlobId = self.beforeBlobId {
            try encodeContainer.encode(beforeBlobId, forKey: .beforeBlobId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let comments = comments {
            var commentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comments)
            for comment0 in comments {
                try commentsContainer.encode(comment0)
            }
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let commentsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Comment?].self, forKey: .comments)
        var commentsDecoded0:[CodeCommitClientTypes.Comment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [CodeCommitClientTypes.Comment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Returns information about comments on the comparison between two commits.
    public struct CommentsForComparedCommit: Swift.Equatable {
        /// The full blob ID of the commit used to establish the after of the comparison.
        public var afterBlobId: Swift.String?
        /// The full commit ID of the commit used to establish the after of the comparison.
        public var afterCommitId: Swift.String?
        /// The full blob ID of the commit used to establish the before of the comparison.
        public var beforeBlobId: Swift.String?
        /// The full commit ID of the commit used to establish the before of the comparison.
        public var beforeCommitId: Swift.String?
        /// An array of comment objects. Each comment object contains information about a comment on the comparison between commits.
        public var comments: [CodeCommitClientTypes.Comment]?
        /// Location information about the comment on the comparison, including the file name, line number, and whether the version of the file where the comment was made is BEFORE or AFTER.
        public var location: CodeCommitClientTypes.Location?
        /// The name of the repository that contains the compared commits.
        public var repositoryName: Swift.String?

        public init(
            afterBlobId: Swift.String? = nil,
            afterCommitId: Swift.String? = nil,
            beforeBlobId: Swift.String? = nil,
            beforeCommitId: Swift.String? = nil,
            comments: [CodeCommitClientTypes.Comment]? = nil,
            location: CodeCommitClientTypes.Location? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.afterBlobId = afterBlobId
            self.afterCommitId = afterCommitId
            self.beforeBlobId = beforeBlobId
            self.beforeCommitId = beforeCommitId
            self.comments = comments
            self.location = location
            self.repositoryName = repositoryName
        }
    }

}

extension CodeCommitClientTypes.CommentsForPullRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comments
        case location
        case pullRequestId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterBlobId = self.afterBlobId {
            try encodeContainer.encode(afterBlobId, forKey: .afterBlobId)
        }
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeBlobId = self.beforeBlobId {
            try encodeContainer.encode(beforeBlobId, forKey: .beforeBlobId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let comments = comments {
            var commentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comments)
            for comment0 in comments {
                try commentsContainer.encode(comment0)
            }
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let commentsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Comment?].self, forKey: .comments)
        var commentsDecoded0:[CodeCommitClientTypes.Comment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [CodeCommitClientTypes.Comment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Returns information about comments on a pull request.
    public struct CommentsForPullRequest: Swift.Equatable {
        /// The full blob ID of the file on which you want to comment on the source commit.
        public var afterBlobId: Swift.String?
        /// The full commit ID of the commit that was the tip of the source branch at the time the comment was made.
        public var afterCommitId: Swift.String?
        /// The full blob ID of the file on which you want to comment on the destination commit.
        public var beforeBlobId: Swift.String?
        /// The full commit ID of the commit that was the tip of the destination branch when the pull request was created. This commit is superceded by the after commit in the source branch when and if you merge the source branch into the destination branch.
        public var beforeCommitId: Swift.String?
        /// An array of comment objects. Each comment object contains information about a comment on the pull request.
        public var comments: [CodeCommitClientTypes.Comment]?
        /// Location information about the comment on the pull request, including the file name, line number, and whether the version of the file where the comment was made is BEFORE (destination branch) or AFTER (source branch).
        public var location: CodeCommitClientTypes.Location?
        /// The system-generated ID of the pull request.
        public var pullRequestId: Swift.String?
        /// The name of the repository that contains the pull request.
        public var repositoryName: Swift.String?

        public init(
            afterBlobId: Swift.String? = nil,
            afterCommitId: Swift.String? = nil,
            beforeBlobId: Swift.String? = nil,
            beforeCommitId: Swift.String? = nil,
            comments: [CodeCommitClientTypes.Comment]? = nil,
            location: CodeCommitClientTypes.Location? = nil,
            pullRequestId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.afterBlobId = afterBlobId
            self.afterCommitId = afterCommitId
            self.beforeBlobId = beforeBlobId
            self.beforeCommitId = beforeCommitId
            self.comments = comments
            self.location = location
            self.pullRequestId = pullRequestId
            self.repositoryName = repositoryName
        }
    }

}

extension CodeCommitClientTypes.Commit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalData
        case author
        case commitId
        case committer
        case message
        case parents
        case treeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalData = self.additionalData {
            try encodeContainer.encode(additionalData, forKey: .additionalData)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let committer = self.committer {
            try encodeContainer.encode(committer, forKey: .committer)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let parents = parents {
            var parentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parents)
            for objectid0 in parents {
                try parentsContainer.encode(objectid0)
            }
        }
        if let treeId = self.treeId {
            try encodeContainer.encode(treeId, forKey: .treeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let parentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parents)
        var parentsDecoded0:[Swift.String]? = nil
        if let parentsContainer = parentsContainer {
            parentsDecoded0 = [Swift.String]()
            for string0 in parentsContainer {
                if let string0 = string0 {
                    parentsDecoded0?.append(string0)
                }
            }
        }
        parents = parentsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let authorDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.UserInfo.self, forKey: .author)
        author = authorDecoded
        let committerDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.UserInfo.self, forKey: .committer)
        committer = committerDecoded
        let additionalDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalData)
        additionalData = additionalDataDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a specific commit.
    public struct Commit: Swift.Equatable {
        /// Any other data associated with the specified commit.
        public var additionalData: Swift.String?
        /// Information about the author of the specified commit. Information includes the date in timestamp format with GMT offset, the name of the author, and the email address for the author, as configured in Git.
        public var author: CodeCommitClientTypes.UserInfo?
        /// The full SHA ID of the specified commit.
        public var commitId: Swift.String?
        /// Information about the person who committed the specified commit, also known as the committer. Information includes the date in timestamp format with GMT offset, the name of the committer, and the email address for the committer, as configured in Git. For more information about the difference between an author and a committer in Git, see [Viewing the Commit History](http://git-scm.com/book/ch2-3.html) in Pro Git by Scott Chacon and Ben Straub.
        public var committer: CodeCommitClientTypes.UserInfo?
        /// The commit message associated with the specified commit.
        public var message: Swift.String?
        /// A list of parent commits for the specified commit. Each parent commit ID is the full commit ID.
        public var parents: [Swift.String]?
        /// Tree information for the specified commit.
        public var treeId: Swift.String?

        public init(
            additionalData: Swift.String? = nil,
            author: CodeCommitClientTypes.UserInfo? = nil,
            commitId: Swift.String? = nil,
            committer: CodeCommitClientTypes.UserInfo? = nil,
            message: Swift.String? = nil,
            parents: [Swift.String]? = nil,
            treeId: Swift.String? = nil
        )
        {
            self.additionalData = additionalData
            self.author = author
            self.commitId = commitId
            self.committer = committer
            self.message = message
            self.parents = parents
            self.treeId = treeId
        }
    }

}

extension CommitDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommitDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified commit does not exist or no commit was specified, and the specified repository has no default branch.
public struct CommitDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommitDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommitIdDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified commit ID does not exist.
public struct CommitIdDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitIdDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommitIdDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitIdDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommitIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A commit ID was not specified.
public struct CommitIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitIdRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommitIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdsLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommitIdsLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.
public struct CommitIdsLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitIdsLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommitIdsLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitIdsLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdsListRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommitIdsListRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A list of commit IDs is required, but was either not specified or the list was empty.
public struct CommitIdsListRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitIdsListRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommitIdsListRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitIdsListRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitMessageLengthExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommitMessageLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit message is too long. Provide a shorter string.
public struct CommitMessageLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitMessageLengthExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommitMessageLengthExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitMessageLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommitRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A commit was not specified.
public struct CommitRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CommitRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CommitRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentReferenceUpdateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentReferenceUpdateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.
public struct ConcurrentReferenceUpdateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentReferenceUpdateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentReferenceUpdateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentReferenceUpdateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.Conflict: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictMetadata
        case mergeHunks
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictMetadata = self.conflictMetadata {
            try encodeContainer.encode(conflictMetadata, forKey: .conflictMetadata)
        }
        if let mergeHunks = mergeHunks {
            var mergeHunksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mergeHunks)
            for mergehunk0 in mergeHunks {
                try mergeHunksContainer.encode(mergehunk0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictMetadata.self, forKey: .conflictMetadata)
        conflictMetadata = conflictMetadataDecoded
        let mergeHunksContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.MergeHunk?].self, forKey: .mergeHunks)
        var mergeHunksDecoded0:[CodeCommitClientTypes.MergeHunk]? = nil
        if let mergeHunksContainer = mergeHunksContainer {
            mergeHunksDecoded0 = [CodeCommitClientTypes.MergeHunk]()
            for structure0 in mergeHunksContainer {
                if let structure0 = structure0 {
                    mergeHunksDecoded0?.append(structure0)
                }
            }
        }
        mergeHunks = mergeHunksDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Information about conflicts in a merge operation.
    public struct Conflict: Swift.Equatable {
        /// Metadata about a conflict in a merge operation.
        public var conflictMetadata: CodeCommitClientTypes.ConflictMetadata?
        /// A list of hunks that contain the differences between files or lines causing the conflict.
        public var mergeHunks: [CodeCommitClientTypes.MergeHunk]?

        public init(
            conflictMetadata: CodeCommitClientTypes.ConflictMetadata? = nil,
            mergeHunks: [CodeCommitClientTypes.MergeHunk]? = nil
        )
        {
            self.conflictMetadata = conflictMetadata
            self.mergeHunks = mergeHunks
        }
    }

}

extension CodeCommitClientTypes {
    public enum ConflictDetailLevelTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fileLevel
        case lineLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictDetailLevelTypeEnum] {
            return [
                .fileLevel,
                .lineLevel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fileLevel: return "FILE_LEVEL"
            case .lineLevel: return "LINE_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictDetailLevelTypeEnum(rawValue: rawValue) ?? ConflictDetailLevelTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.ConflictMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentConflict
        case fileModeConflict
        case fileModes
        case filePath
        case fileSizes
        case isBinaryFile
        case mergeOperations
        case numberOfConflicts
        case objectTypeConflict
        case objectTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if contentConflict != false {
            try encodeContainer.encode(contentConflict, forKey: .contentConflict)
        }
        if fileModeConflict != false {
            try encodeContainer.encode(fileModeConflict, forKey: .fileModeConflict)
        }
        if let fileModes = self.fileModes {
            try encodeContainer.encode(fileModes, forKey: .fileModes)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let fileSizes = self.fileSizes {
            try encodeContainer.encode(fileSizes, forKey: .fileSizes)
        }
        if let isBinaryFile = self.isBinaryFile {
            try encodeContainer.encode(isBinaryFile, forKey: .isBinaryFile)
        }
        if let mergeOperations = self.mergeOperations {
            try encodeContainer.encode(mergeOperations, forKey: .mergeOperations)
        }
        if numberOfConflicts != 0 {
            try encodeContainer.encode(numberOfConflicts, forKey: .numberOfConflicts)
        }
        if objectTypeConflict != false {
            try encodeContainer.encode(objectTypeConflict, forKey: .objectTypeConflict)
        }
        if let objectTypes = self.objectTypes {
            try encodeContainer.encode(objectTypes, forKey: .objectTypes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileSizesDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileSizes.self, forKey: .fileSizes)
        fileSizes = fileSizesDecoded
        let fileModesDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModes.self, forKey: .fileModes)
        fileModes = fileModesDecoded
        let objectTypesDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ObjectTypes.self, forKey: .objectTypes)
        objectTypes = objectTypesDecoded
        let numberOfConflictsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfConflicts) ?? 0
        numberOfConflicts = numberOfConflictsDecoded
        let isBinaryFileDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.IsBinaryFile.self, forKey: .isBinaryFile)
        isBinaryFile = isBinaryFileDecoded
        let contentConflictDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .contentConflict) ?? false
        contentConflict = contentConflictDecoded
        let fileModeConflictDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fileModeConflict) ?? false
        fileModeConflict = fileModeConflictDecoded
        let objectTypeConflictDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .objectTypeConflict) ?? false
        objectTypeConflict = objectTypeConflictDecoded
        let mergeOperationsDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOperations.self, forKey: .mergeOperations)
        mergeOperations = mergeOperationsDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the metadata for a conflict in a merge operation.
    public struct ConflictMetadata: Swift.Equatable {
        /// A boolean value indicating whether there are conflicts in the content of a file.
        public var contentConflict: Swift.Bool
        /// A boolean value indicating whether there are conflicts in the file mode of a file.
        public var fileModeConflict: Swift.Bool
        /// The file modes of the file in the source, destination, and base of the merge.
        public var fileModes: CodeCommitClientTypes.FileModes?
        /// The path of the file that contains conflicts.
        public var filePath: Swift.String?
        /// The file sizes of the file in the source, destination, and base of the merge.
        public var fileSizes: CodeCommitClientTypes.FileSizes?
        /// A boolean value (true or false) indicating whether the file is binary or textual in the source, destination, and base of the merge.
        public var isBinaryFile: CodeCommitClientTypes.IsBinaryFile?
        /// Whether an add, modify, or delete operation caused the conflict between the source and destination of the merge.
        public var mergeOperations: CodeCommitClientTypes.MergeOperations?
        /// The number of conflicts, including both hunk conflicts and metadata conflicts.
        public var numberOfConflicts: Swift.Int
        /// A boolean value (true or false) indicating whether there are conflicts between the branches in the object type of a file, folder, or submodule.
        public var objectTypeConflict: Swift.Bool
        /// Information about any object type conflicts in a merge operation.
        public var objectTypes: CodeCommitClientTypes.ObjectTypes?

        public init(
            contentConflict: Swift.Bool = false,
            fileModeConflict: Swift.Bool = false,
            fileModes: CodeCommitClientTypes.FileModes? = nil,
            filePath: Swift.String? = nil,
            fileSizes: CodeCommitClientTypes.FileSizes? = nil,
            isBinaryFile: CodeCommitClientTypes.IsBinaryFile? = nil,
            mergeOperations: CodeCommitClientTypes.MergeOperations? = nil,
            numberOfConflicts: Swift.Int = 0,
            objectTypeConflict: Swift.Bool = false,
            objectTypes: CodeCommitClientTypes.ObjectTypes? = nil
        )
        {
            self.contentConflict = contentConflict
            self.fileModeConflict = fileModeConflict
            self.fileModes = fileModes
            self.filePath = filePath
            self.fileSizes = fileSizes
            self.isBinaryFile = isBinaryFile
            self.mergeOperations = mergeOperations
            self.numberOfConflicts = numberOfConflicts
            self.objectTypeConflict = objectTypeConflict
            self.objectTypes = objectTypes
        }
    }

}

extension CodeCommitClientTypes.ConflictResolution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteFiles
        case replaceContents
        case setFileModes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteFiles = deleteFiles {
            var deleteFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deleteFiles)
            for deletefileentry0 in deleteFiles {
                try deleteFilesContainer.encode(deletefileentry0)
            }
        }
        if let replaceContents = replaceContents {
            var replaceContentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replaceContents)
            for replacecontententry0 in replaceContents {
                try replaceContentsContainer.encode(replacecontententry0)
            }
        }
        if let setFileModes = setFileModes {
            var setFileModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .setFileModes)
            for setfilemodeentry0 in setFileModes {
                try setFileModesContainer.encode(setfilemodeentry0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replaceContentsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.ReplaceContentEntry?].self, forKey: .replaceContents)
        var replaceContentsDecoded0:[CodeCommitClientTypes.ReplaceContentEntry]? = nil
        if let replaceContentsContainer = replaceContentsContainer {
            replaceContentsDecoded0 = [CodeCommitClientTypes.ReplaceContentEntry]()
            for structure0 in replaceContentsContainer {
                if let structure0 = structure0 {
                    replaceContentsDecoded0?.append(structure0)
                }
            }
        }
        replaceContents = replaceContentsDecoded0
        let deleteFilesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.DeleteFileEntry?].self, forKey: .deleteFiles)
        var deleteFilesDecoded0:[CodeCommitClientTypes.DeleteFileEntry]? = nil
        if let deleteFilesContainer = deleteFilesContainer {
            deleteFilesDecoded0 = [CodeCommitClientTypes.DeleteFileEntry]()
            for structure0 in deleteFilesContainer {
                if let structure0 = structure0 {
                    deleteFilesDecoded0?.append(structure0)
                }
            }
        }
        deleteFiles = deleteFilesDecoded0
        let setFileModesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.SetFileModeEntry?].self, forKey: .setFileModes)
        var setFileModesDecoded0:[CodeCommitClientTypes.SetFileModeEntry]? = nil
        if let setFileModesContainer = setFileModesContainer {
            setFileModesDecoded0 = [CodeCommitClientTypes.SetFileModeEntry]()
            for structure0 in setFileModesContainer {
                if let structure0 = structure0 {
                    setFileModesDecoded0?.append(structure0)
                }
            }
        }
        setFileModes = setFileModesDecoded0
    }
}

extension CodeCommitClientTypes {
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public struct ConflictResolution: Swift.Equatable {
        /// Files to be deleted as part of the merge conflict resolution.
        public var deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]?
        /// Files to have content replaced as part of the merge conflict resolution.
        public var replaceContents: [CodeCommitClientTypes.ReplaceContentEntry]?
        /// File modes that are set as part of the merge conflict resolution.
        public var setFileModes: [CodeCommitClientTypes.SetFileModeEntry]?

        public init(
            deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]? = nil,
            replaceContents: [CodeCommitClientTypes.ReplaceContentEntry]? = nil,
            setFileModes: [CodeCommitClientTypes.SetFileModeEntry]? = nil
        )
        {
            self.deleteFiles = deleteFiles
            self.replaceContents = replaceContents
            self.setFileModes = setFileModes
        }
    }

}

extension CodeCommitClientTypes {
    public enum ConflictResolutionStrategyTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acceptDestination
        case acceptSource
        case automerge
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictResolutionStrategyTypeEnum] {
            return [
                .acceptDestination,
                .acceptSource,
                .automerge,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acceptDestination: return "ACCEPT_DESTINATION"
            case .acceptSource: return "ACCEPT_SOURCE"
            case .automerge: return "AUTOMERGE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictResolutionStrategyTypeEnum(rawValue: rawValue) ?? ConflictResolutionStrategyTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CreateApprovalRuleTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateContent
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateContent = self.approvalRuleTemplateContent {
            try encodeContainer.encode(approvalRuleTemplateContent, forKey: .approvalRuleTemplateContent)
        }
        if let approvalRuleTemplateDescription = self.approvalRuleTemplateDescription {
            try encodeContainer.encode(approvalRuleTemplateDescription, forKey: .approvalRuleTemplateDescription)
        }
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

extension CreateApprovalRuleTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApprovalRuleTemplateInput: Swift.Equatable {
    /// The content of the approval rule that is created on pull requests in associated repositories. If you specify one or more destination references (branches), approval rules are created in an associated repository only if their destination references (branches) match those specified in the template. When you create the content of the approval rule template, you can specify approvers in an approval pool in one of two ways:
    ///
    /// * CodeCommitApprovers: This option only requires an Amazon Web Services account and a resource. It can be used for both IAM users and federated access users whose name matches the provided resource name. This is a very powerful option that offers a great deal of flexibility. For example, if you specify the Amazon Web Services account 123456789012 and Mary_Major, all of the following are counted as approvals coming from that user:
    ///
    /// * An IAM user in the account (arn:aws:iam::123456789012:user/Mary_Major)
    ///
    /// * A federated user identified in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
    ///
    ///
    /// This option does not recognize an active session of someone assuming the role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major) unless you include a wildcard (*Mary_Major).
    ///
    /// * Fully qualified ARN: This option allows you to specify the fully qualified Amazon Resource Name (ARN) of the IAM user or role.
    ///
    ///
    /// For more information about IAM ARNs, wildcards, and formats, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var approvalRuleTemplateContent: Swift.String?
    /// The description of the approval rule template. Consider providing a description that explains what this template does and when it might be appropriate to associate it with repositories.
    public var approvalRuleTemplateDescription: Swift.String?
    /// The name of the approval rule template. Provide descriptive names, because this name is applied to the approval rules created automatically in associated repositories.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init(
        approvalRuleTemplateContent: Swift.String? = nil,
        approvalRuleTemplateDescription: Swift.String? = nil,
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateContent = approvalRuleTemplateContent
        self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct CreateApprovalRuleTemplateInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let approvalRuleTemplateContent: Swift.String?
    let approvalRuleTemplateDescription: Swift.String?
}

extension CreateApprovalRuleTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateContent
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let approvalRuleTemplateContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateContent)
        approvalRuleTemplateContent = approvalRuleTemplateContentDecoded
        let approvalRuleTemplateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateDescription)
        approvalRuleTemplateDescription = approvalRuleTemplateDescriptionDecoded
    }
}

extension CreateApprovalRuleTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApprovalRuleTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct CreateApprovalRuleTemplateOutput: Swift.Equatable {
    /// The content and structure of the created approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init(
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct CreateApprovalRuleTemplateOutputBody: Swift.Equatable {
    let approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?
}

extension CreateApprovalRuleTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

enum CreateApprovalRuleTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateContentRequiredException": return try await ApprovalRuleTemplateContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameAlreadyExistsException": return try await ApprovalRuleTemplateNameAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateContentException": return try await InvalidApprovalRuleTemplateContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateDescriptionException": return try await InvalidApprovalRuleTemplateDescriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NumberOfRuleTemplatesExceededException": return try await NumberOfRuleTemplatesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension CreateBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a create branch operation.
public struct CreateBranchInput: Swift.Equatable {
    /// The name of the new branch to create.
    /// This member is required.
    public var branchName: Swift.String?
    /// The ID of the commit to point the new branch to.
    /// This member is required.
    public var commitId: Swift.String?
    /// The name of the repository in which you want to create the new branch.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        commitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.commitId = commitId
        self.repositoryName = repositoryName
    }
}

struct CreateBranchInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
    let commitId: Swift.String?
}

extension CreateBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
    }
}

extension CreateBranchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateBranchOutput: Swift.Equatable {

    public init() { }
}

enum CreateBranchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BranchNameExistsException": return try await BranchNameExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameRequiredException": return try await BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitIdRequiredException": return try await CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBranchNameException": return try await InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitIdException": return try await InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case branchName
        case commitMessage
        case deleteFiles
        case email
        case keepEmptyFolders
        case parentCommitId
        case putFiles
        case repositoryName
        case setFileModes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let deleteFiles = deleteFiles {
            var deleteFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deleteFiles)
            for deletefileentry0 in deleteFiles {
                try deleteFilesContainer.encode(deletefileentry0)
            }
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let keepEmptyFolders = self.keepEmptyFolders {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let parentCommitId = self.parentCommitId {
            try encodeContainer.encode(parentCommitId, forKey: .parentCommitId)
        }
        if let putFiles = putFiles {
            var putFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .putFiles)
            for putfileentry0 in putFiles {
                try putFilesContainer.encode(putfileentry0)
            }
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let setFileModes = setFileModes {
            var setFileModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .setFileModes)
            for setfilemodeentry0 in setFileModes {
                try setFileModesContainer.encode(setfilemodeentry0)
            }
        }
    }
}

extension CreateCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCommitInput: Swift.Equatable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The name of the branch where you create the commit.
    /// This member is required.
    public var branchName: Swift.String?
    /// The commit message you want to include in the commit. Commit messages are limited to 256 KB. If no message is specified, a default message is used.
    public var commitMessage: Swift.String?
    /// The files to delete in this commit. These files still exist in earlier commits.
    public var deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]?
    /// The email address of the person who created the commit.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a ..gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The ID of the commit that is the parent of the commit you create. Not required if this is an empty repository.
    public var parentCommitId: Swift.String?
    /// The files to add or update in this commit.
    public var putFiles: [CodeCommitClientTypes.PutFileEntry]?
    /// The name of the repository where you create the commit.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The file modes to update for files in this commit.
    public var setFileModes: [CodeCommitClientTypes.SetFileModeEntry]?

    public init(
        authorName: Swift.String? = nil,
        branchName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = nil,
        parentCommitId: Swift.String? = nil,
        putFiles: [CodeCommitClientTypes.PutFileEntry]? = nil,
        repositoryName: Swift.String? = nil,
        setFileModes: [CodeCommitClientTypes.SetFileModeEntry]? = nil
    )
    {
        self.authorName = authorName
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.deleteFiles = deleteFiles
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.parentCommitId = parentCommitId
        self.putFiles = putFiles
        self.repositoryName = repositoryName
        self.setFileModes = setFileModes
    }
}

struct CreateCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
    let parentCommitId: Swift.String?
    let authorName: Swift.String?
    let email: Swift.String?
    let commitMessage: Swift.String?
    let keepEmptyFolders: Swift.Bool?
    let putFiles: [CodeCommitClientTypes.PutFileEntry]?
    let deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]?
    let setFileModes: [CodeCommitClientTypes.SetFileModeEntry]?
}

extension CreateCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case branchName
        case commitMessage
        case deleteFiles
        case email
        case keepEmptyFolders
        case parentCommitId
        case putFiles
        case repositoryName
        case setFileModes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let parentCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentCommitId)
        parentCommitId = parentCommitIdDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let putFilesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.PutFileEntry?].self, forKey: .putFiles)
        var putFilesDecoded0:[CodeCommitClientTypes.PutFileEntry]? = nil
        if let putFilesContainer = putFilesContainer {
            putFilesDecoded0 = [CodeCommitClientTypes.PutFileEntry]()
            for structure0 in putFilesContainer {
                if let structure0 = structure0 {
                    putFilesDecoded0?.append(structure0)
                }
            }
        }
        putFiles = putFilesDecoded0
        let deleteFilesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.DeleteFileEntry?].self, forKey: .deleteFiles)
        var deleteFilesDecoded0:[CodeCommitClientTypes.DeleteFileEntry]? = nil
        if let deleteFilesContainer = deleteFilesContainer {
            deleteFilesDecoded0 = [CodeCommitClientTypes.DeleteFileEntry]()
            for structure0 in deleteFilesContainer {
                if let structure0 = structure0 {
                    deleteFilesDecoded0?.append(structure0)
                }
            }
        }
        deleteFiles = deleteFilesDecoded0
        let setFileModesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.SetFileModeEntry?].self, forKey: .setFileModes)
        var setFileModesDecoded0:[CodeCommitClientTypes.SetFileModeEntry]? = nil
        if let setFileModesContainer = setFileModesContainer {
            setFileModesDecoded0 = [CodeCommitClientTypes.SetFileModeEntry]()
            for structure0 in setFileModesContainer {
                if let structure0 = structure0 {
                    setFileModesDecoded0?.append(structure0)
                }
            }
        }
        setFileModes = setFileModesDecoded0
    }
}

extension CreateCommitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCommitOutputBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.filesAdded = output.filesAdded
            self.filesDeleted = output.filesDeleted
            self.filesUpdated = output.filesUpdated
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.filesAdded = nil
            self.filesDeleted = nil
            self.filesUpdated = nil
            self.treeId = nil
        }
    }
}

public struct CreateCommitOutput: Swift.Equatable {
    /// The full commit ID of the commit that contains your committed file changes.
    public var commitId: Swift.String?
    /// The files added as part of the committed file changes.
    public var filesAdded: [CodeCommitClientTypes.FileMetadata]?
    /// The files deleted as part of the committed file changes.
    public var filesDeleted: [CodeCommitClientTypes.FileMetadata]?
    /// The files updated as part of the commited file changes.
    public var filesUpdated: [CodeCommitClientTypes.FileMetadata]?
    /// The full SHA-1 pointer of the tree information for the commit that contains the commited file changes.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        filesAdded: [CodeCommitClientTypes.FileMetadata]? = nil,
        filesDeleted: [CodeCommitClientTypes.FileMetadata]? = nil,
        filesUpdated: [CodeCommitClientTypes.FileMetadata]? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.filesAdded = filesAdded
        self.filesDeleted = filesDeleted
        self.filesUpdated = filesUpdated
        self.treeId = treeId
    }
}

struct CreateCommitOutputBody: Swift.Equatable {
    let commitId: Swift.String?
    let treeId: Swift.String?
    let filesAdded: [CodeCommitClientTypes.FileMetadata]?
    let filesUpdated: [CodeCommitClientTypes.FileMetadata]?
    let filesDeleted: [CodeCommitClientTypes.FileMetadata]?
}

extension CreateCommitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case filesAdded
        case filesDeleted
        case filesUpdated
        case treeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let filesAddedContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.FileMetadata?].self, forKey: .filesAdded)
        var filesAddedDecoded0:[CodeCommitClientTypes.FileMetadata]? = nil
        if let filesAddedContainer = filesAddedContainer {
            filesAddedDecoded0 = [CodeCommitClientTypes.FileMetadata]()
            for structure0 in filesAddedContainer {
                if let structure0 = structure0 {
                    filesAddedDecoded0?.append(structure0)
                }
            }
        }
        filesAdded = filesAddedDecoded0
        let filesUpdatedContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.FileMetadata?].self, forKey: .filesUpdated)
        var filesUpdatedDecoded0:[CodeCommitClientTypes.FileMetadata]? = nil
        if let filesUpdatedContainer = filesUpdatedContainer {
            filesUpdatedDecoded0 = [CodeCommitClientTypes.FileMetadata]()
            for structure0 in filesUpdatedContainer {
                if let structure0 = structure0 {
                    filesUpdatedDecoded0?.append(structure0)
                }
            }
        }
        filesUpdated = filesUpdatedDecoded0
        let filesDeletedContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.FileMetadata?].self, forKey: .filesDeleted)
        var filesDeletedDecoded0:[CodeCommitClientTypes.FileMetadata]? = nil
        if let filesDeletedContainer = filesDeletedContainer {
            filesDeletedDecoded0 = [CodeCommitClientTypes.FileMetadata]()
            for structure0 in filesDeletedContainer {
                if let structure0 = structure0 {
                    filesDeletedDecoded0?.append(structure0)
                }
            }
        }
        filesDeleted = filesDeletedDecoded0
    }
}

enum CreateCommitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BranchDoesNotExistException": return try await BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameIsTagNameException": return try await BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameRequiredException": return try await BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitMessageLengthExceededException": return try await CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNameConflictsWithFileNameException": return try await DirectoryNameConflictsWithFileNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileContentAndSourceFileSpecifiedException": return try await FileContentAndSourceFileSpecifiedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileContentSizeLimitExceededException": return try await FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileDoesNotExistException": return try await FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileEntryRequiredException": return try await FileEntryRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileModeRequiredException": return try await FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileNameConflictsWithDirectoryNameException": return try await FileNameConflictsWithDirectoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FilePathConflictsWithSubmodulePathException": return try await FilePathConflictsWithSubmodulePathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FolderContentSizeLimitExceededException": return try await FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBranchNameException": return try await InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidDeletionParameterException": return try await InvalidDeletionParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEmailException": return try await InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFileModeException": return try await InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParentCommitIdException": return try await InvalidParentCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumFileEntriesExceededException": return try await MaximumFileEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameLengthExceededException": return try await NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoChangeException": return try await NoChangeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParentCommitDoesNotExistException": return try await ParentCommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParentCommitIdOutdatedException": return try await ParentCommitIdOutdatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParentCommitIdRequiredException": return try await ParentCommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PutFileEntryConflictException": return try await PutFileEntryConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RestrictedSourceFileException": return try await RestrictedSourceFileException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SamePathRequestException": return try await SamePathRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SourceFileOrContentRequiredException": return try await SourceFileOrContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePullRequestApprovalRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleContent
        case approvalRuleName
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleContent = self.approvalRuleContent {
            try encodeContainer.encode(approvalRuleContent, forKey: .approvalRuleContent)
        }
        if let approvalRuleName = self.approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension CreatePullRequestApprovalRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePullRequestApprovalRuleInput: Swift.Equatable {
    /// The content of the approval rule, including the number of approvals needed and the structure of an approval pool defined for approvals, if any. For more information about approval pools, see the CodeCommit User Guide. When you create the content of the approval rule, you can specify approvers in an approval pool in one of two ways:
    ///
    /// * CodeCommitApprovers: This option only requires an Amazon Web Services account and a resource. It can be used for both IAM users and federated access users whose name matches the provided resource name. This is a very powerful option that offers a great deal of flexibility. For example, if you specify the Amazon Web Services account 123456789012 and Mary_Major, all of the following would be counted as approvals coming from that user:
    ///
    /// * An IAM user in the account (arn:aws:iam::123456789012:user/Mary_Major)
    ///
    /// * A federated user identified in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
    ///
    ///
    /// This option does not recognize an active session of someone assuming the role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major) unless you include a wildcard (*Mary_Major).
    ///
    /// * Fully qualified ARN: This option allows you to specify the fully qualified Amazon Resource Name (ARN) of the IAM user or role.
    ///
    ///
    /// For more information about IAM ARNs, wildcards, and formats, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var approvalRuleContent: Swift.String?
    /// The name for the approval rule.
    /// This member is required.
    public var approvalRuleName: Swift.String?
    /// The system-generated ID of the pull request for which you want to create the approval rule.
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        approvalRuleContent: Swift.String? = nil,
        approvalRuleName: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.approvalRuleContent = approvalRuleContent
        self.approvalRuleName = approvalRuleName
        self.pullRequestId = pullRequestId
    }
}

struct CreatePullRequestApprovalRuleInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let approvalRuleName: Swift.String?
    let approvalRuleContent: Swift.String?
}

extension CreatePullRequestApprovalRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleContent
        case approvalRuleName
        case pullRequestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let approvalRuleContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleContent)
        approvalRuleContent = approvalRuleContentDecoded
    }
}

extension CreatePullRequestApprovalRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePullRequestApprovalRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRule = output.approvalRule
        } else {
            self.approvalRule = nil
        }
    }
}

public struct CreatePullRequestApprovalRuleOutput: Swift.Equatable {
    /// Information about the created approval rule.
    /// This member is required.
    public var approvalRule: CodeCommitClientTypes.ApprovalRule?

    public init(
        approvalRule: CodeCommitClientTypes.ApprovalRule? = nil
    )
    {
        self.approvalRule = approvalRule
    }
}

struct CreatePullRequestApprovalRuleOutputBody: Swift.Equatable {
    let approvalRule: CodeCommitClientTypes.ApprovalRule?
}

extension CreatePullRequestApprovalRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRule.self, forKey: .approvalRule)
        approvalRule = approvalRuleDecoded
    }
}

enum CreatePullRequestApprovalRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleContentRequiredException": return try await ApprovalRuleContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleNameAlreadyExistsException": return try await ApprovalRuleNameAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleNameRequiredException": return try await ApprovalRuleNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleContentException": return try await InvalidApprovalRuleContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleNameException": return try await InvalidApprovalRuleNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NumberOfRulesExceededException": return try await NumberOfRulesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestAlreadyClosedException": return try await PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePullRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case description
        case targets
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension CreatePullRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePullRequestInput: Swift.Equatable {
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token. The Amazon Web ServicesSDKs prepopulate client request tokens. If you are using an Amazon Web ServicesSDK, an idempotency token is created for you.
    public var clientRequestToken: Swift.String?
    /// A description of the pull request.
    public var description: Swift.String?
    /// The targets for the pull request, including the source of the code to be reviewed (the source branch) and the destination where the creator of the pull request intends the code to be merged after the pull request is closed (the destination branch).
    /// This member is required.
    public var targets: [CodeCommitClientTypes.Target]?
    /// The title of the pull request. This title is used to identify the pull request to other users in the repository.
    /// This member is required.
    public var title: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        targets: [CodeCommitClientTypes.Target]? = nil,
        title: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.targets = targets
        self.title = title
    }
}

struct CreatePullRequestInputBody: Swift.Equatable {
    let title: Swift.String?
    let description: Swift.String?
    let targets: [CodeCommitClientTypes.Target]?
    let clientRequestToken: Swift.String?
}

extension CreatePullRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case description
        case targets
        case title
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[CodeCommitClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [CodeCommitClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreatePullRequestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePullRequestOutputBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct CreatePullRequestOutput: Swift.Equatable {
    /// Information about the newly created pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct CreatePullRequestOutputBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension CreatePullRequestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

enum CreatePullRequestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientRequestTokenRequiredException": return try await ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyParameterMismatchException": return try await IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientRequestTokenException": return try await InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidDescriptionException": return try await InvalidDescriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReferenceNameException": return try await InvalidReferenceNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTargetException": return try await InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTargetsException": return try await InvalidTargetsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTitleException": return try await InvalidTitleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumOpenPullRequestsExceededException": return try await MaximumOpenPullRequestsExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MultipleRepositoriesInPullRequestException": return try await MultipleRepositoriesInPullRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReferenceDoesNotExistException": return try await ReferenceDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReferenceNameRequiredException": return try await ReferenceNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReferenceTypeNotSupportedException": return try await ReferenceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SourceAndDestinationAreSameException": return try await SourceAndDestinationAreSameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TargetRequiredException": return try await TargetRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TargetsRequiredException": return try await TargetsRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TitleRequiredException": return try await TitleRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryDescription
        case repositoryName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryDescription = self.repositoryDescription {
            try encodeContainer.encode(repositoryDescription, forKey: .repositoryDescription)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a create repository operation.
public struct CreateRepositoryInput: Swift.Equatable {
    /// A comment or description about the new repository. The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a webpage can expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a webpage.
    public var repositoryDescription: Swift.String?
    /// The name of the new repository to be created. The repository name must be unique across the calling Amazon Web Services account. Repository names are limited to 100 alphanumeric, dash, and underscore characters, and cannot include certain characters. For more information about the limits on repository names, see [Quotas](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html) in the CodeCommit User Guide. The suffix .git is prohibited.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// One or more tag key-value pairs to use when tagging this repository.
    public var tags: [Swift.String:Swift.String]?

    public init(
        repositoryDescription: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.repositoryDescription = repositoryDescription
        self.repositoryName = repositoryName
        self.tags = tags
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let repositoryDescription: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryDescription
        case repositoryName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryDescription)
        repositoryDescription = repositoryDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repositoryMetadata = output.repositoryMetadata
        } else {
            self.repositoryMetadata = nil
        }
    }
}

/// Represents the output of a create repository operation.
public struct CreateRepositoryOutput: Swift.Equatable {
    /// Information about the newly created repository.
    public var repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata?

    public init(
        repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata? = nil
    )
    {
        self.repositoryMetadata = repositoryMetadata
    }
}

struct CreateRepositoryOutputBody: Swift.Equatable {
    let repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata?
}

extension CreateRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryMetadata
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.RepositoryMetadata.self, forKey: .repositoryMetadata)
        repositoryMetadata = repositoryMetadataDecoded
    }
}

enum CreateRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryDescriptionException": return try await InvalidRepositoryDescriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSystemTagUsageException": return try await InvalidSystemTagUsageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagsMapException": return try await InvalidTagsMapException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryLimitExceededException": return try await RepositoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameExistsException": return try await RepositoryNameExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagPolicyException": return try await TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUnreferencedMergeCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case mergeOption
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let keepEmptyFolders = self.keepEmptyFolders {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let mergeOption = self.mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension CreateUnreferencedMergeCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUnreferencedMergeCommitInput: Swift.Equatable {
    /// The name of the author who created the unreferenced commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message for the unreferenced commit.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The email address for the person who created the unreferenced commit.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If this is specified as true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// The name of the repository where you want to create the unreferenced merge commit.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = nil,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.mergeOption = mergeOption
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct CreateUnreferencedMergeCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let authorName: Swift.String?
    let email: Swift.String?
    let commitMessage: Swift.String?
    let keepEmptyFolders: Swift.Bool?
    let conflictResolution: CodeCommitClientTypes.ConflictResolution?
}

extension CreateUnreferencedMergeCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case mergeOption
        case repositoryName
        case sourceCommitSpecifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension CreateUnreferencedMergeCommitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUnreferencedMergeCommitOutputBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct CreateUnreferencedMergeCommitOutput: Swift.Equatable {
    /// The full commit ID of the commit that contains your merge results.
    public var commitId: Swift.String?
    /// The full SHA-1 pointer of the tree information for the commit that contains the merge results.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct CreateUnreferencedMergeCommitOutputBody: Swift.Equatable {
    let commitId: Swift.String?
    let treeId: Swift.String?
}

extension CreateUnreferencedMergeCommitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case treeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

enum CreateUnreferencedMergeCommitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitMessageLengthExceededException": return try await CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentReferenceUpdateException": return try await ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileContentSizeLimitExceededException": return try await FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileModeRequiredException": return try await FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FolderContentSizeLimitExceededException": return try await FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictDetailLevelException": return try await InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionException": return try await InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionStrategyException": return try await InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEmailException": return try await InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFileModeException": return try await InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMergeOptionException": return try await InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReplacementContentException": return try await InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReplacementTypeException": return try await InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ManualMergeRequiredException": return try await ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumConflictResolutionEntriesExceededException": return try await MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumFileContentToLoadExceededException": return try await MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumItemsToCompareExceededException": return try await MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MergeOptionRequiredException": return try await MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MultipleConflictResolutionEntriesException": return try await MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameLengthExceededException": return try await NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplacementContentRequiredException": return try await ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplacementTypeRequiredException": return try await ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DefaultBranchCannotBeDeletedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DefaultBranchCannotBeDeletedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.
public struct DefaultBranchCannotBeDeletedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DefaultBranchCannotBeDeletedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DefaultBranchCannotBeDeletedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DefaultBranchCannotBeDeletedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteApprovalRuleTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

extension DeleteApprovalRuleTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApprovalRuleTemplateInput: Swift.Equatable {
    /// The name of the approval rule template to delete.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct DeleteApprovalRuleTemplateInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
}

extension DeleteApprovalRuleTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
    }
}

extension DeleteApprovalRuleTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteApprovalRuleTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplateId = output.approvalRuleTemplateId
        } else {
            self.approvalRuleTemplateId = nil
        }
    }
}

public struct DeleteApprovalRuleTemplateOutput: Swift.Equatable {
    /// The system-generated ID of the deleted approval rule template. If the template has been previously deleted, the only response is a 200 OK.
    /// This member is required.
    public var approvalRuleTemplateId: Swift.String?

    public init(
        approvalRuleTemplateId: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateId = approvalRuleTemplateId
    }
}

struct DeleteApprovalRuleTemplateOutputBody: Swift.Equatable {
    let approvalRuleTemplateId: Swift.String?
}

extension DeleteApprovalRuleTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateId)
        approvalRuleTemplateId = approvalRuleTemplateIdDecoded
    }
}

enum DeleteApprovalRuleTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateInUseException": return try await ApprovalRuleTemplateInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a delete branch operation.
public struct DeleteBranchInput: Swift.Equatable {
    /// The name of the branch to delete.
    /// This member is required.
    public var branchName: Swift.String?
    /// The name of the repository that contains the branch to be deleted.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.repositoryName = repositoryName
    }
}

struct DeleteBranchInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
}

extension DeleteBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension DeleteBranchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBranchOutputBody = try responseDecoder.decode(responseBody: data)
            self.deletedBranch = output.deletedBranch
        } else {
            self.deletedBranch = nil
        }
    }
}

/// Represents the output of a delete branch operation.
public struct DeleteBranchOutput: Swift.Equatable {
    /// Information about the branch deleted by the operation, including the branch name and the commit ID that was the tip of the branch.
    public var deletedBranch: CodeCommitClientTypes.BranchInfo?

    public init(
        deletedBranch: CodeCommitClientTypes.BranchInfo? = nil
    )
    {
        self.deletedBranch = deletedBranch
    }
}

struct DeleteBranchOutputBody: Swift.Equatable {
    let deletedBranch: CodeCommitClientTypes.BranchInfo?
}

extension DeleteBranchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletedBranch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedBranchDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.BranchInfo.self, forKey: .deletedBranch)
        deletedBranch = deletedBranchDecoded
    }
}

enum DeleteBranchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BranchNameRequiredException": return try await BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DefaultBranchCannotBeDeletedException": return try await DefaultBranchCannotBeDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBranchNameException": return try await InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCommentContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
    }
}

extension DeleteCommentContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCommentContentInput: Swift.Equatable {
    /// The unique, system-generated ID of the comment. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var commentId: Swift.String?

    public init(
        commentId: Swift.String? = nil
    )
    {
        self.commentId = commentId
    }
}

struct DeleteCommentContentInputBody: Swift.Equatable {
    let commentId: Swift.String?
}

extension DeleteCommentContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
    }
}

extension DeleteCommentContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteCommentContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct DeleteCommentContentOutput: Swift.Equatable {
    /// Information about the comment you just deleted.
    public var comment: CodeCommitClientTypes.Comment?

    public init(
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct DeleteCommentContentOutputBody: Swift.Equatable {
    let comment: CodeCommitClientTypes.Comment?
}

extension DeleteCommentContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

enum DeleteCommentContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommentDeletedException": return try await CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentDoesNotExistException": return try await CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentIdRequiredException": return try await CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommentIdException": return try await InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.DeleteFileEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

extension CodeCommitClientTypes {
    /// A file that is deleted as part of a commit.
    public struct DeleteFileEntry: Swift.Equatable {
        /// The full path of the file to be deleted, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?

        public init(
            filePath: Swift.String? = nil
        )
        {
            self.filePath = filePath
        }
    }

}

extension DeleteFileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitMessage
        case email
        case filePath
        case keepEmptyFolders
        case name
        case parentCommitId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let keepEmptyFolders = self.keepEmptyFolders {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentCommitId = self.parentCommitId {
            try encodeContainer.encode(parentCommitId, forKey: .parentCommitId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteFileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFileInput: Swift.Equatable {
    /// The name of the branch where the commit that deletes the file is made.
    /// This member is required.
    public var branchName: Swift.String?
    /// The commit message you want to include as part of deleting the file. Commit messages are limited to 256 KB. If no message is specified, a default message is used.
    public var commitMessage: Swift.String?
    /// The email address for the commit that deletes the file. If no email address is specified, the email address is left blank.
    public var email: Swift.String?
    /// The fully qualified path to the file that to be deleted, including the full name and extension of that file. For example, /examples/file.md is a fully qualified path to a file named file.md in a folder named examples.
    /// This member is required.
    public var filePath: Swift.String?
    /// If a file is the only object in the folder or directory, specifies whether to delete the folder or directory that contains the file. By default, empty folders are deleted. This includes empty folders that are part of the directory structure. For example, if the path to a file is dir1/dir2/dir3/dir4, and dir2 and dir3 are empty, deleting the last file in dir4 also deletes the empty folders dir4, dir3, and dir2.
    public var keepEmptyFolders: Swift.Bool?
    /// The name of the author of the commit that deletes the file. If no name is specified, the user's ARN is used as the author name and committer name.
    public var name: Swift.String?
    /// The ID of the commit that is the tip of the branch where you want to create the commit that deletes the file. This must be the HEAD commit for the branch. The commit that deletes the file is created from this commit ID.
    /// This member is required.
    public var parentCommitId: Swift.String?
    /// The name of the repository that contains the file to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        email: Swift.String? = nil,
        filePath: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = nil,
        name: Swift.String? = nil,
        parentCommitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.email = email
        self.filePath = filePath
        self.keepEmptyFolders = keepEmptyFolders
        self.name = name
        self.parentCommitId = parentCommitId
        self.repositoryName = repositoryName
    }
}

struct DeleteFileInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
    let filePath: Swift.String?
    let parentCommitId: Swift.String?
    let keepEmptyFolders: Swift.Bool?
    let commitMessage: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
}

extension DeleteFileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitMessage
        case email
        case filePath
        case keepEmptyFolders
        case name
        case parentCommitId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let parentCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentCommitId)
        parentCommitId = parentCommitIdDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension DeleteFileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteFileOutputBody = try responseDecoder.decode(responseBody: data)
            self.blobId = output.blobId
            self.commitId = output.commitId
            self.filePath = output.filePath
            self.treeId = output.treeId
        } else {
            self.blobId = nil
            self.commitId = nil
            self.filePath = nil
            self.treeId = nil
        }
    }
}

public struct DeleteFileOutput: Swift.Equatable {
    /// The blob ID removed from the tree as part of deleting the file.
    /// This member is required.
    public var blobId: Swift.String?
    /// The full commit ID of the commit that contains the change that deletes the file.
    /// This member is required.
    public var commitId: Swift.String?
    /// The fully qualified path to the file to be deleted, including the full name and extension of that file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The full SHA-1 pointer of the tree information for the commit that contains the delete file change.
    /// This member is required.
    public var treeId: Swift.String?

    public init(
        blobId: Swift.String? = nil,
        commitId: Swift.String? = nil,
        filePath: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.filePath = filePath
        self.treeId = treeId
    }
}

struct DeleteFileOutputBody: Swift.Equatable {
    let commitId: Swift.String?
    let blobId: Swift.String?
    let treeId: Swift.String?
    let filePath: Swift.String?
}

extension DeleteFileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case commitId
        case filePath
        case treeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

enum DeleteFileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BranchDoesNotExistException": return try await BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameIsTagNameException": return try await BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameRequiredException": return try await BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitMessageLengthExceededException": return try await CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileDoesNotExistException": return try await FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBranchNameException": return try await InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEmailException": return try await InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParentCommitIdException": return try await InvalidParentCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameLengthExceededException": return try await NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParentCommitDoesNotExistException": return try await ParentCommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParentCommitIdOutdatedException": return try await ParentCommitIdOutdatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParentCommitIdRequiredException": return try await ParentCommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePullRequestApprovalRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleName
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleName = self.approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension DeletePullRequestApprovalRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePullRequestApprovalRuleInput: Swift.Equatable {
    /// The name of the approval rule you want to delete.
    /// This member is required.
    public var approvalRuleName: Swift.String?
    /// The system-generated ID of the pull request that contains the approval rule you want to delete.
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        approvalRuleName: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.approvalRuleName = approvalRuleName
        self.pullRequestId = pullRequestId
    }
}

struct DeletePullRequestApprovalRuleInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let approvalRuleName: Swift.String?
}

extension DeletePullRequestApprovalRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleName
        case pullRequestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
    }
}

extension DeletePullRequestApprovalRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePullRequestApprovalRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleId = output.approvalRuleId
        } else {
            self.approvalRuleId = nil
        }
    }
}

public struct DeletePullRequestApprovalRuleOutput: Swift.Equatable {
    /// The ID of the deleted approval rule. If the approval rule was deleted in an earlier API call, the response is 200 OK without content.
    /// This member is required.
    public var approvalRuleId: Swift.String?

    public init(
        approvalRuleId: Swift.String? = nil
    )
    {
        self.approvalRuleId = approvalRuleId
    }
}

struct DeletePullRequestApprovalRuleOutputBody: Swift.Equatable {
    let approvalRuleId: Swift.String?
}

extension DeletePullRequestApprovalRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleId)
        approvalRuleId = approvalRuleIdDecoded
    }
}

enum DeletePullRequestApprovalRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleNameRequiredException": return try await ApprovalRuleNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CannotDeleteApprovalRuleFromTemplateException": return try await CannotDeleteApprovalRuleFromTemplateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleNameException": return try await InvalidApprovalRuleNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestAlreadyClosedException": return try await PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a delete repository operation.
public struct DeleteRepositoryInput: Swift.Equatable {
    /// The name of the repository to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
}

extension DeleteRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repositoryId = output.repositoryId
        } else {
            self.repositoryId = nil
        }
    }
}

/// Represents the output of a delete repository operation.
public struct DeleteRepositoryOutput: Swift.Equatable {
    /// The ID of the repository that was deleted.
    public var repositoryId: Swift.String?

    public init(
        repositoryId: Swift.String? = nil
    )
    {
        self.repositoryId = repositoryId
    }
}

struct DeleteRepositoryOutputBody: Swift.Equatable {
    let repositoryId: Swift.String?
}

extension DeleteRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
    }
}

enum DeleteRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMergeConflictsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePath
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let maxMergeHunks = self.maxMergeHunks {
            try encodeContainer.encode(maxMergeHunks, forKey: .maxMergeHunks)
        }
        if let mergeOption = self.mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension DescribeMergeConflictsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMergeConflictsInput: Swift.Equatable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The path of the target files used to describe the conflicts.
    /// This member is required.
    public var filePath: Swift.String?
    /// The maximum number of merge hunks to include in the output.
    public var maxMergeHunks: Swift.Int?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where you want to get information about a merge conflict.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        filePath: Swift.String? = nil,
        maxMergeHunks: Swift.Int? = nil,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.filePath = filePath
        self.maxMergeHunks = maxMergeHunks
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct DescribeMergeConflictsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    let maxMergeHunks: Swift.Int?
    let filePath: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let nextToken: Swift.String?
}

extension DescribeMergeConflictsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePath
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let maxMergeHunksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxMergeHunks)
        maxMergeHunks = maxMergeHunksDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMergeConflictsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMergeConflictsOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseCommitId = output.baseCommitId
            self.conflictMetadata = output.conflictMetadata
            self.destinationCommitId = output.destinationCommitId
            self.mergeHunks = output.mergeHunks
            self.nextToken = output.nextToken
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.conflictMetadata = nil
            self.destinationCommitId = nil
            self.mergeHunks = nil
            self.nextToken = nil
            self.sourceCommitId = nil
        }
    }
}

public struct DescribeMergeConflictsOutput: Swift.Equatable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// Contains metadata about the conflicts found in the merge.
    /// This member is required.
    public var conflictMetadata: CodeCommitClientTypes.ConflictMetadata?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// A list of merge hunks of the differences between the files or lines.
    /// This member is required.
    public var mergeHunks: [CodeCommitClientTypes.MergeHunk]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init(
        baseCommitId: Swift.String? = nil,
        conflictMetadata: CodeCommitClientTypes.ConflictMetadata? = nil,
        destinationCommitId: Swift.String? = nil,
        mergeHunks: [CodeCommitClientTypes.MergeHunk]? = nil,
        nextToken: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflictMetadata = conflictMetadata
        self.destinationCommitId = destinationCommitId
        self.mergeHunks = mergeHunks
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

struct DescribeMergeConflictsOutputBody: Swift.Equatable {
    let conflictMetadata: CodeCommitClientTypes.ConflictMetadata?
    let mergeHunks: [CodeCommitClientTypes.MergeHunk]?
    let nextToken: Swift.String?
    let destinationCommitId: Swift.String?
    let sourceCommitId: Swift.String?
    let baseCommitId: Swift.String?
}

extension DescribeMergeConflictsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCommitId
        case conflictMetadata
        case destinationCommitId
        case mergeHunks
        case nextToken
        case sourceCommitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictMetadata.self, forKey: .conflictMetadata)
        conflictMetadata = conflictMetadataDecoded
        let mergeHunksContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.MergeHunk?].self, forKey: .mergeHunks)
        var mergeHunksDecoded0:[CodeCommitClientTypes.MergeHunk]? = nil
        if let mergeHunksContainer = mergeHunksContainer {
            mergeHunksDecoded0 = [CodeCommitClientTypes.MergeHunk]()
            for structure0 in mergeHunksContainer {
                if let structure0 = structure0 {
                    mergeHunksDecoded0?.append(structure0)
                }
            }
        }
        mergeHunks = mergeHunksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
    }
}

enum DescribeMergeConflictsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileDoesNotExistException": return try await FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictDetailLevelException": return try await InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionStrategyException": return try await InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxMergeHunksException": return try await InvalidMaxMergeHunksException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMergeOptionException": return try await InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumFileContentToLoadExceededException": return try await MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumItemsToCompareExceededException": return try await MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MergeOptionRequiredException": return try await MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePullRequestEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actorArn
        case maxResults
        case nextToken
        case pullRequestEventType
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actorArn = self.actorArn {
            try encodeContainer.encode(actorArn, forKey: .actorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pullRequestEventType = self.pullRequestEventType {
            try encodeContainer.encode(pullRequestEventType.rawValue, forKey: .pullRequestEventType)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension DescribePullRequestEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePullRequestEventsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user whose actions resulted in the event. Examples include updating the pull request with more commits or changing the status of a pull request.
    public var actorArn: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is 100 events, which is also the maximum number of events that can be returned in a result.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// Optional. The pull request event type about which you want to return information.
    public var pullRequestEventType: CodeCommitClientTypes.PullRequestEventType?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        actorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pullRequestEventType: CodeCommitClientTypes.PullRequestEventType? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.actorArn = actorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestEventType = pullRequestEventType
        self.pullRequestId = pullRequestId
    }
}

struct DescribePullRequestEventsInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let pullRequestEventType: CodeCommitClientTypes.PullRequestEventType?
    let actorArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribePullRequestEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actorArn
        case maxResults
        case nextToken
        case pullRequestEventType
        case pullRequestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let pullRequestEventTypeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestEventType.self, forKey: .pullRequestEventType)
        pullRequestEventType = pullRequestEventTypeDecoded
        let actorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actorArn)
        actorArn = actorArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribePullRequestEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePullRequestEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pullRequestEvents = output.pullRequestEvents
        } else {
            self.nextToken = nil
            self.pullRequestEvents = nil
        }
    }
}

public struct DescribePullRequestEventsOutput: Swift.Equatable {
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// Information about the pull request events.
    /// This member is required.
    public var pullRequestEvents: [CodeCommitClientTypes.PullRequestEvent]?

    public init(
        nextToken: Swift.String? = nil,
        pullRequestEvents: [CodeCommitClientTypes.PullRequestEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.pullRequestEvents = pullRequestEvents
    }
}

struct DescribePullRequestEventsOutputBody: Swift.Equatable {
    let pullRequestEvents: [CodeCommitClientTypes.PullRequestEvent]?
    let nextToken: Swift.String?
}

extension DescribePullRequestEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case pullRequestEvents
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestEventsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.PullRequestEvent?].self, forKey: .pullRequestEvents)
        var pullRequestEventsDecoded0:[CodeCommitClientTypes.PullRequestEvent]? = nil
        if let pullRequestEventsContainer = pullRequestEventsContainer {
            pullRequestEventsDecoded0 = [CodeCommitClientTypes.PullRequestEvent]()
            for structure0 in pullRequestEventsContainer {
                if let structure0 = structure0 {
                    pullRequestEventsDecoded0?.append(structure0)
                }
            }
        }
        pullRequestEvents = pullRequestEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribePullRequestEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ActorDoesNotExistException": return try await ActorDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidActorArnException": return try await InvalidActorArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResultsException": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestEventTypeException": return try await InvalidPullRequestEventTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.Difference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterBlob
        case beforeBlob
        case changeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterBlob = self.afterBlob {
            try encodeContainer.encode(afterBlob, forKey: .afterBlob)
        }
        if let beforeBlob = self.beforeBlob {
            try encodeContainer.encode(beforeBlob, forKey: .beforeBlob)
        }
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beforeBlobDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.BlobMetadata.self, forKey: .beforeBlob)
        beforeBlob = beforeBlobDecoded
        let afterBlobDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.BlobMetadata.self, forKey: .afterBlob)
        afterBlob = afterBlobDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ChangeTypeEnum.self, forKey: .changeType)
        changeType = changeTypeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a set of differences for a commit specifier.
    public struct Difference: Swift.Equatable {
        /// Information about an afterBlob data type object, including the ID, the file mode permission code, and the path.
        public var afterBlob: CodeCommitClientTypes.BlobMetadata?
        /// Information about a beforeBlob data type object, including the ID, the file mode permission code, and the path.
        public var beforeBlob: CodeCommitClientTypes.BlobMetadata?
        /// Whether the change type of the difference is an addition (A), deletion (D), or modification (M).
        public var changeType: CodeCommitClientTypes.ChangeTypeEnum?

        public init(
            afterBlob: CodeCommitClientTypes.BlobMetadata? = nil,
            beforeBlob: CodeCommitClientTypes.BlobMetadata? = nil,
            changeType: CodeCommitClientTypes.ChangeTypeEnum? = nil
        )
        {
            self.afterBlob = afterBlob
            self.beforeBlob = beforeBlob
            self.changeType = changeType
        }
    }

}

extension DirectoryNameConflictsWithFileNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryNameConflictsWithFileNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.
public struct DirectoryNameConflictsWithFileNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryNameConflictsWithFileNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DirectoryNameConflictsWithFileNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryNameConflictsWithFileNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateApprovalRuleTemplateFromRepositoryInput: Swift.Equatable {
    /// The name of the approval rule template to disassociate from a specified repository.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The name of the repository you want to disassociate from the template.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryName = repositoryName
    }
}

struct DisassociateApprovalRuleTemplateFromRepositoryInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let repositoryName: Swift.String?
}

extension DisassociateApprovalRuleTemplateFromRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateApprovalRuleTemplateFromRepositoryOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateApprovalRuleTemplateFromRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateDoesNotExistException": return try await ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EncryptionIntegrityChecksFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EncryptionIntegrityChecksFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An encryption integrity check failed.
public struct EncryptionIntegrityChecksFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionIntegrityChecksFailedException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EncryptionIntegrityChecksFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EncryptionIntegrityChecksFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyAccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EncryptionKeyAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An encryption key could not be accessed.
public struct EncryptionKeyAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyAccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EncryptionKeyAccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EncryptionKeyAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyDisabledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EncryptionKeyDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The encryption key is disabled.
public struct EncryptionKeyDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyDisabledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EncryptionKeyDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EncryptionKeyDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EncryptionKeyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// No encryption key was found.
public struct EncryptionKeyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EncryptionKeyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EncryptionKeyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EncryptionKeyUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The encryption key is not available.
public struct EncryptionKeyUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EncryptionKeyUnavailableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EncryptionKeyUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EncryptionKeyUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EvaluatePullRequestApprovalRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension EvaluatePullRequestApprovalRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EvaluatePullRequestApprovalRulesInput: Swift.Equatable {
    /// The system-generated ID of the pull request you want to evaluate.
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID for the pull request revision. To retrieve the most recent revision ID for a pull request, use [GetPullRequest].
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct EvaluatePullRequestApprovalRulesInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let revisionId: Swift.String?
}

extension EvaluatePullRequestApprovalRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension EvaluatePullRequestApprovalRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EvaluatePullRequestApprovalRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluation = output.evaluation
        } else {
            self.evaluation = nil
        }
    }
}

public struct EvaluatePullRequestApprovalRulesOutput: Swift.Equatable {
    /// The result of the evaluation, including the names of the rules whose conditions have been met (if any), the names of the rules whose conditions have not been met (if any), whether the pull request is in the approved state, and whether the pull request approval rule has been set aside by an override.
    /// This member is required.
    public var evaluation: CodeCommitClientTypes.Evaluation?

    public init(
        evaluation: CodeCommitClientTypes.Evaluation? = nil
    )
    {
        self.evaluation = evaluation
    }
}

struct EvaluatePullRequestApprovalRulesOutputBody: Swift.Equatable {
    let evaluation: CodeCommitClientTypes.Evaluation?
}

extension EvaluatePullRequestApprovalRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Evaluation.self, forKey: .evaluation)
        evaluation = evaluationDecoded
    }
}

enum EvaluatePullRequestApprovalRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRevisionIdException": return try await InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RevisionIdRequiredException": return try await RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RevisionNotCurrentException": return try await RevisionNotCurrentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.Evaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRulesNotSatisfied
        case approvalRulesSatisfied
        case approved
        case overridden
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRulesNotSatisfied = approvalRulesNotSatisfied {
            var approvalRulesNotSatisfiedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvalRulesNotSatisfied)
            for approvalrulename0 in approvalRulesNotSatisfied {
                try approvalRulesNotSatisfiedContainer.encode(approvalrulename0)
            }
        }
        if let approvalRulesSatisfied = approvalRulesSatisfied {
            var approvalRulesSatisfiedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvalRulesSatisfied)
            for approvalrulename0 in approvalRulesSatisfied {
                try approvalRulesSatisfiedContainer.encode(approvalrulename0)
            }
        }
        if approved != false {
            try encodeContainer.encode(approved, forKey: .approved)
        }
        if overridden != false {
            try encodeContainer.encode(overridden, forKey: .overridden)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .approved) ?? false
        approved = approvedDecoded
        let overriddenDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overridden) ?? false
        overridden = overriddenDecoded
        let approvalRulesSatisfiedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvalRulesSatisfied)
        var approvalRulesSatisfiedDecoded0:[Swift.String]? = nil
        if let approvalRulesSatisfiedContainer = approvalRulesSatisfiedContainer {
            approvalRulesSatisfiedDecoded0 = [Swift.String]()
            for string0 in approvalRulesSatisfiedContainer {
                if let string0 = string0 {
                    approvalRulesSatisfiedDecoded0?.append(string0)
                }
            }
        }
        approvalRulesSatisfied = approvalRulesSatisfiedDecoded0
        let approvalRulesNotSatisfiedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvalRulesNotSatisfied)
        var approvalRulesNotSatisfiedDecoded0:[Swift.String]? = nil
        if let approvalRulesNotSatisfiedContainer = approvalRulesNotSatisfiedContainer {
            approvalRulesNotSatisfiedDecoded0 = [Swift.String]()
            for string0 in approvalRulesNotSatisfiedContainer {
                if let string0 = string0 {
                    approvalRulesNotSatisfiedDecoded0?.append(string0)
                }
            }
        }
        approvalRulesNotSatisfied = approvalRulesNotSatisfiedDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Returns information about the approval rules applied to a pull request and whether conditions have been met.
    public struct Evaluation: Swift.Equatable {
        /// The names of the approval rules that have not had their conditions met.
        public var approvalRulesNotSatisfied: [Swift.String]?
        /// The names of the approval rules that have had their conditions met.
        public var approvalRulesSatisfied: [Swift.String]?
        /// Whether the state of the pull request is approved.
        public var approved: Swift.Bool
        /// Whether the approval rule requirements for the pull request have been overridden and no longer need to be met.
        public var overridden: Swift.Bool

        public init(
            approvalRulesNotSatisfied: [Swift.String]? = nil,
            approvalRulesSatisfied: [Swift.String]? = nil,
            approved: Swift.Bool = false,
            overridden: Swift.Bool = false
        )
        {
            self.approvalRulesNotSatisfied = approvalRulesNotSatisfied
            self.approvalRulesSatisfied = approvalRulesSatisfied
            self.approved = approved
            self.overridden = overridden
        }
    }

}

extension CodeCommitClientTypes.File: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutePath
        case blobId
        case fileMode
        case relativePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = self.absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let relativePath = self.relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a file in a repository.
    public struct File: Swift.Equatable {
        /// The fully qualified path to the file in the repository.
        public var absolutePath: Swift.String?
        /// The blob ID that contains the file information.
        public var blobId: Swift.String?
        /// The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The relative path of the file from the folder where the query originated.
        public var relativePath: Swift.String?

        public init(
            absolutePath: Swift.String? = nil,
            blobId: Swift.String? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            relativePath: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.blobId = blobId
            self.fileMode = fileMode
            self.relativePath = relativePath
        }
    }

}

extension FileContentAndSourceFileSpecifiedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileContentAndSourceFileSpecifiedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit cannot be created because both a source file and file content have been specified for the same file. You cannot provide both. Either specify a source file or provide the file content directly.
public struct FileContentAndSourceFileSpecifiedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileContentAndSourceFileSpecifiedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FileContentAndSourceFileSpecifiedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileContentAndSourceFileSpecifiedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileContentRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.
public struct FileContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileContentRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FileContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileContentSizeLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileContentSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.
public struct FileContentSizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileContentSizeLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FileContentSizeLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileContentSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified file does not exist. Verify that you have used the correct file name, full path, and extension.
public struct FileDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FileDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileEntryRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileEntryRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.
public struct FileEntryRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileEntryRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FileEntryRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileEntryRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.FileMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutePath
        case blobId
        case fileMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = self.absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let absolutePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension CodeCommitClientTypes {
    /// A file to be added, updated, or deleted as part of a commit.
    public struct FileMetadata: Swift.Equatable {
        /// The full path to the file to be added or updated, including the name of the file.
        public var absolutePath: Swift.String?
        /// The blob ID that contains the file information.
        public var blobId: Swift.String?
        /// The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?

        public init(
            absolutePath: Swift.String? = nil,
            blobId: Swift.String? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil
        )
        {
            self.absolutePath = absolutePath
            self.blobId = blobId
            self.fileMode = fileMode
        }
    }

}

extension FileModeRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileModeRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.
public struct FileModeRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileModeRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FileModeRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileModeRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum FileModeTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case executable
        case normal
        case symlink
        case sdkUnknown(Swift.String)

        public static var allCases: [FileModeTypeEnum] {
            return [
                .executable,
                .normal,
                .symlink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .executable: return "EXECUTABLE"
            case .normal: return "NORMAL"
            case .symlink: return "SYMLINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileModeTypeEnum(rawValue: rawValue) ?? FileModeTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.FileModes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = self.base {
            try encodeContainer.encode(base.rawValue, forKey: .base)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination.rawValue, forKey: .destination)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .base)
        base = baseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about file modes in a merge or pull request.
    public struct FileModes: Swift.Equatable {
        /// The file mode of a file in the base of a merge or pull request.
        public var base: CodeCommitClientTypes.FileModeTypeEnum?
        /// The file mode of a file in the destination of a merge or pull request.
        public var destination: CodeCommitClientTypes.FileModeTypeEnum?
        /// The file mode of a file in the source of a merge or pull request.
        public var source: CodeCommitClientTypes.FileModeTypeEnum?

        public init(
            base: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            destination: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            source: CodeCommitClientTypes.FileModeTypeEnum? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }

}

extension FileNameConflictsWithDirectoryNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileNameConflictsWithDirectoryNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.
public struct FileNameConflictsWithDirectoryNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileNameConflictsWithDirectoryNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FileNameConflictsWithDirectoryNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileNameConflictsWithDirectoryNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FilePathConflictsWithSubmodulePathException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FilePathConflictsWithSubmodulePathExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.
public struct FilePathConflictsWithSubmodulePathException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FilePathConflictsWithSubmodulePathException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FilePathConflictsWithSubmodulePathExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FilePathConflictsWithSubmodulePathExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.FileSizes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if base != 0 {
            try encodeContainer.encode(base, forKey: .base)
        }
        if destination != 0 {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if source != 0 {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .source) ?? 0
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destination) ?? 0
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .base) ?? 0
        base = baseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the size of files in a merge or pull request.
    public struct FileSizes: Swift.Equatable {
        /// The size of a file in the base of a merge or pull request.
        public var base: Swift.Int
        /// The size of a file in the destination of a merge or pull request.
        public var destination: Swift.Int
        /// The size of a file in the source of a merge or pull request.
        public var source: Swift.Int

        public init(
            base: Swift.Int = 0,
            destination: Swift.Int = 0,
            source: Swift.Int = 0
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }

}

extension FileTooLargeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified file exceeds the file size limit for CodeCommit. For more information about limits in CodeCommit, see [Quotas](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html) in the CodeCommit User Guide.
public struct FileTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileTooLargeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FileTooLargeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.FileVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case commit
        case path
        case revisionChildren
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let commit = self.commit {
            try encodeContainer.encode(commit, forKey: .commit)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let revisionChildren = revisionChildren {
            var revisionChildrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revisionChildren)
            for revisionid0 in revisionChildren {
                try revisionChildrenContainer.encode(revisionid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Commit.self, forKey: .commit)
        commit = commitDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let revisionChildrenContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .revisionChildren)
        var revisionChildrenDecoded0:[Swift.String]? = nil
        if let revisionChildrenContainer = revisionChildrenContainer {
            revisionChildrenDecoded0 = [Swift.String]()
            for string0 in revisionChildrenContainer {
                if let string0 = string0 {
                    revisionChildrenDecoded0?.append(string0)
                }
            }
        }
        revisionChildren = revisionChildrenDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Information about a version of a file.
    public struct FileVersion: Swift.Equatable {
        /// The blob ID of the object that represents the content of the file in this version.
        public var blobId: Swift.String?
        /// Returns information about a specific commit.
        public var commit: CodeCommitClientTypes.Commit?
        /// The name and path of the file at which this blob is indexed which contains the data for this version of the file. This value will vary between file versions if a file is renamed or if its path changes.
        public var path: Swift.String?
        /// An array of commit IDs that contain more recent versions of this file. If there are no additional versions of the file, this array will be empty.
        public var revisionChildren: [Swift.String]?

        public init(
            blobId: Swift.String? = nil,
            commit: CodeCommitClientTypes.Commit? = nil,
            path: Swift.String? = nil,
            revisionChildren: [Swift.String]? = nil
        )
        {
            self.blobId = blobId
            self.commit = commit
            self.path = path
            self.revisionChildren = revisionChildren
        }
    }

}

extension CodeCommitClientTypes.Folder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutePath
        case relativePath
        case treeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = self.absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let relativePath = self.relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
        if let treeId = self.treeId {
            try encodeContainer.encode(treeId, forKey: .treeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a folder in a repository.
    public struct Folder: Swift.Equatable {
        /// The fully qualified path of the folder in the repository.
        public var absolutePath: Swift.String?
        /// The relative path of the specified folder from the folder where the query originated.
        public var relativePath: Swift.String?
        /// The full SHA-1 pointer of the tree information for the commit that contains the folder.
        public var treeId: Swift.String?

        public init(
            absolutePath: Swift.String? = nil,
            relativePath: Swift.String? = nil,
            treeId: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.relativePath = relativePath
            self.treeId = treeId
        }
    }

}

extension FolderContentSizeLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FolderContentSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.
public struct FolderContentSizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FolderContentSizeLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FolderContentSizeLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FolderContentSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FolderDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FolderDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified folder does not exist. Either the folder name is not correct, or you did not enter the full path to the folder.
public struct FolderDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FolderDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FolderDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FolderDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetApprovalRuleTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

extension GetApprovalRuleTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetApprovalRuleTemplateInput: Swift.Equatable {
    /// The name of the approval rule template for which you want to get information.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct GetApprovalRuleTemplateInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
}

extension GetApprovalRuleTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
    }
}

extension GetApprovalRuleTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApprovalRuleTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct GetApprovalRuleTemplateOutput: Swift.Equatable {
    /// The content and structure of the approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init(
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct GetApprovalRuleTemplateOutputBody: Swift.Equatable {
    let approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?
}

extension GetApprovalRuleTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

enum GetApprovalRuleTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateDoesNotExistException": return try await ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBlobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetBlobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a get blob operation.
public struct GetBlobInput: Swift.Equatable {
    /// The ID of the blob, which is its SHA-1 pointer.
    /// This member is required.
    public var blobId: Swift.String?
    /// The name of the repository that contains the blob.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        blobId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.blobId = blobId
        self.repositoryName = repositoryName
    }
}

struct GetBlobInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let blobId: Swift.String?
}

extension GetBlobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
    }
}

extension GetBlobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBlobOutputBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

/// Represents the output of a get blob operation.
public struct GetBlobOutput: Swift.Equatable {
    /// The content of the blob, usually a file.
    /// This member is required.
    public var content: ClientRuntime.Data?

    public init(
        content: ClientRuntime.Data? = nil
    )
    {
        self.content = content
    }
}

struct GetBlobOutputBody: Swift.Equatable {
    let content: ClientRuntime.Data?
}

extension GetBlobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

enum GetBlobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BlobIdDoesNotExistException": return try await BlobIdDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BlobIdRequiredException": return try await BlobIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileTooLargeException": return try await FileTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBlobIdException": return try await InvalidBlobIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a get branch operation.
public struct GetBranchInput: Swift.Equatable {
    /// The name of the branch for which you want to retrieve information.
    public var branchName: Swift.String?
    /// The name of the repository that contains the branch for which you want to retrieve information.
    public var repositoryName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.repositoryName = repositoryName
    }
}

struct GetBranchInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
}

extension GetBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension GetBranchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBranchOutputBody = try responseDecoder.decode(responseBody: data)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

/// Represents the output of a get branch operation.
public struct GetBranchOutput: Swift.Equatable {
    /// The name of the branch.
    public var branch: CodeCommitClientTypes.BranchInfo?

    public init(
        branch: CodeCommitClientTypes.BranchInfo? = nil
    )
    {
        self.branch = branch
    }
}

struct GetBranchOutputBody: Swift.Equatable {
    let branch: CodeCommitClientTypes.BranchInfo?
}

extension GetBranchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.BranchInfo.self, forKey: .branch)
        branch = branchDecoded
    }
}

enum GetBranchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BranchDoesNotExistException": return try await BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameRequiredException": return try await BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBranchNameException": return try await InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCommentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
    }
}

extension GetCommentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCommentInput: Swift.Equatable {
    /// The unique, system-generated ID of the comment. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var commentId: Swift.String?

    public init(
        commentId: Swift.String? = nil
    )
    {
        self.commentId = commentId
    }
}

struct GetCommentInputBody: Swift.Equatable {
    let commentId: Swift.String?
}

extension GetCommentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
    }
}

extension GetCommentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCommentOutputBody = try responseDecoder.decode(responseBody: data)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct GetCommentOutput: Swift.Equatable {
    /// The contents of the comment.
    public var comment: CodeCommitClientTypes.Comment?

    public init(
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct GetCommentOutputBody: Swift.Equatable {
    let comment: CodeCommitClientTypes.Comment?
}

extension GetCommentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

enum GetCommentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommentDeletedException": return try await CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentDoesNotExistException": return try await CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentIdRequiredException": return try await CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommentIdException": return try await InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCommentReactionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case maxResults
        case nextToken
        case reactionUserArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let reactionUserArn = self.reactionUserArn {
            try encodeContainer.encode(reactionUserArn, forKey: .reactionUserArn)
        }
    }
}

extension GetCommentReactionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCommentReactionsInput: Swift.Equatable {
    /// The ID of the comment for which you want to get reactions information.
    /// This member is required.
    public var commentId: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is the same as the allowed maximum, 1,000.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// Optional. The Amazon Resource Name (ARN) of the user or identity for which you want to get reaction information.
    public var reactionUserArn: Swift.String?

    public init(
        commentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reactionUserArn: Swift.String? = nil
    )
    {
        self.commentId = commentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reactionUserArn = reactionUserArn
    }
}

struct GetCommentReactionsInputBody: Swift.Equatable {
    let commentId: Swift.String?
    let reactionUserArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetCommentReactionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case maxResults
        case nextToken
        case reactionUserArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let reactionUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reactionUserArn)
        reactionUserArn = reactionUserArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCommentReactionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCommentReactionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reactionsForComment = output.reactionsForComment
        } else {
            self.nextToken = nil
            self.reactionsForComment = nil
        }
    }
}

public struct GetCommentReactionsOutput: Swift.Equatable {
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// An array of reactions to the specified comment.
    /// This member is required.
    public var reactionsForComment: [CodeCommitClientTypes.ReactionForComment]?

    public init(
        nextToken: Swift.String? = nil,
        reactionsForComment: [CodeCommitClientTypes.ReactionForComment]? = nil
    )
    {
        self.nextToken = nextToken
        self.reactionsForComment = reactionsForComment
    }
}

struct GetCommentReactionsOutputBody: Swift.Equatable {
    let reactionsForComment: [CodeCommitClientTypes.ReactionForComment]?
    let nextToken: Swift.String?
}

extension GetCommentReactionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reactionsForComment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactionsForCommentContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.ReactionForComment?].self, forKey: .reactionsForComment)
        var reactionsForCommentDecoded0:[CodeCommitClientTypes.ReactionForComment]? = nil
        if let reactionsForCommentContainer = reactionsForCommentContainer {
            reactionsForCommentDecoded0 = [CodeCommitClientTypes.ReactionForComment]()
            for structure0 in reactionsForCommentContainer {
                if let structure0 = structure0 {
                    reactionsForCommentDecoded0?.append(structure0)
                }
            }
        }
        reactionsForComment = reactionsForCommentDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetCommentReactionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommentDeletedException": return try await CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentDoesNotExistException": return try await CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentIdRequiredException": return try await CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommentIdException": return try await InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResultsException": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReactionUserArnException": return try await InvalidReactionUserArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCommentsForComparedCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetCommentsForComparedCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCommentsForComparedCommitInput: Swift.Equatable {
    /// To establish the directionality of the comparison, the full commit ID of the after commit.
    /// This member is required.
    public var afterCommitId: Swift.String?
    /// To establish the directionality of the comparison, the full commit ID of the before commit.
    public var beforeCommitId: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is 100 comments, but you can configure up to 500.
    public var maxResults: Swift.Int?
    /// An enumeration token that when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where you want to compare commits.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct GetCommentsForComparedCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetCommentsForComparedCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCommentsForComparedCommitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCommentsForComparedCommitOutputBody = try responseDecoder.decode(responseBody: data)
            self.commentsForComparedCommitData = output.commentsForComparedCommitData
            self.nextToken = output.nextToken
        } else {
            self.commentsForComparedCommitData = nil
            self.nextToken = nil
        }
    }
}

public struct GetCommentsForComparedCommitOutput: Swift.Equatable {
    /// A list of comment objects on the compared commit.
    public var commentsForComparedCommitData: [CodeCommitClientTypes.CommentsForComparedCommit]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        commentsForComparedCommitData: [CodeCommitClientTypes.CommentsForComparedCommit]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commentsForComparedCommitData = commentsForComparedCommitData
        self.nextToken = nextToken
    }
}

struct GetCommentsForComparedCommitOutputBody: Swift.Equatable {
    let commentsForComparedCommitData: [CodeCommitClientTypes.CommentsForComparedCommit]?
    let nextToken: Swift.String?
}

extension GetCommentsForComparedCommitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentsForComparedCommitData
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentsForComparedCommitDataContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.CommentsForComparedCommit?].self, forKey: .commentsForComparedCommitData)
        var commentsForComparedCommitDataDecoded0:[CodeCommitClientTypes.CommentsForComparedCommit]? = nil
        if let commentsForComparedCommitDataContainer = commentsForComparedCommitDataContainer {
            commentsForComparedCommitDataDecoded0 = [CodeCommitClientTypes.CommentsForComparedCommit]()
            for structure0 in commentsForComparedCommitDataContainer {
                if let structure0 = structure0 {
                    commentsForComparedCommitDataDecoded0?.append(structure0)
                }
            }
        }
        commentsForComparedCommitData = commentsForComparedCommitDataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetCommentsForComparedCommitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitIdRequiredException": return try await CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitIdException": return try await InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResultsException": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCommentsForPullRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case pullRequestId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetCommentsForPullRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCommentsForPullRequestInput: Swift.Equatable {
    /// The full commit ID of the commit in the source branch that was the tip of the branch at the time the comment was made. Requirement is conditional: afterCommitId must be specified when repositoryName is included.
    public var afterCommitId: Swift.String?
    /// The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was created. Requirement is conditional: beforeCommitId must be specified when repositoryName is included.
    public var beforeCommitId: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is 100 comments. You can return up to 500 comments with a single request.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository that contains the pull request. Requirement is conditional: repositoryName must be specified when beforeCommitId and afterCommitId are included.
    public var repositoryName: Swift.String?

    public init(
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

struct GetCommentsForPullRequestInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let repositoryName: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetCommentsForPullRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case pullRequestId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCommentsForPullRequestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCommentsForPullRequestOutputBody = try responseDecoder.decode(responseBody: data)
            self.commentsForPullRequestData = output.commentsForPullRequestData
            self.nextToken = output.nextToken
        } else {
            self.commentsForPullRequestData = nil
            self.nextToken = nil
        }
    }
}

public struct GetCommentsForPullRequestOutput: Swift.Equatable {
    /// An array of comment objects on the pull request.
    public var commentsForPullRequestData: [CodeCommitClientTypes.CommentsForPullRequest]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        commentsForPullRequestData: [CodeCommitClientTypes.CommentsForPullRequest]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commentsForPullRequestData = commentsForPullRequestData
        self.nextToken = nextToken
    }
}

struct GetCommentsForPullRequestOutputBody: Swift.Equatable {
    let commentsForPullRequestData: [CodeCommitClientTypes.CommentsForPullRequest]?
    let nextToken: Swift.String?
}

extension GetCommentsForPullRequestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentsForPullRequestData
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentsForPullRequestDataContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.CommentsForPullRequest?].self, forKey: .commentsForPullRequestData)
        var commentsForPullRequestDataDecoded0:[CodeCommitClientTypes.CommentsForPullRequest]? = nil
        if let commentsForPullRequestDataContainer = commentsForPullRequestDataContainer {
            commentsForPullRequestDataDecoded0 = [CodeCommitClientTypes.CommentsForPullRequest]()
            for structure0 in commentsForPullRequestDataContainer {
                if let structure0 = structure0 {
                    commentsForPullRequestDataDecoded0?.append(structure0)
                }
            }
        }
        commentsForPullRequestData = commentsForPullRequestDataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetCommentsForPullRequestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitIdRequiredException": return try await CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitIdException": return try await InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResultsException": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotAssociatedWithPullRequestException": return try await RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a get commit operation.
public struct GetCommitInput: Swift.Equatable {
    /// The commit ID. Commit IDs are the full SHA ID of the commit.
    /// This member is required.
    public var commitId: Swift.String?
    /// The name of the repository to which the commit was made.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.repositoryName = repositoryName
    }
}

struct GetCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let commitId: Swift.String?
}

extension GetCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
    }
}

extension GetCommitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCommitOutputBody = try responseDecoder.decode(responseBody: data)
            self.commit = output.commit
        } else {
            self.commit = nil
        }
    }
}

/// Represents the output of a get commit operation.
public struct GetCommitOutput: Swift.Equatable {
    /// A commit data type object that contains information about the specified commit.
    /// This member is required.
    public var commit: CodeCommitClientTypes.Commit?

    public init(
        commit: CodeCommitClientTypes.Commit? = nil
    )
    {
        self.commit = commit
    }
}

struct GetCommitOutputBody: Swift.Equatable {
    let commit: CodeCommitClientTypes.Commit?
}

extension GetCommitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Commit.self, forKey: .commit)
        commit = commitDecoded
    }
}

enum GetCommitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitIdDoesNotExistException": return try await CommitIdDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitIdRequiredException": return try await CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitIdException": return try await InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDifferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case afterCommitSpecifier
        case afterPath
        case beforeCommitSpecifier
        case beforePath
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let afterCommitSpecifier = self.afterCommitSpecifier {
            try encodeContainer.encode(afterCommitSpecifier, forKey: .afterCommitSpecifier)
        }
        if let afterPath = self.afterPath {
            try encodeContainer.encode(afterPath, forKey: .afterPath)
        }
        if let beforeCommitSpecifier = self.beforeCommitSpecifier {
            try encodeContainer.encode(beforeCommitSpecifier, forKey: .beforeCommitSpecifier)
        }
        if let beforePath = self.beforePath {
            try encodeContainer.encode(beforePath, forKey: .beforePath)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetDifferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDifferencesInput: Swift.Equatable {
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit.
    /// This member is required.
    public var afterCommitSpecifier: Swift.String?
    /// The file path in which to check differences. Limits the results to this path. Can also be used to specify the changed name of a directory or folder, if it has changed. If not specified, differences are shown for all paths.
    public var afterPath: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, the full commit ID). Optional. If not specified, all changes before the afterCommitSpecifier value are shown. If you do not use beforeCommitSpecifier in your request, consider limiting the results with maxResults.
    public var beforeCommitSpecifier: Swift.String?
    /// The file path in which to check for differences. Limits the results to this path. Can also be used to specify the previous name of a directory or folder. If beforePath and afterPath are not specified, differences are shown for all paths.
    public var beforePath: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where you want to get differences.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        afterCommitSpecifier: Swift.String? = nil,
        afterPath: Swift.String? = nil,
        beforeCommitSpecifier: Swift.String? = nil,
        beforePath: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitSpecifier = afterCommitSpecifier
        self.afterPath = afterPath
        self.beforeCommitSpecifier = beforeCommitSpecifier
        self.beforePath = beforePath
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct GetDifferencesInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let beforeCommitSpecifier: Swift.String?
    let afterCommitSpecifier: Swift.String?
    let beforePath: Swift.String?
    let afterPath: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetDifferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case afterCommitSpecifier
        case afterPath
        case beforeCommitSpecifier
        case beforePath
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitSpecifier)
        beforeCommitSpecifier = beforeCommitSpecifierDecoded
        let afterCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitSpecifier)
        afterCommitSpecifier = afterCommitSpecifierDecoded
        let beforePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforePath)
        beforePath = beforePathDecoded
        let afterPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterPath)
        afterPath = afterPathDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDifferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDifferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.differences = output.differences
            self.nextToken = output.nextToken
        } else {
            self.nextToken = nil
            self.differences = nil
        }
    }
}

public struct GetDifferencesOutput: Swift.Equatable {
    /// A data type object that contains information about the differences, including whether the difference is added, modified, or deleted (A, D, M).
    public var differences: [CodeCommitClientTypes.Difference]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        differences: [CodeCommitClientTypes.Difference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.differences = differences
        self.nextToken = nextToken
    }
}

struct GetDifferencesOutputBody: Swift.Equatable {
    let differences: [CodeCommitClientTypes.Difference]?
    let nextToken: Swift.String?
}

extension GetDifferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case differences
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let differencesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Difference?].self, forKey: .differences)
        var differencesDecoded0:[CodeCommitClientTypes.Difference]? = nil
        if let differencesContainer = differencesContainer {
            differencesDecoded0 = [CodeCommitClientTypes.Difference]()
            for structure0 in differencesContainer {
                if let structure0 = structure0 {
                    differencesDecoded0?.append(structure0)
                }
            }
        }
        differences = differencesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetDifferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitIdException": return try await InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResultsException": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathDoesNotExistException": return try await PathDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitSpecifier
        case filePath
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitSpecifier = self.commitSpecifier {
            try encodeContainer.encode(commitSpecifier, forKey: .commitSpecifier)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetFileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFileInput: Swift.Equatable {
    /// The fully quaified reference that identifies the commit that contains the file. For example, you can specify a full commit ID, a tag, a branch name, or a reference such as refs/heads/main. If none is provided, the head commit is used.
    public var commitSpecifier: Swift.String?
    /// The fully qualified path to the file, including the full name and extension of the file. For example, /examples/file.md is the fully qualified path to a file named file.md in a folder named examples.
    /// This member is required.
    public var filePath: Swift.String?
    /// The name of the repository that contains the file.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        commitSpecifier: Swift.String? = nil,
        filePath: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitSpecifier = commitSpecifier
        self.filePath = filePath
        self.repositoryName = repositoryName
    }
}

struct GetFileInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let commitSpecifier: Swift.String?
    let filePath: Swift.String?
}

extension GetFileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitSpecifier
        case filePath
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let commitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitSpecifier)
        commitSpecifier = commitSpecifierDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

extension GetFileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFileOutputBody = try responseDecoder.decode(responseBody: data)
            self.blobId = output.blobId
            self.commitId = output.commitId
            self.fileContent = output.fileContent
            self.fileMode = output.fileMode
            self.filePath = output.filePath
            self.fileSize = output.fileSize
        } else {
            self.blobId = nil
            self.commitId = nil
            self.fileContent = nil
            self.fileMode = nil
            self.filePath = nil
            self.fileSize = 0
        }
    }
}

public struct GetFileOutput: Swift.Equatable {
    /// The blob ID of the object that represents the file content.
    /// This member is required.
    public var blobId: Swift.String?
    /// The full commit ID of the commit that contains the content returned by GetFile.
    /// This member is required.
    public var commitId: Swift.String?
    /// The base-64 encoded binary data object that represents the content of the file.
    /// This member is required.
    public var fileContent: ClientRuntime.Data?
    /// The extrapolated file mode permissions of the blob. Valid values include strings such as EXECUTABLE and not numeric values. The file mode permissions returned by this API are not the standard file mode permission values, such as 100644, but rather extrapolated values. See the supported return values.
    /// This member is required.
    public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
    /// The fully qualified path to the specified file. Returns the name and extension of the file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The size of the contents of the file, in bytes.
    /// This member is required.
    public var fileSize: Swift.Int

    public init(
        blobId: Swift.String? = nil,
        commitId: Swift.String? = nil,
        fileContent: ClientRuntime.Data? = nil,
        fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
        filePath: Swift.String? = nil,
        fileSize: Swift.Int = 0
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.fileContent = fileContent
        self.fileMode = fileMode
        self.filePath = filePath
        self.fileSize = fileSize
    }
}

struct GetFileOutputBody: Swift.Equatable {
    let commitId: Swift.String?
    let blobId: Swift.String?
    let filePath: Swift.String?
    let fileMode: CodeCommitClientTypes.FileModeTypeEnum?
    let fileSize: Swift.Int
    let fileContent: ClientRuntime.Data?
}

extension GetFileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case commitId
        case fileContent
        case fileMode
        case filePath
        case fileSize
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let fileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileSize) ?? 0
        fileSize = fileSizeDecoded
        let fileContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .fileContent)
        fileContent = fileContentDecoded
    }
}

enum GetFileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileDoesNotExistException": return try await FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileTooLargeException": return try await FileTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitSpecifier
        case folderPath
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitSpecifier = self.commitSpecifier {
            try encodeContainer.encode(commitSpecifier, forKey: .commitSpecifier)
        }
        if let folderPath = self.folderPath {
            try encodeContainer.encode(folderPath, forKey: .folderPath)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFolderInput: Swift.Equatable {
    /// A fully qualified reference used to identify a commit that contains the version of the folder's content to return. A fully qualified reference can be a commit ID, branch name, tag, or reference such as HEAD. If no specifier is provided, the folder content is returned as it exists in the HEAD commit.
    public var commitSpecifier: Swift.String?
    /// The fully qualified path to the folder whose contents are returned, including the folder name. For example, /examples is a fully-qualified path to a folder named examples that was created off of the root directory (/) of a repository.
    /// This member is required.
    public var folderPath: Swift.String?
    /// The name of the repository.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        commitSpecifier: Swift.String? = nil,
        folderPath: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitSpecifier = commitSpecifier
        self.folderPath = folderPath
        self.repositoryName = repositoryName
    }
}

struct GetFolderInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let commitSpecifier: Swift.String?
    let folderPath: Swift.String?
}

extension GetFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitSpecifier
        case folderPath
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let commitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitSpecifier)
        commitSpecifier = commitSpecifierDecoded
        let folderPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderPath)
        folderPath = folderPathDecoded
    }
}

extension GetFolderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFolderOutputBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.files = output.files
            self.folderPath = output.folderPath
            self.subFolders = output.subFolders
            self.subModules = output.subModules
            self.symbolicLinks = output.symbolicLinks
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.files = nil
            self.folderPath = nil
            self.subFolders = nil
            self.subModules = nil
            self.symbolicLinks = nil
            self.treeId = nil
        }
    }
}

public struct GetFolderOutput: Swift.Equatable {
    /// The full commit ID used as a reference for the returned version of the folder content.
    /// This member is required.
    public var commitId: Swift.String?
    /// The list of files in the specified folder, if any.
    public var files: [CodeCommitClientTypes.File]?
    /// The fully qualified path of the folder whose contents are returned.
    /// This member is required.
    public var folderPath: Swift.String?
    /// The list of folders that exist under the specified folder, if any.
    public var subFolders: [CodeCommitClientTypes.Folder]?
    /// The list of submodules in the specified folder, if any.
    public var subModules: [CodeCommitClientTypes.SubModule]?
    /// The list of symbolic links to other files and folders in the specified folder, if any.
    public var symbolicLinks: [CodeCommitClientTypes.SymbolicLink]?
    /// The full SHA-1 pointer of the tree information for the commit that contains the folder.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        files: [CodeCommitClientTypes.File]? = nil,
        folderPath: Swift.String? = nil,
        subFolders: [CodeCommitClientTypes.Folder]? = nil,
        subModules: [CodeCommitClientTypes.SubModule]? = nil,
        symbolicLinks: [CodeCommitClientTypes.SymbolicLink]? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.files = files
        self.folderPath = folderPath
        self.subFolders = subFolders
        self.subModules = subModules
        self.symbolicLinks = symbolicLinks
        self.treeId = treeId
    }
}

struct GetFolderOutputBody: Swift.Equatable {
    let commitId: Swift.String?
    let folderPath: Swift.String?
    let treeId: Swift.String?
    let subFolders: [CodeCommitClientTypes.Folder]?
    let files: [CodeCommitClientTypes.File]?
    let symbolicLinks: [CodeCommitClientTypes.SymbolicLink]?
    let subModules: [CodeCommitClientTypes.SubModule]?
}

extension GetFolderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case files
        case folderPath
        case subFolders
        case subModules
        case symbolicLinks
        case treeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let folderPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderPath)
        folderPath = folderPathDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let subFoldersContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Folder?].self, forKey: .subFolders)
        var subFoldersDecoded0:[CodeCommitClientTypes.Folder]? = nil
        if let subFoldersContainer = subFoldersContainer {
            subFoldersDecoded0 = [CodeCommitClientTypes.Folder]()
            for structure0 in subFoldersContainer {
                if let structure0 = structure0 {
                    subFoldersDecoded0?.append(structure0)
                }
            }
        }
        subFolders = subFoldersDecoded0
        let filesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.File?].self, forKey: .files)
        var filesDecoded0:[CodeCommitClientTypes.File]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [CodeCommitClientTypes.File]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let symbolicLinksContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.SymbolicLink?].self, forKey: .symbolicLinks)
        var symbolicLinksDecoded0:[CodeCommitClientTypes.SymbolicLink]? = nil
        if let symbolicLinksContainer = symbolicLinksContainer {
            symbolicLinksDecoded0 = [CodeCommitClientTypes.SymbolicLink]()
            for structure0 in symbolicLinksContainer {
                if let structure0 = structure0 {
                    symbolicLinksDecoded0?.append(structure0)
                }
            }
        }
        symbolicLinks = symbolicLinksDecoded0
        let subModulesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.SubModule?].self, forKey: .subModules)
        var subModulesDecoded0:[CodeCommitClientTypes.SubModule]? = nil
        if let subModulesContainer = subModulesContainer {
            subModulesDecoded0 = [CodeCommitClientTypes.SubModule]()
            for structure0 in subModulesContainer {
                if let structure0 = structure0 {
                    subModulesDecoded0?.append(structure0)
                }
            }
        }
        subModules = subModulesDecoded0
    }
}

enum GetFolderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FolderDoesNotExistException": return try await FolderDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMergeCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension GetMergeCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMergeCommitInput: Swift.Equatable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The name of the repository that contains the merge commit about which you want to get information.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct GetMergeCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
}

extension GetMergeCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
    }
}

extension GetMergeCommitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMergeCommitOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseCommitId = output.baseCommitId
            self.destinationCommitId = output.destinationCommitId
            self.mergedCommitId = output.mergedCommitId
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.destinationCommitId = nil
            self.mergedCommitId = nil
            self.sourceCommitId = nil
        }
    }
}

public struct GetMergeCommitOutput: Swift.Equatable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    public var destinationCommitId: Swift.String?
    /// The commit ID for the merge commit created when the source branch was merged into the destination branch. If the fast-forward merge strategy was used, there is no merge commit.
    public var mergedCommitId: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    public var sourceCommitId: Swift.String?

    public init(
        baseCommitId: Swift.String? = nil,
        destinationCommitId: Swift.String? = nil,
        mergedCommitId: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.destinationCommitId = destinationCommitId
        self.mergedCommitId = mergedCommitId
        self.sourceCommitId = sourceCommitId
    }
}

struct GetMergeCommitOutputBody: Swift.Equatable {
    let sourceCommitId: Swift.String?
    let destinationCommitId: Swift.String?
    let baseCommitId: Swift.String?
    let mergedCommitId: Swift.String?
}

extension GetMergeCommitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCommitId
        case destinationCommitId
        case mergedCommitId
        case sourceCommitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
        let mergedCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedCommitId)
        mergedCommitId = mergedCommitIdDecoded
    }
}

enum GetMergeCommitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictDetailLevelException": return try await InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionStrategyException": return try await InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMergeConflictsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case maxConflictFiles
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let maxConflictFiles = self.maxConflictFiles {
            try encodeContainer.encode(maxConflictFiles, forKey: .maxConflictFiles)
        }
        if let mergeOption = self.mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension GetMergeConflictsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMergeConflictsInput: Swift.Equatable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The maximum number of files to include in the output.
    public var maxConflictFiles: Swift.Int?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        maxConflictFiles: Swift.Int? = nil,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.maxConflictFiles = maxConflictFiles
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct GetMergeConflictsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let maxConflictFiles: Swift.Int?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let nextToken: Swift.String?
}

extension GetMergeConflictsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case maxConflictFiles
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let maxConflictFilesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConflictFiles)
        maxConflictFiles = maxConflictFilesDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetMergeConflictsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMergeConflictsOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseCommitId = output.baseCommitId
            self.conflictMetadataList = output.conflictMetadataList
            self.destinationCommitId = output.destinationCommitId
            self.mergeable = output.mergeable
            self.nextToken = output.nextToken
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.conflictMetadataList = nil
            self.destinationCommitId = nil
            self.mergeable = false
            self.nextToken = nil
            self.sourceCommitId = nil
        }
    }
}

public struct GetMergeConflictsOutput: Swift.Equatable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// A list of metadata for any conflicting files. If the specified merge strategy is FAST_FORWARD_MERGE, this list is always empty.
    /// This member is required.
    public var conflictMetadataList: [CodeCommitClientTypes.ConflictMetadata]?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// A Boolean value that indicates whether the code is mergeable by the specified merge option.
    /// This member is required.
    public var mergeable: Swift.Bool
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init(
        baseCommitId: Swift.String? = nil,
        conflictMetadataList: [CodeCommitClientTypes.ConflictMetadata]? = nil,
        destinationCommitId: Swift.String? = nil,
        mergeable: Swift.Bool = false,
        nextToken: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflictMetadataList = conflictMetadataList
        self.destinationCommitId = destinationCommitId
        self.mergeable = mergeable
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

struct GetMergeConflictsOutputBody: Swift.Equatable {
    let mergeable: Swift.Bool
    let destinationCommitId: Swift.String?
    let sourceCommitId: Swift.String?
    let baseCommitId: Swift.String?
    let conflictMetadataList: [CodeCommitClientTypes.ConflictMetadata]?
    let nextToken: Swift.String?
}

extension GetMergeConflictsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCommitId
        case conflictMetadataList
        case destinationCommitId
        case mergeable
        case nextToken
        case sourceCommitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergeableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mergeable) ?? false
        mergeable = mergeableDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
        let conflictMetadataListContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.ConflictMetadata?].self, forKey: .conflictMetadataList)
        var conflictMetadataListDecoded0:[CodeCommitClientTypes.ConflictMetadata]? = nil
        if let conflictMetadataListContainer = conflictMetadataListContainer {
            conflictMetadataListDecoded0 = [CodeCommitClientTypes.ConflictMetadata]()
            for structure0 in conflictMetadataListContainer {
                if let structure0 = structure0 {
                    conflictMetadataListDecoded0?.append(structure0)
                }
            }
        }
        conflictMetadataList = conflictMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetMergeConflictsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictDetailLevelException": return try await InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionStrategyException": return try await InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidDestinationCommitSpecifierException": return try await InvalidDestinationCommitSpecifierException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxConflictFilesException": return try await InvalidMaxConflictFilesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMergeOptionException": return try await InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSourceCommitSpecifierException": return try await InvalidSourceCommitSpecifierException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumFileContentToLoadExceededException": return try await MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumItemsToCompareExceededException": return try await MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MergeOptionRequiredException": return try await MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMergeOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension GetMergeOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMergeOptionsInput: Swift.Equatable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The name of the repository that contains the commits about which you want to get merge options.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init(
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct GetMergeOptionsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
}

extension GetMergeOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
    }
}

extension GetMergeOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMergeOptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseCommitId = output.baseCommitId
            self.destinationCommitId = output.destinationCommitId
            self.mergeOptions = output.mergeOptions
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.destinationCommitId = nil
            self.mergeOptions = nil
            self.sourceCommitId = nil
        }
    }
}

public struct GetMergeOptionsOutput: Swift.Equatable {
    /// The commit ID of the merge base.
    /// This member is required.
    public var baseCommitId: Swift.String?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// The merge option or strategy used to merge the code.
    /// This member is required.
    public var mergeOptions: [CodeCommitClientTypes.MergeOptionTypeEnum]?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init(
        baseCommitId: Swift.String? = nil,
        destinationCommitId: Swift.String? = nil,
        mergeOptions: [CodeCommitClientTypes.MergeOptionTypeEnum]? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.destinationCommitId = destinationCommitId
        self.mergeOptions = mergeOptions
        self.sourceCommitId = sourceCommitId
    }
}

struct GetMergeOptionsOutputBody: Swift.Equatable {
    let mergeOptions: [CodeCommitClientTypes.MergeOptionTypeEnum]?
    let sourceCommitId: Swift.String?
    let destinationCommitId: Swift.String?
    let baseCommitId: Swift.String?
}

extension GetMergeOptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCommitId
        case destinationCommitId
        case mergeOptions
        case sourceCommitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergeOptionsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.MergeOptionTypeEnum?].self, forKey: .mergeOptions)
        var mergeOptionsDecoded0:[CodeCommitClientTypes.MergeOptionTypeEnum]? = nil
        if let mergeOptionsContainer = mergeOptionsContainer {
            mergeOptionsDecoded0 = [CodeCommitClientTypes.MergeOptionTypeEnum]()
            for enum0 in mergeOptionsContainer {
                if let enum0 = enum0 {
                    mergeOptionsDecoded0?.append(enum0)
                }
            }
        }
        mergeOptions = mergeOptionsDecoded0
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
    }
}

enum GetMergeOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictDetailLevelException": return try await InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionStrategyException": return try await InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumFileContentToLoadExceededException": return try await MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumItemsToCompareExceededException": return try await MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPullRequestApprovalStatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension GetPullRequestApprovalStatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPullRequestApprovalStatesInput: Swift.Equatable {
    /// The system-generated ID for the pull request.
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID for the pull request revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct GetPullRequestApprovalStatesInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let revisionId: Swift.String?
}

extension GetPullRequestApprovalStatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetPullRequestApprovalStatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPullRequestApprovalStatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvals = output.approvals
        } else {
            self.approvals = nil
        }
    }
}

public struct GetPullRequestApprovalStatesOutput: Swift.Equatable {
    /// Information about users who have approved the pull request.
    public var approvals: [CodeCommitClientTypes.Approval]?

    public init(
        approvals: [CodeCommitClientTypes.Approval]? = nil
    )
    {
        self.approvals = approvals
    }
}

struct GetPullRequestApprovalStatesOutputBody: Swift.Equatable {
    let approvals: [CodeCommitClientTypes.Approval]?
}

extension GetPullRequestApprovalStatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvals
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Approval?].self, forKey: .approvals)
        var approvalsDecoded0:[CodeCommitClientTypes.Approval]? = nil
        if let approvalsContainer = approvalsContainer {
            approvalsDecoded0 = [CodeCommitClientTypes.Approval]()
            for structure0 in approvalsContainer {
                if let structure0 = structure0 {
                    approvalsDecoded0?.append(structure0)
                }
            }
        }
        approvals = approvalsDecoded0
    }
}

enum GetPullRequestApprovalStatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRevisionIdException": return try await InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RevisionIdRequiredException": return try await RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPullRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension GetPullRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPullRequestInput: Swift.Equatable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
    }
}

struct GetPullRequestInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
}

extension GetPullRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
    }
}

extension GetPullRequestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPullRequestOutputBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct GetPullRequestOutput: Swift.Equatable {
    /// Information about the specified pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct GetPullRequestOutputBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension GetPullRequestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

enum GetPullRequestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPullRequestOverrideStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension GetPullRequestOverrideStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPullRequestOverrideStateInput: Swift.Equatable {
    /// The ID of the pull request for which you want to get information about whether approval rules have been set aside (overridden).
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID of the revision for the pull request. To retrieve the most recent revision ID, use [GetPullRequest].
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct GetPullRequestOverrideStateInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let revisionId: Swift.String?
}

extension GetPullRequestOverrideStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetPullRequestOverrideStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPullRequestOverrideStateOutputBody = try responseDecoder.decode(responseBody: data)
            self.overridden = output.overridden
            self.overrider = output.overrider
        } else {
            self.overridden = false
            self.overrider = nil
        }
    }
}

public struct GetPullRequestOverrideStateOutput: Swift.Equatable {
    /// A Boolean value that indicates whether a pull request has had its rules set aside (TRUE) or whether all approval rules still apply (FALSE).
    public var overridden: Swift.Bool
    /// The Amazon Resource Name (ARN) of the user or identity that overrode the rules and their requirements for the pull request.
    public var overrider: Swift.String?

    public init(
        overridden: Swift.Bool = false,
        overrider: Swift.String? = nil
    )
    {
        self.overridden = overridden
        self.overrider = overrider
    }
}

struct GetPullRequestOverrideStateOutputBody: Swift.Equatable {
    let overridden: Swift.Bool
    let overrider: Swift.String?
}

extension GetPullRequestOverrideStateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overridden
        case overrider
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overriddenDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overridden) ?? false
        overridden = overriddenDecoded
        let overriderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrider)
        overrider = overriderDecoded
    }
}

enum GetPullRequestOverrideStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRevisionIdException": return try await InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RevisionIdRequiredException": return try await RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a get repository operation.
public struct GetRepositoryInput: Swift.Equatable {
    /// The name of the repository to get information about.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
}

extension GetRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repositoryMetadata = output.repositoryMetadata
        } else {
            self.repositoryMetadata = nil
        }
    }
}

/// Represents the output of a get repository operation.
public struct GetRepositoryOutput: Swift.Equatable {
    /// Information about the repository.
    public var repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata?

    public init(
        repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata? = nil
    )
    {
        self.repositoryMetadata = repositoryMetadata
    }
}

struct GetRepositoryOutputBody: Swift.Equatable {
    let repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata?
}

extension GetRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryMetadata
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.RepositoryMetadata.self, forKey: .repositoryMetadata)
        repositoryMetadata = repositoryMetadataDecoded
    }
}

enum GetRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRepositoryTriggersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetRepositoryTriggersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a get repository triggers operation.
public struct GetRepositoryTriggersInput: Swift.Equatable {
    /// The name of the repository for which the trigger is configured.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryTriggersInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
}

extension GetRepositoryTriggersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryTriggersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRepositoryTriggersOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
            self.triggers = output.triggers
        } else {
            self.configurationId = nil
            self.triggers = nil
        }
    }
}

/// Represents the output of a get repository triggers operation.
public struct GetRepositoryTriggersOutput: Swift.Equatable {
    /// The system-generated unique ID for the trigger.
    public var configurationId: Swift.String?
    /// The JSON block of configuration information for each trigger.
    public var triggers: [CodeCommitClientTypes.RepositoryTrigger]?

    public init(
        configurationId: Swift.String? = nil,
        triggers: [CodeCommitClientTypes.RepositoryTrigger]? = nil
    )
    {
        self.configurationId = configurationId
        self.triggers = triggers
    }
}

struct GetRepositoryTriggersOutputBody: Swift.Equatable {
    let configurationId: Swift.String?
    let triggers: [CodeCommitClientTypes.RepositoryTrigger]?
}

extension GetRepositoryTriggersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case triggers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let triggersContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[CodeCommitClientTypes.RepositoryTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [CodeCommitClientTypes.RepositoryTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

enum GetRepositoryTriggersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IdempotencyParameterMismatchException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IdempotencyParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.
public struct IdempotencyParameterMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotencyParameterMismatchException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IdempotencyParameterMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotencyParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidActorArnException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidActorArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request, and then try again.
public struct InvalidActorArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidActorArnException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidActorArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidActorArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleContentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidApprovalRuleContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The content for the approval rule is not valid.
public struct InvalidApprovalRuleContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalRuleContentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidApprovalRuleContentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalRuleContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidApprovalRuleNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The name for the approval rule is not valid.
public struct InvalidApprovalRuleNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalRuleNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidApprovalRuleNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalRuleNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleTemplateContentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidApprovalRuleTemplateContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The content of the approval rule template is not valid.
public struct InvalidApprovalRuleTemplateContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalRuleTemplateContentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidApprovalRuleTemplateContentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalRuleTemplateContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleTemplateDescriptionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidApprovalRuleTemplateDescriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in CodeCommit, see [Quotas](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html) in the CodeCommit User Guide.
public struct InvalidApprovalRuleTemplateDescriptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalRuleTemplateDescriptionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidApprovalRuleTemplateDescriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalRuleTemplateDescriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleTemplateNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidApprovalRuleTemplateNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in CodeCommit, see [Quotas](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html) in the CodeCommit User Guide.
public struct InvalidApprovalRuleTemplateNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalRuleTemplateNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidApprovalRuleTemplateNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalRuleTemplateNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidApprovalStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The state for the approval is not valid. Valid values include APPROVE and REVOKE.
public struct InvalidApprovalStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApprovalStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidApprovalStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAuthorArnException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidAuthorArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.
public struct InvalidAuthorArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAuthorArnException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidAuthorArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAuthorArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidBlobIdException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidBlobIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified blob is not valid.
public struct InvalidBlobIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidBlobIdException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidBlobIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidBlobIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidBranchNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidBranchNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified reference name is not valid.
public struct InvalidBranchNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidBranchNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidBranchNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidBranchNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientRequestTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidClientRequestTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client request token is not valid.
public struct InvalidClientRequestTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClientRequestTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidClientRequestTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidClientRequestTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommentIdException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCommentIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The comment ID is not in a valid format. Make sure that you have provided the full comment ID.
public struct InvalidCommentIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCommentIdException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCommentIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCommentIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommitException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCommitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified commit is not valid.
public struct InvalidCommitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCommitException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCommitExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCommitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommitIdException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCommitIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified commit ID is not valid.
public struct InvalidCommitIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCommitIdException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCommitIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCommitIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConflictDetailLevelException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidConflictDetailLevelExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified conflict detail level is not valid.
public struct InvalidConflictDetailLevelException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConflictDetailLevelException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidConflictDetailLevelExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConflictDetailLevelExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConflictResolutionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidConflictResolutionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified conflict resolution list is not valid.
public struct InvalidConflictResolutionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConflictResolutionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidConflictResolutionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConflictResolutionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConflictResolutionStrategyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidConflictResolutionStrategyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified conflict resolution strategy is not valid.
public struct InvalidConflictResolutionStrategyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConflictResolutionStrategyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidConflictResolutionStrategyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConflictResolutionStrategyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidContinuationTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidContinuationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified continuation token is not valid.
public struct InvalidContinuationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidContinuationTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidContinuationTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidContinuationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeletionParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidDeletionParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified deletion parameter is not valid.
public struct InvalidDeletionParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDeletionParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidDeletionParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDeletionParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDescriptionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidDescriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull request description is not valid. Descriptions cannot be more than 1,000 characters.
public struct InvalidDescriptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDescriptionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidDescriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDescriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDestinationCommitSpecifierException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidDestinationCommitSpecifierExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.
public struct InvalidDestinationCommitSpecifierException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDestinationCommitSpecifierException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidDestinationCommitSpecifierExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDestinationCommitSpecifierExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEmailException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidEmailExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.
public struct InvalidEmailException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEmailException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidEmailExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEmailExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFileLocationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidFileLocationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The location of the file is not valid. Make sure that you include the file name and extension.
public struct InvalidFileLocationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFileLocationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidFileLocationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFileLocationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFileModeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidFileModeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified file mode permission is not valid. For a list of valid file mode permissions, see [PutFile].
public struct InvalidFileModeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFileModeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidFileModeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFileModeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilePositionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidFilePositionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.
public struct InvalidFilePositionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFilePositionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidFilePositionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFilePositionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxConflictFilesException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidMaxConflictFilesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified value for the number of conflict files to return is not valid.
public struct InvalidMaxConflictFilesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMaxConflictFilesException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidMaxConflictFilesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxConflictFilesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxMergeHunksException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidMaxMergeHunksExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified value for the number of merge hunks to return is not valid.
public struct InvalidMaxMergeHunksException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMaxMergeHunksException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidMaxMergeHunksExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxMergeHunksExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified number of maximum results is not valid.
public struct InvalidMaxResultsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMaxResultsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxResultsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMergeOptionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidMergeOptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.
public struct InvalidMergeOptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMergeOptionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidMergeOptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMergeOptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOrderException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidOrderExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified sort order is not valid.
public struct InvalidOrderException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOrderException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidOrderExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOrderExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOverrideStatusException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidOverrideStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The override status is not valid. Valid statuses are OVERRIDE and REVOKE.
public struct InvalidOverrideStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOverrideStatusException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidOverrideStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOverrideStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParentCommitIdException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParentCommitIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.
public struct InvalidParentCommitIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParentCommitIdException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParentCommitIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParentCommitIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPathException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPathExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified path is not valid.
public struct InvalidPathException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPathException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPathExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPathExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestEventTypeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPullRequestEventTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull request event type is not valid.
public struct InvalidPullRequestEventTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPullRequestEventTypeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPullRequestEventTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPullRequestEventTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestIdException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPullRequestIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.
public struct InvalidPullRequestIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPullRequestIdException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPullRequestIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPullRequestIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestStatusException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPullRequestStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull request status is not valid. The only valid values are OPEN and CLOSED.
public struct InvalidPullRequestStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPullRequestStatusException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPullRequestStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPullRequestStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestStatusUpdateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPullRequestStatusUpdateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull request status update is not valid. The only valid update is from OPEN to CLOSED.
public struct InvalidPullRequestStatusUpdateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPullRequestStatusUpdateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPullRequestStatusUpdateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPullRequestStatusUpdateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReactionUserArnException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidReactionUserArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Resource Name (ARN) of the user or identity is not valid.
public struct InvalidReactionUserArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidReactionUserArnException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidReactionUserArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidReactionUserArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReactionValueException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidReactionValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value of the reaction is not valid. For more information, see the [CodeCommit User Guide](https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html).
public struct InvalidReactionValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidReactionValueException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidReactionValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidReactionValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReferenceNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidReferenceNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified reference name format is not valid. Reference names must conform to the Git references format (for example, refs/heads/main). For more information, see [Git Internals - Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References) or consult your Git documentation.
public struct InvalidReferenceNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidReferenceNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidReferenceNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidReferenceNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRelativeFileVersionEnumException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRelativeFileVersionEnumExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.
public struct InvalidRelativeFileVersionEnumException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRelativeFileVersionEnumException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRelativeFileVersionEnumExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRelativeFileVersionEnumExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReplacementContentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidReplacementContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing.
public struct InvalidReplacementContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidReplacementContentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidReplacementContentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidReplacementContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReplacementTypeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidReplacementTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Automerge was specified for resolving the conflict, but the specified replacement type is not valid.
public struct InvalidReplacementTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidReplacementTypeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidReplacementTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidReplacementTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryDescriptionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRepositoryDescriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified repository description is not valid.
public struct InvalidRepositoryDescriptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryDescriptionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRepositoryDescriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryDescriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRepositoryNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A specified repository name is not valid. This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.
public struct InvalidRepositoryNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRepositoryNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerBranchNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerBranchNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more branch names specified for the trigger is not valid.
public struct InvalidRepositoryTriggerBranchNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerBranchNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRepositoryTriggerBranchNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerBranchNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerCustomDataException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerCustomDataExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The custom data provided for the trigger is not valid.
public struct InvalidRepositoryTriggerCustomDataException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerCustomDataException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRepositoryTriggerCustomDataExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerCustomDataExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerDestinationArnException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerDestinationArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.
public struct InvalidRepositoryTriggerDestinationArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerDestinationArnException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRepositoryTriggerDestinationArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerDestinationArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerEventsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerEventsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.
public struct InvalidRepositoryTriggerEventsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerEventsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRepositoryTriggerEventsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerEventsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The name of the trigger is not valid.
public struct InvalidRepositoryTriggerNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRepositoryTriggerNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerRegionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Web Services Region for the trigger target does not match the Amazon Web Services Region for the repository. Triggers must be created in the same Amazon Web Services Region as the target for the trigger.
public struct InvalidRepositoryTriggerRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRepositoryTriggerRegionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRepositoryTriggerRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceArnException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value for the resource ARN is not valid. For more information about resources in CodeCommit, see [CodeCommit Resources and Operations](https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats) in the CodeCommit User Guide.
public struct InvalidResourceArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceArnException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResourceArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRevisionIdException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRevisionIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The revision ID is not valid. Use GetPullRequest to determine the value.
public struct InvalidRevisionIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRevisionIdException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRevisionIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRevisionIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRuleContentSha256Exception {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRuleContentSha256ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The SHA-256 hash signature for the rule content is not valid.
public struct InvalidRuleContentSha256Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRuleContentSha256Exception" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRuleContentSha256ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRuleContentSha256ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSortByException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSortByExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified sort by value is not valid.
public struct InvalidSortByException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSortByException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSortByExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSortByExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSourceCommitSpecifierException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSourceCommitSpecifierExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.
public struct InvalidSourceCommitSpecifierException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSourceCommitSpecifierException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSourceCommitSpecifierExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSourceCommitSpecifierExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSystemTagUsageException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSystemTagUsageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified tag is not valid. Key names cannot be prefixed with aws:.
public struct InvalidSystemTagUsageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSystemTagUsageException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSystemTagUsageExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSystemTagUsageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagKeysListException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTagKeysListExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The list of tags is not valid.
public struct InvalidTagKeysListException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagKeysListException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTagKeysListExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagKeysListExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagsMapException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTagsMapExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The map of tags is not valid.
public struct InvalidTagsMapException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagsMapException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTagsMapExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagsMapExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetBranchException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTargetBranchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified target branch is not valid.
public struct InvalidTargetBranchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTargetBranchException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTargetBranchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTargetBranchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTargetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.
public struct InvalidTargetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTargetException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTargetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTargetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTargetsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for the repository name, source branch, and destination branch for a pull request.
public struct InvalidTargetsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTargetsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTargetsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTargetsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTitleException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTitleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.
public struct InvalidTitleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTitleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTitleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTitleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.IsBinaryFile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = self.base {
            try encodeContainer.encode(base, forKey: .base)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .base)
        base = baseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about whether a file is binary or textual in a merge or pull request operation.
    public struct IsBinaryFile: Swift.Equatable {
        /// The binary or non-binary status of a file in the base of a merge or pull request.
        public var base: Swift.Bool?
        /// The binary or non-binary status of a file in the destination of a merge or pull request.
        public var destination: Swift.Bool?
        /// The binary or non-binary status of file in the source of a merge or pull request.
        public var source: Swift.Bool?

        public init(
            base: Swift.Bool? = nil,
            destination: Swift.Bool? = nil,
            source: Swift.Bool? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }

}

extension ListApprovalRuleTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApprovalRuleTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApprovalRuleTemplatesInput: Swift.Equatable {
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApprovalRuleTemplatesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListApprovalRuleTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApprovalRuleTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApprovalRuleTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplateNames = output.approvalRuleTemplateNames
            self.nextToken = output.nextToken
        } else {
            self.approvalRuleTemplateNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListApprovalRuleTemplatesOutput: Swift.Equatable {
    /// The names of all the approval rule templates found in the Amazon Web Services Region for your Amazon Web Services account.
    public var approvalRuleTemplateNames: [Swift.String]?
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?

    public init(
        approvalRuleTemplateNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateNames = approvalRuleTemplateNames
        self.nextToken = nextToken
    }
}

struct ListApprovalRuleTemplatesOutputBody: Swift.Equatable {
    let approvalRuleTemplateNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListApprovalRuleTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateNames
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvalRuleTemplateNames)
        var approvalRuleTemplateNamesDecoded0:[Swift.String]? = nil
        if let approvalRuleTemplateNamesContainer = approvalRuleTemplateNamesContainer {
            approvalRuleTemplateNamesDecoded0 = [Swift.String]()
            for string0 in approvalRuleTemplateNamesContainer {
                if let string0 = string0 {
                    approvalRuleTemplateNamesDecoded0?.append(string0)
                }
            }
        }
        approvalRuleTemplateNames = approvalRuleTemplateNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApprovalRuleTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResultsException": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryInput: Swift.Equatable {
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository for which you want to list all associated approval rule templates.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct ListAssociatedApprovalRuleTemplatesForRepositoryInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssociatedApprovalRuleTemplatesForRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplateNames = output.approvalRuleTemplateNames
            self.nextToken = output.nextToken
        } else {
            self.approvalRuleTemplateNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryOutput: Swift.Equatable {
    /// The names of all approval rule templates associated with the repository.
    public var approvalRuleTemplateNames: [Swift.String]?
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?

    public init(
        approvalRuleTemplateNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateNames = approvalRuleTemplateNames
        self.nextToken = nextToken
    }
}

struct ListAssociatedApprovalRuleTemplatesForRepositoryOutputBody: Swift.Equatable {
    let approvalRuleTemplateNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateNames
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvalRuleTemplateNames)
        var approvalRuleTemplateNamesDecoded0:[Swift.String]? = nil
        if let approvalRuleTemplateNamesContainer = approvalRuleTemplateNamesContainer {
            approvalRuleTemplateNamesDecoded0 = [Swift.String]()
            for string0 in approvalRuleTemplateNamesContainer {
                if let string0 = string0 {
                    approvalRuleTemplateNamesDecoded0?.append(string0)
                }
            }
        }
        approvalRuleTemplateNames = approvalRuleTemplateNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssociatedApprovalRuleTemplatesForRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResultsException": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBranchesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension ListBranchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a list branches operation.
public struct ListBranchesInput: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the results.
    public var nextToken: Swift.String?
    /// The name of the repository that contains the branches.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct ListBranchesInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let nextToken: Swift.String?
}

extension ListBranchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBranchesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBranchesOutputBody = try responseDecoder.decode(responseBody: data)
            self.branches = output.branches
            self.nextToken = output.nextToken
        } else {
            self.branches = nil
            self.nextToken = nil
        }
    }
}

/// Represents the output of a list branches operation.
public struct ListBranchesOutput: Swift.Equatable {
    /// The list of branch names.
    public var branches: [Swift.String]?
    /// An enumeration token that returns the batch of the results.
    public var nextToken: Swift.String?

    public init(
        branches: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.branches = branches
        self.nextToken = nextToken
    }
}

struct ListBranchesOutputBody: Swift.Equatable {
    let branches: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListBranchesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branches
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .branches)
        var branchesDecoded0:[Swift.String]? = nil
        if let branchesContainer = branchesContainer {
            branchesDecoded0 = [Swift.String]()
            for string0 in branchesContainer {
                if let string0 = string0 {
                    branchesDecoded0?.append(string0)
                }
            }
        }
        branches = branchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBranchesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFileCommitHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitSpecifier
        case filePath
        case maxResults
        case nextToken
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitSpecifier = self.commitSpecifier {
            try encodeContainer.encode(commitSpecifier, forKey: .commitSpecifier)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension ListFileCommitHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFileCommitHistoryInput: Swift.Equatable {
    /// The fully quaified reference that identifies the commit that contains the file. For example, you can specify a full commit ID, a tag, a branch name, or a reference such as refs/heads/main. If none is provided, the head commit is used.
    public var commitSpecifier: Swift.String?
    /// The full path of the file whose history you want to retrieve, including the name of the file.
    /// This member is required.
    public var filePath: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that allows the operation to batch the results.
    public var nextToken: Swift.String?
    /// The name of the repository that contains the file.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        commitSpecifier: Swift.String? = nil,
        filePath: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitSpecifier = commitSpecifier
        self.filePath = filePath
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct ListFileCommitHistoryInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let commitSpecifier: Swift.String?
    let filePath: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFileCommitHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitSpecifier
        case filePath
        case maxResults
        case nextToken
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let commitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitSpecifier)
        commitSpecifier = commitSpecifierDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFileCommitHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFileCommitHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.revisionDag = output.revisionDag
        } else {
            self.nextToken = nil
            self.revisionDag = nil
        }
    }
}

public struct ListFileCommitHistoryOutput: Swift.Equatable {
    /// An enumeration token that can be used to return the next batch of results.
    public var nextToken: Swift.String?
    /// An array of FileVersion objects that form a directed acyclic graph (DAG) of the changes to the file made by the commits that changed the file.
    /// This member is required.
    public var revisionDag: [CodeCommitClientTypes.FileVersion]?

    public init(
        nextToken: Swift.String? = nil,
        revisionDag: [CodeCommitClientTypes.FileVersion]? = nil
    )
    {
        self.nextToken = nextToken
        self.revisionDag = revisionDag
    }
}

struct ListFileCommitHistoryOutputBody: Swift.Equatable {
    let revisionDag: [CodeCommitClientTypes.FileVersion]?
    let nextToken: Swift.String?
}

extension ListFileCommitHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case revisionDag
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionDagContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.FileVersion?].self, forKey: .revisionDag)
        var revisionDagDecoded0:[CodeCommitClientTypes.FileVersion]? = nil
        if let revisionDagContainer = revisionDagContainer {
            revisionDagDecoded0 = [CodeCommitClientTypes.FileVersion]()
            for structure0 in revisionDagContainer {
                if let structure0 = structure0 {
                    revisionDagDecoded0?.append(structure0)
                }
            }
        }
        revisionDag = revisionDagDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFileCommitHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResultsException": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPullRequestsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorArn
        case maxResults
        case nextToken
        case pullRequestStatus
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorArn = self.authorArn {
            try encodeContainer.encode(authorArn, forKey: .authorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pullRequestStatus = self.pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension ListPullRequestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPullRequestsInput: Swift.Equatable {
    /// Optional. The Amazon Resource Name (ARN) of the user who created the pull request. If used, this filters the results to pull requests created by that user.
    public var authorArn: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// Optional. The status of the pull request. If used, this refines the results to the pull requests that match the specified status.
    public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?
    /// The name of the repository for which you want to list pull requests.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        authorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.authorArn = authorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestStatus = pullRequestStatus
        self.repositoryName = repositoryName
    }
}

struct ListPullRequestsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let authorArn: Swift.String?
    let pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPullRequestsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorArn
        case maxResults
        case nextToken
        case pullRequestStatus
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let authorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorArn)
        authorArn = authorArnDecoded
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPullRequestsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPullRequestsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pullRequestIds = output.pullRequestIds
        } else {
            self.nextToken = nil
            self.pullRequestIds = nil
        }
    }
}

public struct ListPullRequestsOutput: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?
    /// The system-generated IDs of the pull requests.
    /// This member is required.
    public var pullRequestIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        pullRequestIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.pullRequestIds = pullRequestIds
    }
}

struct ListPullRequestsOutputBody: Swift.Equatable {
    let pullRequestIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPullRequestsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case pullRequestIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pullRequestIds)
        var pullRequestIdsDecoded0:[Swift.String]? = nil
        if let pullRequestIdsContainer = pullRequestIdsContainer {
            pullRequestIdsDecoded0 = [Swift.String]()
            for string0 in pullRequestIdsContainer {
                if let string0 = string0 {
                    pullRequestIdsDecoded0?.append(string0)
                }
            }
        }
        pullRequestIds = pullRequestIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPullRequestsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorDoesNotExistException": return try await AuthorDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAuthorArnException": return try await InvalidAuthorArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResultsException": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestStatusException": return try await InvalidPullRequestStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRepositoriesForApprovalRuleTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRepositoriesForApprovalRuleTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRepositoriesForApprovalRuleTemplateInput: Swift.Equatable {
    /// The name of the approval rule template for which you want to list repositories that are associated with that template.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRepositoriesForApprovalRuleTemplateInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRepositoriesForApprovalRuleTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRepositoriesForApprovalRuleTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRepositoriesForApprovalRuleTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositoryNames = output.repositoryNames
        } else {
            self.nextToken = nil
            self.repositoryNames = nil
        }
    }
}

public struct ListRepositoriesForApprovalRuleTemplateOutput: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?
    /// A list of repository names that are associated with the specified approval rule template.
    public var repositoryNames: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryNames = repositoryNames
    }
}

struct ListRepositoriesForApprovalRuleTemplateOutputBody: Swift.Equatable {
    let repositoryNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListRepositoriesForApprovalRuleTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositoryNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRepositoriesForApprovalRuleTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateDoesNotExistException": return try await ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResultsException": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case order
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
    }
}

extension ListRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a list repositories operation.
public struct ListRepositoriesInput: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to CodeCommit, another page of 1,000 records is retrieved.
    public var nextToken: Swift.String?
    /// The order in which to sort the results of a list repositories operation.
    public var order: CodeCommitClientTypes.OrderEnum?
    /// The criteria used to sort the results of a list repositories operation.
    public var sortBy: CodeCommitClientTypes.SortByEnum?

    public init(
        nextToken: Swift.String? = nil,
        order: CodeCommitClientTypes.OrderEnum? = nil,
        sortBy: CodeCommitClientTypes.SortByEnum? = nil
    )
    {
        self.nextToken = nextToken
        self.order = order
        self.sortBy = sortBy
    }
}

struct ListRepositoriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sortBy: CodeCommitClientTypes.SortByEnum?
    let order: CodeCommitClientTypes.OrderEnum?
}

extension ListRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case order
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.SortByEnum.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let orderDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.OrderEnum.self, forKey: .order)
        order = orderDecoded
    }
}

extension ListRepositoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRepositoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

/// Represents the output of a list repositories operation.
public struct ListRepositoriesOutput: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to CodeCommit, another page of 1,000 records is retrieved.
    public var nextToken: Swift.String?
    /// Lists the repositories called by the list repositories operation.
    public var repositories: [CodeCommitClientTypes.RepositoryNameIdPair]?

    public init(
        nextToken: Swift.String? = nil,
        repositories: [CodeCommitClientTypes.RepositoryNameIdPair]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesOutputBody: Swift.Equatable {
    let repositories: [CodeCommitClientTypes.RepositoryNameIdPair]?
    let nextToken: Swift.String?
}

extension ListRepositoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryNameIdPair?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeCommitClientTypes.RepositoryNameIdPair]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeCommitClientTypes.RepositoryNameIdPair]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRepositoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidContinuationTokenException": return try await InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOrderException": return try await InvalidOrderException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSortByException": return try await InvalidSortByException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to get information about tags, if any.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?
    /// A list of tag key and value pairs associated with the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceArnException": return try await InvalidResourceArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceArnRequiredException": return try await ResourceArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePath
        case filePosition
        case relativeFileVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let filePosition = self.filePosition {
            try encodeContainer.encode(filePosition, forKey: .filePosition)
        }
        if let relativeFileVersion = self.relativeFileVersion {
            try encodeContainer.encode(relativeFileVersion.rawValue, forKey: .relativeFileVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let filePositionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .filePosition)
        filePosition = filePositionDecoded
        let relativeFileVersionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.RelativeFileVersionEnum.self, forKey: .relativeFileVersion)
        relativeFileVersion = relativeFileVersionDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about the location of a change or comment in the comparison between two commits or a pull request.
    public struct Location: Swift.Equatable {
        /// The name of the file being compared, including its extension and subdirectory, if any.
        public var filePath: Swift.String?
        /// The position of a change in a compared file, in line number format.
        public var filePosition: Swift.Int?
        /// In a comparison of commits or a pull request, whether the change is in the before or after of that comparison.
        public var relativeFileVersion: CodeCommitClientTypes.RelativeFileVersionEnum?

        public init(
            filePath: Swift.String? = nil,
            filePosition: Swift.Int? = nil,
            relativeFileVersion: CodeCommitClientTypes.RelativeFileVersionEnum? = nil
        )
        {
            self.filePath = filePath
            self.filePosition = filePosition
            self.relativeFileVersion = relativeFileVersion
        }
    }

}

extension ManualMergeRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ManualMergeRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.
public struct ManualMergeRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ManualMergeRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ManualMergeRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ManualMergeRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumBranchesExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumBranchesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of branches for the trigger was exceeded.
public struct MaximumBranchesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumBranchesExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumBranchesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumBranchesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumConflictResolutionEntriesExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumConflictResolutionEntriesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of allowed conflict resolution entries was exceeded.
public struct MaximumConflictResolutionEntriesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumConflictResolutionEntriesExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumConflictResolutionEntriesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumConflictResolutionEntriesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumFileContentToLoadExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumFileContentToLoadExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of files to load exceeds the allowed limit.
public struct MaximumFileContentToLoadExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumFileContentToLoadExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumFileContentToLoadExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumFileContentToLoadExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumFileEntriesExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumFileEntriesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of specified files to change as part of this commit exceeds the maximum number of files that can be changed in a single commit. Consider using a Git client for these changes.
public struct MaximumFileEntriesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumFileEntriesExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumFileEntriesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumFileEntriesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumItemsToCompareExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumItemsToCompareExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.
public struct MaximumItemsToCompareExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumItemsToCompareExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumItemsToCompareExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumItemsToCompareExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumNumberOfApprovalsExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumNumberOfApprovalsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of approvals required for the approval rule exceeds the maximum number allowed.
public struct MaximumNumberOfApprovalsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumNumberOfApprovalsExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumNumberOfApprovalsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumNumberOfApprovalsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumOpenPullRequestsExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumOpenPullRequestsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot create the pull request because the repository has too many open pull requests. The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.
public struct MaximumOpenPullRequestsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumOpenPullRequestsExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumOpenPullRequestsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumOpenPullRequestsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumRepositoryNamesExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumRepositoryNamesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of allowed repository names was exceeded. Currently, this number is 100.
public struct MaximumRepositoryNamesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumRepositoryNamesExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumRepositoryNamesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumRepositoryNamesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumRepositoryTriggersExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumRepositoryTriggersExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of triggers allowed for the repository was exceeded.
public struct MaximumRepositoryTriggersExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumRepositoryTriggersExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumRepositoryTriggersExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumRepositoryTriggersExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumRuleTemplatesAssociatedWithRepositoryException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumRuleTemplatesAssociatedWithRepositoryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25 approval rule templates with a repository.
public struct MaximumRuleTemplatesAssociatedWithRepositoryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumRuleTemplatesAssociatedWithRepositoryException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumRuleTemplatesAssociatedWithRepositoryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumRuleTemplatesAssociatedWithRepositoryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MergeBranchesByFastForwardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
        if let targetBranch = self.targetBranch {
            try encodeContainer.encode(targetBranch, forKey: .targetBranch)
        }
    }
}

extension MergeBranchesByFastForwardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergeBranchesByFastForwardInput: Swift.Equatable {
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The name of the repository where you want to merge two branches.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?
    /// The branch where the merge is applied.
    public var targetBranch: Swift.String?

    public init(
        destinationCommitSpecifier: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil,
        targetBranch: Swift.String? = nil
    )
    {
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

struct MergeBranchesByFastForwardInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let targetBranch: Swift.String?
}

extension MergeBranchesByFastForwardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let targetBranchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBranch)
        targetBranch = targetBranchDecoded
    }
}

extension MergeBranchesByFastForwardOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MergeBranchesByFastForwardOutputBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct MergeBranchesByFastForwardOutput: Swift.Equatable {
    /// The commit ID of the merge in the destination or target branch.
    public var commitId: Swift.String?
    /// The tree ID of the merge in the destination or target branch.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct MergeBranchesByFastForwardOutputBody: Swift.Equatable {
    let commitId: Swift.String?
    let treeId: Swift.String?
}

extension MergeBranchesByFastForwardOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case treeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

enum MergeBranchesByFastForwardOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BranchDoesNotExistException": return try await BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameIsTagNameException": return try await BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameRequiredException": return try await BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentReferenceUpdateException": return try await ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBranchNameException": return try await InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTargetBranchException": return try await InvalidTargetBranchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ManualMergeRequiredException": return try await ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MergeBranchesBySquashInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let keepEmptyFolders = self.keepEmptyFolders {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
        if let targetBranch = self.targetBranch {
            try encodeContainer.encode(targetBranch, forKey: .targetBranch)
        }
    }
}

extension MergeBranchesBySquashInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergeBranchesBySquashInput: Swift.Equatable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If this is specified as true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The name of the repository where you want to merge two branches.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?
    /// The branch where the merge is applied.
    public var targetBranch: Swift.String?

    public init(
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil,
        targetBranch: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

struct MergeBranchesBySquashInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let targetBranch: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let authorName: Swift.String?
    let email: Swift.String?
    let commitMessage: Swift.String?
    let keepEmptyFolders: Swift.Bool?
    let conflictResolution: CodeCommitClientTypes.ConflictResolution?
}

extension MergeBranchesBySquashInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let targetBranchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBranch)
        targetBranch = targetBranchDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergeBranchesBySquashOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MergeBranchesBySquashOutputBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct MergeBranchesBySquashOutput: Swift.Equatable {
    /// The commit ID of the merge in the destination or target branch.
    public var commitId: Swift.String?
    /// The tree ID of the merge in the destination or target branch.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct MergeBranchesBySquashOutputBody: Swift.Equatable {
    let commitId: Swift.String?
    let treeId: Swift.String?
}

extension MergeBranchesBySquashOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case treeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

enum MergeBranchesBySquashOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BranchDoesNotExistException": return try await BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameIsTagNameException": return try await BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameRequiredException": return try await BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitMessageLengthExceededException": return try await CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentReferenceUpdateException": return try await ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileContentSizeLimitExceededException": return try await FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileModeRequiredException": return try await FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FolderContentSizeLimitExceededException": return try await FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBranchNameException": return try await InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictDetailLevelException": return try await InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionException": return try await InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionStrategyException": return try await InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEmailException": return try await InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFileModeException": return try await InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReplacementContentException": return try await InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReplacementTypeException": return try await InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTargetBranchException": return try await InvalidTargetBranchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ManualMergeRequiredException": return try await ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumConflictResolutionEntriesExceededException": return try await MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumFileContentToLoadExceededException": return try await MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumItemsToCompareExceededException": return try await MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MultipleConflictResolutionEntriesException": return try await MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameLengthExceededException": return try await NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplacementContentRequiredException": return try await ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplacementTypeRequiredException": return try await ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MergeBranchesByThreeWayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let keepEmptyFolders = self.keepEmptyFolders {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
        if let targetBranch = self.targetBranch {
            try encodeContainer.encode(targetBranch, forKey: .targetBranch)
        }
    }
}

extension MergeBranchesByThreeWayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergeBranchesByThreeWayInput: Swift.Equatable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message to include in the commit information for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The name of the repository where you want to merge two branches.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?
    /// The branch where the merge is applied.
    public var targetBranch: Swift.String?

    public init(
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil,
        targetBranch: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

struct MergeBranchesByThreeWayInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let targetBranch: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let authorName: Swift.String?
    let email: Swift.String?
    let commitMessage: Swift.String?
    let keepEmptyFolders: Swift.Bool?
    let conflictResolution: CodeCommitClientTypes.ConflictResolution?
}

extension MergeBranchesByThreeWayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let targetBranchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBranch)
        targetBranch = targetBranchDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergeBranchesByThreeWayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MergeBranchesByThreeWayOutputBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct MergeBranchesByThreeWayOutput: Swift.Equatable {
    /// The commit ID of the merge in the destination or target branch.
    public var commitId: Swift.String?
    /// The tree ID of the merge in the destination or target branch.
    public var treeId: Swift.String?

    public init(
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct MergeBranchesByThreeWayOutputBody: Swift.Equatable {
    let commitId: Swift.String?
    let treeId: Swift.String?
}

extension MergeBranchesByThreeWayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case treeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

enum MergeBranchesByThreeWayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BranchDoesNotExistException": return try await BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameIsTagNameException": return try await BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameRequiredException": return try await BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitMessageLengthExceededException": return try await CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitRequiredException": return try await CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentReferenceUpdateException": return try await ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileContentSizeLimitExceededException": return try await FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileModeRequiredException": return try await FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FolderContentSizeLimitExceededException": return try await FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBranchNameException": return try await InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitException": return try await InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictDetailLevelException": return try await InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionException": return try await InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionStrategyException": return try await InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEmailException": return try await InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFileModeException": return try await InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReplacementContentException": return try await InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReplacementTypeException": return try await InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTargetBranchException": return try await InvalidTargetBranchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ManualMergeRequiredException": return try await ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumConflictResolutionEntriesExceededException": return try await MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumFileContentToLoadExceededException": return try await MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumItemsToCompareExceededException": return try await MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MultipleConflictResolutionEntriesException": return try await MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameLengthExceededException": return try await NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplacementContentRequiredException": return try await ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplacementTypeRequiredException": return try await ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.MergeHunk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case destination
        case isConflict
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = self.base {
            try encodeContainer.encode(base, forKey: .base)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if isConflict != false {
            try encodeContainer.encode(isConflict, forKey: .isConflict)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isConflictDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isConflict) ?? false
        isConflict = isConflictDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeHunkDetail.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeHunkDetail.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeHunkDetail.self, forKey: .base)
        base = baseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about merge hunks in a merge or pull request operation.
    public struct MergeHunk: Swift.Equatable {
        /// Information about the merge hunk in the base of a merge or pull request.
        public var base: CodeCommitClientTypes.MergeHunkDetail?
        /// Information about the merge hunk in the destination of a merge or pull request.
        public var destination: CodeCommitClientTypes.MergeHunkDetail?
        /// A Boolean value indicating whether a combination of hunks contains a conflict. Conflicts occur when the same file or the same lines in a file were modified in both the source and destination of a merge or pull request. Valid values include true, false, and null. True when the hunk represents a conflict and one or more files contains a line conflict. File mode conflicts in a merge do not set this to true.
        public var isConflict: Swift.Bool
        /// Information about the merge hunk in the source of a merge or pull request.
        public var source: CodeCommitClientTypes.MergeHunkDetail?

        public init(
            base: CodeCommitClientTypes.MergeHunkDetail? = nil,
            destination: CodeCommitClientTypes.MergeHunkDetail? = nil,
            isConflict: Swift.Bool = false,
            source: CodeCommitClientTypes.MergeHunkDetail? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.isConflict = isConflict
            self.source = source
        }
    }

}

extension CodeCommitClientTypes.MergeHunkDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endLine
        case hunkContent
        case startLine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endLine = self.endLine {
            try encodeContainer.encode(endLine, forKey: .endLine)
        }
        if let hunkContent = self.hunkContent {
            try encodeContainer.encode(hunkContent, forKey: .hunkContent)
        }
        if let startLine = self.startLine {
            try encodeContainer.encode(startLine, forKey: .startLine)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startLine)
        startLine = startLineDecoded
        let endLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endLine)
        endLine = endLineDecoded
        let hunkContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hunkContent)
        hunkContent = hunkContentDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the details of a merge hunk that contains a conflict in a merge or pull request operation.
    public struct MergeHunkDetail: Swift.Equatable {
        /// The end position of the hunk in the merge result.
        public var endLine: Swift.Int?
        /// The base-64 encoded content of the hunk merged region that might contain a conflict.
        public var hunkContent: Swift.String?
        /// The start position of the hunk in the merge result.
        public var startLine: Swift.Int?

        public init(
            endLine: Swift.Int? = nil,
            hunkContent: Swift.String? = nil,
            startLine: Swift.Int? = nil
        )
        {
            self.endLine = endLine
            self.hunkContent = hunkContent
            self.startLine = startLine
        }
    }

}

extension CodeCommitClientTypes.MergeMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isMerged
        case mergeCommitId
        case mergeOption
        case mergedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isMerged != false {
            try encodeContainer.encode(isMerged, forKey: .isMerged)
        }
        if let mergeCommitId = self.mergeCommitId {
            try encodeContainer.encode(mergeCommitId, forKey: .mergeCommitId)
        }
        if let mergeOption = self.mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let mergedBy = self.mergedBy {
            try encodeContainer.encode(mergedBy, forKey: .mergedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isMergedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMerged) ?? false
        isMerged = isMergedDecoded
        let mergedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedBy)
        mergedBy = mergedByDecoded
        let mergeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergeCommitId)
        mergeCommitId = mergeCommitIdDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a merge or potential merge between a source reference and a destination reference in a pull request.
    public struct MergeMetadata: Swift.Equatable {
        /// A Boolean value indicating whether the merge has been made.
        public var isMerged: Swift.Bool
        /// The commit ID for the merge commit, if any.
        public var mergeCommitId: Swift.String?
        /// The merge strategy used in the merge.
        public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
        /// The Amazon Resource Name (ARN) of the user who merged the branches.
        public var mergedBy: Swift.String?

        public init(
            isMerged: Swift.Bool = false,
            mergeCommitId: Swift.String? = nil,
            mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
            mergedBy: Swift.String? = nil
        )
        {
            self.isMerged = isMerged
            self.mergeCommitId = mergeCommitId
            self.mergeOption = mergeOption
            self.mergedBy = mergedBy
        }
    }

}

extension CodeCommitClientTypes.MergeOperations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination.rawValue, forKey: .destination)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ChangeTypeEnum.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ChangeTypeEnum.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the file operation conflicts in a merge operation.
    public struct MergeOperations: Swift.Equatable {
        /// The operation on a file in the destination of a merge or pull request.
        public var destination: CodeCommitClientTypes.ChangeTypeEnum?
        /// The operation (add, modify, or delete) on a file in the source of a merge or pull request.
        public var source: CodeCommitClientTypes.ChangeTypeEnum?

        public init(
            destination: CodeCommitClientTypes.ChangeTypeEnum? = nil,
            source: CodeCommitClientTypes.ChangeTypeEnum? = nil
        )
        {
            self.destination = destination
            self.source = source
        }
    }

}

extension MergeOptionRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MergeOptionRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A merge option or stategy is required, and none was provided.
public struct MergeOptionRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MergeOptionRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MergeOptionRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MergeOptionRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum MergeOptionTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fastForwardMerge
        case squashMerge
        case threeWayMerge
        case sdkUnknown(Swift.String)

        public static var allCases: [MergeOptionTypeEnum] {
            return [
                .fastForwardMerge,
                .squashMerge,
                .threeWayMerge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fastForwardMerge: return "FAST_FORWARD_MERGE"
            case .squashMerge: return "SQUASH_MERGE"
            case .threeWayMerge: return "THREE_WAY_MERGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MergeOptionTypeEnum(rawValue: rawValue) ?? MergeOptionTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension MergePullRequestByFastForwardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = self.sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }
}

extension MergePullRequestByFastForwardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergePullRequestByFastForwardInput: Swift.Equatable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.
    public var sourceCommitId: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

struct MergePullRequestByFastForwardInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let repositoryName: Swift.String?
    let sourceCommitId: Swift.String?
}

extension MergePullRequestByFastForwardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
    }
}

extension MergePullRequestByFastForwardOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MergePullRequestByFastForwardOutputBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct MergePullRequestByFastForwardOutput: Swift.Equatable {
    /// Information about the specified pull request, including the merge.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct MergePullRequestByFastForwardOutputBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension MergePullRequestByFastForwardOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

enum MergePullRequestByFastForwardOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentReferenceUpdateException": return try await ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitIdException": return try await InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ManualMergeRequiredException": return try await ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestAlreadyClosedException": return try await PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestApprovalRulesNotSatisfiedException": return try await PullRequestApprovalRulesNotSatisfiedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReferenceDoesNotExistException": return try await ReferenceDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotAssociatedWithPullRequestException": return try await RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipOfSourceReferenceIsDifferentException": return try await TipOfSourceReferenceIsDifferentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MergePullRequestBySquashInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let keepEmptyFolders = self.keepEmptyFolders {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = self.sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }
}

extension MergePullRequestBySquashInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergePullRequestBySquashInput: Swift.Equatable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message to include in the commit information for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.
    public var sourceCommitId: Swift.String?

    public init(
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

struct MergePullRequestBySquashInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let repositoryName: Swift.String?
    let sourceCommitId: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let commitMessage: Swift.String?
    let authorName: Swift.String?
    let email: Swift.String?
    let keepEmptyFolders: Swift.Bool?
    let conflictResolution: CodeCommitClientTypes.ConflictResolution?
}

extension MergePullRequestBySquashInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergePullRequestBySquashOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MergePullRequestBySquashOutputBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct MergePullRequestBySquashOutput: Swift.Equatable {
    /// Returns information about a pull request.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct MergePullRequestBySquashOutputBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension MergePullRequestBySquashOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

enum MergePullRequestBySquashOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitMessageLengthExceededException": return try await CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentReferenceUpdateException": return try await ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileContentSizeLimitExceededException": return try await FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FolderContentSizeLimitExceededException": return try await FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitIdException": return try await InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictDetailLevelException": return try await InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionException": return try await InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionStrategyException": return try await InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEmailException": return try await InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFileModeException": return try await InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReplacementContentException": return try await InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReplacementTypeException": return try await InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ManualMergeRequiredException": return try await ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumConflictResolutionEntriesExceededException": return try await MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumFileContentToLoadExceededException": return try await MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumItemsToCompareExceededException": return try await MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MultipleConflictResolutionEntriesException": return try await MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameLengthExceededException": return try await NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestAlreadyClosedException": return try await PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestApprovalRulesNotSatisfiedException": return try await PullRequestApprovalRulesNotSatisfiedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplacementContentRequiredException": return try await ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplacementTypeRequiredException": return try await ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotAssociatedWithPullRequestException": return try await RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipOfSourceReferenceIsDifferentException": return try await TipOfSourceReferenceIsDifferentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MergePullRequestByThreeWayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let keepEmptyFolders = self.keepEmptyFolders {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = self.sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }
}

extension MergePullRequestByThreeWayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergePullRequestByThreeWayInput: Swift.Equatable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message to include in the commit information for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.
    public var sourceCommitId: Swift.String?

    public init(
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

struct MergePullRequestByThreeWayInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let repositoryName: Swift.String?
    let sourceCommitId: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let commitMessage: Swift.String?
    let authorName: Swift.String?
    let email: Swift.String?
    let keepEmptyFolders: Swift.Bool?
    let conflictResolution: CodeCommitClientTypes.ConflictResolution?
}

extension MergePullRequestByThreeWayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergePullRequestByThreeWayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MergePullRequestByThreeWayOutputBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct MergePullRequestByThreeWayOutput: Swift.Equatable {
    /// Returns information about a pull request.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct MergePullRequestByThreeWayOutputBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension MergePullRequestByThreeWayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

enum MergePullRequestByThreeWayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommitMessageLengthExceededException": return try await CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentReferenceUpdateException": return try await ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileContentSizeLimitExceededException": return try await FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FolderContentSizeLimitExceededException": return try await FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitIdException": return try await InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictDetailLevelException": return try await InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionException": return try await InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConflictResolutionStrategyException": return try await InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEmailException": return try await InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFileModeException": return try await InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReplacementContentException": return try await InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReplacementTypeException": return try await InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ManualMergeRequiredException": return try await ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumConflictResolutionEntriesExceededException": return try await MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumFileContentToLoadExceededException": return try await MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumItemsToCompareExceededException": return try await MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MultipleConflictResolutionEntriesException": return try await MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameLengthExceededException": return try await NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestAlreadyClosedException": return try await PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestApprovalRulesNotSatisfiedException": return try await PullRequestApprovalRulesNotSatisfiedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplacementContentRequiredException": return try await ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplacementTypeRequiredException": return try await ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotAssociatedWithPullRequestException": return try await RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipOfSourceReferenceIsDifferentException": return try await TipOfSourceReferenceIsDifferentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TipsDivergenceExceededException": return try await TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MultipleConflictResolutionEntriesException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MultipleConflictResolutionEntriesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.
public struct MultipleConflictResolutionEntriesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MultipleConflictResolutionEntriesException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MultipleConflictResolutionEntriesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MultipleConflictResolutionEntriesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MultipleRepositoriesInPullRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MultipleRepositoriesInPullRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.
public struct MultipleRepositoriesInPullRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MultipleRepositoriesInPullRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MultipleRepositoriesInPullRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MultipleRepositoriesInPullRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NameLengthExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NameLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user name is not valid because it has exceeded the character limit for author names.
public struct NameLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NameLengthExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NameLengthExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NameLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoChangeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoChangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.
public struct NoChangeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoChangeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoChangeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoChangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NumberOfRuleTemplatesExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NumberOfRuleTemplatesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of approval rule templates has been exceeded for this Amazon Web Services Region.
public struct NumberOfRuleTemplatesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NumberOfRuleTemplatesExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NumberOfRuleTemplatesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NumberOfRuleTemplatesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NumberOfRulesExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NumberOfRulesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.
public struct NumberOfRulesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NumberOfRulesExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NumberOfRulesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NumberOfRulesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum ObjectTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directory
        case file
        case gitLink
        case symbolicLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectTypeEnum] {
            return [
                .directory,
                .file,
                .gitLink,
                .symbolicLink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directory: return "DIRECTORY"
            case .file: return "FILE"
            case .gitLink: return "GIT_LINK"
            case .symbolicLink: return "SYMBOLIC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectTypeEnum(rawValue: rawValue) ?? ObjectTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.ObjectTypes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = self.base {
            try encodeContainer.encode(base.rawValue, forKey: .base)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination.rawValue, forKey: .destination)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ObjectTypeEnum.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ObjectTypeEnum.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ObjectTypeEnum.self, forKey: .base)
        base = baseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the type of an object in a merge operation.
    public struct ObjectTypes: Swift.Equatable {
        /// The type of the object in the base commit of the merge.
        public var base: CodeCommitClientTypes.ObjectTypeEnum?
        /// The type of the object in the destination branch.
        public var destination: CodeCommitClientTypes.ObjectTypeEnum?
        /// The type of the object in the source branch.
        public var source: CodeCommitClientTypes.ObjectTypeEnum?

        public init(
            base: CodeCommitClientTypes.ObjectTypeEnum? = nil,
            destination: CodeCommitClientTypes.ObjectTypeEnum? = nil,
            source: CodeCommitClientTypes.ObjectTypeEnum? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }

}

extension CodeCommitClientTypes {
    public enum OrderEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderEnum] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ascending"
            case .descending: return "descending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderEnum(rawValue: rawValue) ?? OrderEnum.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.OriginApprovalRuleTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateId
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateId = self.approvalRuleTemplateId {
            try encodeContainer.encode(approvalRuleTemplateId, forKey: .approvalRuleTemplateId)
        }
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateId)
        approvalRuleTemplateId = approvalRuleTemplateIdDecoded
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about the template that created the approval rule for a pull request.
    public struct OriginApprovalRuleTemplate: Swift.Equatable {
        /// The ID of the template that created the approval rule.
        public var approvalRuleTemplateId: Swift.String?
        /// The name of the template that created the approval rule.
        public var approvalRuleTemplateName: Swift.String?

        public init(
            approvalRuleTemplateId: Swift.String? = nil,
            approvalRuleTemplateName: Swift.String? = nil
        )
        {
            self.approvalRuleTemplateId = approvalRuleTemplateId
            self.approvalRuleTemplateName = approvalRuleTemplateName
        }
    }

}

extension OverrideAlreadySetException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OverrideAlreadySetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull request has already had its approval rules set to override.
public struct OverrideAlreadySetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OverrideAlreadySetException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OverrideAlreadySetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OverrideAlreadySetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OverridePullRequestApprovalRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideStatus
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideStatus = self.overrideStatus {
            try encodeContainer.encode(overrideStatus.rawValue, forKey: .overrideStatus)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension OverridePullRequestApprovalRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct OverridePullRequestApprovalRulesInput: Swift.Equatable {
    /// Whether you want to set aside approval rule requirements for the pull request (OVERRIDE) or revoke a previous override and apply approval rule requirements (REVOKE). REVOKE status is not stored.
    /// This member is required.
    public var overrideStatus: CodeCommitClientTypes.OverrideStatus?
    /// The system-generated ID of the pull request for which you want to override all approval rule requirements. To get this information, use [GetPullRequest].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID of the most recent revision of the pull request. You cannot override approval rules for anything but the most recent revision of a pull request. To get the revision ID, use GetPullRequest.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        overrideStatus: CodeCommitClientTypes.OverrideStatus? = nil,
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.overrideStatus = overrideStatus
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct OverridePullRequestApprovalRulesInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let revisionId: Swift.String?
    let overrideStatus: CodeCommitClientTypes.OverrideStatus?
}

extension OverridePullRequestApprovalRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideStatus
        case pullRequestId
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let overrideStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.OverrideStatus.self, forKey: .overrideStatus)
        overrideStatus = overrideStatusDecoded
    }
}

extension OverridePullRequestApprovalRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct OverridePullRequestApprovalRulesOutput: Swift.Equatable {

    public init() { }
}

enum OverridePullRequestApprovalRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOverrideStatusException": return try await InvalidOverrideStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRevisionIdException": return try await InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OverrideAlreadySetException": return try await OverrideAlreadySetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OverrideStatusRequiredException": return try await OverrideStatusRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestAlreadyClosedException": return try await PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RevisionIdRequiredException": return try await RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RevisionNotCurrentException": return try await RevisionNotCurrentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes {
    public enum OverrideStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `override`
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [OverrideStatus] {
            return [
                .override,
                .revoke,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .override: return "OVERRIDE"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OverrideStatus(rawValue: rawValue) ?? OverrideStatus.sdkUnknown(rawValue)
        }
    }
}

extension OverrideStatusRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OverrideStatusRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.
public struct OverrideStatusRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OverrideStatusRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OverrideStatusRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OverrideStatusRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParentCommitDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ParentCommitDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.
public struct ParentCommitDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParentCommitDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ParentCommitDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParentCommitDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParentCommitIdOutdatedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ParentCommitIdOutdatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use [GetBranch].
public struct ParentCommitIdOutdatedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParentCommitIdOutdatedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ParentCommitIdOutdatedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParentCommitIdOutdatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParentCommitIdRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ParentCommitIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A parent commit ID is required. To view the full commit ID of a branch in a repository, use [GetBranch] or a Git command (for example, git pull or git log).
public struct ParentCommitIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParentCommitIdRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ParentCommitIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParentCommitIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PathDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PathDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified path does not exist.
public struct PathDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PathDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PathDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PathDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PathRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PathRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The folderPath for a location cannot be null.
public struct PathRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PathRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PathRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PathRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PostCommentForComparedCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PostCommentForComparedCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PostCommentForComparedCommitInput: Swift.Equatable {
    /// To establish the directionality of the comparison, the full commit ID of the after commit.
    /// This member is required.
    public var afterCommitId: Swift.String?
    /// To establish the directionality of the comparison, the full commit ID of the before commit. Required for commenting on any commit unless that commit is the initial commit.
    public var beforeCommitId: Swift.String?
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
    public var clientRequestToken: Swift.String?
    /// The content of the comment you want to make.
    /// This member is required.
    public var content: Swift.String?
    /// The location of the comparison where you want to comment.
    public var location: CodeCommitClientTypes.Location?
    /// The name of the repository where you want to post a comment on the comparison between commits.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.location = location
        self.repositoryName = repositoryName
    }
}

struct PostCommentForComparedCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let location: CodeCommitClientTypes.Location?
    let content: Swift.String?
    let clientRequestToken: Swift.String?
}

extension PostCommentForComparedCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension PostCommentForComparedCommitOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PostCommentForComparedCommitOutputBody = try responseDecoder.decode(responseBody: data)
            self.afterBlobId = output.afterBlobId
            self.afterCommitId = output.afterCommitId
            self.beforeBlobId = output.beforeBlobId
            self.beforeCommitId = output.beforeCommitId
            self.comment = output.comment
            self.location = output.location
            self.repositoryName = output.repositoryName
        } else {
            self.afterBlobId = nil
            self.afterCommitId = nil
            self.beforeBlobId = nil
            self.beforeCommitId = nil
            self.comment = nil
            self.location = nil
            self.repositoryName = nil
        }
    }
}

public struct PostCommentForComparedCommitOutput: Swift.Equatable {
    /// In the directionality you established, the blob ID of the after blob.
    public var afterBlobId: Swift.String?
    /// In the directionality you established, the full commit ID of the after commit.
    public var afterCommitId: Swift.String?
    /// In the directionality you established, the blob ID of the before blob.
    public var beforeBlobId: Swift.String?
    /// In the directionality you established, the full commit ID of the before commit.
    public var beforeCommitId: Swift.String?
    /// The content of the comment you posted.
    public var comment: CodeCommitClientTypes.Comment?
    /// The location of the comment in the comparison between the two commits.
    public var location: CodeCommitClientTypes.Location?
    /// The name of the repository where you posted a comment on the comparison between commits.
    public var repositoryName: Swift.String?

    public init(
        afterBlobId: Swift.String? = nil,
        afterCommitId: Swift.String? = nil,
        beforeBlobId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        comment: CodeCommitClientTypes.Comment? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterBlobId = afterBlobId
        self.afterCommitId = afterCommitId
        self.beforeBlobId = beforeBlobId
        self.beforeCommitId = beforeCommitId
        self.comment = comment
        self.location = location
        self.repositoryName = repositoryName
    }
}

struct PostCommentForComparedCommitOutputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let beforeBlobId: Swift.String?
    let afterBlobId: Swift.String?
    let location: CodeCommitClientTypes.Location?
    let comment: CodeCommitClientTypes.Comment?
}

extension PostCommentForComparedCommitOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comment
        case location
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

enum PostCommentForComparedCommitOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BeforeCommitIdAndAfterCommitIdAreSameException": return try await BeforeCommitIdAndAfterCommitIdAreSameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientRequestTokenRequiredException": return try await ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentContentRequiredException": return try await CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentContentSizeLimitExceededException": return try await CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitIdRequiredException": return try await CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyParameterMismatchException": return try await IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientRequestTokenException": return try await InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitIdException": return try await InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFileLocationException": return try await InvalidFileLocationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFilePositionException": return try await InvalidFilePositionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRelativeFileVersionEnumException": return try await InvalidRelativeFileVersionEnumException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathDoesNotExistException": return try await PathDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PostCommentForPullRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case pullRequestId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PostCommentForPullRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PostCommentForPullRequestInput: Swift.Equatable {
    /// The full commit ID of the commit in the source branch that is the current tip of the branch for the pull request when you post the comment.
    /// This member is required.
    public var afterCommitId: Swift.String?
    /// The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was created.
    /// This member is required.
    public var beforeCommitId: Swift.String?
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
    public var clientRequestToken: Swift.String?
    /// The content of your comment on the change.
    /// This member is required.
    public var content: Swift.String?
    /// The location of the change where you want to post your comment. If no location is provided, the comment is posted as a general comment on the pull request difference between the before commit ID and the after commit ID.
    public var location: CodeCommitClientTypes.Location?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where you want to post a comment on a pull request.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.location = location
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

struct PostCommentForPullRequestInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let repositoryName: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let location: CodeCommitClientTypes.Location?
    let content: Swift.String?
    let clientRequestToken: Swift.String?
}

extension PostCommentForPullRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case pullRequestId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension PostCommentForPullRequestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PostCommentForPullRequestOutputBody = try responseDecoder.decode(responseBody: data)
            self.afterBlobId = output.afterBlobId
            self.afterCommitId = output.afterCommitId
            self.beforeBlobId = output.beforeBlobId
            self.beforeCommitId = output.beforeCommitId
            self.comment = output.comment
            self.location = output.location
            self.pullRequestId = output.pullRequestId
            self.repositoryName = output.repositoryName
        } else {
            self.afterBlobId = nil
            self.afterCommitId = nil
            self.beforeBlobId = nil
            self.beforeCommitId = nil
            self.comment = nil
            self.location = nil
            self.pullRequestId = nil
            self.repositoryName = nil
        }
    }
}

public struct PostCommentForPullRequestOutput: Swift.Equatable {
    /// In the directionality of the pull request, the blob ID of the after blob.
    public var afterBlobId: Swift.String?
    /// The full commit ID of the commit in the destination branch where the pull request is merged.
    public var afterCommitId: Swift.String?
    /// In the directionality of the pull request, the blob ID of the before blob.
    public var beforeBlobId: Swift.String?
    /// The full commit ID of the commit in the source branch used to create the pull request, or in the case of an updated pull request, the full commit ID of the commit used to update the pull request.
    public var beforeCommitId: Swift.String?
    /// The content of the comment you posted.
    public var comment: CodeCommitClientTypes.Comment?
    /// The location of the change where you posted your comment.
    public var location: CodeCommitClientTypes.Location?
    /// The system-generated ID of the pull request.
    public var pullRequestId: Swift.String?
    /// The name of the repository where you posted a comment on a pull request.
    public var repositoryName: Swift.String?

    public init(
        afterBlobId: Swift.String? = nil,
        afterCommitId: Swift.String? = nil,
        beforeBlobId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        comment: CodeCommitClientTypes.Comment? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterBlobId = afterBlobId
        self.afterCommitId = afterCommitId
        self.beforeBlobId = beforeBlobId
        self.beforeCommitId = beforeCommitId
        self.comment = comment
        self.location = location
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

struct PostCommentForPullRequestOutputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let pullRequestId: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let beforeBlobId: Swift.String?
    let afterBlobId: Swift.String?
    let location: CodeCommitClientTypes.Location?
    let comment: CodeCommitClientTypes.Comment?
}

extension PostCommentForPullRequestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comment
        case location
        case pullRequestId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

enum PostCommentForPullRequestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BeforeCommitIdAndAfterCommitIdAreSameException": return try await BeforeCommitIdAndAfterCommitIdAreSameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientRequestTokenRequiredException": return try await ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentContentRequiredException": return try await CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentContentSizeLimitExceededException": return try await CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitDoesNotExistException": return try await CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitIdRequiredException": return try await CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyParameterMismatchException": return try await IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientRequestTokenException": return try await InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommitIdException": return try await InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFileLocationException": return try await InvalidFileLocationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFilePositionException": return try await InvalidFilePositionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRelativeFileVersionEnumException": return try await InvalidRelativeFileVersionEnumException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathDoesNotExistException": return try await PathDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotAssociatedWithPullRequestException": return try await RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PostCommentReplyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case content
        case inReplyTo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let inReplyTo = self.inReplyTo {
            try encodeContainer.encode(inReplyTo, forKey: .inReplyTo)
        }
    }
}

extension PostCommentReplyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PostCommentReplyInput: Swift.Equatable {
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
    public var clientRequestToken: Swift.String?
    /// The contents of your reply to a comment.
    /// This member is required.
    public var content: Swift.String?
    /// The system-generated ID of the comment to which you want to reply. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var inReplyTo: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        inReplyTo: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.inReplyTo = inReplyTo
    }
}

struct PostCommentReplyInputBody: Swift.Equatable {
    let inReplyTo: Swift.String?
    let clientRequestToken: Swift.String?
    let content: Swift.String?
}

extension PostCommentReplyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case content
        case inReplyTo
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inReplyToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inReplyTo)
        inReplyTo = inReplyToDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension PostCommentReplyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PostCommentReplyOutputBody = try responseDecoder.decode(responseBody: data)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct PostCommentReplyOutput: Swift.Equatable {
    /// Information about the reply to a comment.
    public var comment: CodeCommitClientTypes.Comment?

    public init(
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct PostCommentReplyOutputBody: Swift.Equatable {
    let comment: CodeCommitClientTypes.Comment?
}

extension PostCommentReplyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

enum PostCommentReplyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientRequestTokenRequiredException": return try await ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentContentRequiredException": return try await CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentContentSizeLimitExceededException": return try await CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentDoesNotExistException": return try await CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentIdRequiredException": return try await CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotencyParameterMismatchException": return try await IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientRequestTokenException": return try await InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommentIdException": return try await InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.PullRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules
        case authorArn
        case clientRequestToken
        case creationDate
        case description
        case lastActivityDate
        case pullRequestId
        case pullRequestStatus
        case pullRequestTargets
        case revisionId
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            var approvalRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvalRules)
            for approvalrule0 in approvalRules {
                try approvalRulesContainer.encode(approvalrule0)
            }
        }
        if let authorArn = self.authorArn {
            try encodeContainer.encode(authorArn, forKey: .authorArn)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastActivityDate = self.lastActivityDate {
            try encodeContainer.encodeTimestamp(lastActivityDate, format: .epochSeconds, forKey: .lastActivityDate)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let pullRequestStatus = self.pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
        if let pullRequestTargets = pullRequestTargets {
            var pullRequestTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pullRequestTargets)
            for pullrequesttarget0 in pullRequestTargets {
                try pullRequestTargetsContainer.encode(pullrequesttarget0)
            }
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastActivityDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastActivityDate)
        lastActivityDate = lastActivityDateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
        let authorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorArn)
        authorArn = authorArnDecoded
        let pullRequestTargetsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.PullRequestTarget?].self, forKey: .pullRequestTargets)
        var pullRequestTargetsDecoded0:[CodeCommitClientTypes.PullRequestTarget]? = nil
        if let pullRequestTargetsContainer = pullRequestTargetsContainer {
            pullRequestTargetsDecoded0 = [CodeCommitClientTypes.PullRequestTarget]()
            for structure0 in pullRequestTargetsContainer {
                if let structure0 = structure0 {
                    pullRequestTargetsDecoded0?.append(structure0)
                }
            }
        }
        pullRequestTargets = pullRequestTargetsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let approvalRulesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.ApprovalRule?].self, forKey: .approvalRules)
        var approvalRulesDecoded0:[CodeCommitClientTypes.ApprovalRule]? = nil
        if let approvalRulesContainer = approvalRulesContainer {
            approvalRulesDecoded0 = [CodeCommitClientTypes.ApprovalRule]()
            for structure0 in approvalRulesContainer {
                if let structure0 = structure0 {
                    approvalRulesDecoded0?.append(structure0)
                }
            }
        }
        approvalRules = approvalRulesDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a pull request.
    public struct PullRequest: Swift.Equatable {
        /// The approval rules applied to the pull request.
        public var approvalRules: [CodeCommitClientTypes.ApprovalRule]?
        /// The Amazon Resource Name (ARN) of the user who created the pull request.
        public var authorArn: Swift.String?
        /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
        public var clientRequestToken: Swift.String?
        /// The date and time the pull request was originally created, in timestamp format.
        public var creationDate: ClientRuntime.Date?
        /// The user-defined description of the pull request. This description can be used to clarify what should be reviewed and other details of the request.
        public var description: Swift.String?
        /// The day and time of the last user or system activity on the pull request, in timestamp format.
        public var lastActivityDate: ClientRuntime.Date?
        /// The system-generated ID of the pull request.
        public var pullRequestId: Swift.String?
        /// The status of the pull request. Pull request status can only change from OPEN to CLOSED.
        public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?
        /// The targets of the pull request, including the source branch and destination branch for the pull request.
        public var pullRequestTargets: [CodeCommitClientTypes.PullRequestTarget]?
        /// The system-generated revision ID for the pull request.
        public var revisionId: Swift.String?
        /// The user-defined title of the pull request. This title is displayed in the list of pull requests to other repository users.
        public var title: Swift.String?

        public init(
            approvalRules: [CodeCommitClientTypes.ApprovalRule]? = nil,
            authorArn: Swift.String? = nil,
            clientRequestToken: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastActivityDate: ClientRuntime.Date? = nil,
            pullRequestId: Swift.String? = nil,
            pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil,
            pullRequestTargets: [CodeCommitClientTypes.PullRequestTarget]? = nil,
            revisionId: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.approvalRules = approvalRules
            self.authorArn = authorArn
            self.clientRequestToken = clientRequestToken
            self.creationDate = creationDate
            self.description = description
            self.lastActivityDate = lastActivityDate
            self.pullRequestId = pullRequestId
            self.pullRequestStatus = pullRequestStatus
            self.pullRequestTargets = pullRequestTargets
            self.revisionId = revisionId
            self.title = title
        }
    }

}

extension PullRequestAlreadyClosedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PullRequestAlreadyClosedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull request status cannot be updated because it is already closed.
public struct PullRequestAlreadyClosedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestAlreadyClosedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PullRequestAlreadyClosedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestAlreadyClosedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullRequestApprovalRulesNotSatisfiedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PullRequestApprovalRulesNotSatisfiedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.
public struct PullRequestApprovalRulesNotSatisfiedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestApprovalRulesNotSatisfiedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PullRequestApprovalRulesNotSatisfiedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestApprovalRulesNotSatisfiedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullRequestCannotBeApprovedByAuthorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PullRequestCannotBeApprovedByAuthorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull request that you created.
public struct PullRequestCannotBeApprovedByAuthorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestCannotBeApprovedByAuthorException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PullRequestCannotBeApprovedByAuthorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestCannotBeApprovedByAuthorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.PullRequestCreatedEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCommitId
        case mergeBase
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommitId = self.destinationCommitId {
            try encodeContainer.encode(destinationCommitId, forKey: .destinationCommitId)
        }
        if let mergeBase = self.mergeBase {
            try encodeContainer.encode(mergeBase, forKey: .mergeBase)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = self.sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let mergeBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergeBase)
        mergeBase = mergeBaseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Metadata about the pull request that is used when comparing the pull request source with its destination.
    public struct PullRequestCreatedEventMetadata: Swift.Equatable {
        /// The commit ID of the tip of the branch specified as the destination branch when the pull request was created.
        public var destinationCommitId: Swift.String?
        /// The commit ID of the most recent commit that the source branch and the destination branch have in common.
        public var mergeBase: Swift.String?
        /// The name of the repository where the pull request was created.
        public var repositoryName: Swift.String?
        /// The commit ID on the source branch used when the pull request was created.
        public var sourceCommitId: Swift.String?

        public init(
            destinationCommitId: Swift.String? = nil,
            mergeBase: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            sourceCommitId: Swift.String? = nil
        )
        {
            self.destinationCommitId = destinationCommitId
            self.mergeBase = mergeBase
            self.repositoryName = repositoryName
            self.sourceCommitId = sourceCommitId
        }
    }

}

extension PullRequestDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PullRequestDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.
public struct PullRequestDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PullRequestDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.PullRequestEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actorArn
        case approvalRuleEventMetadata
        case approvalRuleOverriddenEventMetadata
        case approvalStateChangedEventMetadata
        case eventDate
        case pullRequestCreatedEventMetadata
        case pullRequestEventType
        case pullRequestId
        case pullRequestMergedStateChangedEventMetadata
        case pullRequestSourceReferenceUpdatedEventMetadata
        case pullRequestStatusChangedEventMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actorArn = self.actorArn {
            try encodeContainer.encode(actorArn, forKey: .actorArn)
        }
        if let approvalRuleEventMetadata = self.approvalRuleEventMetadata {
            try encodeContainer.encode(approvalRuleEventMetadata, forKey: .approvalRuleEventMetadata)
        }
        if let approvalRuleOverriddenEventMetadata = self.approvalRuleOverriddenEventMetadata {
            try encodeContainer.encode(approvalRuleOverriddenEventMetadata, forKey: .approvalRuleOverriddenEventMetadata)
        }
        if let approvalStateChangedEventMetadata = self.approvalStateChangedEventMetadata {
            try encodeContainer.encode(approvalStateChangedEventMetadata, forKey: .approvalStateChangedEventMetadata)
        }
        if let eventDate = self.eventDate {
            try encodeContainer.encodeTimestamp(eventDate, format: .epochSeconds, forKey: .eventDate)
        }
        if let pullRequestCreatedEventMetadata = self.pullRequestCreatedEventMetadata {
            try encodeContainer.encode(pullRequestCreatedEventMetadata, forKey: .pullRequestCreatedEventMetadata)
        }
        if let pullRequestEventType = self.pullRequestEventType {
            try encodeContainer.encode(pullRequestEventType.rawValue, forKey: .pullRequestEventType)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let pullRequestMergedStateChangedEventMetadata = self.pullRequestMergedStateChangedEventMetadata {
            try encodeContainer.encode(pullRequestMergedStateChangedEventMetadata, forKey: .pullRequestMergedStateChangedEventMetadata)
        }
        if let pullRequestSourceReferenceUpdatedEventMetadata = self.pullRequestSourceReferenceUpdatedEventMetadata {
            try encodeContainer.encode(pullRequestSourceReferenceUpdatedEventMetadata, forKey: .pullRequestSourceReferenceUpdatedEventMetadata)
        }
        if let pullRequestStatusChangedEventMetadata = self.pullRequestStatusChangedEventMetadata {
            try encodeContainer.encode(pullRequestStatusChangedEventMetadata, forKey: .pullRequestStatusChangedEventMetadata)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let eventDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventDate)
        eventDate = eventDateDecoded
        let pullRequestEventTypeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestEventType.self, forKey: .pullRequestEventType)
        pullRequestEventType = pullRequestEventTypeDecoded
        let actorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actorArn)
        actorArn = actorArnDecoded
        let pullRequestCreatedEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestCreatedEventMetadata.self, forKey: .pullRequestCreatedEventMetadata)
        pullRequestCreatedEventMetadata = pullRequestCreatedEventMetadataDecoded
        let pullRequestStatusChangedEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestStatusChangedEventMetadata.self, forKey: .pullRequestStatusChangedEventMetadata)
        pullRequestStatusChangedEventMetadata = pullRequestStatusChangedEventMetadataDecoded
        let pullRequestSourceReferenceUpdatedEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata.self, forKey: .pullRequestSourceReferenceUpdatedEventMetadata)
        pullRequestSourceReferenceUpdatedEventMetadata = pullRequestSourceReferenceUpdatedEventMetadataDecoded
        let pullRequestMergedStateChangedEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata.self, forKey: .pullRequestMergedStateChangedEventMetadata)
        pullRequestMergedStateChangedEventMetadata = pullRequestMergedStateChangedEventMetadataDecoded
        let approvalRuleEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleEventMetadata.self, forKey: .approvalRuleEventMetadata)
        approvalRuleEventMetadata = approvalRuleEventMetadataDecoded
        let approvalStateChangedEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalStateChangedEventMetadata.self, forKey: .approvalStateChangedEventMetadata)
        approvalStateChangedEventMetadata = approvalStateChangedEventMetadataDecoded
        let approvalRuleOverriddenEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata.self, forKey: .approvalRuleOverriddenEventMetadata)
        approvalRuleOverriddenEventMetadata = approvalRuleOverriddenEventMetadataDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a pull request event.
    public struct PullRequestEvent: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the user whose actions resulted in the event. Examples include updating the pull request with more commits or changing the status of a pull request.
        public var actorArn: Swift.String?
        /// Information about a pull request event.
        public var approvalRuleEventMetadata: CodeCommitClientTypes.ApprovalRuleEventMetadata?
        /// Information about an approval rule override event for a pull request.
        public var approvalRuleOverriddenEventMetadata: CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata?
        /// Information about an approval state change for a pull request.
        public var approvalStateChangedEventMetadata: CodeCommitClientTypes.ApprovalStateChangedEventMetadata?
        /// The day and time of the pull request event, in timestamp format.
        public var eventDate: ClientRuntime.Date?
        /// Information about the source and destination branches for the pull request.
        public var pullRequestCreatedEventMetadata: CodeCommitClientTypes.PullRequestCreatedEventMetadata?
        /// The type of the pull request event (for example, a status change event (PULL_REQUEST_STATUS_CHANGED) or update event (PULL_REQUEST_SOURCE_REFERENCE_UPDATED)).
        public var pullRequestEventType: CodeCommitClientTypes.PullRequestEventType?
        /// The system-generated ID of the pull request.
        public var pullRequestId: Swift.String?
        /// Information about the change in mergability state for the pull request event.
        public var pullRequestMergedStateChangedEventMetadata: CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata?
        /// Information about the updated source branch for the pull request event.
        public var pullRequestSourceReferenceUpdatedEventMetadata: CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata?
        /// Information about the change in status for the pull request event.
        public var pullRequestStatusChangedEventMetadata: CodeCommitClientTypes.PullRequestStatusChangedEventMetadata?

        public init(
            actorArn: Swift.String? = nil,
            approvalRuleEventMetadata: CodeCommitClientTypes.ApprovalRuleEventMetadata? = nil,
            approvalRuleOverriddenEventMetadata: CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata? = nil,
            approvalStateChangedEventMetadata: CodeCommitClientTypes.ApprovalStateChangedEventMetadata? = nil,
            eventDate: ClientRuntime.Date? = nil,
            pullRequestCreatedEventMetadata: CodeCommitClientTypes.PullRequestCreatedEventMetadata? = nil,
            pullRequestEventType: CodeCommitClientTypes.PullRequestEventType? = nil,
            pullRequestId: Swift.String? = nil,
            pullRequestMergedStateChangedEventMetadata: CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata? = nil,
            pullRequestSourceReferenceUpdatedEventMetadata: CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata? = nil,
            pullRequestStatusChangedEventMetadata: CodeCommitClientTypes.PullRequestStatusChangedEventMetadata? = nil
        )
        {
            self.actorArn = actorArn
            self.approvalRuleEventMetadata = approvalRuleEventMetadata
            self.approvalRuleOverriddenEventMetadata = approvalRuleOverriddenEventMetadata
            self.approvalStateChangedEventMetadata = approvalStateChangedEventMetadata
            self.eventDate = eventDate
            self.pullRequestCreatedEventMetadata = pullRequestCreatedEventMetadata
            self.pullRequestEventType = pullRequestEventType
            self.pullRequestId = pullRequestId
            self.pullRequestMergedStateChangedEventMetadata = pullRequestMergedStateChangedEventMetadata
            self.pullRequestSourceReferenceUpdatedEventMetadata = pullRequestSourceReferenceUpdatedEventMetadata
            self.pullRequestStatusChangedEventMetadata = pullRequestStatusChangedEventMetadata
        }
    }

}

extension CodeCommitClientTypes {
    public enum PullRequestEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pullRequestApprovalRuleCreated
        case pullRequestApprovalRuleDeleted
        case pullRequestApprovalRuleOverridden
        case pullRequestApprovalRuleUpdated
        case pullRequestApprovalStateChanged
        case pullRequestCreated
        case pullRequestMergeStateChanged
        case pullRequestSourceReferenceUpdated
        case pullRequestStatusChanged
        case sdkUnknown(Swift.String)

        public static var allCases: [PullRequestEventType] {
            return [
                .pullRequestApprovalRuleCreated,
                .pullRequestApprovalRuleDeleted,
                .pullRequestApprovalRuleOverridden,
                .pullRequestApprovalRuleUpdated,
                .pullRequestApprovalStateChanged,
                .pullRequestCreated,
                .pullRequestMergeStateChanged,
                .pullRequestSourceReferenceUpdated,
                .pullRequestStatusChanged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pullRequestApprovalRuleCreated: return "PULL_REQUEST_APPROVAL_RULE_CREATED"
            case .pullRequestApprovalRuleDeleted: return "PULL_REQUEST_APPROVAL_RULE_DELETED"
            case .pullRequestApprovalRuleOverridden: return "PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN"
            case .pullRequestApprovalRuleUpdated: return "PULL_REQUEST_APPROVAL_RULE_UPDATED"
            case .pullRequestApprovalStateChanged: return "PULL_REQUEST_APPROVAL_STATE_CHANGED"
            case .pullRequestCreated: return "PULL_REQUEST_CREATED"
            case .pullRequestMergeStateChanged: return "PULL_REQUEST_MERGE_STATE_CHANGED"
            case .pullRequestSourceReferenceUpdated: return "PULL_REQUEST_SOURCE_REFERENCE_UPDATED"
            case .pullRequestStatusChanged: return "PULL_REQUEST_STATUS_CHANGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PullRequestEventType(rawValue: rawValue) ?? PullRequestEventType.sdkUnknown(rawValue)
        }
    }
}

extension PullRequestIdRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PullRequestIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A pull request ID is required, but none was provided.
public struct PullRequestIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestIdRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PullRequestIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationReference
        case mergeMetadata
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationReference = self.destinationReference {
            try encodeContainer.encode(destinationReference, forKey: .destinationReference)
        }
        if let mergeMetadata = self.mergeMetadata {
            try encodeContainer.encode(mergeMetadata, forKey: .mergeMetadata)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationReference)
        destinationReference = destinationReferenceDecoded
        let mergeMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeMetadata.self, forKey: .mergeMetadata)
        mergeMetadata = mergeMetadataDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about the change in the merge state for a pull request event.
    public struct PullRequestMergedStateChangedEventMetadata: Swift.Equatable {
        /// The name of the branch that the pull request is merged into.
        public var destinationReference: Swift.String?
        /// Information about the merge state change event.
        public var mergeMetadata: CodeCommitClientTypes.MergeMetadata?
        /// The name of the repository where the pull request was created.
        public var repositoryName: Swift.String?

        public init(
            destinationReference: Swift.String? = nil,
            mergeMetadata: CodeCommitClientTypes.MergeMetadata? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.destinationReference = destinationReference
            self.mergeMetadata = mergeMetadata
            self.repositoryName = repositoryName
        }
    }

}

extension CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case mergeBase
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let mergeBase = self.mergeBase {
            try encodeContainer.encode(mergeBase, forKey: .mergeBase)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let mergeBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergeBase)
        mergeBase = mergeBaseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about an update to the source branch of a pull request.
    public struct PullRequestSourceReferenceUpdatedEventMetadata: Swift.Equatable {
        /// The full commit ID of the commit in the source branch that was the tip of the branch at the time the pull request was updated.
        public var afterCommitId: Swift.String?
        /// The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was updated.
        public var beforeCommitId: Swift.String?
        /// The commit ID of the most recent commit that the source branch and the destination branch have in common.
        public var mergeBase: Swift.String?
        /// The name of the repository where the pull request was updated.
        public var repositoryName: Swift.String?

        public init(
            afterCommitId: Swift.String? = nil,
            beforeCommitId: Swift.String? = nil,
            mergeBase: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.afterCommitId = afterCommitId
            self.beforeCommitId = beforeCommitId
            self.mergeBase = mergeBase
            self.repositoryName = repositoryName
        }
    }

}

extension CodeCommitClientTypes.PullRequestStatusChangedEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestStatus = self.pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a change to the status of a pull request.
    public struct PullRequestStatusChangedEventMetadata: Swift.Equatable {
        /// The changed status of the pull request.
        public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?

        public init(
            pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil
        )
        {
            self.pullRequestStatus = pullRequestStatus
        }
    }

}

extension CodeCommitClientTypes {
    public enum PullRequestStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [PullRequestStatusEnum] {
            return [
                .closed,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .open: return "OPEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PullRequestStatusEnum(rawValue: rawValue) ?? PullRequestStatusEnum.sdkUnknown(rawValue)
        }
    }
}

extension PullRequestStatusRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PullRequestStatusRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A pull request status is required, but none was provided.
public struct PullRequestStatusRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullRequestStatusRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PullRequestStatusRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestStatusRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.PullRequestTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCommit
        case destinationReference
        case mergeBase
        case mergeMetadata
        case repositoryName
        case sourceCommit
        case sourceReference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommit = self.destinationCommit {
            try encodeContainer.encode(destinationCommit, forKey: .destinationCommit)
        }
        if let destinationReference = self.destinationReference {
            try encodeContainer.encode(destinationReference, forKey: .destinationReference)
        }
        if let mergeBase = self.mergeBase {
            try encodeContainer.encode(mergeBase, forKey: .mergeBase)
        }
        if let mergeMetadata = self.mergeMetadata {
            try encodeContainer.encode(mergeMetadata, forKey: .mergeMetadata)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommit = self.sourceCommit {
            try encodeContainer.encode(sourceCommit, forKey: .sourceCommit)
        }
        if let sourceReference = self.sourceReference {
            try encodeContainer.encode(sourceReference, forKey: .sourceReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceReference)
        sourceReference = sourceReferenceDecoded
        let destinationReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationReference)
        destinationReference = destinationReferenceDecoded
        let destinationCommitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommit)
        destinationCommit = destinationCommitDecoded
        let sourceCommitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommit)
        sourceCommit = sourceCommitDecoded
        let mergeBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergeBase)
        mergeBase = mergeBaseDecoded
        let mergeMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeMetadata.self, forKey: .mergeMetadata)
        mergeMetadata = mergeMetadataDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a pull request target.
    public struct PullRequestTarget: Swift.Equatable {
        /// The full commit ID that is the tip of the destination branch. This is the commit where the pull request was or will be merged.
        public var destinationCommit: Swift.String?
        /// The branch of the repository where the pull request changes are merged. Also known as the destination branch.
        public var destinationReference: Swift.String?
        /// The commit ID of the most recent commit that the source branch and the destination branch have in common.
        public var mergeBase: Swift.String?
        /// Returns metadata about the state of the merge, including whether the merge has been made.
        public var mergeMetadata: CodeCommitClientTypes.MergeMetadata?
        /// The name of the repository that contains the pull request source and destination branches.
        public var repositoryName: Swift.String?
        /// The full commit ID of the tip of the source branch used to create the pull request. If the pull request branch is updated by a push while the pull request is open, the commit ID changes to reflect the new tip of the branch.
        public var sourceCommit: Swift.String?
        /// The branch of the repository that contains the changes for the pull request. Also known as the source branch.
        public var sourceReference: Swift.String?

        public init(
            destinationCommit: Swift.String? = nil,
            destinationReference: Swift.String? = nil,
            mergeBase: Swift.String? = nil,
            mergeMetadata: CodeCommitClientTypes.MergeMetadata? = nil,
            repositoryName: Swift.String? = nil,
            sourceCommit: Swift.String? = nil,
            sourceReference: Swift.String? = nil
        )
        {
            self.destinationCommit = destinationCommit
            self.destinationReference = destinationReference
            self.mergeBase = mergeBase
            self.mergeMetadata = mergeMetadata
            self.repositoryName = repositoryName
            self.sourceCommit = sourceCommit
            self.sourceReference = sourceReference
        }
    }

}

extension PutCommentReactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case reactionValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let reactionValue = self.reactionValue {
            try encodeContainer.encode(reactionValue, forKey: .reactionValue)
        }
    }
}

extension PutCommentReactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutCommentReactionInput: Swift.Equatable {
    /// The ID of the comment to which you want to add or update a reaction.
    /// This member is required.
    public var commentId: Swift.String?
    /// The emoji reaction you want to add or update. To remove a reaction, provide a value of blank or null. You can also provide the value of none. For information about emoji reaction values supported in CodeCommit, see the [CodeCommit User Guide](https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-commit-comment.html#emoji-reaction-table).
    /// This member is required.
    public var reactionValue: Swift.String?

    public init(
        commentId: Swift.String? = nil,
        reactionValue: Swift.String? = nil
    )
    {
        self.commentId = commentId
        self.reactionValue = reactionValue
    }
}

struct PutCommentReactionInputBody: Swift.Equatable {
    let commentId: Swift.String?
    let reactionValue: Swift.String?
}

extension PutCommentReactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case reactionValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let reactionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reactionValue)
        reactionValue = reactionValueDecoded
    }
}

extension PutCommentReactionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutCommentReactionOutput: Swift.Equatable {

    public init() { }
}

enum PutCommentReactionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommentDeletedException": return try await CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentDoesNotExistException": return try await CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentIdRequiredException": return try await CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommentIdException": return try await InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidReactionValueException": return try await InvalidReactionValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReactionLimitExceededException": return try await ReactionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReactionValueRequiredException": return try await ReactionValueRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.PutFileEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileContent
        case fileMode
        case filePath
        case sourceFile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileContent = self.fileContent {
            try encodeContainer.encode(fileContent.base64EncodedString(), forKey: .fileContent)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let sourceFile = self.sourceFile {
            try encodeContainer.encode(sourceFile, forKey: .sourceFile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let fileContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .fileContent)
        fileContent = fileContentDecoded
        let sourceFileDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.SourceFileSpecifier.self, forKey: .sourceFile)
        sourceFile = sourceFileDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a file added or updated as part of a commit.
    public struct PutFileEntry: Swift.Equatable {
        /// The content of the file, if a source file is not specified.
        public var fileContent: ClientRuntime.Data?
        /// The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The full path to the file in the repository, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?
        /// The name and full path of the file that contains the changes you want to make as part of the commit, if you are not providing the file content directly.
        public var sourceFile: CodeCommitClientTypes.SourceFileSpecifier?

        public init(
            fileContent: ClientRuntime.Data? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            filePath: Swift.String? = nil,
            sourceFile: CodeCommitClientTypes.SourceFileSpecifier? = nil
        )
        {
            self.fileContent = fileContent
            self.fileMode = fileMode
            self.filePath = filePath
            self.sourceFile = sourceFile
        }
    }

}

extension PutFileEntryConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutFileEntryConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit cannot be created because one or more files specified in the commit reference both a file and a folder.
public struct PutFileEntryConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PutFileEntryConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PutFileEntryConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PutFileEntryConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutFileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitMessage
        case email
        case fileContent
        case fileMode
        case filePath
        case name
        case parentCommitId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let fileContent = self.fileContent {
            try encodeContainer.encode(fileContent.base64EncodedString(), forKey: .fileContent)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentCommitId = self.parentCommitId {
            try encodeContainer.encode(parentCommitId, forKey: .parentCommitId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PutFileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutFileInput: Swift.Equatable {
    /// The name of the branch where you want to add or update the file. If this is an empty repository, this branch is created.
    /// This member is required.
    public var branchName: Swift.String?
    /// A message about why this file was added or updated. Although it is optional, a message makes the commit history for your repository more useful.
    public var commitMessage: Swift.String?
    /// An email address for the person adding or updating the file.
    public var email: Swift.String?
    /// The content of the file, in binary object format.
    /// This member is required.
    public var fileContent: ClientRuntime.Data?
    /// The file mode permissions of the blob. Valid file mode permissions are listed here.
    public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
    /// The name of the file you want to add or update, including the relative path to the file in the repository. If the path does not currently exist in the repository, the path is created as part of adding the file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The name of the person adding or updating the file. Although it is optional, a name makes the commit history for your repository more useful.
    public var name: Swift.String?
    /// The full commit ID of the head commit in the branch where you want to add or update the file. If this is an empty repository, no commit ID is required. If this is not an empty repository, a commit ID is required. The commit ID must match the ID of the head commit at the time of the operation. Otherwise, an error occurs, and the file is not added or updated.
    public var parentCommitId: Swift.String?
    /// The name of the repository where you want to add or update the file.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        email: Swift.String? = nil,
        fileContent: ClientRuntime.Data? = nil,
        fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
        filePath: Swift.String? = nil,
        name: Swift.String? = nil,
        parentCommitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.email = email
        self.fileContent = fileContent
        self.fileMode = fileMode
        self.filePath = filePath
        self.name = name
        self.parentCommitId = parentCommitId
        self.repositoryName = repositoryName
    }
}

struct PutFileInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
    let fileContent: ClientRuntime.Data?
    let filePath: Swift.String?
    let fileMode: CodeCommitClientTypes.FileModeTypeEnum?
    let parentCommitId: Swift.String?
    let commitMessage: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
}

extension PutFileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitMessage
        case email
        case fileContent
        case fileMode
        case filePath
        case name
        case parentCommitId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let fileContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .fileContent)
        fileContent = fileContentDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let parentCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentCommitId)
        parentCommitId = parentCommitIdDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension PutFileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutFileOutputBody = try responseDecoder.decode(responseBody: data)
            self.blobId = output.blobId
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.blobId = nil
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct PutFileOutput: Swift.Equatable {
    /// The ID of the blob, which is its SHA-1 pointer.
    /// This member is required.
    public var blobId: Swift.String?
    /// The full SHA ID of the commit that contains this file change.
    /// This member is required.
    public var commitId: Swift.String?
    /// The full SHA-1 pointer of the tree information for the commit that contains this file change.
    /// This member is required.
    public var treeId: Swift.String?

    public init(
        blobId: Swift.String? = nil,
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct PutFileOutputBody: Swift.Equatable {
    let commitId: Swift.String?
    let blobId: Swift.String?
    let treeId: Swift.String?
}

extension PutFileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case commitId
        case treeId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

enum PutFileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BranchDoesNotExistException": return try await BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameIsTagNameException": return try await BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameRequiredException": return try await BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommitMessageLengthExceededException": return try await CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNameConflictsWithFileNameException": return try await DirectoryNameConflictsWithFileNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileContentRequiredException": return try await FileContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileContentSizeLimitExceededException": return try await FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileNameConflictsWithDirectoryNameException": return try await FileNameConflictsWithDirectoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FilePathConflictsWithSubmodulePathException": return try await FilePathConflictsWithSubmodulePathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FolderContentSizeLimitExceededException": return try await FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBranchNameException": return try await InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidDeletionParameterException": return try await InvalidDeletionParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEmailException": return try await InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFileModeException": return try await InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParentCommitIdException": return try await InvalidParentCommitIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPathException": return try await InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameLengthExceededException": return try await NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParentCommitDoesNotExistException": return try await ParentCommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParentCommitIdOutdatedException": return try await ParentCommitIdOutdatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ParentCommitIdRequiredException": return try await ParentCommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PathRequiredException": return try await PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SameFileContentException": return try await SameFileContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutRepositoryTriggersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case triggers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for repositorytrigger0 in triggers {
                try triggersContainer.encode(repositorytrigger0)
            }
        }
    }
}

extension PutRepositoryTriggersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a put repository triggers operation.
public struct PutRepositoryTriggersInput: Swift.Equatable {
    /// The name of the repository where you want to create or update the trigger.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The JSON block of configuration information for each trigger.
    /// This member is required.
    public var triggers: [CodeCommitClientTypes.RepositoryTrigger]?

    public init(
        repositoryName: Swift.String? = nil,
        triggers: [CodeCommitClientTypes.RepositoryTrigger]? = nil
    )
    {
        self.repositoryName = repositoryName
        self.triggers = triggers
    }
}

struct PutRepositoryTriggersInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let triggers: [CodeCommitClientTypes.RepositoryTrigger]?
}

extension PutRepositoryTriggersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case triggers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let triggersContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[CodeCommitClientTypes.RepositoryTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [CodeCommitClientTypes.RepositoryTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

extension PutRepositoryTriggersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutRepositoryTriggersOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
        } else {
            self.configurationId = nil
        }
    }
}

/// Represents the output of a put repository triggers operation.
public struct PutRepositoryTriggersOutput: Swift.Equatable {
    /// The system-generated unique ID for the create or update operation.
    public var configurationId: Swift.String?

    public init(
        configurationId: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

struct PutRepositoryTriggersOutputBody: Swift.Equatable {
    let configurationId: Swift.String?
}

extension PutRepositoryTriggersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
    }
}

enum PutRepositoryTriggersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerBranchNameException": return try await InvalidRepositoryTriggerBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerCustomDataException": return try await InvalidRepositoryTriggerCustomDataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerDestinationArnException": return try await InvalidRepositoryTriggerDestinationArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerEventsException": return try await InvalidRepositoryTriggerEventsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerNameException": return try await InvalidRepositoryTriggerNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerRegionException": return try await InvalidRepositoryTriggerRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumBranchesExceededException": return try await MaximumBranchesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumRepositoryTriggersExceededException": return try await MaximumRepositoryTriggersExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryTriggerBranchNameListRequiredException": return try await RepositoryTriggerBranchNameListRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryTriggerDestinationArnRequiredException": return try await RepositoryTriggerDestinationArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryTriggerEventsListRequiredException": return try await RepositoryTriggerEventsListRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryTriggerNameRequiredException": return try await RepositoryTriggerNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryTriggersListRequiredException": return try await RepositoryTriggersListRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.ReactionForComment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reaction
        case reactionUsers
        case reactionsFromDeletedUsersCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reaction = self.reaction {
            try encodeContainer.encode(reaction, forKey: .reaction)
        }
        if let reactionUsers = reactionUsers {
            var reactionUsersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reactionUsers)
            for arn0 in reactionUsers {
                try reactionUsersContainer.encode(arn0)
            }
        }
        if let reactionsFromDeletedUsersCount = self.reactionsFromDeletedUsersCount {
            try encodeContainer.encode(reactionsFromDeletedUsersCount, forKey: .reactionsFromDeletedUsersCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ReactionValueFormats.self, forKey: .reaction)
        reaction = reactionDecoded
        let reactionUsersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reactionUsers)
        var reactionUsersDecoded0:[Swift.String]? = nil
        if let reactionUsersContainer = reactionUsersContainer {
            reactionUsersDecoded0 = [Swift.String]()
            for string0 in reactionUsersContainer {
                if let string0 = string0 {
                    reactionUsersDecoded0?.append(string0)
                }
            }
        }
        reactionUsers = reactionUsersDecoded0
        let reactionsFromDeletedUsersCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reactionsFromDeletedUsersCount)
        reactionsFromDeletedUsersCount = reactionsFromDeletedUsersCountDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the reaction values provided by users on a comment.
    public struct ReactionForComment: Swift.Equatable {
        /// The reaction for a specified comment.
        public var reaction: CodeCommitClientTypes.ReactionValueFormats?
        /// The Amazon Resource Names (ARNs) of users who have provided reactions to the comment.
        public var reactionUsers: [Swift.String]?
        /// A numerical count of users who reacted with the specified emoji whose identities have been subsequently deleted from IAM. While these IAM users or roles no longer exist, the reactions might still appear in total reaction counts.
        public var reactionsFromDeletedUsersCount: Swift.Int?

        public init(
            reaction: CodeCommitClientTypes.ReactionValueFormats? = nil,
            reactionUsers: [Swift.String]? = nil,
            reactionsFromDeletedUsersCount: Swift.Int? = nil
        )
        {
            self.reaction = reaction
            self.reactionUsers = reactionUsers
            self.reactionsFromDeletedUsersCount = reactionsFromDeletedUsersCount
        }
    }

}

extension ReactionLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReactionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.
public struct ReactionLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReactionLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReactionLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReactionLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.ReactionValueFormats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emoji
        case shortCode
        case unicode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emoji = self.emoji {
            try encodeContainer.encode(emoji, forKey: .emoji)
        }
        if let shortCode = self.shortCode {
            try encodeContainer.encode(shortCode, forKey: .shortCode)
        }
        if let unicode = self.unicode {
            try encodeContainer.encode(unicode, forKey: .unicode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emojiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emoji)
        emoji = emojiDecoded
        let shortCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortCode)
        shortCode = shortCodeDecoded
        let unicodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unicode)
        unicode = unicodeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the values for reactions to a comment. CodeCommit supports a limited set of reactions.
    public struct ReactionValueFormats: Swift.Equatable {
        /// The Emoji Version 1.0 graphic of the reaction. These graphics are interpreted slightly differently on different operating systems.
        public var emoji: Swift.String?
        /// The emoji short code for the reaction. Short codes are interpreted slightly differently on different operating systems.
        public var shortCode: Swift.String?
        /// The Unicode codepoint for the reaction.
        public var unicode: Swift.String?

        public init(
            emoji: Swift.String? = nil,
            shortCode: Swift.String? = nil,
            unicode: Swift.String? = nil
        )
        {
            self.emoji = emoji
            self.shortCode = shortCode
            self.unicode = unicode
        }
    }

}

extension ReactionValueRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReactionValueRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A reaction value is required.
public struct ReactionValueRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReactionValueRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReactionValueRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReactionValueRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReferenceDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReferenceDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified reference does not exist. You must provide a full commit ID.
public struct ReferenceDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReferenceDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReferenceDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReferenceDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReferenceNameRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReferenceNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A reference name is required, but none was provided.
public struct ReferenceNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReferenceNameRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReferenceNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReferenceNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReferenceTypeNotSupportedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReferenceTypeNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified reference is not a supported type.
public struct ReferenceTypeNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReferenceTypeNotSupportedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReferenceTypeNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReferenceTypeNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum RelativeFileVersionEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case after
        case before
        case sdkUnknown(Swift.String)

        public static var allCases: [RelativeFileVersionEnum] {
            return [
                .after,
                .before,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .after: return "AFTER"
            case .before: return "BEFORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelativeFileVersionEnum(rawValue: rawValue) ?? RelativeFileVersionEnum.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.ReplaceContentEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case fileMode
        case filePath
        case replacementType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content.base64EncodedString(), forKey: .content)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let replacementType = self.replacementType {
            try encodeContainer.encode(replacementType.rawValue, forKey: .replacementType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let replacementTypeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ReplacementTypeEnum.self, forKey: .replacementType)
        replacementType = replacementTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a replacement content entry in the conflict of a merge or pull request operation.
    public struct ReplaceContentEntry: Swift.Equatable {
        /// The base-64 encoded content to use when the replacement type is USE_NEW_CONTENT.
        public var content: ClientRuntime.Data?
        /// The file mode to apply during conflict resoltion.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The path of the conflicting file.
        /// This member is required.
        public var filePath: Swift.String?
        /// The replacement type to use when determining how to resolve the conflict.
        /// This member is required.
        public var replacementType: CodeCommitClientTypes.ReplacementTypeEnum?

        public init(
            content: ClientRuntime.Data? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            filePath: Swift.String? = nil,
            replacementType: CodeCommitClientTypes.ReplacementTypeEnum? = nil
        )
        {
            self.content = content
            self.fileMode = fileMode
            self.filePath = filePath
            self.replacementType = replacementType
        }
    }

}

extension ReplacementContentRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReplacementContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// USE_NEW_CONTENT was specified, but no replacement content has been provided.
public struct ReplacementContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplacementContentRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReplacementContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReplacementContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum ReplacementTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case keepBase
        case keepDestination
        case keepSource
        case useNewContent
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplacementTypeEnum] {
            return [
                .keepBase,
                .keepDestination,
                .keepSource,
                .useNewContent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .keepBase: return "KEEP_BASE"
            case .keepDestination: return "KEEP_DESTINATION"
            case .keepSource: return "KEEP_SOURCE"
            case .useNewContent: return "USE_NEW_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplacementTypeEnum(rawValue: rawValue) ?? ReplacementTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension ReplacementTypeRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReplacementTypeRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A replacement type is required.
public struct ReplacementTypeRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplacementTypeRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReplacementTypeRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReplacementTypeRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified repository does not exist.
public struct RepositoryDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A repository resource limit was exceeded.
public struct RepositoryLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.RepositoryMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case accountId
        case cloneUrlHttp
        case cloneUrlSsh
        case creationDate
        case defaultBranch
        case lastModifiedDate
        case repositoryDescription
        case repositoryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let cloneUrlHttp = self.cloneUrlHttp {
            try encodeContainer.encode(cloneUrlHttp, forKey: .cloneUrlHttp)
        }
        if let cloneUrlSsh = self.cloneUrlSsh {
            try encodeContainer.encode(cloneUrlSsh, forKey: .cloneUrlSsh)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let defaultBranch = self.defaultBranch {
            try encodeContainer.encode(defaultBranch, forKey: .defaultBranch)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let repositoryDescription = self.repositoryDescription {
            try encodeContainer.encode(repositoryDescription, forKey: .repositoryDescription)
        }
        if let repositoryId = self.repositoryId {
            try encodeContainer.encode(repositoryId, forKey: .repositoryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let repositoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryDescription)
        repositoryDescription = repositoryDescriptionDecoded
        let defaultBranchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultBranch)
        defaultBranch = defaultBranchDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let cloneUrlHttpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloneUrlHttp)
        cloneUrlHttp = cloneUrlHttpDecoded
        let cloneUrlSshDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloneUrlSsh)
        cloneUrlSsh = cloneUrlSshDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a repository.
    public struct RepositoryMetadata: Swift.Equatable {
        /// The ID of the Amazon Web Services account associated with the repository.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the repository.
        public var arn: Swift.String?
        /// The URL to use for cloning the repository over HTTPS.
        public var cloneUrlHttp: Swift.String?
        /// The URL to use for cloning the repository over SSH.
        public var cloneUrlSsh: Swift.String?
        /// The date and time the repository was created, in timestamp format.
        public var creationDate: ClientRuntime.Date?
        /// The repository's default branch name.
        public var defaultBranch: Swift.String?
        /// The date and time the repository was last modified, in timestamp format.
        public var lastModifiedDate: ClientRuntime.Date?
        /// A comment or description about the repository.
        public var repositoryDescription: Swift.String?
        /// The ID of the repository.
        public var repositoryId: Swift.String?
        /// The repository's name.
        public var repositoryName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            cloneUrlHttp: Swift.String? = nil,
            cloneUrlSsh: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            defaultBranch: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            repositoryDescription: Swift.String? = nil,
            repositoryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.cloneUrlHttp = cloneUrlHttp
            self.cloneUrlSsh = cloneUrlSsh
            self.creationDate = creationDate
            self.defaultBranch = defaultBranch
            self.lastModifiedDate = lastModifiedDate
            self.repositoryDescription = repositoryDescription
            self.repositoryId = repositoryId
            self.repositoryName = repositoryName
        }
    }

}

extension RepositoryNameExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryNameExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified repository name already exists.
public struct RepositoryNameExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryNameExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryNameExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNameExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.RepositoryNameIdPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryId = self.repositoryId {
            try encodeContainer.encode(repositoryId, forKey: .repositoryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a repository name and ID.
    public struct RepositoryNameIdPair: Swift.Equatable {
        /// The ID associated with the repository.
        public var repositoryId: Swift.String?
        /// The name associated with the repository.
        public var repositoryName: Swift.String?

        public init(
            repositoryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.repositoryId = repositoryId
            self.repositoryName = repositoryName
        }
    }

}

extension RepositoryNameRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A repository name is required, but was not specified.
public struct RepositoryNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryNameRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNamesRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryNamesRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// At least one repository name object is required, but was not specified.
public struct RepositoryNamesRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryNamesRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryNamesRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNamesRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotAssociatedWithPullRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryNotAssociatedWithPullRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.
public struct RepositoryNotAssociatedWithPullRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryNotAssociatedWithPullRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryNotAssociatedWithPullRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNotAssociatedWithPullRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.RepositoryTrigger: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branches
        case customData
        case destinationArn
        case events
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branches = branches {
            var branchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .branches)
            for branchname0 in branches {
                try branchesContainer.encode(branchname0)
            }
        }
        if let customData = self.customData {
            try encodeContainer.encode(customData, forKey: .customData)
        }
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for repositorytriggereventenum0 in events {
                try eventsContainer.encode(repositorytriggereventenum0.rawValue)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let customDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customData)
        customData = customDataDecoded
        let branchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .branches)
        var branchesDecoded0:[Swift.String]? = nil
        if let branchesContainer = branchesContainer {
            branchesDecoded0 = [Swift.String]()
            for string0 in branchesContainer {
                if let string0 = string0 {
                    branchesDecoded0?.append(string0)
                }
            }
        }
        branches = branchesDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryTriggerEventEnum?].self, forKey: .events)
        var eventsDecoded0:[CodeCommitClientTypes.RepositoryTriggerEventEnum]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [CodeCommitClientTypes.RepositoryTriggerEventEnum]()
            for enum0 in eventsContainer {
                if let enum0 = enum0 {
                    eventsDecoded0?.append(enum0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Information about a trigger for a repository. If you want to receive notifications about repository events, consider using notifications instead of triggers. For more information, see [Configuring notifications for repository events](https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-repository-email.html).
    public struct RepositoryTrigger: Swift.Equatable {
        /// The branches to be included in the trigger configuration. If you specify an empty array, the trigger applies to all branches. Although no content is required in the array, you must include the array itself.
        public var branches: [Swift.String]?
        /// Any custom data associated with the trigger to be included in the information sent to the target of the trigger.
        public var customData: Swift.String?
        /// The ARN of the resource that is the target for a trigger (for example, the ARN of a topic in Amazon SNS).
        /// This member is required.
        public var destinationArn: Swift.String?
        /// The repository events that cause the trigger to run actions in another service, such as sending a notification through Amazon SNS. The valid value "all" cannot be used with any other values.
        /// This member is required.
        public var events: [CodeCommitClientTypes.RepositoryTriggerEventEnum]?
        /// The name of the trigger.
        /// This member is required.
        public var name: Swift.String?

        public init(
            branches: [Swift.String]? = nil,
            customData: Swift.String? = nil,
            destinationArn: Swift.String? = nil,
            events: [CodeCommitClientTypes.RepositoryTriggerEventEnum]? = nil,
            name: Swift.String? = nil
        )
        {
            self.branches = branches
            self.customData = customData
            self.destinationArn = destinationArn
            self.events = events
            self.name = name
        }
    }

}

extension RepositoryTriggerBranchNameListRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryTriggerBranchNameListRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// At least one branch name is required, but was not specified in the trigger configuration.
public struct RepositoryTriggerBranchNameListRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryTriggerBranchNameListRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryTriggerBranchNameListRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryTriggerBranchNameListRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryTriggerDestinationArnRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryTriggerDestinationArnRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A destination ARN for the target service for the trigger is required, but was not specified.
public struct RepositoryTriggerDestinationArnRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryTriggerDestinationArnRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryTriggerDestinationArnRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryTriggerDestinationArnRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum RepositoryTriggerEventEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case createReference
        case deleteReference
        case updateReference
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositoryTriggerEventEnum] {
            return [
                .all,
                .createReference,
                .deleteReference,
                .updateReference,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .createReference: return "createReference"
            case .deleteReference: return "deleteReference"
            case .updateReference: return "updateReference"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositoryTriggerEventEnum(rawValue: rawValue) ?? RepositoryTriggerEventEnum.sdkUnknown(rawValue)
        }
    }
}

extension RepositoryTriggerEventsListRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryTriggerEventsListRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// At least one event for the trigger is required, but was not specified.
public struct RepositoryTriggerEventsListRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryTriggerEventsListRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryTriggerEventsListRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryTriggerEventsListRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.RepositoryTriggerExecutionFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureMessage
        case trigger
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let trigger = self.trigger {
            try encodeContainer.encode(trigger, forKey: .trigger)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trigger)
        trigger = triggerDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension CodeCommitClientTypes {
    /// A trigger failed to run.
    public struct RepositoryTriggerExecutionFailure: Swift.Equatable {
        /// Message information about the trigger that did not run.
        public var failureMessage: Swift.String?
        /// The name of the trigger that did not run.
        public var trigger: Swift.String?

        public init(
            failureMessage: Swift.String? = nil,
            trigger: Swift.String? = nil
        )
        {
            self.failureMessage = failureMessage
            self.trigger = trigger
        }
    }

}

extension RepositoryTriggerNameRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryTriggerNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A name for the trigger is required, but was not specified.
public struct RepositoryTriggerNameRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryTriggerNameRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryTriggerNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryTriggerNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryTriggersListRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryTriggersListRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The list of triggers for the repository is required, but was not specified.
public struct RepositoryTriggersListRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryTriggersListRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryTriggersListRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryTriggersListRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceArnRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceArnRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A valid Amazon Resource Name (ARN) for an CodeCommit resource is required. For a list of valid resources in CodeCommit, see [CodeCommit Resources and Operations](https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats) in the CodeCommit User Guide.
public struct ResourceArnRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceArnRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceArnRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceArnRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestrictedSourceFileException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestrictedSourceFileExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.
public struct RestrictedSourceFileException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RestrictedSourceFileException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RestrictedSourceFileExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RestrictedSourceFileExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RevisionIdRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RevisionIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A revision ID is required, but was not provided.
public struct RevisionIdRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RevisionIdRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RevisionIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RevisionIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RevisionNotCurrentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RevisionNotCurrentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.
public struct RevisionNotCurrentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RevisionNotCurrentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RevisionNotCurrentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RevisionNotCurrentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SameFileContentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SameFileContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch that you specified.
public struct SameFileContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SameFileContentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SameFileContentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SameFileContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SamePathRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SamePathRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example, you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same file as part of the same commit.
public struct SamePathRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SamePathRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SamePathRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SamePathRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.SetFileModeEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileMode
        case filePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the file mode changes.
    public struct SetFileModeEntry: Swift.Equatable {
        /// The file mode for the file.
        /// This member is required.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The full path to the file, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?

        public init(
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            filePath: Swift.String? = nil
        )
        {
            self.fileMode = fileMode
            self.filePath = filePath
        }
    }

}

extension CodeCommitClientTypes {
    public enum SortByEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case modifiedDate
        case repositoryName
        case sdkUnknown(Swift.String)

        public static var allCases: [SortByEnum] {
            return [
                .modifiedDate,
                .repositoryName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .modifiedDate: return "lastModifiedDate"
            case .repositoryName: return "repositoryName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortByEnum(rawValue: rawValue) ?? SortByEnum.sdkUnknown(rawValue)
        }
    }
}

extension SourceAndDestinationAreSameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SourceAndDestinationAreSameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The source branch and destination branch for the pull request are the same. You must specify different branches for the source and destination.
public struct SourceAndDestinationAreSameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SourceAndDestinationAreSameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SourceAndDestinationAreSameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SourceAndDestinationAreSameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceFileOrContentRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SourceFileOrContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The commit cannot be created because no source files or file content have been specified for the commit.
public struct SourceFileOrContentRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SourceFileOrContentRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SourceFileOrContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SourceFileOrContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.SourceFileSpecifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePath
        case isMove
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if isMove != false {
            try encodeContainer.encode(isMove, forKey: .isMove)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let isMoveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMove) ?? false
        isMove = isMoveDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a source file that is part of changes made in a commit.
    public struct SourceFileSpecifier: Swift.Equatable {
        /// The full path to the file, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?
        /// Whether to remove the source file from the parent commit.
        public var isMove: Swift.Bool

        public init(
            filePath: Swift.String? = nil,
            isMove: Swift.Bool = false
        )
        {
            self.filePath = filePath
            self.isMove = isMove
        }
    }

}

extension CodeCommitClientTypes.SubModule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutePath
        case commitId
        case relativePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = self.absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let relativePath = self.relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a submodule reference in a repository folder.
    public struct SubModule: Swift.Equatable {
        /// The fully qualified path to the folder that contains the reference to the submodule.
        public var absolutePath: Swift.String?
        /// The commit ID that contains the reference to the submodule.
        public var commitId: Swift.String?
        /// The relative path of the submodule from the folder where the query originated.
        public var relativePath: Swift.String?

        public init(
            absolutePath: Swift.String? = nil,
            commitId: Swift.String? = nil,
            relativePath: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.commitId = commitId
            self.relativePath = relativePath
        }
    }

}

extension CodeCommitClientTypes.SymbolicLink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutePath
        case blobId
        case fileMode
        case relativePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = self.absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let relativePath = self.relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a symbolic link in a repository folder.
    public struct SymbolicLink: Swift.Equatable {
        /// The fully qualified path to the folder that contains the symbolic link.
        public var absolutePath: Swift.String?
        /// The blob ID that contains the information about the symbolic link.
        public var blobId: Swift.String?
        /// The file mode permissions of the blob that cotains information about the symbolic link.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The relative path of the symbolic link from the folder where the query originated.
        public var relativePath: Swift.String?

        public init(
            absolutePath: Swift.String? = nil,
            blobId: Swift.String? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            relativePath: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.blobId = blobId
            self.fileMode = fileMode
            self.relativePath = relativePath
        }
    }

}

extension TagKeysListRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagKeysListRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A list of tag keys is required. The list cannot be empty or null.
public struct TagKeysListRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagKeysListRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagKeysListRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagKeysListRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The tag policy is not valid.
public struct TagPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which you want to add or update tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair to use when tagging this repository.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceArnException": return try await InvalidResourceArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSystemTagUsageException": return try await InvalidSystemTagUsageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagsMapException": return try await InvalidTagsMapException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceArnRequiredException": return try await ResourceArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagPolicyException": return try await TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagsMapRequiredException": return try await TagsMapRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagsMapRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagsMapRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A map of tags is required.
public struct TagsMapRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagsMapRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagsMapRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagsMapRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.Target: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationReference
        case repositoryName
        case sourceReference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationReference = self.destinationReference {
            try encodeContainer.encode(destinationReference, forKey: .destinationReference)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceReference = self.sourceReference {
            try encodeContainer.encode(sourceReference, forKey: .sourceReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceReference)
        sourceReference = sourceReferenceDecoded
        let destinationReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationReference)
        destinationReference = destinationReferenceDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a target for a pull request.
    public struct Target: Swift.Equatable {
        /// The branch of the repository where the pull request changes are merged. Also known as the destination branch.
        public var destinationReference: Swift.String?
        /// The name of the repository that contains the pull request.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// The branch of the repository that contains the changes for the pull request. Also known as the source branch.
        /// This member is required.
        public var sourceReference: Swift.String?

        public init(
            destinationReference: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            sourceReference: Swift.String? = nil
        )
        {
            self.destinationReference = destinationReference
            self.repositoryName = repositoryName
            self.sourceReference = sourceReference
        }
    }

}

extension TargetRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TargetRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.
public struct TargetRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TargetRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TargetRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TargetRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TargetsRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TargetsRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An array of target objects is required. It cannot be empty or null.
public struct TargetsRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TargetsRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TargetsRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TargetsRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TestRepositoryTriggersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case triggers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for repositorytrigger0 in triggers {
                try triggersContainer.encode(repositorytrigger0)
            }
        }
    }
}

extension TestRepositoryTriggersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a test repository triggers operation.
public struct TestRepositoryTriggersInput: Swift.Equatable {
    /// The name of the repository in which to test the triggers.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The list of triggers to test.
    /// This member is required.
    public var triggers: [CodeCommitClientTypes.RepositoryTrigger]?

    public init(
        repositoryName: Swift.String? = nil,
        triggers: [CodeCommitClientTypes.RepositoryTrigger]? = nil
    )
    {
        self.repositoryName = repositoryName
        self.triggers = triggers
    }
}

struct TestRepositoryTriggersInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let triggers: [CodeCommitClientTypes.RepositoryTrigger]?
}

extension TestRepositoryTriggersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case triggers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let triggersContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[CodeCommitClientTypes.RepositoryTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [CodeCommitClientTypes.RepositoryTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

extension TestRepositoryTriggersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestRepositoryTriggersOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedExecutions = output.failedExecutions
            self.successfulExecutions = output.successfulExecutions
        } else {
            self.failedExecutions = nil
            self.successfulExecutions = nil
        }
    }
}

/// Represents the output of a test repository triggers operation.
public struct TestRepositoryTriggersOutput: Swift.Equatable {
    /// The list of triggers that were not tested. This list provides the names of the triggers that could not be tested, separated by commas.
    public var failedExecutions: [CodeCommitClientTypes.RepositoryTriggerExecutionFailure]?
    /// The list of triggers that were successfully tested. This list provides the names of the triggers that were successfully tested, separated by commas.
    public var successfulExecutions: [Swift.String]?

    public init(
        failedExecutions: [CodeCommitClientTypes.RepositoryTriggerExecutionFailure]? = nil,
        successfulExecutions: [Swift.String]? = nil
    )
    {
        self.failedExecutions = failedExecutions
        self.successfulExecutions = successfulExecutions
    }
}

struct TestRepositoryTriggersOutputBody: Swift.Equatable {
    let successfulExecutions: [Swift.String]?
    let failedExecutions: [CodeCommitClientTypes.RepositoryTriggerExecutionFailure]?
}

extension TestRepositoryTriggersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedExecutions
        case successfulExecutions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulExecutionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .successfulExecutions)
        var successfulExecutionsDecoded0:[Swift.String]? = nil
        if let successfulExecutionsContainer = successfulExecutionsContainer {
            successfulExecutionsDecoded0 = [Swift.String]()
            for string0 in successfulExecutionsContainer {
                if let string0 = string0 {
                    successfulExecutionsDecoded0?.append(string0)
                }
            }
        }
        successfulExecutions = successfulExecutionsDecoded0
        let failedExecutionsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryTriggerExecutionFailure?].self, forKey: .failedExecutions)
        var failedExecutionsDecoded0:[CodeCommitClientTypes.RepositoryTriggerExecutionFailure]? = nil
        if let failedExecutionsContainer = failedExecutionsContainer {
            failedExecutionsDecoded0 = [CodeCommitClientTypes.RepositoryTriggerExecutionFailure]()
            for structure0 in failedExecutionsContainer {
                if let structure0 = structure0 {
                    failedExecutionsDecoded0?.append(structure0)
                }
            }
        }
        failedExecutions = failedExecutionsDecoded0
    }
}

enum TestRepositoryTriggersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerBranchNameException": return try await InvalidRepositoryTriggerBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerCustomDataException": return try await InvalidRepositoryTriggerCustomDataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerDestinationArnException": return try await InvalidRepositoryTriggerDestinationArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerEventsException": return try await InvalidRepositoryTriggerEventsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerNameException": return try await InvalidRepositoryTriggerNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryTriggerRegionException": return try await InvalidRepositoryTriggerRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumBranchesExceededException": return try await MaximumBranchesExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumRepositoryTriggersExceededException": return try await MaximumRepositoryTriggersExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryTriggerBranchNameListRequiredException": return try await RepositoryTriggerBranchNameListRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryTriggerDestinationArnRequiredException": return try await RepositoryTriggerDestinationArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryTriggerEventsListRequiredException": return try await RepositoryTriggerEventsListRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryTriggerNameRequiredException": return try await RepositoryTriggerNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryTriggersListRequiredException": return try await RepositoryTriggersListRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TipOfSourceReferenceIsDifferentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TipOfSourceReferenceIsDifferentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.
public struct TipOfSourceReferenceIsDifferentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TipOfSourceReferenceIsDifferentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TipOfSourceReferenceIsDifferentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TipOfSourceReferenceIsDifferentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TipsDivergenceExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TipsDivergenceExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using git diff or a diff tool.
public struct TipsDivergenceExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TipsDivergenceExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TipsDivergenceExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TipsDivergenceExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TitleRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TitleRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A pull request title is required. It cannot be empty or null.
public struct TitleRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TitleRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TitleRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TitleRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of tags for an CodeCommit resource has been exceeded.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which you want to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key for each tag that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceArnException": return try await InvalidResourceArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSystemTagUsageException": return try await InvalidSystemTagUsageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagKeysListException": return try await InvalidTagKeysListException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceArnRequiredException": return try await ResourceArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagKeysListRequiredException": return try await TagKeysListRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagPolicyException": return try await TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApprovalRuleTemplateContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case existingRuleContentSha256
        case newRuleContent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let existingRuleContentSha256 = self.existingRuleContentSha256 {
            try encodeContainer.encode(existingRuleContentSha256, forKey: .existingRuleContentSha256)
        }
        if let newRuleContent = self.newRuleContent {
            try encodeContainer.encode(newRuleContent, forKey: .newRuleContent)
        }
    }
}

extension UpdateApprovalRuleTemplateContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApprovalRuleTemplateContentInput: Swift.Equatable {
    /// The name of the approval rule template where you want to update the content of the rule.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The SHA-256 hash signature for the content of the approval rule. You can retrieve this information by using [GetPullRequest].
    public var existingRuleContentSha256: Swift.String?
    /// The content that replaces the existing content of the rule. Content statements must be complete. You cannot provide only the changes.
    /// This member is required.
    public var newRuleContent: Swift.String?

    public init(
        approvalRuleTemplateName: Swift.String? = nil,
        existingRuleContentSha256: Swift.String? = nil,
        newRuleContent: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.existingRuleContentSha256 = existingRuleContentSha256
        self.newRuleContent = newRuleContent
    }
}

struct UpdateApprovalRuleTemplateContentInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let newRuleContent: Swift.String?
    let existingRuleContentSha256: Swift.String?
}

extension UpdateApprovalRuleTemplateContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case existingRuleContentSha256
        case newRuleContent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let newRuleContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newRuleContent)
        newRuleContent = newRuleContentDecoded
        let existingRuleContentSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingRuleContentSha256)
        existingRuleContentSha256 = existingRuleContentSha256Decoded
    }
}

extension UpdateApprovalRuleTemplateContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApprovalRuleTemplateContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct UpdateApprovalRuleTemplateContentOutput: Swift.Equatable {
    /// Returns information about an approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init(
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct UpdateApprovalRuleTemplateContentOutputBody: Swift.Equatable {
    let approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?
}

extension UpdateApprovalRuleTemplateContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

enum UpdateApprovalRuleTemplateContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateContentRequiredException": return try await ApprovalRuleTemplateContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateDoesNotExistException": return try await ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateContentException": return try await InvalidApprovalRuleTemplateContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRuleContentSha256Exception": return try await InvalidRuleContentSha256Exception(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApprovalRuleTemplateDescriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateDescription = self.approvalRuleTemplateDescription {
            try encodeContainer.encode(approvalRuleTemplateDescription, forKey: .approvalRuleTemplateDescription)
        }
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

extension UpdateApprovalRuleTemplateDescriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApprovalRuleTemplateDescriptionInput: Swift.Equatable {
    /// The updated description of the approval rule template.
    /// This member is required.
    public var approvalRuleTemplateDescription: Swift.String?
    /// The name of the template for which you want to update the description.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init(
        approvalRuleTemplateDescription: Swift.String? = nil,
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct UpdateApprovalRuleTemplateDescriptionInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let approvalRuleTemplateDescription: Swift.String?
}

extension UpdateApprovalRuleTemplateDescriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let approvalRuleTemplateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateDescription)
        approvalRuleTemplateDescription = approvalRuleTemplateDescriptionDecoded
    }
}

extension UpdateApprovalRuleTemplateDescriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApprovalRuleTemplateDescriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct UpdateApprovalRuleTemplateDescriptionOutput: Swift.Equatable {
    /// The structure and content of the updated approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init(
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct UpdateApprovalRuleTemplateDescriptionOutputBody: Swift.Equatable {
    let approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?
}

extension UpdateApprovalRuleTemplateDescriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

enum UpdateApprovalRuleTemplateDescriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateDoesNotExistException": return try await ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateDescriptionException": return try await InvalidApprovalRuleTemplateDescriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApprovalRuleTemplateNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newApprovalRuleTemplateName
        case oldApprovalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newApprovalRuleTemplateName = self.newApprovalRuleTemplateName {
            try encodeContainer.encode(newApprovalRuleTemplateName, forKey: .newApprovalRuleTemplateName)
        }
        if let oldApprovalRuleTemplateName = self.oldApprovalRuleTemplateName {
            try encodeContainer.encode(oldApprovalRuleTemplateName, forKey: .oldApprovalRuleTemplateName)
        }
    }
}

extension UpdateApprovalRuleTemplateNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApprovalRuleTemplateNameInput: Swift.Equatable {
    /// The new name you want to apply to the approval rule template.
    /// This member is required.
    public var newApprovalRuleTemplateName: Swift.String?
    /// The current name of the approval rule template.
    /// This member is required.
    public var oldApprovalRuleTemplateName: Swift.String?

    public init(
        newApprovalRuleTemplateName: Swift.String? = nil,
        oldApprovalRuleTemplateName: Swift.String? = nil
    )
    {
        self.newApprovalRuleTemplateName = newApprovalRuleTemplateName
        self.oldApprovalRuleTemplateName = oldApprovalRuleTemplateName
    }
}

struct UpdateApprovalRuleTemplateNameInputBody: Swift.Equatable {
    let oldApprovalRuleTemplateName: Swift.String?
    let newApprovalRuleTemplateName: Swift.String?
}

extension UpdateApprovalRuleTemplateNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newApprovalRuleTemplateName
        case oldApprovalRuleTemplateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oldApprovalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oldApprovalRuleTemplateName)
        oldApprovalRuleTemplateName = oldApprovalRuleTemplateNameDecoded
        let newApprovalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newApprovalRuleTemplateName)
        newApprovalRuleTemplateName = newApprovalRuleTemplateNameDecoded
    }
}

extension UpdateApprovalRuleTemplateNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApprovalRuleTemplateNameOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct UpdateApprovalRuleTemplateNameOutput: Swift.Equatable {
    /// The structure and content of the updated approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init(
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct UpdateApprovalRuleTemplateNameOutputBody: Swift.Equatable {
    let approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?
}

extension UpdateApprovalRuleTemplateNameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

enum UpdateApprovalRuleTemplateNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleTemplateDoesNotExistException": return try await ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameAlreadyExistsException": return try await ApprovalRuleTemplateNameAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleTemplateNameRequiredException": return try await ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleTemplateNameException": return try await InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCommentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case content
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

extension UpdateCommentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCommentInput: Swift.Equatable {
    /// The system-generated ID of the comment you want to update. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var commentId: Swift.String?
    /// The updated content to replace the existing content of the comment.
    /// This member is required.
    public var content: Swift.String?

    public init(
        commentId: Swift.String? = nil,
        content: Swift.String? = nil
    )
    {
        self.commentId = commentId
        self.content = content
    }
}

struct UpdateCommentInputBody: Swift.Equatable {
    let commentId: Swift.String?
    let content: Swift.String?
}

extension UpdateCommentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case content
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateCommentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCommentOutputBody = try responseDecoder.decode(responseBody: data)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct UpdateCommentOutput: Swift.Equatable {
    /// Information about the updated comment.
    public var comment: CodeCommitClientTypes.Comment?

    public init(
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct UpdateCommentOutputBody: Swift.Equatable {
    let comment: CodeCommitClientTypes.Comment?
}

extension UpdateCommentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

enum UpdateCommentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CommentContentRequiredException": return try await CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentContentSizeLimitExceededException": return try await CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentDeletedException": return try await CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentDoesNotExistException": return try await CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentIdRequiredException": return try await CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CommentNotCreatedByCallerException": return try await CommentNotCreatedByCallerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCommentIdException": return try await InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDefaultBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultBranchName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultBranchName = self.defaultBranchName {
            try encodeContainer.encode(defaultBranchName, forKey: .defaultBranchName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension UpdateDefaultBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of an update default branch operation.
public struct UpdateDefaultBranchInput: Swift.Equatable {
    /// The name of the branch to set as the default branch.
    /// This member is required.
    public var defaultBranchName: Swift.String?
    /// The name of the repository for which you want to set or change the default branch.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        defaultBranchName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.defaultBranchName = defaultBranchName
        self.repositoryName = repositoryName
    }
}

struct UpdateDefaultBranchInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let defaultBranchName: Swift.String?
}

extension UpdateDefaultBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultBranchName
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let defaultBranchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultBranchName)
        defaultBranchName = defaultBranchNameDecoded
    }
}

extension UpdateDefaultBranchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDefaultBranchOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDefaultBranchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BranchDoesNotExistException": return try await BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BranchNameRequiredException": return try await BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidBranchNameException": return try await InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePullRequestApprovalRuleContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleName
        case existingRuleContentSha256
        case newRuleContent
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleName = self.approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let existingRuleContentSha256 = self.existingRuleContentSha256 {
            try encodeContainer.encode(existingRuleContentSha256, forKey: .existingRuleContentSha256)
        }
        if let newRuleContent = self.newRuleContent {
            try encodeContainer.encode(newRuleContent, forKey: .newRuleContent)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension UpdatePullRequestApprovalRuleContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePullRequestApprovalRuleContentInput: Swift.Equatable {
    /// The name of the approval rule you want to update.
    /// This member is required.
    public var approvalRuleName: Swift.String?
    /// The SHA-256 hash signature for the content of the approval rule. You can retrieve this information by using [GetPullRequest].
    public var existingRuleContentSha256: Swift.String?
    /// The updated content for the approval rule. When you update the content of the approval rule, you can specify approvers in an approval pool in one of two ways:
    ///
    /// * CodeCommitApprovers: This option only requires an Amazon Web Services account and a resource. It can be used for both IAM users and federated access users whose name matches the provided resource name. This is a very powerful option that offers a great deal of flexibility. For example, if you specify the Amazon Web Services account 123456789012 and Mary_Major, all of the following are counted as approvals coming from that user:
    ///
    /// * An IAM user in the account (arn:aws:iam::123456789012:user/Mary_Major)
    ///
    /// * A federated user identified in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
    ///
    ///
    /// This option does not recognize an active session of someone assuming the role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major) unless you include a wildcard (*Mary_Major).
    ///
    /// * Fully qualified ARN: This option allows you to specify the fully qualified Amazon Resource Name (ARN) of the IAM user or role.
    ///
    ///
    /// For more information about IAM ARNs, wildcards, and formats, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var newRuleContent: Swift.String?
    /// The system-generated ID of the pull request.
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        approvalRuleName: Swift.String? = nil,
        existingRuleContentSha256: Swift.String? = nil,
        newRuleContent: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.approvalRuleName = approvalRuleName
        self.existingRuleContentSha256 = existingRuleContentSha256
        self.newRuleContent = newRuleContent
        self.pullRequestId = pullRequestId
    }
}

struct UpdatePullRequestApprovalRuleContentInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let approvalRuleName: Swift.String?
    let existingRuleContentSha256: Swift.String?
    let newRuleContent: Swift.String?
}

extension UpdatePullRequestApprovalRuleContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleName
        case existingRuleContentSha256
        case newRuleContent
        case pullRequestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let existingRuleContentSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingRuleContentSha256)
        existingRuleContentSha256 = existingRuleContentSha256Decoded
        let newRuleContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newRuleContent)
        newRuleContent = newRuleContentDecoded
    }
}

extension UpdatePullRequestApprovalRuleContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePullRequestApprovalRuleContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.approvalRule = output.approvalRule
        } else {
            self.approvalRule = nil
        }
    }
}

public struct UpdatePullRequestApprovalRuleContentOutput: Swift.Equatable {
    /// Information about the updated approval rule.
    /// This member is required.
    public var approvalRule: CodeCommitClientTypes.ApprovalRule?

    public init(
        approvalRule: CodeCommitClientTypes.ApprovalRule? = nil
    )
    {
        self.approvalRule = approvalRule
    }
}

struct UpdatePullRequestApprovalRuleContentOutputBody: Swift.Equatable {
    let approvalRule: CodeCommitClientTypes.ApprovalRule?
}

extension UpdatePullRequestApprovalRuleContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRule.self, forKey: .approvalRule)
        approvalRule = approvalRuleDecoded
    }
}

enum UpdatePullRequestApprovalRuleContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalRuleContentRequiredException": return try await ApprovalRuleContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleDoesNotExistException": return try await ApprovalRuleDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApprovalRuleNameRequiredException": return try await ApprovalRuleNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CannotModifyApprovalRuleFromTemplateException": return try await CannotModifyApprovalRuleFromTemplateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleContentException": return try await InvalidApprovalRuleContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalRuleNameException": return try await InvalidApprovalRuleNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRuleContentSha256Exception": return try await InvalidRuleContentSha256Exception(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestAlreadyClosedException": return try await PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePullRequestApprovalStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalState
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalState = self.approvalState {
            try encodeContainer.encode(approvalState.rawValue, forKey: .approvalState)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension UpdatePullRequestApprovalStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePullRequestApprovalStateInput: Swift.Equatable {
    /// The approval state to associate with the user on the pull request.
    /// This member is required.
    public var approvalState: CodeCommitClientTypes.ApprovalState?
    /// The system-generated ID of the pull request.
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID of the revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        approvalState: CodeCommitClientTypes.ApprovalState? = nil,
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.approvalState = approvalState
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct UpdatePullRequestApprovalStateInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let revisionId: Swift.String?
    let approvalState: CodeCommitClientTypes.ApprovalState?
}

extension UpdatePullRequestApprovalStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalState
        case pullRequestId
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let approvalStateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalState.self, forKey: .approvalState)
        approvalState = approvalStateDecoded
    }
}

extension UpdatePullRequestApprovalStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePullRequestApprovalStateOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePullRequestApprovalStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApprovalStateRequiredException": return try await ApprovalStateRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidApprovalStateException": return try await InvalidApprovalStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRevisionIdException": return try await InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumNumberOfApprovalsExceededException": return try await MaximumNumberOfApprovalsExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestAlreadyClosedException": return try await PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestCannotBeApprovedByAuthorException": return try await PullRequestCannotBeApprovedByAuthorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RevisionIdRequiredException": return try await RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RevisionNotCurrentException": return try await RevisionNotCurrentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePullRequestDescriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension UpdatePullRequestDescriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePullRequestDescriptionInput: Swift.Equatable {
    /// The updated content of the description for the pull request. This content replaces the existing description.
    /// This member is required.
    public var description: Swift.String?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init(
        description: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.description = description
        self.pullRequestId = pullRequestId
    }
}

struct UpdatePullRequestDescriptionInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let description: Swift.String?
}

extension UpdatePullRequestDescriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case pullRequestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdatePullRequestDescriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePullRequestDescriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct UpdatePullRequestDescriptionOutput: Swift.Equatable {
    /// Information about the updated pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct UpdatePullRequestDescriptionOutputBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension UpdatePullRequestDescriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

enum UpdatePullRequestDescriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidDescriptionException": return try await InvalidDescriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestAlreadyClosedException": return try await PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePullRequestStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case pullRequestStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let pullRequestStatus = self.pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
    }
}

extension UpdatePullRequestStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePullRequestStatusInput: Swift.Equatable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The status of the pull request. The only valid operations are to update the status from OPEN to OPEN, OPEN to CLOSED or from CLOSED to CLOSED.
    /// This member is required.
    public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?

    public init(
        pullRequestId: Swift.String? = nil,
        pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.pullRequestStatus = pullRequestStatus
    }
}

struct UpdatePullRequestStatusInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?
}

extension UpdatePullRequestStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case pullRequestStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
    }
}

extension UpdatePullRequestStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePullRequestStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct UpdatePullRequestStatusOutput: Swift.Equatable {
    /// Information about the pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct UpdatePullRequestStatusOutputBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension UpdatePullRequestStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

enum UpdatePullRequestStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestStatusException": return try await InvalidPullRequestStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPullRequestStatusUpdateException": return try await InvalidPullRequestStatusUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestStatusRequiredException": return try await PullRequestStatusRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePullRequestTitleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension UpdatePullRequestTitleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePullRequestTitleInput: Swift.Equatable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The updated title of the pull request. This replaces the existing title.
    /// This member is required.
    public var title: Swift.String?

    public init(
        pullRequestId: Swift.String? = nil,
        title: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.title = title
    }
}

struct UpdatePullRequestTitleInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let title: Swift.String?
}

extension UpdatePullRequestTitleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case title
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
    }
}

extension UpdatePullRequestTitleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePullRequestTitleOutputBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct UpdatePullRequestTitleOutput: Swift.Equatable {
    /// Information about the updated pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init(
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct UpdatePullRequestTitleOutputBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension UpdatePullRequestTitleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

enum UpdatePullRequestTitleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPullRequestIdException": return try await InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTitleException": return try await InvalidTitleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestAlreadyClosedException": return try await PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestDoesNotExistException": return try await PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullRequestIdRequiredException": return try await PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TitleRequiredException": return try await TitleRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRepositoryDescriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryDescription
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryDescription = self.repositoryDescription {
            try encodeContainer.encode(repositoryDescription, forKey: .repositoryDescription)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension UpdateRepositoryDescriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of an update repository description operation.
public struct UpdateRepositoryDescriptionInput: Swift.Equatable {
    /// The new comment or description for the specified repository. Repository descriptions are limited to 1,000 characters.
    public var repositoryDescription: Swift.String?
    /// The name of the repository to set or change the comment or description for.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        repositoryDescription: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryDescription = repositoryDescription
        self.repositoryName = repositoryName
    }
}

struct UpdateRepositoryDescriptionInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let repositoryDescription: Swift.String?
}

extension UpdateRepositoryDescriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryDescription
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryDescription)
        repositoryDescription = repositoryDescriptionDecoded
    }
}

extension UpdateRepositoryDescriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRepositoryDescriptionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRepositoryDescriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EncryptionIntegrityChecksFailedException": return try await EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyAccessDeniedException": return try await EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyDisabledException": return try await EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyNotFoundException": return try await EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EncryptionKeyUnavailableException": return try await EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryDescriptionException": return try await InvalidRepositoryDescriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRepositoryNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newName
        case oldName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newName = self.newName {
            try encodeContainer.encode(newName, forKey: .newName)
        }
        if let oldName = self.oldName {
            try encodeContainer.encode(oldName, forKey: .oldName)
        }
    }
}

extension UpdateRepositoryNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of an update repository description operation.
public struct UpdateRepositoryNameInput: Swift.Equatable {
    /// The new name for the repository.
    /// This member is required.
    public var newName: Swift.String?
    /// The current name of the repository.
    /// This member is required.
    public var oldName: Swift.String?

    public init(
        newName: Swift.String? = nil,
        oldName: Swift.String? = nil
    )
    {
        self.newName = newName
        self.oldName = oldName
    }
}

struct UpdateRepositoryNameInputBody: Swift.Equatable {
    let oldName: Swift.String?
    let newName: Swift.String?
}

extension UpdateRepositoryNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newName
        case oldName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oldName)
        oldName = oldNameDecoded
        let newNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newName)
        newName = newNameDecoded
    }
}

extension UpdateRepositoryNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRepositoryNameOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRepositoryNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRepositoryNameException": return try await InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryDoesNotExistException": return try await RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameExistsException": return try await RepositoryNameExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNameRequiredException": return try await RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCommitClientTypes.UserInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date
        case email
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = self.date {
            try encodeContainer.encode(date, forKey: .date)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let dateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .date)
        date = dateDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the user who made a specified commit.
    public struct UserInfo: Swift.Equatable {
        /// The date when the specified commit was commited, in timestamp format with GMT offset.
        public var date: Swift.String?
        /// The email address associated with the user who made the commit, if any.
        public var email: Swift.String?
        /// The name of the user who made the specified commit.
        public var name: Swift.String?

        public init(
            date: Swift.String? = nil,
            email: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.date = date
            self.email = email
            self.name = name
        }
    }

}
