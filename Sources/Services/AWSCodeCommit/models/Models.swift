// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActorDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ActorDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon Resource Name (ARN) does not exist in the AWS account.
public struct ActorDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ActorDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ActorDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.Approval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalState
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalState = self.approvalState {
            try encodeContainer.encode(approvalState.rawValue, forKey: .approvalState)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let approvalStateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalState.self, forKey: .approvalState)
        approvalState = approvalStateDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a specific approval on a pull request.
    public struct Approval: Swift.Equatable {
        /// The state of the approval, APPROVE or REVOKE. REVOKE states are not stored.
        public var approvalState: CodeCommitClientTypes.ApprovalState?
        /// The Amazon Resource Name (ARN) of the user.
        public var userArn: Swift.String?

        public init (
            approvalState: CodeCommitClientTypes.ApprovalState? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.approvalState = approvalState
            self.userArn = userArn
        }
    }

}

extension CodeCommitClientTypes.ApprovalRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleContent
        case approvalRuleId
        case approvalRuleName
        case creationDate
        case lastModifiedDate
        case lastModifiedUser
        case originApprovalRuleTemplate
        case ruleContentSha256
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleContent = self.approvalRuleContent {
            try encodeContainer.encode(approvalRuleContent, forKey: .approvalRuleContent)
        }
        if let approvalRuleId = self.approvalRuleId {
            try encodeContainer.encode(approvalRuleId, forKey: .approvalRuleId)
        }
        if let approvalRuleName = self.approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = self.lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let originApprovalRuleTemplate = self.originApprovalRuleTemplate {
            try encodeContainer.encode(originApprovalRuleTemplate, forKey: .originApprovalRuleTemplate)
        }
        if let ruleContentSha256 = self.ruleContentSha256 {
            try encodeContainer.encode(ruleContentSha256, forKey: .ruleContentSha256)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleId)
        approvalRuleId = approvalRuleIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let approvalRuleContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleContent)
        approvalRuleContent = approvalRuleContentDecoded
        let ruleContentSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleContentSha256)
        ruleContentSha256 = ruleContentSha256Decoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let originApprovalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.OriginApprovalRuleTemplate.self, forKey: .originApprovalRuleTemplate)
        originApprovalRuleTemplate = originApprovalRuleTemplateDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about an approval rule.
    public struct ApprovalRule: Swift.Equatable {
        /// The content of the approval rule.
        public var approvalRuleContent: Swift.String?
        /// The system-generated ID of the approval rule.
        public var approvalRuleId: Swift.String?
        /// The name of the approval rule.
        public var approvalRuleName: Swift.String?
        /// The date the approval rule was created, in timestamp format.
        public var creationDate: ClientRuntime.Date?
        /// The date the approval rule was most recently changed, in timestamp format.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who made the most recent changes to the approval rule.
        public var lastModifiedUser: Swift.String?
        /// The approval rule template used to create the rule.
        public var originApprovalRuleTemplate: CodeCommitClientTypes.OriginApprovalRuleTemplate?
        /// The SHA-256 hash signature for the content of the approval rule.
        public var ruleContentSha256: Swift.String?

        public init (
            approvalRuleContent: Swift.String? = nil,
            approvalRuleId: Swift.String? = nil,
            approvalRuleName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            originApprovalRuleTemplate: CodeCommitClientTypes.OriginApprovalRuleTemplate? = nil,
            ruleContentSha256: Swift.String? = nil
        )
        {
            self.approvalRuleContent = approvalRuleContent
            self.approvalRuleId = approvalRuleId
            self.approvalRuleName = approvalRuleName
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.originApprovalRuleTemplate = originApprovalRuleTemplate
            self.ruleContentSha256 = ruleContentSha256
        }
    }

}

extension ApprovalRuleContentRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApprovalRuleContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.
public struct ApprovalRuleContentRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApprovalRuleDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified approval rule does not exist.
public struct ApprovalRuleDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.ApprovalRuleEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleContent
        case approvalRuleId
        case approvalRuleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleContent = self.approvalRuleContent {
            try encodeContainer.encode(approvalRuleContent, forKey: .approvalRuleContent)
        }
        if let approvalRuleId = self.approvalRuleId {
            try encodeContainer.encode(approvalRuleId, forKey: .approvalRuleId)
        }
        if let approvalRuleName = self.approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let approvalRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleId)
        approvalRuleId = approvalRuleIdDecoded
        let approvalRuleContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleContent)
        approvalRuleContent = approvalRuleContentDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about an event for an approval rule.
    public struct ApprovalRuleEventMetadata: Swift.Equatable {
        /// The content of the approval rule.
        public var approvalRuleContent: Swift.String?
        /// The system-generated ID of the approval rule.
        public var approvalRuleId: Swift.String?
        /// The name of the approval rule.
        public var approvalRuleName: Swift.String?

        public init (
            approvalRuleContent: Swift.String? = nil,
            approvalRuleId: Swift.String? = nil,
            approvalRuleName: Swift.String? = nil
        )
        {
            self.approvalRuleContent = approvalRuleContent
            self.approvalRuleId = approvalRuleId
            self.approvalRuleName = approvalRuleName
        }
    }

}

extension ApprovalRuleNameAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApprovalRuleNameAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An approval rule with that name already exists. Approval rule names must be unique within the scope of a pull request.
public struct ApprovalRuleNameAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleNameAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleNameAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleNameRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApprovalRuleNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An approval rule name is required, but was not specified.
public struct ApprovalRuleNameRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideStatus
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideStatus = self.overrideStatus {
            try encodeContainer.encode(overrideStatus.rawValue, forKey: .overrideStatus)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let overrideStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.OverrideStatus.self, forKey: .overrideStatus)
        overrideStatus = overrideStatusDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about an override event for approval rules for a pull request.
    public struct ApprovalRuleOverriddenEventMetadata: Swift.Equatable {
        /// The status of the override event.
        public var overrideStatus: CodeCommitClientTypes.OverrideStatus?
        /// The revision ID of the pull request when the override event occurred.
        public var revisionId: Swift.String?

        public init (
            overrideStatus: CodeCommitClientTypes.OverrideStatus? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.overrideStatus = overrideStatus
            self.revisionId = revisionId
        }
    }

}

extension CodeCommitClientTypes.ApprovalRuleTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateContent
        case approvalRuleTemplateDescription
        case approvalRuleTemplateId
        case approvalRuleTemplateName
        case creationDate
        case lastModifiedDate
        case lastModifiedUser
        case ruleContentSha256
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateContent = self.approvalRuleTemplateContent {
            try encodeContainer.encode(approvalRuleTemplateContent, forKey: .approvalRuleTemplateContent)
        }
        if let approvalRuleTemplateDescription = self.approvalRuleTemplateDescription {
            try encodeContainer.encode(approvalRuleTemplateDescription, forKey: .approvalRuleTemplateDescription)
        }
        if let approvalRuleTemplateId = self.approvalRuleTemplateId {
            try encodeContainer.encode(approvalRuleTemplateId, forKey: .approvalRuleTemplateId)
        }
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = self.lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let ruleContentSha256 = self.ruleContentSha256 {
            try encodeContainer.encode(ruleContentSha256, forKey: .ruleContentSha256)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateId)
        approvalRuleTemplateId = approvalRuleTemplateIdDecoded
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let approvalRuleTemplateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateDescription)
        approvalRuleTemplateDescription = approvalRuleTemplateDescriptionDecoded
        let approvalRuleTemplateContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateContent)
        approvalRuleTemplateContent = approvalRuleTemplateContentDecoded
        let ruleContentSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleContentSha256)
        ruleContentSha256 = ruleContentSha256Decoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about an approval rule template.
    public struct ApprovalRuleTemplate: Swift.Equatable {
        /// The content of the approval rule template.
        public var approvalRuleTemplateContent: Swift.String?
        /// The description of the approval rule template.
        public var approvalRuleTemplateDescription: Swift.String?
        /// The system-generated ID of the approval rule template.
        public var approvalRuleTemplateId: Swift.String?
        /// The name of the approval rule template.
        public var approvalRuleTemplateName: Swift.String?
        /// The date the approval rule template was created, in timestamp format.
        public var creationDate: ClientRuntime.Date?
        /// The date the approval rule template was most recently changed, in timestamp format.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who made the most recent changes to the approval rule template.
        public var lastModifiedUser: Swift.String?
        /// The SHA-256 hash signature for the content of the approval rule template.
        public var ruleContentSha256: Swift.String?

        public init (
            approvalRuleTemplateContent: Swift.String? = nil,
            approvalRuleTemplateDescription: Swift.String? = nil,
            approvalRuleTemplateId: Swift.String? = nil,
            approvalRuleTemplateName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            ruleContentSha256: Swift.String? = nil
        )
        {
            self.approvalRuleTemplateContent = approvalRuleTemplateContent
            self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
            self.approvalRuleTemplateId = approvalRuleTemplateId
            self.approvalRuleTemplateName = approvalRuleTemplateName
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.ruleContentSha256 = ruleContentSha256
        }
    }

}

extension ApprovalRuleTemplateContentRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApprovalRuleTemplateContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.
public struct ApprovalRuleTemplateContentRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleTemplateContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleTemplateContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApprovalRuleTemplateDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.
public struct ApprovalRuleTemplateDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleTemplateDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleTemplateDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApprovalRuleTemplateInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove all associations, and then try again.
public struct ApprovalRuleTemplateInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleTemplateInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleTemplateInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateNameAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApprovalRuleTemplateNameAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot create an approval rule template with that name because a template with that name already exists in this AWS Region for your AWS account. Approval rule template names must be unique.
public struct ApprovalRuleTemplateNameAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleTemplateNameAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleTemplateNameAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateNameRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApprovalRuleTemplateNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An approval rule template name is required, but was not specified.
public struct ApprovalRuleTemplateNameRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleTemplateNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalRuleTemplateNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum ApprovalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approve
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [ApprovalState] {
            return [
                .approve,
                .revoke,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approve: return "APPROVE"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApprovalState(rawValue: rawValue) ?? ApprovalState.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.ApprovalStateChangedEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalStatus
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalStatus = self.approvalStatus {
            try encodeContainer.encode(approvalStatus.rawValue, forKey: .approvalStatus)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let approvalStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalState.self, forKey: .approvalStatus)
        approvalStatus = approvalStatusDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a change in the approval state for a pull request.
    public struct ApprovalStateChangedEventMetadata: Swift.Equatable {
        /// The approval status for the pull request.
        public var approvalStatus: CodeCommitClientTypes.ApprovalState?
        /// The revision ID of the pull request when the approval state changed.
        public var revisionId: Swift.String?

        public init (
            approvalStatus: CodeCommitClientTypes.ApprovalState? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.approvalStatus = approvalStatus
            self.revisionId = revisionId
        }
    }

}

extension ApprovalStateRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApprovalStateRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An approval state is required, but was not specified.
public struct ApprovalStateRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalStateRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApprovalStateRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateApprovalRuleTemplateWithRepositoryInput: Swift.Equatable {
    /// The name for the approval rule template.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The name of the repository that you want to associate with the template.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryName = repositoryName
    }
}

struct AssociateApprovalRuleTemplateWithRepositoryInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let repositoryName: Swift.String?
}

extension AssociateApprovalRuleTemplateWithRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRuleTemplatesAssociatedWithRepositoryException" : self = .maximumRuleTemplatesAssociatedWithRepositoryException(try MaximumRuleTemplatesAssociatedWithRepositoryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateApprovalRuleTemplateWithRepositoryOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumRuleTemplatesAssociatedWithRepositoryException(MaximumRuleTemplatesAssociatedWithRepositoryException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateApprovalRuleTemplateWithRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateApprovalRuleTemplateWithRepositoryOutputResponse: Swift.Equatable {

    public init () { }
}

extension AuthorDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AuthorDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon Resource Name (ARN) does not exist in the AWS account.
public struct AuthorDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AuthorDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about errors in a BatchAssociateApprovalRuleTemplateWithRepositories operation.
    public struct BatchAssociateApprovalRuleTemplateWithRepositoriesError: Swift.Equatable {
        /// An error code that specifies whether the repository name was not valid or not found.
        public var errorCode: Swift.String?
        /// An error message that provides details about why the repository name was not found or not valid.
        public var errorMessage: Swift.String?
        /// The name of the repository where the association was not made.
        public var repositoryName: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.repositoryName = repositoryName
        }
    }

}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositoryname0 in repositoryNames {
                try repositoryNamesContainer.encode(repositoryname0)
            }
        }
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesInput: Swift.Equatable {
    /// The name of the template you want to associate with one or more repositories.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The names of the repositories you want to associate with the template. The length constraint limit is for each string in the array. The array itself can be empty.
    /// This member is required.
    public var repositoryNames: [Swift.String]?

    public init (
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryNames = repositoryNames
    }
}

struct BatchAssociateApprovalRuleTemplateWithRepositoriesInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let repositoryNames: [Swift.String]?
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRepositoryNamesExceededException" : self = .maximumRepositoryNamesExceededException(try MaximumRepositoryNamesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNamesRequiredException" : self = .repositoryNamesRequiredException(try RepositoryNamesRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case maximumRepositoryNamesExceededException(MaximumRepositoryNamesExceededException)
    case repositoryNamesRequiredException(RepositoryNamesRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedRepositoryNames = output.associatedRepositoryNames
            self.errors = output.errors
        } else {
            self.associatedRepositoryNames = nil
            self.errors = nil
        }
    }
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse: Swift.Equatable {
    /// A list of names of the repositories that have been associated with the template.
    /// This member is required.
    public var associatedRepositoryNames: [Swift.String]?
    /// A list of any errors that might have occurred while attempting to create the association between the template and the repositories.
    /// This member is required.
    public var errors: [CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]?

    public init (
        associatedRepositoryNames: [Swift.String]? = nil,
        errors: [CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]? = nil
    )
    {
        self.associatedRepositoryNames = associatedRepositoryNames
        self.errors = errors
    }
}

struct BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponseBody: Swift.Equatable {
    let associatedRepositoryNames: [Swift.String]?
    let errors: [CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]?
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedRepositoryNames
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedRepositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedRepositoryNames)
        var associatedRepositoryNamesDecoded0:[Swift.String]? = nil
        if let associatedRepositoryNamesContainer = associatedRepositoryNamesContainer {
            associatedRepositoryNamesDecoded0 = [Swift.String]()
            for string0 in associatedRepositoryNamesContainer {
                if let string0 = string0 {
                    associatedRepositoryNamesDecoded0?.append(string0)
                }
            }
        }
        associatedRepositoryNames = associatedRepositoryNamesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError?].self, forKey: .errors)
        var errorsDecoded0:[CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CodeCommitClientTypes.BatchAssociateApprovalRuleTemplateWithRepositoriesError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension CodeCommitClientTypes.BatchDescribeMergeConflictsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionName
        case filePath
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptionName = self.exceptionName {
            try encodeContainer.encode(exceptionName, forKey: .exceptionName)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let exceptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionName)
        exceptionName = exceptionNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about errors in a BatchDescribeMergeConflicts operation.
    public struct BatchDescribeMergeConflictsError: Swift.Equatable {
        /// The name of the exception.
        /// This member is required.
        public var exceptionName: Swift.String?
        /// The path to the file.
        /// This member is required.
        public var filePath: Swift.String?
        /// The message provided by the exception.
        /// This member is required.
        public var message: Swift.String?

        public init (
            exceptionName: Swift.String? = nil,
            filePath: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.exceptionName = exceptionName
            self.filePath = filePath
            self.message = message
        }
    }

}

extension BatchDescribeMergeConflictsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePaths
        case maxConflictFiles
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let filePaths = filePaths {
            var filePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filePaths)
            for path0 in filePaths {
                try filePathsContainer.encode(path0)
            }
        }
        if let maxConflictFiles = self.maxConflictFiles {
            try encodeContainer.encode(maxConflictFiles, forKey: .maxConflictFiles)
        }
        if let maxMergeHunks = self.maxMergeHunks {
            try encodeContainer.encode(maxMergeHunks, forKey: .maxMergeHunks)
        }
        if let mergeOption = self.mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension BatchDescribeMergeConflictsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDescribeMergeConflictsInput: Swift.Equatable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The path of the target files used to describe the conflicts. If not specified, the default is all conflict files.
    public var filePaths: [Swift.String]?
    /// The maximum number of files to include in the output.
    public var maxConflictFiles: Swift.Int?
    /// The maximum number of merge hunks to include in the output.
    public var maxMergeHunks: Swift.Int?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository that contains the merge conflicts you want to review.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init (
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        filePaths: [Swift.String]? = nil,
        maxConflictFiles: Swift.Int? = nil,
        maxMergeHunks: Swift.Int? = nil,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.filePaths = filePaths
        self.maxConflictFiles = maxConflictFiles
        self.maxMergeHunks = maxMergeHunks
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct BatchDescribeMergeConflictsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    let maxMergeHunks: Swift.Int?
    let maxConflictFiles: Swift.Int?
    let filePaths: [Swift.String]?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let nextToken: Swift.String?
}

extension BatchDescribeMergeConflictsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePaths
        case maxConflictFiles
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let maxMergeHunksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxMergeHunks)
        maxMergeHunks = maxMergeHunksDecoded
        let maxConflictFilesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConflictFiles)
        maxConflictFiles = maxConflictFilesDecoded
        let filePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filePaths)
        var filePathsDecoded0:[Swift.String]? = nil
        if let filePathsContainer = filePathsContainer {
            filePathsDecoded0 = [Swift.String]()
            for string0 in filePathsContainer {
                if let string0 = string0 {
                    filePathsDecoded0?.append(string0)
                }
            }
        }
        filePaths = filePathsDecoded0
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchDescribeMergeConflictsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDescribeMergeConflictsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxConflictFilesException" : self = .invalidMaxConflictFilesException(try InvalidMaxConflictFilesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxMergeHunksException" : self = .invalidMaxMergeHunksException(try InvalidMaxMergeHunksException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMergeOptionException" : self = .invalidMergeOptionException(try InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MergeOptionRequiredException" : self = .mergeOptionRequiredException(try MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDescribeMergeConflictsOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxConflictFilesException(InvalidMaxConflictFilesException)
    case invalidMaxMergeHunksException(InvalidMaxMergeHunksException)
    case invalidMergeOptionException(InvalidMergeOptionException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case mergeOptionRequiredException(MergeOptionRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDescribeMergeConflictsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDescribeMergeConflictsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baseCommitId = output.baseCommitId
            self.conflicts = output.conflicts
            self.destinationCommitId = output.destinationCommitId
            self.errors = output.errors
            self.nextToken = output.nextToken
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.conflicts = nil
            self.destinationCommitId = nil
            self.errors = nil
            self.nextToken = nil
            self.sourceCommitId = nil
        }
    }
}

public struct BatchDescribeMergeConflictsOutputResponse: Swift.Equatable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// A list of conflicts for each file, including the conflict metadata and the hunks of the differences between the files.
    /// This member is required.
    public var conflicts: [CodeCommitClientTypes.Conflict]?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// A list of any errors returned while describing the merge conflicts for each file.
    public var errors: [CodeCommitClientTypes.BatchDescribeMergeConflictsError]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init (
        baseCommitId: Swift.String? = nil,
        conflicts: [CodeCommitClientTypes.Conflict]? = nil,
        destinationCommitId: Swift.String? = nil,
        errors: [CodeCommitClientTypes.BatchDescribeMergeConflictsError]? = nil,
        nextToken: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflicts = conflicts
        self.destinationCommitId = destinationCommitId
        self.errors = errors
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

struct BatchDescribeMergeConflictsOutputResponseBody: Swift.Equatable {
    let conflicts: [CodeCommitClientTypes.Conflict]?
    let nextToken: Swift.String?
    let errors: [CodeCommitClientTypes.BatchDescribeMergeConflictsError]?
    let destinationCommitId: Swift.String?
    let sourceCommitId: Swift.String?
    let baseCommitId: Swift.String?
}

extension BatchDescribeMergeConflictsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCommitId
        case conflicts
        case destinationCommitId
        case errors
        case nextToken
        case sourceCommitId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Conflict?].self, forKey: .conflicts)
        var conflictsDecoded0:[CodeCommitClientTypes.Conflict]? = nil
        if let conflictsContainer = conflictsContainer {
            conflictsDecoded0 = [CodeCommitClientTypes.Conflict]()
            for structure0 in conflictsContainer {
                if let structure0 = structure0 {
                    conflictsDecoded0?.append(structure0)
                }
            }
        }
        conflicts = conflictsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let errorsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.BatchDescribeMergeConflictsError?].self, forKey: .errors)
        var errorsDecoded0:[CodeCommitClientTypes.BatchDescribeMergeConflictsError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CodeCommitClientTypes.BatchDescribeMergeConflictsError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
    }
}

extension CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about errors in a BatchDisassociateApprovalRuleTemplateFromRepositories operation.
    public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesError: Swift.Equatable {
        /// An error code that specifies whether the repository name was not valid or not found.
        public var errorCode: Swift.String?
        /// An error message that provides details about why the repository name was either not found or not valid.
        public var errorMessage: Swift.String?
        /// The name of the repository where the association with the template was not able to be removed.
        public var repositoryName: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.repositoryName = repositoryName
        }
    }

}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositoryname0 in repositoryNames {
                try repositoryNamesContainer.encode(repositoryname0)
            }
        }
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesInput: Swift.Equatable {
    /// The name of the template that you want to disassociate from one or more repositories.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The repository names that you want to disassociate from the approval rule template. The length constraint limit is for each string in the array. The array itself can be empty.
    /// This member is required.
    public var repositoryNames: [Swift.String]?

    public init (
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryNames = repositoryNames
    }
}

struct BatchDisassociateApprovalRuleTemplateFromRepositoriesInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let repositoryNames: [Swift.String]?
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRepositoryNamesExceededException" : self = .maximumRepositoryNamesExceededException(try MaximumRepositoryNamesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNamesRequiredException" : self = .repositoryNamesRequiredException(try RepositoryNamesRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case maximumRepositoryNamesExceededException(MaximumRepositoryNamesExceededException)
    case repositoryNamesRequiredException(RepositoryNamesRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.disassociatedRepositoryNames = output.disassociatedRepositoryNames
            self.errors = output.errors
        } else {
            self.disassociatedRepositoryNames = nil
            self.errors = nil
        }
    }
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse: Swift.Equatable {
    /// A list of repository names that have had their association with the template removed.
    /// This member is required.
    public var disassociatedRepositoryNames: [Swift.String]?
    /// A list of any errors that might have occurred while attempting to remove the association between the template and the repositories.
    /// This member is required.
    public var errors: [CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]?

    public init (
        disassociatedRepositoryNames: [Swift.String]? = nil,
        errors: [CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]? = nil
    )
    {
        self.disassociatedRepositoryNames = disassociatedRepositoryNames
        self.errors = errors
    }
}

struct BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponseBody: Swift.Equatable {
    let disassociatedRepositoryNames: [Swift.String]?
    let errors: [CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]?
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedRepositoryNames
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disassociatedRepositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .disassociatedRepositoryNames)
        var disassociatedRepositoryNamesDecoded0:[Swift.String]? = nil
        if let disassociatedRepositoryNamesContainer = disassociatedRepositoryNamesContainer {
            disassociatedRepositoryNamesDecoded0 = [Swift.String]()
            for string0 in disassociatedRepositoryNamesContainer {
                if let string0 = string0 {
                    disassociatedRepositoryNamesDecoded0?.append(string0)
                }
            }
        }
        disassociatedRepositoryNames = disassociatedRepositoryNamesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError?].self, forKey: .errors)
        var errorsDecoded0:[CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CodeCommitClientTypes.BatchDisassociateApprovalRuleTemplateFromRepositoriesError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension CodeCommitClientTypes.BatchGetCommitsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about errors in a BatchGetCommits operation.
    public struct BatchGetCommitsError: Swift.Equatable {
        /// A commit ID that either could not be found or was not in a valid format.
        public var commitId: Swift.String?
        /// An error code that specifies whether the commit ID was not valid or not found.
        public var errorCode: Swift.String?
        /// An error message that provides detail about why the commit ID either was not found or was not valid.
        public var errorMessage: Swift.String?

        public init (
            commitId: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.commitId = commitId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension BatchGetCommitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitIds
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitIds = commitIds {
            var commitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commitIds)
            for objectid0 in commitIds {
                try commitIdsContainer.encode(objectid0)
            }
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension BatchGetCommitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetCommitsInput: Swift.Equatable {
    /// The full commit IDs of the commits to get information about. You must supply the full SHA IDs of each commit. You cannot use shortened SHA IDs.
    /// This member is required.
    public var commitIds: [Swift.String]?
    /// The name of the repository that contains the commits.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        commitIds: [Swift.String]? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitIds = commitIds
        self.repositoryName = repositoryName
    }
}

struct BatchGetCommitsInputBody: Swift.Equatable {
    let commitIds: [Swift.String]?
    let repositoryName: Swift.String?
}

extension BatchGetCommitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitIds
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .commitIds)
        var commitIdsDecoded0:[Swift.String]? = nil
        if let commitIdsContainer = commitIdsContainer {
            commitIdsDecoded0 = [Swift.String]()
            for string0 in commitIdsContainer {
                if let string0 = string0 {
                    commitIdsDecoded0?.append(string0)
                }
            }
        }
        commitIds = commitIdsDecoded0
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension BatchGetCommitsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetCommitsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitIdsLimitExceededException" : self = .commitIdsLimitExceededException(try CommitIdsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdsListRequiredException" : self = .commitIdsListRequiredException(try CommitIdsListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetCommitsOutputError: Swift.Error, Swift.Equatable {
    case commitIdsLimitExceededException(CommitIdsLimitExceededException)
    case commitIdsListRequiredException(CommitIdsListRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetCommitsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetCommitsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commits = output.commits
            self.errors = output.errors
        } else {
            self.commits = nil
            self.errors = nil
        }
    }
}

public struct BatchGetCommitsOutputResponse: Swift.Equatable {
    /// An array of commit data type objects, each of which contains information about a specified commit.
    public var commits: [CodeCommitClientTypes.Commit]?
    /// Returns any commit IDs for which information could not be found. For example, if one of the commit IDs was a shortened SHA ID or that commit was not found in the specified repository, the ID returns an error object with more information.
    public var errors: [CodeCommitClientTypes.BatchGetCommitsError]?

    public init (
        commits: [CodeCommitClientTypes.Commit]? = nil,
        errors: [CodeCommitClientTypes.BatchGetCommitsError]? = nil
    )
    {
        self.commits = commits
        self.errors = errors
    }
}

struct BatchGetCommitsOutputResponseBody: Swift.Equatable {
    let commits: [CodeCommitClientTypes.Commit]?
    let errors: [CodeCommitClientTypes.BatchGetCommitsError]?
}

extension BatchGetCommitsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commits
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Commit?].self, forKey: .commits)
        var commitsDecoded0:[CodeCommitClientTypes.Commit]? = nil
        if let commitsContainer = commitsContainer {
            commitsDecoded0 = [CodeCommitClientTypes.Commit]()
            for structure0 in commitsContainer {
                if let structure0 = structure0 {
                    commitsDecoded0?.append(structure0)
                }
            }
        }
        commits = commitsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.BatchGetCommitsError?].self, forKey: .errors)
        var errorsDecoded0:[CodeCommitClientTypes.BatchGetCommitsError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CodeCommitClientTypes.BatchGetCommitsError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchGetRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositoryname0 in repositoryNames {
                try repositoryNamesContainer.encode(repositoryname0)
            }
        }
    }
}

extension BatchGetRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a batch get repositories operation.
public struct BatchGetRepositoriesInput: Swift.Equatable {
    /// The names of the repositories to get information about. The length constraint limit is for each string in the array. The array itself can be empty.
    /// This member is required.
    public var repositoryNames: [Swift.String]?

    public init (
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.repositoryNames = repositoryNames
    }
}

struct BatchGetRepositoriesInputBody: Swift.Equatable {
    let repositoryNames: [Swift.String]?
}

extension BatchGetRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryNames
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
    }
}

extension BatchGetRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRepositoryNamesExceededException" : self = .maximumRepositoryNamesExceededException(try MaximumRepositoryNamesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNamesRequiredException" : self = .repositoryNamesRequiredException(try RepositoryNamesRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumRepositoryNamesExceededException(MaximumRepositoryNamesExceededException)
    case repositoryNamesRequiredException(RepositoryNamesRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositories = output.repositories
            self.repositoriesNotFound = output.repositoriesNotFound
        } else {
            self.repositories = nil
            self.repositoriesNotFound = nil
        }
    }
}

/// Represents the output of a batch get repositories operation.
public struct BatchGetRepositoriesOutputResponse: Swift.Equatable {
    /// A list of repositories returned by the batch get repositories operation.
    public var repositories: [CodeCommitClientTypes.RepositoryMetadata]?
    /// Returns a list of repository names for which information could not be found.
    public var repositoriesNotFound: [Swift.String]?

    public init (
        repositories: [CodeCommitClientTypes.RepositoryMetadata]? = nil,
        repositoriesNotFound: [Swift.String]? = nil
    )
    {
        self.repositories = repositories
        self.repositoriesNotFound = repositoriesNotFound
    }
}

struct BatchGetRepositoriesOutputResponseBody: Swift.Equatable {
    let repositories: [CodeCommitClientTypes.RepositoryMetadata]?
    let repositoriesNotFound: [Swift.String]?
}

extension BatchGetRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositories
        case repositoriesNotFound
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryMetadata?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeCommitClientTypes.RepositoryMetadata]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeCommitClientTypes.RepositoryMetadata]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let repositoriesNotFoundContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoriesNotFound)
        var repositoriesNotFoundDecoded0:[Swift.String]? = nil
        if let repositoriesNotFoundContainer = repositoriesNotFoundContainer {
            repositoriesNotFoundDecoded0 = [Swift.String]()
            for string0 in repositoriesNotFoundContainer {
                if let string0 = string0 {
                    repositoriesNotFoundDecoded0?.append(string0)
                }
            }
        }
        repositoriesNotFound = repositoriesNotFoundDecoded0
    }
}

extension BeforeCommitIdAndAfterCommitIdAreSameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BeforeCommitIdAndAfterCommitIdAreSameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.
public struct BeforeCommitIdAndAfterCommitIdAreSameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BeforeCommitIdAndAfterCommitIdAreSameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BeforeCommitIdAndAfterCommitIdAreSameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BlobIdDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BlobIdDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified blob does not exist.
public struct BlobIdDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BlobIdDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BlobIdDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BlobIdRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BlobIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A blob ID is required, but was not specified.
public struct BlobIdRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BlobIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BlobIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.BlobMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case mode
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode, forKey: .mode)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let modeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a specific Git blob object.
    public struct BlobMetadata: Swift.Equatable {
        /// The full ID of the blob.
        public var blobId: Swift.String?
        /// The file mode permissions of the blob. File mode permission codes include:
        ///
        /// * 100644 indicates read/write
        ///
        /// * 100755 indicates read/write/execute
        ///
        /// * 160000 indicates a submodule
        ///
        /// * 120000 indicates a symlink
        public var mode: Swift.String?
        /// The path to the blob and associated file name, if any.
        public var path: Swift.String?

        public init (
            blobId: Swift.String? = nil,
            mode: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.blobId = blobId
            self.mode = mode
            self.path = path
        }
    }

}

extension BranchDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BranchDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified branch does not exist.
public struct BranchDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BranchDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BranchDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.BranchInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a branch.
    public struct BranchInfo: Swift.Equatable {
        /// The name of the branch.
        public var branchName: Swift.String?
        /// The ID of the last commit made to the branch.
        public var commitId: Swift.String?

        public init (
            branchName: Swift.String? = nil,
            commitId: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.commitId = commitId
        }
    }

}

extension BranchNameExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BranchNameExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name. Branch names must be unique.
public struct BranchNameExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BranchNameExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BranchNameExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BranchNameIsTagNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BranchNameIsTagNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use [ListBranches].
public struct BranchNameIsTagNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BranchNameIsTagNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BranchNameIsTagNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BranchNameRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BranchNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A branch name is required, but was not specified.
public struct BranchNameRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BranchNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BranchNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CannotDeleteApprovalRuleFromTemplateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CannotDeleteApprovalRuleFromTemplateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The approval rule cannot be deleted from the pull request because it was created by an approval rule template and applied to the pull request automatically.
public struct CannotDeleteApprovalRuleFromTemplateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CannotDeleteApprovalRuleFromTemplateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CannotDeleteApprovalRuleFromTemplateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CannotModifyApprovalRuleFromTemplateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CannotModifyApprovalRuleFromTemplateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The approval rule cannot be modified for the pull request because it was created by an approval rule template and applied to the pull request automatically.
public struct CannotModifyApprovalRuleFromTemplateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CannotModifyApprovalRuleFromTemplateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CannotModifyApprovalRuleFromTemplateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum ChangeTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case added
        case deleted
        case modified
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeTypeEnum] {
            return [
                .added,
                .deleted,
                .modified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .added: return "A"
            case .deleted: return "D"
            case .modified: return "M"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeTypeEnum(rawValue: rawValue) ?? ChangeTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension ClientRequestTokenRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ClientRequestTokenRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
public struct ClientRequestTokenRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClientRequestTokenRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClientRequestTokenRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.Comment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorArn
        case callerReactions
        case clientRequestToken
        case commentId
        case content
        case creationDate
        case deleted
        case inReplyTo
        case lastModifiedDate
        case reactionCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorArn = self.authorArn {
            try encodeContainer.encode(authorArn, forKey: .authorArn)
        }
        if let callerReactions = callerReactions {
            var callerReactionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callerReactions)
            for reactionvalue0 in callerReactions {
                try callerReactionsContainer.encode(reactionvalue0)
            }
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if deleted != false {
            try encodeContainer.encode(deleted, forKey: .deleted)
        }
        if let inReplyTo = self.inReplyTo {
            try encodeContainer.encode(inReplyTo, forKey: .inReplyTo)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let reactionCounts = reactionCounts {
            var reactionCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .reactionCounts)
            for (dictKey0, reactionCountsMap0) in reactionCounts {
                try reactionCountsContainer.encode(reactionCountsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let inReplyToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inReplyTo)
        inReplyTo = inReplyToDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let authorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorArn)
        authorArn = authorArnDecoded
        let deletedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleted) ?? false
        deleted = deletedDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let callerReactionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .callerReactions)
        var callerReactionsDecoded0:[Swift.String]? = nil
        if let callerReactionsContainer = callerReactionsContainer {
            callerReactionsDecoded0 = [Swift.String]()
            for string0 in callerReactionsContainer {
                if let string0 = string0 {
                    callerReactionsDecoded0?.append(string0)
                }
            }
        }
        callerReactions = callerReactionsDecoded0
        let reactionCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .reactionCounts)
        var reactionCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let reactionCountsContainer = reactionCountsContainer {
            reactionCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in reactionCountsContainer {
                if let count0 = count0 {
                    reactionCountsDecoded0?[key0] = count0
                }
            }
        }
        reactionCounts = reactionCountsDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a specific comment.
    public struct Comment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the person who posted the comment.
        public var authorArn: Swift.String?
        /// The emoji reactions to a comment, if any, submitted by the user whose credentials are associated with the call to the API.
        public var callerReactions: [Swift.String]?
        /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
        public var clientRequestToken: Swift.String?
        /// The system-generated comment ID.
        public var commentId: Swift.String?
        /// The content of the comment.
        public var content: Swift.String?
        /// The date and time the comment was created, in timestamp format.
        public var creationDate: ClientRuntime.Date?
        /// A Boolean value indicating whether the comment has been deleted.
        public var deleted: Swift.Bool
        /// The ID of the comment for which this comment is a reply, if any.
        public var inReplyTo: Swift.String?
        /// The date and time the comment was most recently modified, in timestamp format.
        public var lastModifiedDate: ClientRuntime.Date?
        /// A string to integer map that represents the number of individual users who have responded to a comment with the specified reactions.
        public var reactionCounts: [Swift.String:Swift.Int]?

        public init (
            authorArn: Swift.String? = nil,
            callerReactions: [Swift.String]? = nil,
            clientRequestToken: Swift.String? = nil,
            commentId: Swift.String? = nil,
            content: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            deleted: Swift.Bool = false,
            inReplyTo: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            reactionCounts: [Swift.String:Swift.Int]? = nil
        )
        {
            self.authorArn = authorArn
            self.callerReactions = callerReactions
            self.clientRequestToken = clientRequestToken
            self.commentId = commentId
            self.content = content
            self.creationDate = creationDate
            self.deleted = deleted
            self.inReplyTo = inReplyTo
            self.lastModifiedDate = lastModifiedDate
            self.reactionCounts = reactionCounts
        }
    }

}

extension CommentContentRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommentContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The comment is empty. You must provide some content for a comment. The content cannot be null.
public struct CommentContentRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommentContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentContentSizeLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommentContentSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The comment is too large. Comments are limited to 1,000 characters.
public struct CommentContentSizeLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommentContentSizeLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentContentSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentDeletedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommentDeletedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This comment has already been deleted. You cannot edit or delete a deleted comment.
public struct CommentDeletedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommentDeletedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentDeletedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommentDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.
public struct CommentDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommentDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentIdRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommentIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The comment ID is missing or null. A comment ID is required.
public struct CommentIdRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommentIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentNotCreatedByCallerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommentNotCreatedByCallerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot modify or delete this comment. Only comment authors can modify or delete their comments.
public struct CommentNotCreatedByCallerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommentNotCreatedByCallerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommentNotCreatedByCallerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.CommentsForComparedCommit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comments
        case location
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterBlobId = self.afterBlobId {
            try encodeContainer.encode(afterBlobId, forKey: .afterBlobId)
        }
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeBlobId = self.beforeBlobId {
            try encodeContainer.encode(beforeBlobId, forKey: .beforeBlobId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let comments = comments {
            var commentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comments)
            for comment0 in comments {
                try commentsContainer.encode(comment0)
            }
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let commentsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Comment?].self, forKey: .comments)
        var commentsDecoded0:[CodeCommitClientTypes.Comment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [CodeCommitClientTypes.Comment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Returns information about comments on the comparison between two commits.
    public struct CommentsForComparedCommit: Swift.Equatable {
        /// The full blob ID of the commit used to establish the after of the comparison.
        public var afterBlobId: Swift.String?
        /// The full commit ID of the commit used to establish the after of the comparison.
        public var afterCommitId: Swift.String?
        /// The full blob ID of the commit used to establish the before of the comparison.
        public var beforeBlobId: Swift.String?
        /// The full commit ID of the commit used to establish the before of the comparison.
        public var beforeCommitId: Swift.String?
        /// An array of comment objects. Each comment object contains information about a comment on the comparison between commits.
        public var comments: [CodeCommitClientTypes.Comment]?
        /// Location information about the comment on the comparison, including the file name, line number, and whether the version of the file where the comment was made is BEFORE or AFTER.
        public var location: CodeCommitClientTypes.Location?
        /// The name of the repository that contains the compared commits.
        public var repositoryName: Swift.String?

        public init (
            afterBlobId: Swift.String? = nil,
            afterCommitId: Swift.String? = nil,
            beforeBlobId: Swift.String? = nil,
            beforeCommitId: Swift.String? = nil,
            comments: [CodeCommitClientTypes.Comment]? = nil,
            location: CodeCommitClientTypes.Location? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.afterBlobId = afterBlobId
            self.afterCommitId = afterCommitId
            self.beforeBlobId = beforeBlobId
            self.beforeCommitId = beforeCommitId
            self.comments = comments
            self.location = location
            self.repositoryName = repositoryName
        }
    }

}

extension CodeCommitClientTypes.CommentsForPullRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comments
        case location
        case pullRequestId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterBlobId = self.afterBlobId {
            try encodeContainer.encode(afterBlobId, forKey: .afterBlobId)
        }
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeBlobId = self.beforeBlobId {
            try encodeContainer.encode(beforeBlobId, forKey: .beforeBlobId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let comments = comments {
            var commentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comments)
            for comment0 in comments {
                try commentsContainer.encode(comment0)
            }
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let commentsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Comment?].self, forKey: .comments)
        var commentsDecoded0:[CodeCommitClientTypes.Comment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [CodeCommitClientTypes.Comment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Returns information about comments on a pull request.
    public struct CommentsForPullRequest: Swift.Equatable {
        /// The full blob ID of the file on which you want to comment on the source commit.
        public var afterBlobId: Swift.String?
        /// The full commit ID of the commit that was the tip of the source branch at the time the comment was made.
        public var afterCommitId: Swift.String?
        /// The full blob ID of the file on which you want to comment on the destination commit.
        public var beforeBlobId: Swift.String?
        /// The full commit ID of the commit that was the tip of the destination branch when the pull request was created. This commit is superceded by the after commit in the source branch when and if you merge the source branch into the destination branch.
        public var beforeCommitId: Swift.String?
        /// An array of comment objects. Each comment object contains information about a comment on the pull request.
        public var comments: [CodeCommitClientTypes.Comment]?
        /// Location information about the comment on the pull request, including the file name, line number, and whether the version of the file where the comment was made is BEFORE (destination branch) or AFTER (source branch).
        public var location: CodeCommitClientTypes.Location?
        /// The system-generated ID of the pull request.
        public var pullRequestId: Swift.String?
        /// The name of the repository that contains the pull request.
        public var repositoryName: Swift.String?

        public init (
            afterBlobId: Swift.String? = nil,
            afterCommitId: Swift.String? = nil,
            beforeBlobId: Swift.String? = nil,
            beforeCommitId: Swift.String? = nil,
            comments: [CodeCommitClientTypes.Comment]? = nil,
            location: CodeCommitClientTypes.Location? = nil,
            pullRequestId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.afterBlobId = afterBlobId
            self.afterCommitId = afterCommitId
            self.beforeBlobId = beforeBlobId
            self.beforeCommitId = beforeCommitId
            self.comments = comments
            self.location = location
            self.pullRequestId = pullRequestId
            self.repositoryName = repositoryName
        }
    }

}

extension CodeCommitClientTypes.Commit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalData
        case author
        case commitId
        case committer
        case message
        case parents
        case treeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalData = self.additionalData {
            try encodeContainer.encode(additionalData, forKey: .additionalData)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let committer = self.committer {
            try encodeContainer.encode(committer, forKey: .committer)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let parents = parents {
            var parentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parents)
            for objectid0 in parents {
                try parentsContainer.encode(objectid0)
            }
        }
        if let treeId = self.treeId {
            try encodeContainer.encode(treeId, forKey: .treeId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let parentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parents)
        var parentsDecoded0:[Swift.String]? = nil
        if let parentsContainer = parentsContainer {
            parentsDecoded0 = [Swift.String]()
            for string0 in parentsContainer {
                if let string0 = string0 {
                    parentsDecoded0?.append(string0)
                }
            }
        }
        parents = parentsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let authorDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.UserInfo.self, forKey: .author)
        author = authorDecoded
        let committerDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.UserInfo.self, forKey: .committer)
        committer = committerDecoded
        let additionalDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalData)
        additionalData = additionalDataDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a specific commit.
    public struct Commit: Swift.Equatable {
        /// Any other data associated with the specified commit.
        public var additionalData: Swift.String?
        /// Information about the author of the specified commit. Information includes the date in timestamp format with GMT offset, the name of the author, and the email address for the author, as configured in Git.
        public var author: CodeCommitClientTypes.UserInfo?
        /// The full SHA ID of the specified commit.
        public var commitId: Swift.String?
        /// Information about the person who committed the specified commit, also known as the committer. Information includes the date in timestamp format with GMT offset, the name of the committer, and the email address for the committer, as configured in Git. For more information about the difference between an author and a committer in Git, see [Viewing the Commit History](http://git-scm.com/book/ch2-3.html) in Pro Git by Scott Chacon and Ben Straub.
        public var committer: CodeCommitClientTypes.UserInfo?
        /// The commit message associated with the specified commit.
        public var message: Swift.String?
        /// A list of parent commits for the specified commit. Each parent commit ID is the full commit ID.
        public var parents: [Swift.String]?
        /// Tree information for the specified commit.
        public var treeId: Swift.String?

        public init (
            additionalData: Swift.String? = nil,
            author: CodeCommitClientTypes.UserInfo? = nil,
            commitId: Swift.String? = nil,
            committer: CodeCommitClientTypes.UserInfo? = nil,
            message: Swift.String? = nil,
            parents: [Swift.String]? = nil,
            treeId: Swift.String? = nil
        )
        {
            self.additionalData = additionalData
            self.author = author
            self.commitId = commitId
            self.committer = committer
            self.message = message
            self.parents = parents
            self.treeId = treeId
        }
    }

}

extension CommitDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommitDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified commit does not exist or no commit was specified, and the specified repository has no default branch.
public struct CommitDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommitDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommitIdDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified commit ID does not exist.
public struct CommitIdDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommitIdDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitIdDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommitIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A commit ID was not specified.
public struct CommitIdRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommitIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdsLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommitIdsLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.
public struct CommitIdsLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommitIdsLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitIdsLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdsListRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommitIdsListRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A list of commit IDs is required, but was either not specified or the list was empty.
public struct CommitIdsListRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommitIdsListRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitIdsListRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitMessageLengthExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommitMessageLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit message is too long. Provide a shorter string.
public struct CommitMessageLengthExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommitMessageLengthExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitMessageLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CommitRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A commit was not specified.
public struct CommitRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CommitRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CommitRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentReferenceUpdateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentReferenceUpdateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.
public struct ConcurrentReferenceUpdateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentReferenceUpdateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentReferenceUpdateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.Conflict: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictMetadata
        case mergeHunks
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictMetadata = self.conflictMetadata {
            try encodeContainer.encode(conflictMetadata, forKey: .conflictMetadata)
        }
        if let mergeHunks = mergeHunks {
            var mergeHunksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mergeHunks)
            for mergehunk0 in mergeHunks {
                try mergeHunksContainer.encode(mergehunk0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictMetadata.self, forKey: .conflictMetadata)
        conflictMetadata = conflictMetadataDecoded
        let mergeHunksContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.MergeHunk?].self, forKey: .mergeHunks)
        var mergeHunksDecoded0:[CodeCommitClientTypes.MergeHunk]? = nil
        if let mergeHunksContainer = mergeHunksContainer {
            mergeHunksDecoded0 = [CodeCommitClientTypes.MergeHunk]()
            for structure0 in mergeHunksContainer {
                if let structure0 = structure0 {
                    mergeHunksDecoded0?.append(structure0)
                }
            }
        }
        mergeHunks = mergeHunksDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Information about conflicts in a merge operation.
    public struct Conflict: Swift.Equatable {
        /// Metadata about a conflict in a merge operation.
        public var conflictMetadata: CodeCommitClientTypes.ConflictMetadata?
        /// A list of hunks that contain the differences between files or lines causing the conflict.
        public var mergeHunks: [CodeCommitClientTypes.MergeHunk]?

        public init (
            conflictMetadata: CodeCommitClientTypes.ConflictMetadata? = nil,
            mergeHunks: [CodeCommitClientTypes.MergeHunk]? = nil
        )
        {
            self.conflictMetadata = conflictMetadata
            self.mergeHunks = mergeHunks
        }
    }

}

extension CodeCommitClientTypes {
    public enum ConflictDetailLevelTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fileLevel
        case lineLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictDetailLevelTypeEnum] {
            return [
                .fileLevel,
                .lineLevel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fileLevel: return "FILE_LEVEL"
            case .lineLevel: return "LINE_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictDetailLevelTypeEnum(rawValue: rawValue) ?? ConflictDetailLevelTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.ConflictMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentConflict
        case fileModeConflict
        case fileModes
        case filePath
        case fileSizes
        case isBinaryFile
        case mergeOperations
        case numberOfConflicts
        case objectTypeConflict
        case objectTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if contentConflict != false {
            try encodeContainer.encode(contentConflict, forKey: .contentConflict)
        }
        if fileModeConflict != false {
            try encodeContainer.encode(fileModeConflict, forKey: .fileModeConflict)
        }
        if let fileModes = self.fileModes {
            try encodeContainer.encode(fileModes, forKey: .fileModes)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let fileSizes = self.fileSizes {
            try encodeContainer.encode(fileSizes, forKey: .fileSizes)
        }
        if let isBinaryFile = self.isBinaryFile {
            try encodeContainer.encode(isBinaryFile, forKey: .isBinaryFile)
        }
        if let mergeOperations = self.mergeOperations {
            try encodeContainer.encode(mergeOperations, forKey: .mergeOperations)
        }
        if numberOfConflicts != 0 {
            try encodeContainer.encode(numberOfConflicts, forKey: .numberOfConflicts)
        }
        if objectTypeConflict != false {
            try encodeContainer.encode(objectTypeConflict, forKey: .objectTypeConflict)
        }
        if let objectTypes = self.objectTypes {
            try encodeContainer.encode(objectTypes, forKey: .objectTypes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileSizesDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileSizes.self, forKey: .fileSizes)
        fileSizes = fileSizesDecoded
        let fileModesDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModes.self, forKey: .fileModes)
        fileModes = fileModesDecoded
        let objectTypesDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ObjectTypes.self, forKey: .objectTypes)
        objectTypes = objectTypesDecoded
        let numberOfConflictsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfConflicts) ?? 0
        numberOfConflicts = numberOfConflictsDecoded
        let isBinaryFileDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.IsBinaryFile.self, forKey: .isBinaryFile)
        isBinaryFile = isBinaryFileDecoded
        let contentConflictDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .contentConflict) ?? false
        contentConflict = contentConflictDecoded
        let fileModeConflictDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fileModeConflict) ?? false
        fileModeConflict = fileModeConflictDecoded
        let objectTypeConflictDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .objectTypeConflict) ?? false
        objectTypeConflict = objectTypeConflictDecoded
        let mergeOperationsDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOperations.self, forKey: .mergeOperations)
        mergeOperations = mergeOperationsDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the metadata for a conflict in a merge operation.
    public struct ConflictMetadata: Swift.Equatable {
        /// A boolean value indicating whether there are conflicts in the content of a file.
        public var contentConflict: Swift.Bool
        /// A boolean value indicating whether there are conflicts in the file mode of a file.
        public var fileModeConflict: Swift.Bool
        /// The file modes of the file in the source, destination, and base of the merge.
        public var fileModes: CodeCommitClientTypes.FileModes?
        /// The path of the file that contains conflicts.
        public var filePath: Swift.String?
        /// The file sizes of the file in the source, destination, and base of the merge.
        public var fileSizes: CodeCommitClientTypes.FileSizes?
        /// A boolean value (true or false) indicating whether the file is binary or textual in the source, destination, and base of the merge.
        public var isBinaryFile: CodeCommitClientTypes.IsBinaryFile?
        /// Whether an add, modify, or delete operation caused the conflict between the source and destination of the merge.
        public var mergeOperations: CodeCommitClientTypes.MergeOperations?
        /// The number of conflicts, including both hunk conflicts and metadata conflicts.
        public var numberOfConflicts: Swift.Int
        /// A boolean value (true or false) indicating whether there are conflicts between the branches in the object type of a file, folder, or submodule.
        public var objectTypeConflict: Swift.Bool
        /// Information about any object type conflicts in a merge operation.
        public var objectTypes: CodeCommitClientTypes.ObjectTypes?

        public init (
            contentConflict: Swift.Bool = false,
            fileModeConflict: Swift.Bool = false,
            fileModes: CodeCommitClientTypes.FileModes? = nil,
            filePath: Swift.String? = nil,
            fileSizes: CodeCommitClientTypes.FileSizes? = nil,
            isBinaryFile: CodeCommitClientTypes.IsBinaryFile? = nil,
            mergeOperations: CodeCommitClientTypes.MergeOperations? = nil,
            numberOfConflicts: Swift.Int = 0,
            objectTypeConflict: Swift.Bool = false,
            objectTypes: CodeCommitClientTypes.ObjectTypes? = nil
        )
        {
            self.contentConflict = contentConflict
            self.fileModeConflict = fileModeConflict
            self.fileModes = fileModes
            self.filePath = filePath
            self.fileSizes = fileSizes
            self.isBinaryFile = isBinaryFile
            self.mergeOperations = mergeOperations
            self.numberOfConflicts = numberOfConflicts
            self.objectTypeConflict = objectTypeConflict
            self.objectTypes = objectTypes
        }
    }

}

extension CodeCommitClientTypes.ConflictResolution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteFiles
        case replaceContents
        case setFileModes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteFiles = deleteFiles {
            var deleteFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deleteFiles)
            for deletefileentry0 in deleteFiles {
                try deleteFilesContainer.encode(deletefileentry0)
            }
        }
        if let replaceContents = replaceContents {
            var replaceContentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replaceContents)
            for replacecontententry0 in replaceContents {
                try replaceContentsContainer.encode(replacecontententry0)
            }
        }
        if let setFileModes = setFileModes {
            var setFileModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .setFileModes)
            for setfilemodeentry0 in setFileModes {
                try setFileModesContainer.encode(setfilemodeentry0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replaceContentsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.ReplaceContentEntry?].self, forKey: .replaceContents)
        var replaceContentsDecoded0:[CodeCommitClientTypes.ReplaceContentEntry]? = nil
        if let replaceContentsContainer = replaceContentsContainer {
            replaceContentsDecoded0 = [CodeCommitClientTypes.ReplaceContentEntry]()
            for structure0 in replaceContentsContainer {
                if let structure0 = structure0 {
                    replaceContentsDecoded0?.append(structure0)
                }
            }
        }
        replaceContents = replaceContentsDecoded0
        let deleteFilesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.DeleteFileEntry?].self, forKey: .deleteFiles)
        var deleteFilesDecoded0:[CodeCommitClientTypes.DeleteFileEntry]? = nil
        if let deleteFilesContainer = deleteFilesContainer {
            deleteFilesDecoded0 = [CodeCommitClientTypes.DeleteFileEntry]()
            for structure0 in deleteFilesContainer {
                if let structure0 = structure0 {
                    deleteFilesDecoded0?.append(structure0)
                }
            }
        }
        deleteFiles = deleteFilesDecoded0
        let setFileModesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.SetFileModeEntry?].self, forKey: .setFileModes)
        var setFileModesDecoded0:[CodeCommitClientTypes.SetFileModeEntry]? = nil
        if let setFileModesContainer = setFileModesContainer {
            setFileModesDecoded0 = [CodeCommitClientTypes.SetFileModeEntry]()
            for structure0 in setFileModesContainer {
                if let structure0 = structure0 {
                    setFileModesDecoded0?.append(structure0)
                }
            }
        }
        setFileModes = setFileModesDecoded0
    }
}

extension CodeCommitClientTypes {
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public struct ConflictResolution: Swift.Equatable {
        /// Files to be deleted as part of the merge conflict resolution.
        public var deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]?
        /// Files to have content replaced as part of the merge conflict resolution.
        public var replaceContents: [CodeCommitClientTypes.ReplaceContentEntry]?
        /// File modes that are set as part of the merge conflict resolution.
        public var setFileModes: [CodeCommitClientTypes.SetFileModeEntry]?

        public init (
            deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]? = nil,
            replaceContents: [CodeCommitClientTypes.ReplaceContentEntry]? = nil,
            setFileModes: [CodeCommitClientTypes.SetFileModeEntry]? = nil
        )
        {
            self.deleteFiles = deleteFiles
            self.replaceContents = replaceContents
            self.setFileModes = setFileModes
        }
    }

}

extension CodeCommitClientTypes {
    public enum ConflictResolutionStrategyTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acceptDestination
        case acceptSource
        case automerge
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictResolutionStrategyTypeEnum] {
            return [
                .acceptDestination,
                .acceptSource,
                .automerge,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acceptDestination: return "ACCEPT_DESTINATION"
            case .acceptSource: return "ACCEPT_SOURCE"
            case .automerge: return "AUTOMERGE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictResolutionStrategyTypeEnum(rawValue: rawValue) ?? ConflictResolutionStrategyTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CreateApprovalRuleTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateContent
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateContent = self.approvalRuleTemplateContent {
            try encodeContainer.encode(approvalRuleTemplateContent, forKey: .approvalRuleTemplateContent)
        }
        if let approvalRuleTemplateDescription = self.approvalRuleTemplateDescription {
            try encodeContainer.encode(approvalRuleTemplateDescription, forKey: .approvalRuleTemplateDescription)
        }
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

extension CreateApprovalRuleTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApprovalRuleTemplateInput: Swift.Equatable {
    /// The content of the approval rule that is created on pull requests in associated repositories. If you specify one or more destination references (branches), approval rules are created in an associated repository only if their destination references (branches) match those specified in the template. When you create the content of the approval rule template, you can specify approvers in an approval pool in one of two ways:
    ///
    /// * CodeCommitApprovers: This option only requires an AWS account and a resource. It can be used for both IAM users and federated access users whose name matches the provided resource name. This is a very powerful option that offers a great deal of flexibility. For example, if you specify the AWS account 123456789012 and Mary_Major, all of the following are counted as approvals coming from that user:
    ///
    /// * An IAM user in the account (arn:aws:iam::123456789012:user/Mary_Major)
    ///
    /// * A federated user identified in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
    ///
    ///
    /// This option does not recognize an active session of someone assuming the role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major) unless you include a wildcard (*Mary_Major).
    ///
    /// * Fully qualified ARN: This option allows you to specify the fully qualified Amazon Resource Name (ARN) of the IAM user or role.
    ///
    ///
    /// For more information about IAM ARNs, wildcards, and formats, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var approvalRuleTemplateContent: Swift.String?
    /// The description of the approval rule template. Consider providing a description that explains what this template does and when it might be appropriate to associate it with repositories.
    public var approvalRuleTemplateDescription: Swift.String?
    /// The name of the approval rule template. Provide descriptive names, because this name is applied to the approval rules created automatically in associated repositories.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init (
        approvalRuleTemplateContent: Swift.String? = nil,
        approvalRuleTemplateDescription: Swift.String? = nil,
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateContent = approvalRuleTemplateContent
        self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct CreateApprovalRuleTemplateInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let approvalRuleTemplateContent: Swift.String?
    let approvalRuleTemplateDescription: Swift.String?
}

extension CreateApprovalRuleTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateContent
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let approvalRuleTemplateContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateContent)
        approvalRuleTemplateContent = approvalRuleTemplateContentDecoded
        let approvalRuleTemplateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateDescription)
        approvalRuleTemplateDescription = approvalRuleTemplateDescriptionDecoded
    }
}

extension CreateApprovalRuleTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApprovalRuleTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateContentRequiredException" : self = .approvalRuleTemplateContentRequiredException(try ApprovalRuleTemplateContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameAlreadyExistsException" : self = .approvalRuleTemplateNameAlreadyExistsException(try ApprovalRuleTemplateNameAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateContentException" : self = .invalidApprovalRuleTemplateContentException(try InvalidApprovalRuleTemplateContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateDescriptionException" : self = .invalidApprovalRuleTemplateDescriptionException(try InvalidApprovalRuleTemplateDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfRuleTemplatesExceededException" : self = .numberOfRuleTemplatesExceededException(try NumberOfRuleTemplatesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateApprovalRuleTemplateOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateContentRequiredException(ApprovalRuleTemplateContentRequiredException)
    case approvalRuleTemplateNameAlreadyExistsException(ApprovalRuleTemplateNameAlreadyExistsException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateContentException(InvalidApprovalRuleTemplateContentException)
    case invalidApprovalRuleTemplateDescriptionException(InvalidApprovalRuleTemplateDescriptionException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case numberOfRuleTemplatesExceededException(NumberOfRuleTemplatesExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApprovalRuleTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateApprovalRuleTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct CreateApprovalRuleTemplateOutputResponse: Swift.Equatable {
    /// The content and structure of the created approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init (
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct CreateApprovalRuleTemplateOutputResponseBody: Swift.Equatable {
    let approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?
}

extension CreateApprovalRuleTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

extension CreateBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension CreateBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a create branch operation.
public struct CreateBranchInput: Swift.Equatable {
    /// The name of the new branch to create.
    /// This member is required.
    public var branchName: Swift.String?
    /// The ID of the commit to point the new branch to.
    /// This member is required.
    public var commitId: Swift.String?
    /// The name of the repository in which you want to create the new branch.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        branchName: Swift.String? = nil,
        commitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.commitId = commitId
        self.repositoryName = repositoryName
    }
}

struct CreateBranchInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
    let commitId: Swift.String?
}

extension CreateBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
    }
}

extension CreateBranchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBranchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BranchNameExistsException" : self = .branchNameExistsException(try BranchNameExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBranchOutputError: Swift.Error, Swift.Equatable {
    case branchNameExistsException(BranchNameExistsException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBranchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateBranchOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case branchName
        case commitMessage
        case deleteFiles
        case email
        case keepEmptyFolders
        case parentCommitId
        case putFiles
        case repositoryName
        case setFileModes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let deleteFiles = deleteFiles {
            var deleteFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deleteFiles)
            for deletefileentry0 in deleteFiles {
                try deleteFilesContainer.encode(deletefileentry0)
            }
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let parentCommitId = self.parentCommitId {
            try encodeContainer.encode(parentCommitId, forKey: .parentCommitId)
        }
        if let putFiles = putFiles {
            var putFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .putFiles)
            for putfileentry0 in putFiles {
                try putFilesContainer.encode(putfileentry0)
            }
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let setFileModes = setFileModes {
            var setFileModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .setFileModes)
            for setfilemodeentry0 in setFileModes {
                try setFileModesContainer.encode(setfilemodeentry0)
            }
        }
    }
}

extension CreateCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCommitInput: Swift.Equatable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The name of the branch where you create the commit.
    /// This member is required.
    public var branchName: Swift.String?
    /// The commit message you want to include in the commit. Commit messages are limited to 256 KB. If no message is specified, a default message is used.
    public var commitMessage: Swift.String?
    /// The files to delete in this commit. These files still exist in earlier commits.
    public var deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]?
    /// The email address of the person who created the commit.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a ..gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool
    /// The ID of the commit that is the parent of the commit you create. Not required if this is an empty repository.
    public var parentCommitId: Swift.String?
    /// The files to add or update in this commit.
    public var putFiles: [CodeCommitClientTypes.PutFileEntry]?
    /// The name of the repository where you create the commit.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The file modes to update for files in this commit.
    public var setFileModes: [CodeCommitClientTypes.SetFileModeEntry]?

    public init (
        authorName: Swift.String? = nil,
        branchName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool = false,
        parentCommitId: Swift.String? = nil,
        putFiles: [CodeCommitClientTypes.PutFileEntry]? = nil,
        repositoryName: Swift.String? = nil,
        setFileModes: [CodeCommitClientTypes.SetFileModeEntry]? = nil
    )
    {
        self.authorName = authorName
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.deleteFiles = deleteFiles
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.parentCommitId = parentCommitId
        self.putFiles = putFiles
        self.repositoryName = repositoryName
        self.setFileModes = setFileModes
    }
}

struct CreateCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
    let parentCommitId: Swift.String?
    let authorName: Swift.String?
    let email: Swift.String?
    let commitMessage: Swift.String?
    let keepEmptyFolders: Swift.Bool
    let putFiles: [CodeCommitClientTypes.PutFileEntry]?
    let deleteFiles: [CodeCommitClientTypes.DeleteFileEntry]?
    let setFileModes: [CodeCommitClientTypes.SetFileModeEntry]?
}

extension CreateCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case branchName
        case commitMessage
        case deleteFiles
        case email
        case keepEmptyFolders
        case parentCommitId
        case putFiles
        case repositoryName
        case setFileModes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let parentCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentCommitId)
        parentCommitId = parentCommitIdDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders) ?? false
        keepEmptyFolders = keepEmptyFoldersDecoded
        let putFilesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.PutFileEntry?].self, forKey: .putFiles)
        var putFilesDecoded0:[CodeCommitClientTypes.PutFileEntry]? = nil
        if let putFilesContainer = putFilesContainer {
            putFilesDecoded0 = [CodeCommitClientTypes.PutFileEntry]()
            for structure0 in putFilesContainer {
                if let structure0 = structure0 {
                    putFilesDecoded0?.append(structure0)
                }
            }
        }
        putFiles = putFilesDecoded0
        let deleteFilesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.DeleteFileEntry?].self, forKey: .deleteFiles)
        var deleteFilesDecoded0:[CodeCommitClientTypes.DeleteFileEntry]? = nil
        if let deleteFilesContainer = deleteFilesContainer {
            deleteFilesDecoded0 = [CodeCommitClientTypes.DeleteFileEntry]()
            for structure0 in deleteFilesContainer {
                if let structure0 = structure0 {
                    deleteFilesDecoded0?.append(structure0)
                }
            }
        }
        deleteFiles = deleteFilesDecoded0
        let setFileModesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.SetFileModeEntry?].self, forKey: .setFileModes)
        var setFileModesDecoded0:[CodeCommitClientTypes.SetFileModeEntry]? = nil
        if let setFileModesContainer = setFileModesContainer {
            setFileModesDecoded0 = [CodeCommitClientTypes.SetFileModeEntry]()
            for structure0 in setFileModesContainer {
                if let structure0 = structure0 {
                    setFileModesDecoded0?.append(structure0)
                }
            }
        }
        setFileModes = setFileModesDecoded0
    }
}

extension CreateCommitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCommitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNameConflictsWithFileNameException" : self = .directoryNameConflictsWithFileNameException(try DirectoryNameConflictsWithFileNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentAndSourceFileSpecifiedException" : self = .fileContentAndSourceFileSpecifiedException(try FileContentAndSourceFileSpecifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileDoesNotExistException" : self = .fileDoesNotExistException(try FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileEntryRequiredException" : self = .fileEntryRequiredException(try FileEntryRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileModeRequiredException" : self = .fileModeRequiredException(try FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileNameConflictsWithDirectoryNameException" : self = .fileNameConflictsWithDirectoryNameException(try FileNameConflictsWithDirectoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilePathConflictsWithSubmodulePathException" : self = .filePathConflictsWithSubmodulePathException(try FilePathConflictsWithSubmodulePathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeletionParameterException" : self = .invalidDeletionParameterException(try InvalidDeletionParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParentCommitIdException" : self = .invalidParentCommitIdException(try InvalidParentCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileEntriesExceededException" : self = .maximumFileEntriesExceededException(try MaximumFileEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoChangeException" : self = .noChangeException(try NoChangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitDoesNotExistException" : self = .parentCommitDoesNotExistException(try ParentCommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdOutdatedException" : self = .parentCommitIdOutdatedException(try ParentCommitIdOutdatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdRequiredException" : self = .parentCommitIdRequiredException(try ParentCommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PutFileEntryConflictException" : self = .putFileEntryConflictException(try PutFileEntryConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RestrictedSourceFileException" : self = .restrictedSourceFileException(try RestrictedSourceFileException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SamePathRequestException" : self = .samePathRequestException(try SamePathRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceFileOrContentRequiredException" : self = .sourceFileOrContentRequiredException(try SourceFileOrContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCommitOutputError: Swift.Error, Swift.Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case directoryNameConflictsWithFileNameException(DirectoryNameConflictsWithFileNameException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentAndSourceFileSpecifiedException(FileContentAndSourceFileSpecifiedException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case fileDoesNotExistException(FileDoesNotExistException)
    case fileEntryRequiredException(FileEntryRequiredException)
    case fileModeRequiredException(FileModeRequiredException)
    case fileNameConflictsWithDirectoryNameException(FileNameConflictsWithDirectoryNameException)
    case filePathConflictsWithSubmodulePathException(FilePathConflictsWithSubmodulePathException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidDeletionParameterException(InvalidDeletionParameterException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidParentCommitIdException(InvalidParentCommitIdException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumFileEntriesExceededException(MaximumFileEntriesExceededException)
    case nameLengthExceededException(NameLengthExceededException)
    case noChangeException(NoChangeException)
    case parentCommitDoesNotExistException(ParentCommitDoesNotExistException)
    case parentCommitIdOutdatedException(ParentCommitIdOutdatedException)
    case parentCommitIdRequiredException(ParentCommitIdRequiredException)
    case pathRequiredException(PathRequiredException)
    case putFileEntryConflictException(PutFileEntryConflictException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case restrictedSourceFileException(RestrictedSourceFileException)
    case samePathRequestException(SamePathRequestException)
    case sourceFileOrContentRequiredException(SourceFileOrContentRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCommitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCommitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.filesAdded = output.filesAdded
            self.filesDeleted = output.filesDeleted
            self.filesUpdated = output.filesUpdated
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.filesAdded = nil
            self.filesDeleted = nil
            self.filesUpdated = nil
            self.treeId = nil
        }
    }
}

public struct CreateCommitOutputResponse: Swift.Equatable {
    /// The full commit ID of the commit that contains your committed file changes.
    public var commitId: Swift.String?
    /// The files added as part of the committed file changes.
    public var filesAdded: [CodeCommitClientTypes.FileMetadata]?
    /// The files deleted as part of the committed file changes.
    public var filesDeleted: [CodeCommitClientTypes.FileMetadata]?
    /// The files updated as part of the commited file changes.
    public var filesUpdated: [CodeCommitClientTypes.FileMetadata]?
    /// The full SHA-1 pointer of the tree information for the commit that contains the commited file changes.
    public var treeId: Swift.String?

    public init (
        commitId: Swift.String? = nil,
        filesAdded: [CodeCommitClientTypes.FileMetadata]? = nil,
        filesDeleted: [CodeCommitClientTypes.FileMetadata]? = nil,
        filesUpdated: [CodeCommitClientTypes.FileMetadata]? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.filesAdded = filesAdded
        self.filesDeleted = filesDeleted
        self.filesUpdated = filesUpdated
        self.treeId = treeId
    }
}

struct CreateCommitOutputResponseBody: Swift.Equatable {
    let commitId: Swift.String?
    let treeId: Swift.String?
    let filesAdded: [CodeCommitClientTypes.FileMetadata]?
    let filesUpdated: [CodeCommitClientTypes.FileMetadata]?
    let filesDeleted: [CodeCommitClientTypes.FileMetadata]?
}

extension CreateCommitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case filesAdded
        case filesDeleted
        case filesUpdated
        case treeId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let filesAddedContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.FileMetadata?].self, forKey: .filesAdded)
        var filesAddedDecoded0:[CodeCommitClientTypes.FileMetadata]? = nil
        if let filesAddedContainer = filesAddedContainer {
            filesAddedDecoded0 = [CodeCommitClientTypes.FileMetadata]()
            for structure0 in filesAddedContainer {
                if let structure0 = structure0 {
                    filesAddedDecoded0?.append(structure0)
                }
            }
        }
        filesAdded = filesAddedDecoded0
        let filesUpdatedContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.FileMetadata?].self, forKey: .filesUpdated)
        var filesUpdatedDecoded0:[CodeCommitClientTypes.FileMetadata]? = nil
        if let filesUpdatedContainer = filesUpdatedContainer {
            filesUpdatedDecoded0 = [CodeCommitClientTypes.FileMetadata]()
            for structure0 in filesUpdatedContainer {
                if let structure0 = structure0 {
                    filesUpdatedDecoded0?.append(structure0)
                }
            }
        }
        filesUpdated = filesUpdatedDecoded0
        let filesDeletedContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.FileMetadata?].self, forKey: .filesDeleted)
        var filesDeletedDecoded0:[CodeCommitClientTypes.FileMetadata]? = nil
        if let filesDeletedContainer = filesDeletedContainer {
            filesDeletedDecoded0 = [CodeCommitClientTypes.FileMetadata]()
            for structure0 in filesDeletedContainer {
                if let structure0 = structure0 {
                    filesDeletedDecoded0?.append(structure0)
                }
            }
        }
        filesDeleted = filesDeletedDecoded0
    }
}

extension CreatePullRequestApprovalRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleContent
        case approvalRuleName
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleContent = self.approvalRuleContent {
            try encodeContainer.encode(approvalRuleContent, forKey: .approvalRuleContent)
        }
        if let approvalRuleName = self.approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension CreatePullRequestApprovalRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePullRequestApprovalRuleInput: Swift.Equatable {
    /// The content of the approval rule, including the number of approvals needed and the structure of an approval pool defined for approvals, if any. For more information about approval pools, see the AWS CodeCommit User Guide. When you create the content of the approval rule, you can specify approvers in an approval pool in one of two ways:
    ///
    /// * CodeCommitApprovers: This option only requires an AWS account and a resource. It can be used for both IAM users and federated access users whose name matches the provided resource name. This is a very powerful option that offers a great deal of flexibility. For example, if you specify the AWS account 123456789012 and Mary_Major, all of the following would be counted as approvals coming from that user:
    ///
    /// * An IAM user in the account (arn:aws:iam::123456789012:user/Mary_Major)
    ///
    /// * A federated user identified in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
    ///
    ///
    /// This option does not recognize an active session of someone assuming the role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major) unless you include a wildcard (*Mary_Major).
    ///
    /// * Fully qualified ARN: This option allows you to specify the fully qualified Amazon Resource Name (ARN) of the IAM user or role.
    ///
    ///
    /// For more information about IAM ARNs, wildcards, and formats, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var approvalRuleContent: Swift.String?
    /// The name for the approval rule.
    /// This member is required.
    public var approvalRuleName: Swift.String?
    /// The system-generated ID of the pull request for which you want to create the approval rule.
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init (
        approvalRuleContent: Swift.String? = nil,
        approvalRuleName: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.approvalRuleContent = approvalRuleContent
        self.approvalRuleName = approvalRuleName
        self.pullRequestId = pullRequestId
    }
}

struct CreatePullRequestApprovalRuleInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let approvalRuleName: Swift.String?
    let approvalRuleContent: Swift.String?
}

extension CreatePullRequestApprovalRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleContent
        case approvalRuleName
        case pullRequestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let approvalRuleContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleContent)
        approvalRuleContent = approvalRuleContentDecoded
    }
}

extension CreatePullRequestApprovalRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePullRequestApprovalRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleContentRequiredException" : self = .approvalRuleContentRequiredException(try ApprovalRuleContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleNameAlreadyExistsException" : self = .approvalRuleNameAlreadyExistsException(try ApprovalRuleNameAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleNameRequiredException" : self = .approvalRuleNameRequiredException(try ApprovalRuleNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleContentException" : self = .invalidApprovalRuleContentException(try InvalidApprovalRuleContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleNameException" : self = .invalidApprovalRuleNameException(try InvalidApprovalRuleNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfRulesExceededException" : self = .numberOfRulesExceededException(try NumberOfRulesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePullRequestApprovalRuleOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleContentRequiredException(ApprovalRuleContentRequiredException)
    case approvalRuleNameAlreadyExistsException(ApprovalRuleNameAlreadyExistsException)
    case approvalRuleNameRequiredException(ApprovalRuleNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleContentException(InvalidApprovalRuleContentException)
    case invalidApprovalRuleNameException(InvalidApprovalRuleNameException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case numberOfRulesExceededException(NumberOfRulesExceededException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePullRequestApprovalRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePullRequestApprovalRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRule = output.approvalRule
        } else {
            self.approvalRule = nil
        }
    }
}

public struct CreatePullRequestApprovalRuleOutputResponse: Swift.Equatable {
    /// Information about the created approval rule.
    /// This member is required.
    public var approvalRule: CodeCommitClientTypes.ApprovalRule?

    public init (
        approvalRule: CodeCommitClientTypes.ApprovalRule? = nil
    )
    {
        self.approvalRule = approvalRule
    }
}

struct CreatePullRequestApprovalRuleOutputResponseBody: Swift.Equatable {
    let approvalRule: CodeCommitClientTypes.ApprovalRule?
}

extension CreatePullRequestApprovalRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRule
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRule.self, forKey: .approvalRule)
        approvalRule = approvalRuleDecoded
    }
}

extension CreatePullRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case description
        case targets
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension CreatePullRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePullRequestInput: Swift.Equatable {
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token. The AWS SDKs prepopulate client request tokens. If you are using an AWS SDK, an idempotency token is created for you.
    public var clientRequestToken: Swift.String?
    /// A description of the pull request.
    public var description: Swift.String?
    /// The targets for the pull request, including the source of the code to be reviewed (the source branch) and the destination where the creator of the pull request intends the code to be merged after the pull request is closed (the destination branch).
    /// This member is required.
    public var targets: [CodeCommitClientTypes.Target]?
    /// The title of the pull request. This title is used to identify the pull request to other users in the repository.
    /// This member is required.
    public var title: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        targets: [CodeCommitClientTypes.Target]? = nil,
        title: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.targets = targets
        self.title = title
    }
}

struct CreatePullRequestInputBody: Swift.Equatable {
    let title: Swift.String?
    let description: Swift.String?
    let targets: [CodeCommitClientTypes.Target]?
    let clientRequestToken: Swift.String?
}

extension CreatePullRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case description
        case targets
        case title
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[CodeCommitClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [CodeCommitClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreatePullRequestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePullRequestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientRequestTokenRequiredException" : self = .clientRequestTokenRequiredException(try ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyParameterMismatchException" : self = .idempotencyParameterMismatchException(try IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientRequestTokenException" : self = .invalidClientRequestTokenException(try InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDescriptionException" : self = .invalidDescriptionException(try InvalidDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReferenceNameException" : self = .invalidReferenceNameException(try InvalidReferenceNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetException" : self = .invalidTargetException(try InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetsException" : self = .invalidTargetsException(try InvalidTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTitleException" : self = .invalidTitleException(try InvalidTitleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumOpenPullRequestsExceededException" : self = .maximumOpenPullRequestsExceededException(try MaximumOpenPullRequestsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleRepositoriesInPullRequestException" : self = .multipleRepositoriesInPullRequestException(try MultipleRepositoriesInPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferenceDoesNotExistException" : self = .referenceDoesNotExistException(try ReferenceDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferenceNameRequiredException" : self = .referenceNameRequiredException(try ReferenceNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferenceTypeNotSupportedException" : self = .referenceTypeNotSupportedException(try ReferenceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceAndDestinationAreSameException" : self = .sourceAndDestinationAreSameException(try SourceAndDestinationAreSameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetRequiredException" : self = .targetRequiredException(try TargetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetsRequiredException" : self = .targetsRequiredException(try TargetsRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TitleRequiredException" : self = .titleRequiredException(try TitleRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePullRequestOutputError: Swift.Error, Swift.Equatable {
    case clientRequestTokenRequiredException(ClientRequestTokenRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case idempotencyParameterMismatchException(IdempotencyParameterMismatchException)
    case invalidClientRequestTokenException(InvalidClientRequestTokenException)
    case invalidDescriptionException(InvalidDescriptionException)
    case invalidReferenceNameException(InvalidReferenceNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidTargetException(InvalidTargetException)
    case invalidTargetsException(InvalidTargetsException)
    case invalidTitleException(InvalidTitleException)
    case maximumOpenPullRequestsExceededException(MaximumOpenPullRequestsExceededException)
    case multipleRepositoriesInPullRequestException(MultipleRepositoriesInPullRequestException)
    case referenceDoesNotExistException(ReferenceDoesNotExistException)
    case referenceNameRequiredException(ReferenceNameRequiredException)
    case referenceTypeNotSupportedException(ReferenceTypeNotSupportedException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case sourceAndDestinationAreSameException(SourceAndDestinationAreSameException)
    case targetRequiredException(TargetRequiredException)
    case targetsRequiredException(TargetsRequiredException)
    case titleRequiredException(TitleRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePullRequestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePullRequestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct CreatePullRequestOutputResponse: Swift.Equatable {
    /// Information about the newly created pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init (
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct CreatePullRequestOutputResponseBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension CreatePullRequestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

extension CreateRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryDescription
        case repositoryName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryDescription = self.repositoryDescription {
            try encodeContainer.encode(repositoryDescription, forKey: .repositoryDescription)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a create repository operation.
public struct CreateRepositoryInput: Swift.Equatable {
    /// A comment or description about the new repository. The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a webpage can expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a webpage.
    public var repositoryDescription: Swift.String?
    /// The name of the new repository to be created. The repository name must be unique across the calling AWS account. Repository names are limited to 100 alphanumeric, dash, and underscore characters, and cannot include certain characters. For more information about the limits on repository names, see [Limits](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html) in the AWS CodeCommit User Guide. The suffix .git is prohibited.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// One or more tag key-value pairs to use when tagging this repository.
    public var tags: [Swift.String:Swift.String]?

    public init (
        repositoryDescription: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.repositoryDescription = repositoryDescription
        self.repositoryName = repositoryName
        self.tags = tags
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let repositoryDescription: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryDescription
        case repositoryName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryDescription)
        repositoryDescription = repositoryDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryDescriptionException" : self = .invalidRepositoryDescriptionException(try InvalidRepositoryDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSystemTagUsageException" : self = .invalidSystemTagUsageException(try InvalidSystemTagUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsMapException" : self = .invalidTagsMapException(try InvalidTagsMapException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryLimitExceededException" : self = .repositoryLimitExceededException(try RepositoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameExistsException" : self = .repositoryNameExistsException(try RepositoryNameExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryDescriptionException(InvalidRepositoryDescriptionException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidSystemTagUsageException(InvalidSystemTagUsageException)
    case invalidTagsMapException(InvalidTagsMapException)
    case repositoryLimitExceededException(RepositoryLimitExceededException)
    case repositoryNameExistsException(RepositoryNameExistsException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tagPolicyException(TagPolicyException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryMetadata = output.repositoryMetadata
        } else {
            self.repositoryMetadata = nil
        }
    }
}

/// Represents the output of a create repository operation.
public struct CreateRepositoryOutputResponse: Swift.Equatable {
    /// Information about the newly created repository.
    public var repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata?

    public init (
        repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata? = nil
    )
    {
        self.repositoryMetadata = repositoryMetadata
    }
}

struct CreateRepositoryOutputResponseBody: Swift.Equatable {
    let repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata?
}

extension CreateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryMetadata
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.RepositoryMetadata.self, forKey: .repositoryMetadata)
        repositoryMetadata = repositoryMetadataDecoded
    }
}

extension CreateUnreferencedMergeCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case mergeOption
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let mergeOption = self.mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension CreateUnreferencedMergeCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUnreferencedMergeCommitInput: Swift.Equatable {
    /// The name of the author who created the unreferenced commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message for the unreferenced commit.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The email address for the person who created the unreferenced commit.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If this is specified as true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// The name of the repository where you want to create the unreferenced merge commit.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init (
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool = false,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.mergeOption = mergeOption
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct CreateUnreferencedMergeCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let authorName: Swift.String?
    let email: Swift.String?
    let commitMessage: Swift.String?
    let keepEmptyFolders: Swift.Bool
    let conflictResolution: CodeCommitClientTypes.ConflictResolution?
}

extension CreateUnreferencedMergeCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case mergeOption
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders) ?? false
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension CreateUnreferencedMergeCommitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUnreferencedMergeCommitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileModeRequiredException" : self = .fileModeRequiredException(try FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionException" : self = .invalidConflictResolutionException(try InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMergeOptionException" : self = .invalidMergeOptionException(try InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementContentException" : self = .invalidReplacementContentException(try InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementTypeException" : self = .invalidReplacementTypeException(try InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumConflictResolutionEntriesExceededException" : self = .maximumConflictResolutionEntriesExceededException(try MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MergeOptionRequiredException" : self = .mergeOptionRequiredException(try MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleConflictResolutionEntriesException" : self = .multipleConflictResolutionEntriesException(try MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementContentRequiredException" : self = .replacementContentRequiredException(try ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementTypeRequiredException" : self = .replacementTypeRequiredException(try ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUnreferencedMergeCommitOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case commitRequiredException(CommitRequiredException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case fileModeRequiredException(FileModeRequiredException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionException(InvalidConflictResolutionException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidMergeOptionException(InvalidMergeOptionException)
    case invalidPathException(InvalidPathException)
    case invalidReplacementContentException(InvalidReplacementContentException)
    case invalidReplacementTypeException(InvalidReplacementTypeException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case maximumConflictResolutionEntriesExceededException(MaximumConflictResolutionEntriesExceededException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case mergeOptionRequiredException(MergeOptionRequiredException)
    case multipleConflictResolutionEntriesException(MultipleConflictResolutionEntriesException)
    case nameLengthExceededException(NameLengthExceededException)
    case pathRequiredException(PathRequiredException)
    case replacementContentRequiredException(ReplacementContentRequiredException)
    case replacementTypeRequiredException(ReplacementTypeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUnreferencedMergeCommitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUnreferencedMergeCommitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct CreateUnreferencedMergeCommitOutputResponse: Swift.Equatable {
    /// The full commit ID of the commit that contains your merge results.
    public var commitId: Swift.String?
    /// The full SHA-1 pointer of the tree information for the commit that contains the merge results.
    public var treeId: Swift.String?

    public init (
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct CreateUnreferencedMergeCommitOutputResponseBody: Swift.Equatable {
    let commitId: Swift.String?
    let treeId: Swift.String?
}

extension CreateUnreferencedMergeCommitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case treeId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

extension DefaultBranchCannotBeDeletedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DefaultBranchCannotBeDeletedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.
public struct DefaultBranchCannotBeDeletedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DefaultBranchCannotBeDeletedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DefaultBranchCannotBeDeletedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteApprovalRuleTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

extension DeleteApprovalRuleTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApprovalRuleTemplateInput: Swift.Equatable {
    /// The name of the approval rule template to delete.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init (
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct DeleteApprovalRuleTemplateInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
}

extension DeleteApprovalRuleTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
    }
}

extension DeleteApprovalRuleTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApprovalRuleTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateInUseException" : self = .approvalRuleTemplateInUseException(try ApprovalRuleTemplateInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApprovalRuleTemplateOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateInUseException(ApprovalRuleTemplateInUseException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApprovalRuleTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteApprovalRuleTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplateId = output.approvalRuleTemplateId
        } else {
            self.approvalRuleTemplateId = nil
        }
    }
}

public struct DeleteApprovalRuleTemplateOutputResponse: Swift.Equatable {
    /// The system-generated ID of the deleted approval rule template. If the template has been previously deleted, the only response is a 200 OK.
    /// This member is required.
    public var approvalRuleTemplateId: Swift.String?

    public init (
        approvalRuleTemplateId: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateId = approvalRuleTemplateId
    }
}

struct DeleteApprovalRuleTemplateOutputResponseBody: Swift.Equatable {
    let approvalRuleTemplateId: Swift.String?
}

extension DeleteApprovalRuleTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateId)
        approvalRuleTemplateId = approvalRuleTemplateIdDecoded
    }
}

extension DeleteBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a delete branch operation.
public struct DeleteBranchInput: Swift.Equatable {
    /// The name of the branch to delete.
    /// This member is required.
    public var branchName: Swift.String?
    /// The name of the repository that contains the branch to be deleted.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        branchName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.repositoryName = repositoryName
    }
}

struct DeleteBranchInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
}

extension DeleteBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension DeleteBranchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBranchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DefaultBranchCannotBeDeletedException" : self = .defaultBranchCannotBeDeletedException(try DefaultBranchCannotBeDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBranchOutputError: Swift.Error, Swift.Equatable {
    case branchNameRequiredException(BranchNameRequiredException)
    case defaultBranchCannotBeDeletedException(DefaultBranchCannotBeDeletedException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBranchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBranchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletedBranch = output.deletedBranch
        } else {
            self.deletedBranch = nil
        }
    }
}

/// Represents the output of a delete branch operation.
public struct DeleteBranchOutputResponse: Swift.Equatable {
    /// Information about the branch deleted by the operation, including the branch name and the commit ID that was the tip of the branch.
    public var deletedBranch: CodeCommitClientTypes.BranchInfo?

    public init (
        deletedBranch: CodeCommitClientTypes.BranchInfo? = nil
    )
    {
        self.deletedBranch = deletedBranch
    }
}

struct DeleteBranchOutputResponseBody: Swift.Equatable {
    let deletedBranch: CodeCommitClientTypes.BranchInfo?
}

extension DeleteBranchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletedBranch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedBranchDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.BranchInfo.self, forKey: .deletedBranch)
        deletedBranch = deletedBranchDecoded
    }
}

extension DeleteCommentContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
    }
}

extension DeleteCommentContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCommentContentInput: Swift.Equatable {
    /// The unique, system-generated ID of the comment. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var commentId: Swift.String?

    public init (
        commentId: Swift.String? = nil
    )
    {
        self.commentId = commentId
    }
}

struct DeleteCommentContentInputBody: Swift.Equatable {
    let commentId: Swift.String?
}

extension DeleteCommentContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
    }
}

extension DeleteCommentContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCommentContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommentDeletedException" : self = .commentDeletedException(try CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCommentContentOutputError: Swift.Error, Swift.Equatable {
    case commentDeletedException(CommentDeletedException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case invalidCommentIdException(InvalidCommentIdException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCommentContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteCommentContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct DeleteCommentContentOutputResponse: Swift.Equatable {
    /// Information about the comment you just deleted.
    public var comment: CodeCommitClientTypes.Comment?

    public init (
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct DeleteCommentContentOutputResponseBody: Swift.Equatable {
    let comment: CodeCommitClientTypes.Comment?
}

extension DeleteCommentContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CodeCommitClientTypes.DeleteFileEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

extension CodeCommitClientTypes {
    /// A file that is deleted as part of a commit.
    public struct DeleteFileEntry: Swift.Equatable {
        /// The full path of the file to be deleted, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?

        public init (
            filePath: Swift.String? = nil
        )
        {
            self.filePath = filePath
        }
    }

}

extension DeleteFileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitMessage
        case email
        case filePath
        case keepEmptyFolders
        case name
        case parentCommitId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentCommitId = self.parentCommitId {
            try encodeContainer.encode(parentCommitId, forKey: .parentCommitId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteFileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFileInput: Swift.Equatable {
    /// The name of the branch where the commit that deletes the file is made.
    /// This member is required.
    public var branchName: Swift.String?
    /// The commit message you want to include as part of deleting the file. Commit messages are limited to 256 KB. If no message is specified, a default message is used.
    public var commitMessage: Swift.String?
    /// The email address for the commit that deletes the file. If no email address is specified, the email address is left blank.
    public var email: Swift.String?
    /// The fully qualified path to the file that to be deleted, including the full name and extension of that file. For example, /examples/file.md is a fully qualified path to a file named file.md in a folder named examples.
    /// This member is required.
    public var filePath: Swift.String?
    /// If a file is the only object in the folder or directory, specifies whether to delete the folder or directory that contains the file. By default, empty folders are deleted. This includes empty folders that are part of the directory structure. For example, if the path to a file is dir1/dir2/dir3/dir4, and dir2 and dir3 are empty, deleting the last file in dir4 also deletes the empty folders dir4, dir3, and dir2.
    public var keepEmptyFolders: Swift.Bool
    /// The name of the author of the commit that deletes the file. If no name is specified, the user's ARN is used as the author name and committer name.
    public var name: Swift.String?
    /// The ID of the commit that is the tip of the branch where you want to create the commit that deletes the file. This must be the HEAD commit for the branch. The commit that deletes the file is created from this commit ID.
    /// This member is required.
    public var parentCommitId: Swift.String?
    /// The name of the repository that contains the file to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        branchName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        email: Swift.String? = nil,
        filePath: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool = false,
        name: Swift.String? = nil,
        parentCommitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.email = email
        self.filePath = filePath
        self.keepEmptyFolders = keepEmptyFolders
        self.name = name
        self.parentCommitId = parentCommitId
        self.repositoryName = repositoryName
    }
}

struct DeleteFileInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
    let filePath: Swift.String?
    let parentCommitId: Swift.String?
    let keepEmptyFolders: Swift.Bool
    let commitMessage: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
}

extension DeleteFileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitMessage
        case email
        case filePath
        case keepEmptyFolders
        case name
        case parentCommitId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let parentCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentCommitId)
        parentCommitId = parentCommitIdDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders) ?? false
        keepEmptyFolders = keepEmptyFoldersDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension DeleteFileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileDoesNotExistException" : self = .fileDoesNotExistException(try FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParentCommitIdException" : self = .invalidParentCommitIdException(try InvalidParentCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitDoesNotExistException" : self = .parentCommitDoesNotExistException(try ParentCommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdOutdatedException" : self = .parentCommitIdOutdatedException(try ParentCommitIdOutdatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdRequiredException" : self = .parentCommitIdRequiredException(try ParentCommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFileOutputError: Swift.Error, Swift.Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileDoesNotExistException(FileDoesNotExistException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidEmailException(InvalidEmailException)
    case invalidParentCommitIdException(InvalidParentCommitIdException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case nameLengthExceededException(NameLengthExceededException)
    case parentCommitDoesNotExistException(ParentCommitDoesNotExistException)
    case parentCommitIdOutdatedException(ParentCommitIdOutdatedException)
    case parentCommitIdRequiredException(ParentCommitIdRequiredException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteFileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.blobId = output.blobId
            self.commitId = output.commitId
            self.filePath = output.filePath
            self.treeId = output.treeId
        } else {
            self.blobId = nil
            self.commitId = nil
            self.filePath = nil
            self.treeId = nil
        }
    }
}

public struct DeleteFileOutputResponse: Swift.Equatable {
    /// The blob ID removed from the tree as part of deleting the file.
    /// This member is required.
    public var blobId: Swift.String?
    /// The full commit ID of the commit that contains the change that deletes the file.
    /// This member is required.
    public var commitId: Swift.String?
    /// The fully qualified path to the file to be deleted, including the full name and extension of that file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The full SHA-1 pointer of the tree information for the commit that contains the delete file change.
    /// This member is required.
    public var treeId: Swift.String?

    public init (
        blobId: Swift.String? = nil,
        commitId: Swift.String? = nil,
        filePath: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.filePath = filePath
        self.treeId = treeId
    }
}

struct DeleteFileOutputResponseBody: Swift.Equatable {
    let commitId: Swift.String?
    let blobId: Swift.String?
    let treeId: Swift.String?
    let filePath: Swift.String?
}

extension DeleteFileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case commitId
        case filePath
        case treeId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

extension DeletePullRequestApprovalRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleName
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleName = self.approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension DeletePullRequestApprovalRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePullRequestApprovalRuleInput: Swift.Equatable {
    /// The name of the approval rule you want to delete.
    /// This member is required.
    public var approvalRuleName: Swift.String?
    /// The system-generated ID of the pull request that contains the approval rule you want to delete.
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init (
        approvalRuleName: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.approvalRuleName = approvalRuleName
        self.pullRequestId = pullRequestId
    }
}

struct DeletePullRequestApprovalRuleInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let approvalRuleName: Swift.String?
}

extension DeletePullRequestApprovalRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleName
        case pullRequestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
    }
}

extension DeletePullRequestApprovalRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePullRequestApprovalRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleNameRequiredException" : self = .approvalRuleNameRequiredException(try ApprovalRuleNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotDeleteApprovalRuleFromTemplateException" : self = .cannotDeleteApprovalRuleFromTemplateException(try CannotDeleteApprovalRuleFromTemplateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleNameException" : self = .invalidApprovalRuleNameException(try InvalidApprovalRuleNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePullRequestApprovalRuleOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleNameRequiredException(ApprovalRuleNameRequiredException)
    case cannotDeleteApprovalRuleFromTemplateException(CannotDeleteApprovalRuleFromTemplateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleNameException(InvalidApprovalRuleNameException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePullRequestApprovalRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeletePullRequestApprovalRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleId = output.approvalRuleId
        } else {
            self.approvalRuleId = nil
        }
    }
}

public struct DeletePullRequestApprovalRuleOutputResponse: Swift.Equatable {
    /// The ID of the deleted approval rule. If the approval rule was deleted in an earlier API call, the response is 200 OK without content.
    /// This member is required.
    public var approvalRuleId: Swift.String?

    public init (
        approvalRuleId: Swift.String? = nil
    )
    {
        self.approvalRuleId = approvalRuleId
    }
}

struct DeletePullRequestApprovalRuleOutputResponseBody: Swift.Equatable {
    let approvalRuleId: Swift.String?
}

extension DeletePullRequestApprovalRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleId)
        approvalRuleId = approvalRuleIdDecoded
    }
}

extension DeleteRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a delete repository operation.
public struct DeleteRepositoryInput: Swift.Equatable {
    /// The name of the repository to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
}

extension DeleteRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRepositoryOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryId = output.repositoryId
        } else {
            self.repositoryId = nil
        }
    }
}

/// Represents the output of a delete repository operation.
public struct DeleteRepositoryOutputResponse: Swift.Equatable {
    /// The ID of the repository that was deleted.
    public var repositoryId: Swift.String?

    public init (
        repositoryId: Swift.String? = nil
    )
    {
        self.repositoryId = repositoryId
    }
}

struct DeleteRepositoryOutputResponseBody: Swift.Equatable {
    let repositoryId: Swift.String?
}

extension DeleteRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
    }
}

extension DescribeMergeConflictsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePath
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let maxMergeHunks = self.maxMergeHunks {
            try encodeContainer.encode(maxMergeHunks, forKey: .maxMergeHunks)
        }
        if let mergeOption = self.mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension DescribeMergeConflictsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMergeConflictsInput: Swift.Equatable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The path of the target files used to describe the conflicts.
    /// This member is required.
    public var filePath: Swift.String?
    /// The maximum number of merge hunks to include in the output.
    public var maxMergeHunks: Swift.Int?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where you want to get information about a merge conflict.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init (
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        filePath: Swift.String? = nil,
        maxMergeHunks: Swift.Int? = nil,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.filePath = filePath
        self.maxMergeHunks = maxMergeHunks
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct DescribeMergeConflictsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    let maxMergeHunks: Swift.Int?
    let filePath: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let nextToken: Swift.String?
}

extension DescribeMergeConflictsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePath
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let maxMergeHunksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxMergeHunks)
        maxMergeHunks = maxMergeHunksDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMergeConflictsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMergeConflictsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileDoesNotExistException" : self = .fileDoesNotExistException(try FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxMergeHunksException" : self = .invalidMaxMergeHunksException(try InvalidMaxMergeHunksException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMergeOptionException" : self = .invalidMergeOptionException(try InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MergeOptionRequiredException" : self = .mergeOptionRequiredException(try MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMergeConflictsOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileDoesNotExistException(FileDoesNotExistException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxMergeHunksException(InvalidMaxMergeHunksException)
    case invalidMergeOptionException(InvalidMergeOptionException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case mergeOptionRequiredException(MergeOptionRequiredException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMergeConflictsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMergeConflictsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baseCommitId = output.baseCommitId
            self.conflictMetadata = output.conflictMetadata
            self.destinationCommitId = output.destinationCommitId
            self.mergeHunks = output.mergeHunks
            self.nextToken = output.nextToken
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.conflictMetadata = nil
            self.destinationCommitId = nil
            self.mergeHunks = nil
            self.nextToken = nil
            self.sourceCommitId = nil
        }
    }
}

public struct DescribeMergeConflictsOutputResponse: Swift.Equatable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// Contains metadata about the conflicts found in the merge.
    /// This member is required.
    public var conflictMetadata: CodeCommitClientTypes.ConflictMetadata?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// A list of merge hunks of the differences between the files or lines.
    /// This member is required.
    public var mergeHunks: [CodeCommitClientTypes.MergeHunk]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init (
        baseCommitId: Swift.String? = nil,
        conflictMetadata: CodeCommitClientTypes.ConflictMetadata? = nil,
        destinationCommitId: Swift.String? = nil,
        mergeHunks: [CodeCommitClientTypes.MergeHunk]? = nil,
        nextToken: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflictMetadata = conflictMetadata
        self.destinationCommitId = destinationCommitId
        self.mergeHunks = mergeHunks
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

struct DescribeMergeConflictsOutputResponseBody: Swift.Equatable {
    let conflictMetadata: CodeCommitClientTypes.ConflictMetadata?
    let mergeHunks: [CodeCommitClientTypes.MergeHunk]?
    let nextToken: Swift.String?
    let destinationCommitId: Swift.String?
    let sourceCommitId: Swift.String?
    let baseCommitId: Swift.String?
}

extension DescribeMergeConflictsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCommitId
        case conflictMetadata
        case destinationCommitId
        case mergeHunks
        case nextToken
        case sourceCommitId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictMetadata.self, forKey: .conflictMetadata)
        conflictMetadata = conflictMetadataDecoded
        let mergeHunksContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.MergeHunk?].self, forKey: .mergeHunks)
        var mergeHunksDecoded0:[CodeCommitClientTypes.MergeHunk]? = nil
        if let mergeHunksContainer = mergeHunksContainer {
            mergeHunksDecoded0 = [CodeCommitClientTypes.MergeHunk]()
            for structure0 in mergeHunksContainer {
                if let structure0 = structure0 {
                    mergeHunksDecoded0?.append(structure0)
                }
            }
        }
        mergeHunks = mergeHunksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
    }
}

extension DescribePullRequestEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actorArn
        case maxResults
        case nextToken
        case pullRequestEventType
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actorArn = self.actorArn {
            try encodeContainer.encode(actorArn, forKey: .actorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pullRequestEventType = self.pullRequestEventType {
            try encodeContainer.encode(pullRequestEventType.rawValue, forKey: .pullRequestEventType)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension DescribePullRequestEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePullRequestEventsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user whose actions resulted in the event. Examples include updating the pull request with more commits or changing the status of a pull request.
    public var actorArn: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is 100 events, which is also the maximum number of events that can be returned in a result.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// Optional. The pull request event type about which you want to return information.
    public var pullRequestEventType: CodeCommitClientTypes.PullRequestEventType?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init (
        actorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pullRequestEventType: CodeCommitClientTypes.PullRequestEventType? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.actorArn = actorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestEventType = pullRequestEventType
        self.pullRequestId = pullRequestId
    }
}

struct DescribePullRequestEventsInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let pullRequestEventType: CodeCommitClientTypes.PullRequestEventType?
    let actorArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribePullRequestEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actorArn
        case maxResults
        case nextToken
        case pullRequestEventType
        case pullRequestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let pullRequestEventTypeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestEventType.self, forKey: .pullRequestEventType)
        pullRequestEventType = pullRequestEventTypeDecoded
        let actorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actorArn)
        actorArn = actorArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribePullRequestEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePullRequestEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActorDoesNotExistException" : self = .actorDoesNotExistException(try ActorDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidActorArnException" : self = .invalidActorArnException(try InvalidActorArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestEventTypeException" : self = .invalidPullRequestEventTypeException(try InvalidPullRequestEventTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePullRequestEventsOutputError: Swift.Error, Swift.Equatable {
    case actorDoesNotExistException(ActorDoesNotExistException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidActorArnException(InvalidActorArnException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidPullRequestEventTypeException(InvalidPullRequestEventTypeException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePullRequestEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePullRequestEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pullRequestEvents = output.pullRequestEvents
        } else {
            self.nextToken = nil
            self.pullRequestEvents = nil
        }
    }
}

public struct DescribePullRequestEventsOutputResponse: Swift.Equatable {
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// Information about the pull request events.
    /// This member is required.
    public var pullRequestEvents: [CodeCommitClientTypes.PullRequestEvent]?

    public init (
        nextToken: Swift.String? = nil,
        pullRequestEvents: [CodeCommitClientTypes.PullRequestEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.pullRequestEvents = pullRequestEvents
    }
}

struct DescribePullRequestEventsOutputResponseBody: Swift.Equatable {
    let pullRequestEvents: [CodeCommitClientTypes.PullRequestEvent]?
    let nextToken: Swift.String?
}

extension DescribePullRequestEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case pullRequestEvents
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestEventsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.PullRequestEvent?].self, forKey: .pullRequestEvents)
        var pullRequestEventsDecoded0:[CodeCommitClientTypes.PullRequestEvent]? = nil
        if let pullRequestEventsContainer = pullRequestEventsContainer {
            pullRequestEventsDecoded0 = [CodeCommitClientTypes.PullRequestEvent]()
            for structure0 in pullRequestEventsContainer {
                if let structure0 = structure0 {
                    pullRequestEventsDecoded0?.append(structure0)
                }
            }
        }
        pullRequestEvents = pullRequestEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CodeCommitClientTypes.Difference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterBlob
        case beforeBlob
        case changeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterBlob = self.afterBlob {
            try encodeContainer.encode(afterBlob, forKey: .afterBlob)
        }
        if let beforeBlob = self.beforeBlob {
            try encodeContainer.encode(beforeBlob, forKey: .beforeBlob)
        }
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beforeBlobDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.BlobMetadata.self, forKey: .beforeBlob)
        beforeBlob = beforeBlobDecoded
        let afterBlobDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.BlobMetadata.self, forKey: .afterBlob)
        afterBlob = afterBlobDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ChangeTypeEnum.self, forKey: .changeType)
        changeType = changeTypeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a set of differences for a commit specifier.
    public struct Difference: Swift.Equatable {
        /// Information about an afterBlob data type object, including the ID, the file mode permission code, and the path.
        public var afterBlob: CodeCommitClientTypes.BlobMetadata?
        /// Information about a beforeBlob data type object, including the ID, the file mode permission code, and the path.
        public var beforeBlob: CodeCommitClientTypes.BlobMetadata?
        /// Whether the change type of the difference is an addition (A), deletion (D), or modification (M).
        public var changeType: CodeCommitClientTypes.ChangeTypeEnum?

        public init (
            afterBlob: CodeCommitClientTypes.BlobMetadata? = nil,
            beforeBlob: CodeCommitClientTypes.BlobMetadata? = nil,
            changeType: CodeCommitClientTypes.ChangeTypeEnum? = nil
        )
        {
            self.afterBlob = afterBlob
            self.beforeBlob = beforeBlob
            self.changeType = changeType
        }
    }

}

extension DirectoryNameConflictsWithFileNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DirectoryNameConflictsWithFileNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.
public struct DirectoryNameConflictsWithFileNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryNameConflictsWithFileNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryNameConflictsWithFileNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateApprovalRuleTemplateFromRepositoryInput: Swift.Equatable {
    /// The name of the approval rule template to disassociate from a specified repository.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The name of the repository you want to disassociate from the template.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        approvalRuleTemplateName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryName = repositoryName
    }
}

struct DisassociateApprovalRuleTemplateFromRepositoryInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let repositoryName: Swift.String?
}

extension DisassociateApprovalRuleTemplateFromRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateApprovalRuleTemplateFromRepositoryOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateApprovalRuleTemplateFromRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateApprovalRuleTemplateFromRepositoryOutputResponse: Swift.Equatable {

    public init () { }
}

extension EncryptionIntegrityChecksFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EncryptionIntegrityChecksFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An encryption integrity check failed.
public struct EncryptionIntegrityChecksFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionIntegrityChecksFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EncryptionIntegrityChecksFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyAccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EncryptionKeyAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An encryption key could not be accessed.
public struct EncryptionKeyAccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionKeyAccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EncryptionKeyAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EncryptionKeyDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The encryption key is disabled.
public struct EncryptionKeyDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionKeyDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EncryptionKeyDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EncryptionKeyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No encryption key was found.
public struct EncryptionKeyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionKeyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EncryptionKeyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EncryptionKeyUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The encryption key is not available.
public struct EncryptionKeyUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionKeyUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EncryptionKeyUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EvaluatePullRequestApprovalRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension EvaluatePullRequestApprovalRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EvaluatePullRequestApprovalRulesInput: Swift.Equatable {
    /// The system-generated ID of the pull request you want to evaluate.
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID for the pull request revision. To retrieve the most recent revision ID for a pull request, use [GetPullRequest].
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct EvaluatePullRequestApprovalRulesInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let revisionId: Swift.String?
}

extension EvaluatePullRequestApprovalRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension EvaluatePullRequestApprovalRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EvaluatePullRequestApprovalRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRevisionIdException" : self = .invalidRevisionIdException(try InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionIdRequiredException" : self = .revisionIdRequiredException(try RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionNotCurrentException" : self = .revisionNotCurrentException(try RevisionNotCurrentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EvaluatePullRequestApprovalRulesOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRevisionIdException(InvalidRevisionIdException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case revisionIdRequiredException(RevisionIdRequiredException)
    case revisionNotCurrentException(RevisionNotCurrentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EvaluatePullRequestApprovalRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EvaluatePullRequestApprovalRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.evaluation = output.evaluation
        } else {
            self.evaluation = nil
        }
    }
}

public struct EvaluatePullRequestApprovalRulesOutputResponse: Swift.Equatable {
    /// The result of the evaluation, including the names of the rules whose conditions have been met (if any), the names of the rules whose conditions have not been met (if any), whether the pull request is in the approved state, and whether the pull request approval rule has been set aside by an override.
    /// This member is required.
    public var evaluation: CodeCommitClientTypes.Evaluation?

    public init (
        evaluation: CodeCommitClientTypes.Evaluation? = nil
    )
    {
        self.evaluation = evaluation
    }
}

struct EvaluatePullRequestApprovalRulesOutputResponseBody: Swift.Equatable {
    let evaluation: CodeCommitClientTypes.Evaluation?
}

extension EvaluatePullRequestApprovalRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Evaluation.self, forKey: .evaluation)
        evaluation = evaluationDecoded
    }
}

extension CodeCommitClientTypes.Evaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRulesNotSatisfied
        case approvalRulesSatisfied
        case approved
        case overridden
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRulesNotSatisfied = approvalRulesNotSatisfied {
            var approvalRulesNotSatisfiedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvalRulesNotSatisfied)
            for approvalrulename0 in approvalRulesNotSatisfied {
                try approvalRulesNotSatisfiedContainer.encode(approvalrulename0)
            }
        }
        if let approvalRulesSatisfied = approvalRulesSatisfied {
            var approvalRulesSatisfiedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvalRulesSatisfied)
            for approvalrulename0 in approvalRulesSatisfied {
                try approvalRulesSatisfiedContainer.encode(approvalrulename0)
            }
        }
        if approved != false {
            try encodeContainer.encode(approved, forKey: .approved)
        }
        if overridden != false {
            try encodeContainer.encode(overridden, forKey: .overridden)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .approved) ?? false
        approved = approvedDecoded
        let overriddenDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overridden) ?? false
        overridden = overriddenDecoded
        let approvalRulesSatisfiedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvalRulesSatisfied)
        var approvalRulesSatisfiedDecoded0:[Swift.String]? = nil
        if let approvalRulesSatisfiedContainer = approvalRulesSatisfiedContainer {
            approvalRulesSatisfiedDecoded0 = [Swift.String]()
            for string0 in approvalRulesSatisfiedContainer {
                if let string0 = string0 {
                    approvalRulesSatisfiedDecoded0?.append(string0)
                }
            }
        }
        approvalRulesSatisfied = approvalRulesSatisfiedDecoded0
        let approvalRulesNotSatisfiedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvalRulesNotSatisfied)
        var approvalRulesNotSatisfiedDecoded0:[Swift.String]? = nil
        if let approvalRulesNotSatisfiedContainer = approvalRulesNotSatisfiedContainer {
            approvalRulesNotSatisfiedDecoded0 = [Swift.String]()
            for string0 in approvalRulesNotSatisfiedContainer {
                if let string0 = string0 {
                    approvalRulesNotSatisfiedDecoded0?.append(string0)
                }
            }
        }
        approvalRulesNotSatisfied = approvalRulesNotSatisfiedDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Returns information about the approval rules applied to a pull request and whether conditions have been met.
    public struct Evaluation: Swift.Equatable {
        /// The names of the approval rules that have not had their conditions met.
        public var approvalRulesNotSatisfied: [Swift.String]?
        /// The names of the approval rules that have had their conditions met.
        public var approvalRulesSatisfied: [Swift.String]?
        /// Whether the state of the pull request is approved.
        public var approved: Swift.Bool
        /// Whether the approval rule requirements for the pull request have been overridden and no longer need to be met.
        public var overridden: Swift.Bool

        public init (
            approvalRulesNotSatisfied: [Swift.String]? = nil,
            approvalRulesSatisfied: [Swift.String]? = nil,
            approved: Swift.Bool = false,
            overridden: Swift.Bool = false
        )
        {
            self.approvalRulesNotSatisfied = approvalRulesNotSatisfied
            self.approvalRulesSatisfied = approvalRulesSatisfied
            self.approved = approved
            self.overridden = overridden
        }
    }

}

extension CodeCommitClientTypes.File: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutePath
        case blobId
        case fileMode
        case relativePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = self.absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let relativePath = self.relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a file in a repository.
    public struct File: Swift.Equatable {
        /// The fully qualified path to the file in the repository.
        public var absolutePath: Swift.String?
        /// The blob ID that contains the file information.
        public var blobId: Swift.String?
        /// The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The relative path of the file from the folder where the query originated.
        public var relativePath: Swift.String?

        public init (
            absolutePath: Swift.String? = nil,
            blobId: Swift.String? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            relativePath: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.blobId = blobId
            self.fileMode = fileMode
            self.relativePath = relativePath
        }
    }

}

extension FileContentAndSourceFileSpecifiedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FileContentAndSourceFileSpecifiedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit cannot be created because both a source file and file content have been specified for the same file. You cannot provide both. Either specify a source file or provide the file content directly.
public struct FileContentAndSourceFileSpecifiedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FileContentAndSourceFileSpecifiedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileContentAndSourceFileSpecifiedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileContentRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FileContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.
public struct FileContentRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FileContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileContentSizeLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FileContentSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.
public struct FileContentSizeLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FileContentSizeLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileContentSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FileDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified file does not exist. Verify that you have used the correct file name, full path, and extension.
public struct FileDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FileDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileEntryRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FileEntryRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.
public struct FileEntryRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FileEntryRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileEntryRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.FileMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutePath
        case blobId
        case fileMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = self.absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let absolutePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension CodeCommitClientTypes {
    /// A file to be added, updated, or deleted as part of a commit.
    public struct FileMetadata: Swift.Equatable {
        /// The full path to the file to be added or updated, including the name of the file.
        public var absolutePath: Swift.String?
        /// The blob ID that contains the file information.
        public var blobId: Swift.String?
        /// The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?

        public init (
            absolutePath: Swift.String? = nil,
            blobId: Swift.String? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil
        )
        {
            self.absolutePath = absolutePath
            self.blobId = blobId
            self.fileMode = fileMode
        }
    }

}

extension FileModeRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FileModeRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.
public struct FileModeRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FileModeRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileModeRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum FileModeTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case executable
        case normal
        case symlink
        case sdkUnknown(Swift.String)

        public static var allCases: [FileModeTypeEnum] {
            return [
                .executable,
                .normal,
                .symlink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .executable: return "EXECUTABLE"
            case .normal: return "NORMAL"
            case .symlink: return "SYMLINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileModeTypeEnum(rawValue: rawValue) ?? FileModeTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.FileModes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = self.base {
            try encodeContainer.encode(base.rawValue, forKey: .base)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination.rawValue, forKey: .destination)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .base)
        base = baseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about file modes in a merge or pull request.
    public struct FileModes: Swift.Equatable {
        /// The file mode of a file in the base of a merge or pull request.
        public var base: CodeCommitClientTypes.FileModeTypeEnum?
        /// The file mode of a file in the destination of a merge or pull request.
        public var destination: CodeCommitClientTypes.FileModeTypeEnum?
        /// The file mode of a file in the source of a merge or pull request.
        public var source: CodeCommitClientTypes.FileModeTypeEnum?

        public init (
            base: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            destination: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            source: CodeCommitClientTypes.FileModeTypeEnum? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }

}

extension FileNameConflictsWithDirectoryNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FileNameConflictsWithDirectoryNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.
public struct FileNameConflictsWithDirectoryNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FileNameConflictsWithDirectoryNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileNameConflictsWithDirectoryNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FilePathConflictsWithSubmodulePathException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FilePathConflictsWithSubmodulePathExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.
public struct FilePathConflictsWithSubmodulePathException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FilePathConflictsWithSubmodulePathExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FilePathConflictsWithSubmodulePathExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.FileSizes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if base != 0 {
            try encodeContainer.encode(base, forKey: .base)
        }
        if destination != 0 {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if source != 0 {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .source) ?? 0
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destination) ?? 0
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .base) ?? 0
        base = baseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the size of files in a merge or pull request.
    public struct FileSizes: Swift.Equatable {
        /// The size of a file in the base of a merge or pull request.
        public var base: Swift.Int
        /// The size of a file in the destination of a merge or pull request.
        public var destination: Swift.Int
        /// The size of a file in the source of a merge or pull request.
        public var source: Swift.Int

        public init (
            base: Swift.Int = 0,
            destination: Swift.Int = 0,
            source: Swift.Int = 0
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }

}

extension FileTooLargeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FileTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see [AWS CodeCommit User Guide](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
public struct FileTooLargeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FileTooLargeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FileTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.Folder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutePath
        case relativePath
        case treeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = self.absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let relativePath = self.relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
        if let treeId = self.treeId {
            try encodeContainer.encode(treeId, forKey: .treeId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a folder in a repository.
    public struct Folder: Swift.Equatable {
        /// The fully qualified path of the folder in the repository.
        public var absolutePath: Swift.String?
        /// The relative path of the specified folder from the folder where the query originated.
        public var relativePath: Swift.String?
        /// The full SHA-1 pointer of the tree information for the commit that contains the folder.
        public var treeId: Swift.String?

        public init (
            absolutePath: Swift.String? = nil,
            relativePath: Swift.String? = nil,
            treeId: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.relativePath = relativePath
            self.treeId = treeId
        }
    }

}

extension FolderContentSizeLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FolderContentSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.
public struct FolderContentSizeLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FolderContentSizeLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FolderContentSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FolderDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FolderDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified folder does not exist. Either the folder name is not correct, or you did not enter the full path to the folder.
public struct FolderDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FolderDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FolderDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetApprovalRuleTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

extension GetApprovalRuleTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetApprovalRuleTemplateInput: Swift.Equatable {
    /// The name of the approval rule template for which you want to get information.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init (
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct GetApprovalRuleTemplateInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
}

extension GetApprovalRuleTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
    }
}

extension GetApprovalRuleTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApprovalRuleTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetApprovalRuleTemplateOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApprovalRuleTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetApprovalRuleTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct GetApprovalRuleTemplateOutputResponse: Swift.Equatable {
    /// The content and structure of the approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init (
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct GetApprovalRuleTemplateOutputResponseBody: Swift.Equatable {
    let approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?
}

extension GetApprovalRuleTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

extension GetBlobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetBlobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a get blob operation.
public struct GetBlobInput: Swift.Equatable {
    /// The ID of the blob, which is its SHA-1 pointer.
    /// This member is required.
    public var blobId: Swift.String?
    /// The name of the repository that contains the blob.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        blobId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.blobId = blobId
        self.repositoryName = repositoryName
    }
}

struct GetBlobInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let blobId: Swift.String?
}

extension GetBlobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
    }
}

extension GetBlobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBlobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BlobIdDoesNotExistException" : self = .blobIdDoesNotExistException(try BlobIdDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BlobIdRequiredException" : self = .blobIdRequiredException(try BlobIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileTooLargeException" : self = .fileTooLargeException(try FileTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBlobIdException" : self = .invalidBlobIdException(try InvalidBlobIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBlobOutputError: Swift.Error, Swift.Equatable {
    case blobIdDoesNotExistException(BlobIdDoesNotExistException)
    case blobIdRequiredException(BlobIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileTooLargeException(FileTooLargeException)
    case invalidBlobIdException(InvalidBlobIdException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBlobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBlobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

/// Represents the output of a get blob operation.
public struct GetBlobOutputResponse: Swift.Equatable {
    /// The content of the blob, usually a file.
    /// This member is required.
    public var content: ClientRuntime.Data?

    public init (
        content: ClientRuntime.Data? = nil
    )
    {
        self.content = content
    }
}

struct GetBlobOutputResponseBody: Swift.Equatable {
    let content: ClientRuntime.Data?
}

extension GetBlobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension GetBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a get branch operation.
public struct GetBranchInput: Swift.Equatable {
    /// The name of the branch for which you want to retrieve information.
    public var branchName: Swift.String?
    /// The name of the repository that contains the branch for which you want to retrieve information.
    public var repositoryName: Swift.String?

    public init (
        branchName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.repositoryName = repositoryName
    }
}

struct GetBranchInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
}

extension GetBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension GetBranchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBranchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBranchOutputError: Swift.Error, Swift.Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameRequiredException(BranchNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBranchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBranchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

/// Represents the output of a get branch operation.
public struct GetBranchOutputResponse: Swift.Equatable {
    /// The name of the branch.
    public var branch: CodeCommitClientTypes.BranchInfo?

    public init (
        branch: CodeCommitClientTypes.BranchInfo? = nil
    )
    {
        self.branch = branch
    }
}

struct GetBranchOutputResponseBody: Swift.Equatable {
    let branch: CodeCommitClientTypes.BranchInfo?
}

extension GetBranchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.BranchInfo.self, forKey: .branch)
        branch = branchDecoded
    }
}

extension GetCommentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
    }
}

extension GetCommentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCommentInput: Swift.Equatable {
    /// The unique, system-generated ID of the comment. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var commentId: Swift.String?

    public init (
        commentId: Swift.String? = nil
    )
    {
        self.commentId = commentId
    }
}

struct GetCommentInputBody: Swift.Equatable {
    let commentId: Swift.String?
}

extension GetCommentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
    }
}

extension GetCommentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommentDeletedException" : self = .commentDeletedException(try CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCommentOutputError: Swift.Error, Swift.Equatable {
    case commentDeletedException(CommentDeletedException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommentIdException(InvalidCommentIdException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCommentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct GetCommentOutputResponse: Swift.Equatable {
    /// The contents of the comment.
    public var comment: CodeCommitClientTypes.Comment?

    public init (
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct GetCommentOutputResponseBody: Swift.Equatable {
    let comment: CodeCommitClientTypes.Comment?
}

extension GetCommentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension GetCommentReactionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case maxResults
        case nextToken
        case reactionUserArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let reactionUserArn = self.reactionUserArn {
            try encodeContainer.encode(reactionUserArn, forKey: .reactionUserArn)
        }
    }
}

extension GetCommentReactionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCommentReactionsInput: Swift.Equatable {
    /// The ID of the comment for which you want to get reactions information.
    /// This member is required.
    public var commentId: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is the same as the allowed maximum, 1,000.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// Optional. The Amazon Resource Name (ARN) of the user or identity for which you want to get reaction information.
    public var reactionUserArn: Swift.String?

    public init (
        commentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reactionUserArn: Swift.String? = nil
    )
    {
        self.commentId = commentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reactionUserArn = reactionUserArn
    }
}

struct GetCommentReactionsInputBody: Swift.Equatable {
    let commentId: Swift.String?
    let reactionUserArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetCommentReactionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case maxResults
        case nextToken
        case reactionUserArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let reactionUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reactionUserArn)
        reactionUserArn = reactionUserArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCommentReactionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommentReactionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommentDeletedException" : self = .commentDeletedException(try CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReactionUserArnException" : self = .invalidReactionUserArnException(try InvalidReactionUserArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCommentReactionsOutputError: Swift.Error, Swift.Equatable {
    case commentDeletedException(CommentDeletedException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case invalidCommentIdException(InvalidCommentIdException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidReactionUserArnException(InvalidReactionUserArnException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommentReactionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCommentReactionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reactionsForComment = output.reactionsForComment
        } else {
            self.nextToken = nil
            self.reactionsForComment = nil
        }
    }
}

public struct GetCommentReactionsOutputResponse: Swift.Equatable {
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// An array of reactions to the specified comment.
    /// This member is required.
    public var reactionsForComment: [CodeCommitClientTypes.ReactionForComment]?

    public init (
        nextToken: Swift.String? = nil,
        reactionsForComment: [CodeCommitClientTypes.ReactionForComment]? = nil
    )
    {
        self.nextToken = nextToken
        self.reactionsForComment = reactionsForComment
    }
}

struct GetCommentReactionsOutputResponseBody: Swift.Equatable {
    let reactionsForComment: [CodeCommitClientTypes.ReactionForComment]?
    let nextToken: Swift.String?
}

extension GetCommentReactionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reactionsForComment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactionsForCommentContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.ReactionForComment?].self, forKey: .reactionsForComment)
        var reactionsForCommentDecoded0:[CodeCommitClientTypes.ReactionForComment]? = nil
        if let reactionsForCommentContainer = reactionsForCommentContainer {
            reactionsForCommentDecoded0 = [CodeCommitClientTypes.ReactionForComment]()
            for structure0 in reactionsForCommentContainer {
                if let structure0 = structure0 {
                    reactionsForCommentDecoded0?.append(structure0)
                }
            }
        }
        reactionsForComment = reactionsForCommentDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCommentsForComparedCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetCommentsForComparedCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCommentsForComparedCommitInput: Swift.Equatable {
    /// To establish the directionality of the comparison, the full commit ID of the after commit.
    /// This member is required.
    public var afterCommitId: Swift.String?
    /// To establish the directionality of the comparison, the full commit ID of the before commit.
    public var beforeCommitId: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is 100 comments, but you can configure up to 500.
    public var maxResults: Swift.Int?
    /// An enumeration token that when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where you want to compare commits.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct GetCommentsForComparedCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetCommentsForComparedCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCommentsForComparedCommitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommentsForComparedCommitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCommentsForComparedCommitOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommentsForComparedCommitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCommentsForComparedCommitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commentsForComparedCommitData = output.commentsForComparedCommitData
            self.nextToken = output.nextToken
        } else {
            self.commentsForComparedCommitData = nil
            self.nextToken = nil
        }
    }
}

public struct GetCommentsForComparedCommitOutputResponse: Swift.Equatable {
    /// A list of comment objects on the compared commit.
    public var commentsForComparedCommitData: [CodeCommitClientTypes.CommentsForComparedCommit]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init (
        commentsForComparedCommitData: [CodeCommitClientTypes.CommentsForComparedCommit]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commentsForComparedCommitData = commentsForComparedCommitData
        self.nextToken = nextToken
    }
}

struct GetCommentsForComparedCommitOutputResponseBody: Swift.Equatable {
    let commentsForComparedCommitData: [CodeCommitClientTypes.CommentsForComparedCommit]?
    let nextToken: Swift.String?
}

extension GetCommentsForComparedCommitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentsForComparedCommitData
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentsForComparedCommitDataContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.CommentsForComparedCommit?].self, forKey: .commentsForComparedCommitData)
        var commentsForComparedCommitDataDecoded0:[CodeCommitClientTypes.CommentsForComparedCommit]? = nil
        if let commentsForComparedCommitDataContainer = commentsForComparedCommitDataContainer {
            commentsForComparedCommitDataDecoded0 = [CodeCommitClientTypes.CommentsForComparedCommit]()
            for structure0 in commentsForComparedCommitDataContainer {
                if let structure0 = structure0 {
                    commentsForComparedCommitDataDecoded0?.append(structure0)
                }
            }
        }
        commentsForComparedCommitData = commentsForComparedCommitDataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCommentsForPullRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case pullRequestId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetCommentsForPullRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCommentsForPullRequestInput: Swift.Equatable {
    /// The full commit ID of the commit in the source branch that was the tip of the branch at the time the comment was made.
    public var afterCommitId: Swift.String?
    /// The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was created.
    public var beforeCommitId: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results. The default is 100 comments. You can return up to 500 comments with a single request.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository that contains the pull request.
    public var repositoryName: Swift.String?

    public init (
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

struct GetCommentsForPullRequestInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let repositoryName: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetCommentsForPullRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case pullRequestId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCommentsForPullRequestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommentsForPullRequestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotAssociatedWithPullRequestException" : self = .repositoryNotAssociatedWithPullRequestException(try RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCommentsForPullRequestOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryNotAssociatedWithPullRequestException(RepositoryNotAssociatedWithPullRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommentsForPullRequestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCommentsForPullRequestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commentsForPullRequestData = output.commentsForPullRequestData
            self.nextToken = output.nextToken
        } else {
            self.commentsForPullRequestData = nil
            self.nextToken = nil
        }
    }
}

public struct GetCommentsForPullRequestOutputResponse: Swift.Equatable {
    /// An array of comment objects on the pull request.
    public var commentsForPullRequestData: [CodeCommitClientTypes.CommentsForPullRequest]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init (
        commentsForPullRequestData: [CodeCommitClientTypes.CommentsForPullRequest]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commentsForPullRequestData = commentsForPullRequestData
        self.nextToken = nextToken
    }
}

struct GetCommentsForPullRequestOutputResponseBody: Swift.Equatable {
    let commentsForPullRequestData: [CodeCommitClientTypes.CommentsForPullRequest]?
    let nextToken: Swift.String?
}

extension GetCommentsForPullRequestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentsForPullRequestData
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentsForPullRequestDataContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.CommentsForPullRequest?].self, forKey: .commentsForPullRequestData)
        var commentsForPullRequestDataDecoded0:[CodeCommitClientTypes.CommentsForPullRequest]? = nil
        if let commentsForPullRequestDataContainer = commentsForPullRequestDataContainer {
            commentsForPullRequestDataDecoded0 = [CodeCommitClientTypes.CommentsForPullRequest]()
            for structure0 in commentsForPullRequestDataContainer {
                if let structure0 = structure0 {
                    commentsForPullRequestDataDecoded0?.append(structure0)
                }
            }
        }
        commentsForPullRequestData = commentsForPullRequestDataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a get commit operation.
public struct GetCommitInput: Swift.Equatable {
    /// The commit ID. Commit IDs are the full SHA ID of the commit.
    /// This member is required.
    public var commitId: Swift.String?
    /// The name of the repository to which the commit was made.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        commitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.repositoryName = repositoryName
    }
}

struct GetCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let commitId: Swift.String?
}

extension GetCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
    }
}

extension GetCommitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitIdDoesNotExistException" : self = .commitIdDoesNotExistException(try CommitIdDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCommitOutputError: Swift.Error, Swift.Equatable {
    case commitIdDoesNotExistException(CommitIdDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCommitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commit = output.commit
        } else {
            self.commit = nil
        }
    }
}

/// Represents the output of a get commit operation.
public struct GetCommitOutputResponse: Swift.Equatable {
    /// A commit data type object that contains information about the specified commit.
    /// This member is required.
    public var commit: CodeCommitClientTypes.Commit?

    public init (
        commit: CodeCommitClientTypes.Commit? = nil
    )
    {
        self.commit = commit
    }
}

struct GetCommitOutputResponseBody: Swift.Equatable {
    let commit: CodeCommitClientTypes.Commit?
}

extension GetCommitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commit
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Commit.self, forKey: .commit)
        commit = commitDecoded
    }
}

extension GetDifferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case afterCommitSpecifier
        case afterPath
        case beforeCommitSpecifier
        case beforePath
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let afterCommitSpecifier = self.afterCommitSpecifier {
            try encodeContainer.encode(afterCommitSpecifier, forKey: .afterCommitSpecifier)
        }
        if let afterPath = self.afterPath {
            try encodeContainer.encode(afterPath, forKey: .afterPath)
        }
        if let beforeCommitSpecifier = self.beforeCommitSpecifier {
            try encodeContainer.encode(beforeCommitSpecifier, forKey: .beforeCommitSpecifier)
        }
        if let beforePath = self.beforePath {
            try encodeContainer.encode(beforePath, forKey: .beforePath)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetDifferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDifferencesInput: Swift.Equatable {
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit.
    /// This member is required.
    public var afterCommitSpecifier: Swift.String?
    /// The file path in which to check differences. Limits the results to this path. Can also be used to specify the changed name of a directory or folder, if it has changed. If not specified, differences are shown for all paths.
    public var afterPath: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, the full commit ID). Optional. If not specified, all changes before the afterCommitSpecifier value are shown. If you do not use beforeCommitSpecifier in your request, consider limiting the results with maxResults.
    public var beforeCommitSpecifier: Swift.String?
    /// The file path in which to check for differences. Limits the results to this path. Can also be used to specify the previous name of a directory or folder. If beforePath and afterPath are not specified, differences are shown for all paths.
    public var beforePath: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where you want to get differences.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        afterCommitSpecifier: Swift.String? = nil,
        afterPath: Swift.String? = nil,
        beforeCommitSpecifier: Swift.String? = nil,
        beforePath: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitSpecifier = afterCommitSpecifier
        self.afterPath = afterPath
        self.beforeCommitSpecifier = beforeCommitSpecifier
        self.beforePath = beforePath
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct GetDifferencesInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let beforeCommitSpecifier: Swift.String?
    let afterCommitSpecifier: Swift.String?
    let beforePath: Swift.String?
    let afterPath: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetDifferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case afterCommitSpecifier
        case afterPath
        case beforeCommitSpecifier
        case beforePath
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitSpecifier)
        beforeCommitSpecifier = beforeCommitSpecifierDecoded
        let afterCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitSpecifier)
        afterCommitSpecifier = afterCommitSpecifierDecoded
        let beforePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforePath)
        beforePath = beforePathDecoded
        let afterPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterPath)
        afterPath = afterPathDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDifferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDifferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathDoesNotExistException" : self = .pathDoesNotExistException(try PathDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDifferencesOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitException(InvalidCommitException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pathDoesNotExistException(PathDoesNotExistException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDifferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDifferencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.differences = output.differences
            self.nextToken = output.nextToken
        } else {
            self.nextToken = nil
            self.differences = nil
        }
    }
}

public struct GetDifferencesOutputResponse: Swift.Equatable {
    /// A data type object that contains information about the differences, including whether the difference is added, modified, or deleted (A, D, M).
    public var differences: [CodeCommitClientTypes.Difference]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init (
        differences: [CodeCommitClientTypes.Difference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.differences = differences
        self.nextToken = nextToken
    }
}

struct GetDifferencesOutputResponseBody: Swift.Equatable {
    let differences: [CodeCommitClientTypes.Difference]?
    let nextToken: Swift.String?
}

extension GetDifferencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case differences
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let differencesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Difference?].self, forKey: .differences)
        var differencesDecoded0:[CodeCommitClientTypes.Difference]? = nil
        if let differencesContainer = differencesContainer {
            differencesDecoded0 = [CodeCommitClientTypes.Difference]()
            for structure0 in differencesContainer {
                if let structure0 = structure0 {
                    differencesDecoded0?.append(structure0)
                }
            }
        }
        differences = differencesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetFileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitSpecifier
        case filePath
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitSpecifier = self.commitSpecifier {
            try encodeContainer.encode(commitSpecifier, forKey: .commitSpecifier)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetFileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFileInput: Swift.Equatable {
    /// The fully quaified reference that identifies the commit that contains the file. For example, you can specify a full commit ID, a tag, a branch name, or a reference such as refs/heads/master. If none is provided, the head commit is used.
    public var commitSpecifier: Swift.String?
    /// The fully qualified path to the file, including the full name and extension of the file. For example, /examples/file.md is the fully qualified path to a file named file.md in a folder named examples.
    /// This member is required.
    public var filePath: Swift.String?
    /// The name of the repository that contains the file.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        commitSpecifier: Swift.String? = nil,
        filePath: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitSpecifier = commitSpecifier
        self.filePath = filePath
        self.repositoryName = repositoryName
    }
}

struct GetFileInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let commitSpecifier: Swift.String?
    let filePath: Swift.String?
}

extension GetFileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitSpecifier
        case filePath
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let commitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitSpecifier)
        commitSpecifier = commitSpecifierDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

extension GetFileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileDoesNotExistException" : self = .fileDoesNotExistException(try FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileTooLargeException" : self = .fileTooLargeException(try FileTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFileOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileDoesNotExistException(FileDoesNotExistException)
    case fileTooLargeException(FileTooLargeException)
    case invalidCommitException(InvalidCommitException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.blobId = output.blobId
            self.commitId = output.commitId
            self.fileContent = output.fileContent
            self.fileMode = output.fileMode
            self.filePath = output.filePath
            self.fileSize = output.fileSize
        } else {
            self.blobId = nil
            self.commitId = nil
            self.fileContent = nil
            self.fileMode = nil
            self.filePath = nil
            self.fileSize = 0
        }
    }
}

public struct GetFileOutputResponse: Swift.Equatable {
    /// The blob ID of the object that represents the file content.
    /// This member is required.
    public var blobId: Swift.String?
    /// The full commit ID of the commit that contains the content returned by GetFile.
    /// This member is required.
    public var commitId: Swift.String?
    /// The base-64 encoded binary data object that represents the content of the file.
    /// This member is required.
    public var fileContent: ClientRuntime.Data?
    /// The extrapolated file mode permissions of the blob. Valid values include strings such as EXECUTABLE and not numeric values. The file mode permissions returned by this API are not the standard file mode permission values, such as 100644, but rather extrapolated values. See the supported return values.
    /// This member is required.
    public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
    /// The fully qualified path to the specified file. Returns the name and extension of the file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The size of the contents of the file, in bytes.
    /// This member is required.
    public var fileSize: Swift.Int

    public init (
        blobId: Swift.String? = nil,
        commitId: Swift.String? = nil,
        fileContent: ClientRuntime.Data? = nil,
        fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
        filePath: Swift.String? = nil,
        fileSize: Swift.Int = 0
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.fileContent = fileContent
        self.fileMode = fileMode
        self.filePath = filePath
        self.fileSize = fileSize
    }
}

struct GetFileOutputResponseBody: Swift.Equatable {
    let commitId: Swift.String?
    let blobId: Swift.String?
    let filePath: Swift.String?
    let fileMode: CodeCommitClientTypes.FileModeTypeEnum?
    let fileSize: Swift.Int
    let fileContent: ClientRuntime.Data?
}

extension GetFileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case commitId
        case fileContent
        case fileMode
        case filePath
        case fileSize
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let fileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileSize) ?? 0
        fileSize = fileSizeDecoded
        let fileContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .fileContent)
        fileContent = fileContentDecoded
    }
}

extension GetFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitSpecifier
        case folderPath
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitSpecifier = self.commitSpecifier {
            try encodeContainer.encode(commitSpecifier, forKey: .commitSpecifier)
        }
        if let folderPath = self.folderPath {
            try encodeContainer.encode(folderPath, forKey: .folderPath)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFolderInput: Swift.Equatable {
    /// A fully qualified reference used to identify a commit that contains the version of the folder's content to return. A fully qualified reference can be a commit ID, branch name, tag, or reference such as HEAD. If no specifier is provided, the folder content is returned as it exists in the HEAD commit.
    public var commitSpecifier: Swift.String?
    /// The fully qualified path to the folder whose contents are returned, including the folder name. For example, /examples is a fully-qualified path to a folder named examples that was created off of the root directory (/) of a repository.
    /// This member is required.
    public var folderPath: Swift.String?
    /// The name of the repository.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        commitSpecifier: Swift.String? = nil,
        folderPath: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.commitSpecifier = commitSpecifier
        self.folderPath = folderPath
        self.repositoryName = repositoryName
    }
}

struct GetFolderInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let commitSpecifier: Swift.String?
    let folderPath: Swift.String?
}

extension GetFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitSpecifier
        case folderPath
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let commitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitSpecifier)
        commitSpecifier = commitSpecifierDecoded
        let folderPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderPath)
        folderPath = folderPathDecoded
    }
}

extension GetFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderDoesNotExistException" : self = .folderDoesNotExistException(try FolderDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFolderOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case folderDoesNotExistException(FolderDoesNotExistException)
    case invalidCommitException(InvalidCommitException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.files = output.files
            self.folderPath = output.folderPath
            self.subFolders = output.subFolders
            self.subModules = output.subModules
            self.symbolicLinks = output.symbolicLinks
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.files = nil
            self.folderPath = nil
            self.subFolders = nil
            self.subModules = nil
            self.symbolicLinks = nil
            self.treeId = nil
        }
    }
}

public struct GetFolderOutputResponse: Swift.Equatable {
    /// The full commit ID used as a reference for the returned version of the folder content.
    /// This member is required.
    public var commitId: Swift.String?
    /// The list of files in the specified folder, if any.
    public var files: [CodeCommitClientTypes.File]?
    /// The fully qualified path of the folder whose contents are returned.
    /// This member is required.
    public var folderPath: Swift.String?
    /// The list of folders that exist under the specified folder, if any.
    public var subFolders: [CodeCommitClientTypes.Folder]?
    /// The list of submodules in the specified folder, if any.
    public var subModules: [CodeCommitClientTypes.SubModule]?
    /// The list of symbolic links to other files and folders in the specified folder, if any.
    public var symbolicLinks: [CodeCommitClientTypes.SymbolicLink]?
    /// The full SHA-1 pointer of the tree information for the commit that contains the folder.
    public var treeId: Swift.String?

    public init (
        commitId: Swift.String? = nil,
        files: [CodeCommitClientTypes.File]? = nil,
        folderPath: Swift.String? = nil,
        subFolders: [CodeCommitClientTypes.Folder]? = nil,
        subModules: [CodeCommitClientTypes.SubModule]? = nil,
        symbolicLinks: [CodeCommitClientTypes.SymbolicLink]? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.files = files
        self.folderPath = folderPath
        self.subFolders = subFolders
        self.subModules = subModules
        self.symbolicLinks = symbolicLinks
        self.treeId = treeId
    }
}

struct GetFolderOutputResponseBody: Swift.Equatable {
    let commitId: Swift.String?
    let folderPath: Swift.String?
    let treeId: Swift.String?
    let subFolders: [CodeCommitClientTypes.Folder]?
    let files: [CodeCommitClientTypes.File]?
    let symbolicLinks: [CodeCommitClientTypes.SymbolicLink]?
    let subModules: [CodeCommitClientTypes.SubModule]?
}

extension GetFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case files
        case folderPath
        case subFolders
        case subModules
        case symbolicLinks
        case treeId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let folderPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderPath)
        folderPath = folderPathDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let subFoldersContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Folder?].self, forKey: .subFolders)
        var subFoldersDecoded0:[CodeCommitClientTypes.Folder]? = nil
        if let subFoldersContainer = subFoldersContainer {
            subFoldersDecoded0 = [CodeCommitClientTypes.Folder]()
            for structure0 in subFoldersContainer {
                if let structure0 = structure0 {
                    subFoldersDecoded0?.append(structure0)
                }
            }
        }
        subFolders = subFoldersDecoded0
        let filesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.File?].self, forKey: .files)
        var filesDecoded0:[CodeCommitClientTypes.File]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [CodeCommitClientTypes.File]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let symbolicLinksContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.SymbolicLink?].self, forKey: .symbolicLinks)
        var symbolicLinksDecoded0:[CodeCommitClientTypes.SymbolicLink]? = nil
        if let symbolicLinksContainer = symbolicLinksContainer {
            symbolicLinksDecoded0 = [CodeCommitClientTypes.SymbolicLink]()
            for structure0 in symbolicLinksContainer {
                if let structure0 = structure0 {
                    symbolicLinksDecoded0?.append(structure0)
                }
            }
        }
        symbolicLinks = symbolicLinksDecoded0
        let subModulesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.SubModule?].self, forKey: .subModules)
        var subModulesDecoded0:[CodeCommitClientTypes.SubModule]? = nil
        if let subModulesContainer = subModulesContainer {
            subModulesDecoded0 = [CodeCommitClientTypes.SubModule]()
            for structure0 in subModulesContainer {
                if let structure0 = structure0 {
                    subModulesDecoded0?.append(structure0)
                }
            }
        }
        subModules = subModulesDecoded0
    }
}

extension GetMergeCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension GetMergeCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMergeCommitInput: Swift.Equatable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The name of the repository that contains the merge commit about which you want to get information.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init (
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct GetMergeCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
}

extension GetMergeCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
    }
}

extension GetMergeCommitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMergeCommitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMergeCommitOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMergeCommitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMergeCommitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baseCommitId = output.baseCommitId
            self.destinationCommitId = output.destinationCommitId
            self.mergedCommitId = output.mergedCommitId
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.destinationCommitId = nil
            self.mergedCommitId = nil
            self.sourceCommitId = nil
        }
    }
}

public struct GetMergeCommitOutputResponse: Swift.Equatable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    public var destinationCommitId: Swift.String?
    /// The commit ID for the merge commit created when the source branch was merged into the destination branch. If the fast-forward merge strategy was used, there is no merge commit.
    public var mergedCommitId: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    public var sourceCommitId: Swift.String?

    public init (
        baseCommitId: Swift.String? = nil,
        destinationCommitId: Swift.String? = nil,
        mergedCommitId: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.destinationCommitId = destinationCommitId
        self.mergedCommitId = mergedCommitId
        self.sourceCommitId = sourceCommitId
    }
}

struct GetMergeCommitOutputResponseBody: Swift.Equatable {
    let sourceCommitId: Swift.String?
    let destinationCommitId: Swift.String?
    let baseCommitId: Swift.String?
    let mergedCommitId: Swift.String?
}

extension GetMergeCommitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCommitId
        case destinationCommitId
        case mergedCommitId
        case sourceCommitId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
        let mergedCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedCommitId)
        mergedCommitId = mergedCommitIdDecoded
    }
}

extension GetMergeConflictsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case maxConflictFiles
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let maxConflictFiles = self.maxConflictFiles {
            try encodeContainer.encode(maxConflictFiles, forKey: .maxConflictFiles)
        }
        if let mergeOption = self.mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension GetMergeConflictsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMergeConflictsInput: Swift.Equatable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The maximum number of files to include in the output.
    public var maxConflictFiles: Swift.Int?
    /// The merge option or strategy you want to use to merge the code.
    /// This member is required.
    public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init (
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        maxConflictFiles: Swift.Int? = nil,
        mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.maxConflictFiles = maxConflictFiles
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct GetMergeConflictsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let maxConflictFiles: Swift.Int?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let nextToken: Swift.String?
}

extension GetMergeConflictsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case maxConflictFiles
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let maxConflictFilesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConflictFiles)
        maxConflictFiles = maxConflictFilesDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetMergeConflictsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMergeConflictsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDestinationCommitSpecifierException" : self = .invalidDestinationCommitSpecifierException(try InvalidDestinationCommitSpecifierException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxConflictFilesException" : self = .invalidMaxConflictFilesException(try InvalidMaxConflictFilesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMergeOptionException" : self = .invalidMergeOptionException(try InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSourceCommitSpecifierException" : self = .invalidSourceCommitSpecifierException(try InvalidSourceCommitSpecifierException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MergeOptionRequiredException" : self = .mergeOptionRequiredException(try MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMergeConflictsOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidDestinationCommitSpecifierException(InvalidDestinationCommitSpecifierException)
    case invalidMaxConflictFilesException(InvalidMaxConflictFilesException)
    case invalidMergeOptionException(InvalidMergeOptionException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidSourceCommitSpecifierException(InvalidSourceCommitSpecifierException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case mergeOptionRequiredException(MergeOptionRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMergeConflictsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMergeConflictsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baseCommitId = output.baseCommitId
            self.conflictMetadataList = output.conflictMetadataList
            self.destinationCommitId = output.destinationCommitId
            self.mergeable = output.mergeable
            self.nextToken = output.nextToken
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.conflictMetadataList = nil
            self.destinationCommitId = nil
            self.mergeable = false
            self.nextToken = nil
            self.sourceCommitId = nil
        }
    }
}

public struct GetMergeConflictsOutputResponse: Swift.Equatable {
    /// The commit ID of the merge base.
    public var baseCommitId: Swift.String?
    /// A list of metadata for any conflicting files. If the specified merge strategy is FAST_FORWARD_MERGE, this list is always empty.
    /// This member is required.
    public var conflictMetadataList: [CodeCommitClientTypes.ConflictMetadata]?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// A Boolean value that indicates whether the code is mergeable by the specified merge option.
    /// This member is required.
    public var mergeable: Swift.Bool
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init (
        baseCommitId: Swift.String? = nil,
        conflictMetadataList: [CodeCommitClientTypes.ConflictMetadata]? = nil,
        destinationCommitId: Swift.String? = nil,
        mergeable: Swift.Bool = false,
        nextToken: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflictMetadataList = conflictMetadataList
        self.destinationCommitId = destinationCommitId
        self.mergeable = mergeable
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

struct GetMergeConflictsOutputResponseBody: Swift.Equatable {
    let mergeable: Swift.Bool
    let destinationCommitId: Swift.String?
    let sourceCommitId: Swift.String?
    let baseCommitId: Swift.String?
    let conflictMetadataList: [CodeCommitClientTypes.ConflictMetadata]?
    let nextToken: Swift.String?
}

extension GetMergeConflictsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCommitId
        case conflictMetadataList
        case destinationCommitId
        case mergeable
        case nextToken
        case sourceCommitId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergeableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mergeable) ?? false
        mergeable = mergeableDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
        let conflictMetadataListContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.ConflictMetadata?].self, forKey: .conflictMetadataList)
        var conflictMetadataListDecoded0:[CodeCommitClientTypes.ConflictMetadata]? = nil
        if let conflictMetadataListContainer = conflictMetadataListContainer {
            conflictMetadataListDecoded0 = [CodeCommitClientTypes.ConflictMetadata]()
            for structure0 in conflictMetadataListContainer {
                if let structure0 = structure0 {
                    conflictMetadataListDecoded0?.append(structure0)
                }
            }
        }
        conflictMetadataList = conflictMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetMergeOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

extension GetMergeOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMergeOptionsInput: Swift.Equatable {
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The name of the repository that contains the commits about which you want to get merge options.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?

    public init (
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct GetMergeOptionsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
}

extension GetMergeOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
    }
}

extension GetMergeOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMergeOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMergeOptionsOutputError: Swift.Error, Swift.Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMergeOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMergeOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baseCommitId = output.baseCommitId
            self.destinationCommitId = output.destinationCommitId
            self.mergeOptions = output.mergeOptions
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.destinationCommitId = nil
            self.mergeOptions = nil
            self.sourceCommitId = nil
        }
    }
}

public struct GetMergeOptionsOutputResponse: Swift.Equatable {
    /// The commit ID of the merge base.
    /// This member is required.
    public var baseCommitId: Swift.String?
    /// The commit ID of the destination commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var destinationCommitId: Swift.String?
    /// The merge option or strategy used to merge the code.
    /// This member is required.
    public var mergeOptions: [CodeCommitClientTypes.MergeOptionTypeEnum]?
    /// The commit ID of the source commit specifier that was used in the merge evaluation.
    /// This member is required.
    public var sourceCommitId: Swift.String?

    public init (
        baseCommitId: Swift.String? = nil,
        destinationCommitId: Swift.String? = nil,
        mergeOptions: [CodeCommitClientTypes.MergeOptionTypeEnum]? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.destinationCommitId = destinationCommitId
        self.mergeOptions = mergeOptions
        self.sourceCommitId = sourceCommitId
    }
}

struct GetMergeOptionsOutputResponseBody: Swift.Equatable {
    let mergeOptions: [CodeCommitClientTypes.MergeOptionTypeEnum]?
    let sourceCommitId: Swift.String?
    let destinationCommitId: Swift.String?
    let baseCommitId: Swift.String?
}

extension GetMergeOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseCommitId
        case destinationCommitId
        case mergeOptions
        case sourceCommitId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergeOptionsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.MergeOptionTypeEnum?].self, forKey: .mergeOptions)
        var mergeOptionsDecoded0:[CodeCommitClientTypes.MergeOptionTypeEnum]? = nil
        if let mergeOptionsContainer = mergeOptionsContainer {
            mergeOptionsDecoded0 = [CodeCommitClientTypes.MergeOptionTypeEnum]()
            for string0 in mergeOptionsContainer {
                if let string0 = string0 {
                    mergeOptionsDecoded0?.append(string0)
                }
            }
        }
        mergeOptions = mergeOptionsDecoded0
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
    }
}

extension GetPullRequestApprovalStatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension GetPullRequestApprovalStatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPullRequestApprovalStatesInput: Swift.Equatable {
    /// The system-generated ID for the pull request.
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID for the pull request revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct GetPullRequestApprovalStatesInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let revisionId: Swift.String?
}

extension GetPullRequestApprovalStatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetPullRequestApprovalStatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPullRequestApprovalStatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRevisionIdException" : self = .invalidRevisionIdException(try InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionIdRequiredException" : self = .revisionIdRequiredException(try RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPullRequestApprovalStatesOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRevisionIdException(InvalidRevisionIdException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case revisionIdRequiredException(RevisionIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPullRequestApprovalStatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPullRequestApprovalStatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvals = output.approvals
        } else {
            self.approvals = nil
        }
    }
}

public struct GetPullRequestApprovalStatesOutputResponse: Swift.Equatable {
    /// Information about users who have approved the pull request.
    public var approvals: [CodeCommitClientTypes.Approval]?

    public init (
        approvals: [CodeCommitClientTypes.Approval]? = nil
    )
    {
        self.approvals = approvals
    }
}

struct GetPullRequestApprovalStatesOutputResponseBody: Swift.Equatable {
    let approvals: [CodeCommitClientTypes.Approval]?
}

extension GetPullRequestApprovalStatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvals
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.Approval?].self, forKey: .approvals)
        var approvalsDecoded0:[CodeCommitClientTypes.Approval]? = nil
        if let approvalsContainer = approvalsContainer {
            approvalsDecoded0 = [CodeCommitClientTypes.Approval]()
            for structure0 in approvalsContainer {
                if let structure0 = structure0 {
                    approvalsDecoded0?.append(structure0)
                }
            }
        }
        approvals = approvalsDecoded0
    }
}

extension GetPullRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension GetPullRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPullRequestInput: Swift.Equatable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init (
        pullRequestId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
    }
}

struct GetPullRequestInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
}

extension GetPullRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
    }
}

extension GetPullRequestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPullRequestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPullRequestOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPullRequestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPullRequestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct GetPullRequestOutputResponse: Swift.Equatable {
    /// Information about the specified pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init (
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct GetPullRequestOutputResponseBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension GetPullRequestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

extension GetPullRequestOverrideStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension GetPullRequestOverrideStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPullRequestOverrideStateInput: Swift.Equatable {
    /// The ID of the pull request for which you want to get information about whether approval rules have been set aside (overridden).
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID of the revision for the pull request. To retrieve the most recent revision ID, use [GetPullRequest].
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct GetPullRequestOverrideStateInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let revisionId: Swift.String?
}

extension GetPullRequestOverrideStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetPullRequestOverrideStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPullRequestOverrideStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRevisionIdException" : self = .invalidRevisionIdException(try InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionIdRequiredException" : self = .revisionIdRequiredException(try RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPullRequestOverrideStateOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRevisionIdException(InvalidRevisionIdException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case revisionIdRequiredException(RevisionIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPullRequestOverrideStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPullRequestOverrideStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.overridden = output.overridden
            self.overrider = output.overrider
        } else {
            self.overridden = false
            self.overrider = nil
        }
    }
}

public struct GetPullRequestOverrideStateOutputResponse: Swift.Equatable {
    /// A Boolean value that indicates whether a pull request has had its rules set aside (TRUE) or whether all approval rules still apply (FALSE).
    public var overridden: Swift.Bool
    /// The Amazon Resource Name (ARN) of the user or identity that overrode the rules and their requirements for the pull request.
    public var overrider: Swift.String?

    public init (
        overridden: Swift.Bool = false,
        overrider: Swift.String? = nil
    )
    {
        self.overridden = overridden
        self.overrider = overrider
    }
}

struct GetPullRequestOverrideStateOutputResponseBody: Swift.Equatable {
    let overridden: Swift.Bool
    let overrider: Swift.String?
}

extension GetPullRequestOverrideStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overridden
        case overrider
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overriddenDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overridden) ?? false
        overridden = overriddenDecoded
        let overriderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrider)
        overrider = overriderDecoded
    }
}

extension GetRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a get repository operation.
public struct GetRepositoryInput: Swift.Equatable {
    /// The name of the repository to get information about.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
}

extension GetRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRepositoryOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryMetadata = output.repositoryMetadata
        } else {
            self.repositoryMetadata = nil
        }
    }
}

/// Represents the output of a get repository operation.
public struct GetRepositoryOutputResponse: Swift.Equatable {
    /// Information about the repository.
    public var repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata?

    public init (
        repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata? = nil
    )
    {
        self.repositoryMetadata = repositoryMetadata
    }
}

struct GetRepositoryOutputResponseBody: Swift.Equatable {
    let repositoryMetadata: CodeCommitClientTypes.RepositoryMetadata?
}

extension GetRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryMetadata
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.RepositoryMetadata.self, forKey: .repositoryMetadata)
        repositoryMetadata = repositoryMetadataDecoded
    }
}

extension GetRepositoryTriggersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetRepositoryTriggersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a get repository triggers operation.
public struct GetRepositoryTriggersInput: Swift.Equatable {
    /// The name of the repository for which the trigger is configured.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryTriggersInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
}

extension GetRepositoryTriggersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryTriggersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryTriggersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRepositoryTriggersOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryTriggersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRepositoryTriggersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
            self.triggers = output.triggers
        } else {
            self.configurationId = nil
            self.triggers = nil
        }
    }
}

/// Represents the output of a get repository triggers operation.
public struct GetRepositoryTriggersOutputResponse: Swift.Equatable {
    /// The system-generated unique ID for the trigger.
    public var configurationId: Swift.String?
    /// The JSON block of configuration information for each trigger.
    public var triggers: [CodeCommitClientTypes.RepositoryTrigger]?

    public init (
        configurationId: Swift.String? = nil,
        triggers: [CodeCommitClientTypes.RepositoryTrigger]? = nil
    )
    {
        self.configurationId = configurationId
        self.triggers = triggers
    }
}

struct GetRepositoryTriggersOutputResponseBody: Swift.Equatable {
    let configurationId: Swift.String?
    let triggers: [CodeCommitClientTypes.RepositoryTrigger]?
}

extension GetRepositoryTriggersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case triggers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let triggersContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[CodeCommitClientTypes.RepositoryTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [CodeCommitClientTypes.RepositoryTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

extension IdempotencyParameterMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IdempotencyParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.
public struct IdempotencyParameterMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotencyParameterMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotencyParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidActorArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidActorArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request, and then try again.
public struct InvalidActorArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidActorArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidActorArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleContentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidApprovalRuleContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The content for the approval rule is not valid.
public struct InvalidApprovalRuleContentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalRuleContentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalRuleContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidApprovalRuleNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The name for the approval rule is not valid.
public struct InvalidApprovalRuleNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalRuleNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalRuleNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleTemplateContentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidApprovalRuleTemplateContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The content of the approval rule template is not valid.
public struct InvalidApprovalRuleTemplateContentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalRuleTemplateContentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalRuleTemplateContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleTemplateDescriptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidApprovalRuleTemplateDescriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in AWS CodeCommit, see [AWS CodeCommit User Guide](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
public struct InvalidApprovalRuleTemplateDescriptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalRuleTemplateDescriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalRuleTemplateDescriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleTemplateNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidApprovalRuleTemplateNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see [AWS CodeCommit User Guide](https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
public struct InvalidApprovalRuleTemplateNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalRuleTemplateNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalRuleTemplateNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidApprovalStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state for the approval is not valid. Valid values include APPROVE and REVOKE.
public struct InvalidApprovalStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApprovalStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAuthorArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidAuthorArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.
public struct InvalidAuthorArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAuthorArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAuthorArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidBlobIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidBlobIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified blob is not valid.
public struct InvalidBlobIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidBlobIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidBlobIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidBranchNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidBranchNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified reference name is not valid.
public struct InvalidBranchNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidBranchNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidBranchNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientRequestTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidClientRequestTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client request token is not valid.
public struct InvalidClientRequestTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClientRequestTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidClientRequestTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommentIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidCommentIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The comment ID is not in a valid format. Make sure that you have provided the full comment ID.
public struct InvalidCommentIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCommentIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCommentIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommitException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidCommitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified commit is not valid.
public struct InvalidCommitException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCommitExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCommitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommitIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidCommitIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified commit ID is not valid.
public struct InvalidCommitIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCommitIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCommitIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConflictDetailLevelException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidConflictDetailLevelExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified conflict detail level is not valid.
public struct InvalidConflictDetailLevelException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConflictDetailLevelExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConflictDetailLevelExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConflictResolutionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidConflictResolutionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified conflict resolution list is not valid.
public struct InvalidConflictResolutionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConflictResolutionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConflictResolutionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConflictResolutionStrategyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidConflictResolutionStrategyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified conflict resolution strategy is not valid.
public struct InvalidConflictResolutionStrategyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConflictResolutionStrategyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConflictResolutionStrategyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidContinuationTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidContinuationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified continuation token is not valid.
public struct InvalidContinuationTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidContinuationTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidContinuationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeletionParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidDeletionParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified deletion parameter is not valid.
public struct InvalidDeletionParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeletionParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDeletionParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDescriptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidDescriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pull request description is not valid. Descriptions cannot be more than 1,000 characters.
public struct InvalidDescriptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDescriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDescriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDestinationCommitSpecifierException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidDestinationCommitSpecifierExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.
public struct InvalidDestinationCommitSpecifierException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDestinationCommitSpecifierExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDestinationCommitSpecifierExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEmailException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidEmailExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.
public struct InvalidEmailException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEmailExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEmailExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFileLocationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidFileLocationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The location of the file is not valid. Make sure that you include the file name and extension.
public struct InvalidFileLocationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFileLocationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFileLocationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFileModeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidFileModeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified file mode permission is not valid. For a list of valid file mode permissions, see [PutFile].
public struct InvalidFileModeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFileModeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFileModeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilePositionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidFilePositionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.
public struct InvalidFilePositionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilePositionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFilePositionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxConflictFilesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidMaxConflictFilesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified value for the number of conflict files to return is not valid.
public struct InvalidMaxConflictFilesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxConflictFilesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxConflictFilesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxMergeHunksException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidMaxMergeHunksExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified value for the number of merge hunks to return is not valid.
public struct InvalidMaxMergeHunksException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxMergeHunksExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxMergeHunksExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified number of maximum results is not valid.
public struct InvalidMaxResultsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxResultsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMergeOptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidMergeOptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.
public struct InvalidMergeOptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMergeOptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMergeOptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOrderException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidOrderExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified sort order is not valid.
public struct InvalidOrderException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOrderExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOrderExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOverrideStatusException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidOverrideStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The override status is not valid. Valid statuses are OVERRIDE and REVOKE.
public struct InvalidOverrideStatusException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOverrideStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOverrideStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParentCommitIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParentCommitIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.
public struct InvalidParentCommitIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParentCommitIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParentCommitIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPathException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidPathExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified path is not valid.
public struct InvalidPathException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPathExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPathExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestEventTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidPullRequestEventTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pull request event type is not valid.
public struct InvalidPullRequestEventTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPullRequestEventTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPullRequestEventTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidPullRequestIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.
public struct InvalidPullRequestIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPullRequestIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPullRequestIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestStatusException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidPullRequestStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pull request status is not valid. The only valid values are OPEN and CLOSED.
public struct InvalidPullRequestStatusException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPullRequestStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPullRequestStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestStatusUpdateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidPullRequestStatusUpdateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pull request status update is not valid. The only valid update is from OPEN to CLOSED.
public struct InvalidPullRequestStatusUpdateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPullRequestStatusUpdateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPullRequestStatusUpdateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReactionUserArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidReactionUserArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Resource Name (ARN) of the user or identity is not valid.
public struct InvalidReactionUserArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReactionUserArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidReactionUserArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReactionValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidReactionValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value of the reaction is not valid. For more information, see the [AWS CodeCommit User Guide](https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html).
public struct InvalidReactionValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReactionValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidReactionValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReferenceNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidReferenceNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified reference name format is not valid. Reference names must conform to the Git references format (for example, refs/heads/master). For more information, see [Git Internals - Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References) or consult your Git documentation.
public struct InvalidReferenceNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReferenceNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidReferenceNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRelativeFileVersionEnumException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRelativeFileVersionEnumExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.
public struct InvalidRelativeFileVersionEnumException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRelativeFileVersionEnumExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRelativeFileVersionEnumExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReplacementContentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidReplacementContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing.
public struct InvalidReplacementContentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReplacementContentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidReplacementContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReplacementTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidReplacementTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Automerge was specified for resolving the conflict, but the specified replacement type is not valid.
public struct InvalidReplacementTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReplacementTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidReplacementTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryDescriptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRepositoryDescriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository description is not valid.
public struct InvalidRepositoryDescriptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryDescriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryDescriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRepositoryNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A specified repository name is not valid. This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.
public struct InvalidRepositoryNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerBranchNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRepositoryTriggerBranchNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more branch names specified for the trigger is not valid.
public struct InvalidRepositoryTriggerBranchNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerBranchNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerBranchNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerCustomDataException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRepositoryTriggerCustomDataExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The custom data provided for the trigger is not valid.
public struct InvalidRepositoryTriggerCustomDataException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerCustomDataExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerCustomDataExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerDestinationArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRepositoryTriggerDestinationArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.
public struct InvalidRepositoryTriggerDestinationArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerDestinationArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerDestinationArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerEventsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRepositoryTriggerEventsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.
public struct InvalidRepositoryTriggerEventsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerEventsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerEventsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRepositoryTriggerNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The name of the trigger is not valid.
public struct InvalidRepositoryTriggerNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerRegionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRepositoryTriggerRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The AWS Region for the trigger target does not match the AWS Region for the repository. Triggers must be created in the same Region as the target for the trigger.
public struct InvalidRepositoryTriggerRegionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRepositoryTriggerRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidResourceArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see [CodeCommit Resources and Operations](https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats) in the AWS CodeCommit User Guide.
public struct InvalidResourceArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRevisionIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRevisionIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The revision ID is not valid. Use GetPullRequest to determine the value.
public struct InvalidRevisionIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRevisionIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRevisionIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRuleContentSha256Exception {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRuleContentSha256ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The SHA-256 hash signature for the rule content is not valid.
public struct InvalidRuleContentSha256Exception: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRuleContentSha256ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRuleContentSha256ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSortByException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSortByExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified sort by value is not valid.
public struct InvalidSortByException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSortByExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSortByExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSourceCommitSpecifierException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSourceCommitSpecifierExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.
public struct InvalidSourceCommitSpecifierException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSourceCommitSpecifierExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSourceCommitSpecifierExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSystemTagUsageException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSystemTagUsageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified tag is not valid. Key names cannot be prefixed with aws:.
public struct InvalidSystemTagUsageException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSystemTagUsageExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSystemTagUsageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagKeysListException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTagKeysListExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The list of tags is not valid.
public struct InvalidTagKeysListException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagKeysListExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagKeysListExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagsMapException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTagsMapExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The map of tags is not valid.
public struct InvalidTagsMapException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagsMapExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagsMapExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetBranchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTargetBranchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified target branch is not valid.
public struct InvalidTargetBranchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetBranchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTargetBranchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTargetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.
public struct InvalidTargetException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTargetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTargetsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for the repository name, source branch, and destination branch for a pull request.
public struct InvalidTargetsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTargetsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTitleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTitleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.
public struct InvalidTitleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTitleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTitleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.IsBinaryFile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = self.base {
            try encodeContainer.encode(base, forKey: .base)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .base)
        base = baseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about whether a file is binary or textual in a merge or pull request operation.
    public struct IsBinaryFile: Swift.Equatable {
        /// The binary or non-binary status of a file in the base of a merge or pull request.
        public var base: Swift.Bool?
        /// The binary or non-binary status of a file in the destination of a merge or pull request.
        public var destination: Swift.Bool?
        /// The binary or non-binary status of file in the source of a merge or pull request.
        public var source: Swift.Bool?

        public init (
            base: Swift.Bool? = nil,
            destination: Swift.Bool? = nil,
            source: Swift.Bool? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }

}

extension ListApprovalRuleTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApprovalRuleTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApprovalRuleTemplatesInput: Swift.Equatable {
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApprovalRuleTemplatesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListApprovalRuleTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApprovalRuleTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApprovalRuleTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApprovalRuleTemplatesOutputError: Swift.Error, Swift.Equatable {
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApprovalRuleTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApprovalRuleTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplateNames = output.approvalRuleTemplateNames
            self.nextToken = output.nextToken
        } else {
            self.approvalRuleTemplateNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListApprovalRuleTemplatesOutputResponse: Swift.Equatable {
    /// The names of all the approval rule templates found in the AWS Region for your AWS account.
    public var approvalRuleTemplateNames: [Swift.String]?
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?

    public init (
        approvalRuleTemplateNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateNames = approvalRuleTemplateNames
        self.nextToken = nextToken
    }
}

struct ListApprovalRuleTemplatesOutputResponseBody: Swift.Equatable {
    let approvalRuleTemplateNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListApprovalRuleTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateNames
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvalRuleTemplateNames)
        var approvalRuleTemplateNamesDecoded0:[Swift.String]? = nil
        if let approvalRuleTemplateNamesContainer = approvalRuleTemplateNamesContainer {
            approvalRuleTemplateNamesDecoded0 = [Swift.String]()
            for string0 in approvalRuleTemplateNamesContainer {
                if let string0 = string0 {
                    approvalRuleTemplateNamesDecoded0?.append(string0)
                }
            }
        }
        approvalRuleTemplateNames = approvalRuleTemplateNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryInput: Swift.Equatable {
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The name of the repository for which you want to list all associated approval rule templates.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct ListAssociatedApprovalRuleTemplatesForRepositoryInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssociatedApprovalRuleTemplatesForRepositoryOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplateNames = output.approvalRuleTemplateNames
            self.nextToken = output.nextToken
        } else {
            self.approvalRuleTemplateNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse: Swift.Equatable {
    /// The names of all approval rule templates associated with the repository.
    public var approvalRuleTemplateNames: [Swift.String]?
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?

    public init (
        approvalRuleTemplateNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateNames = approvalRuleTemplateNames
        self.nextToken = nextToken
    }
}

struct ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponseBody: Swift.Equatable {
    let approvalRuleTemplateNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateNames
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvalRuleTemplateNames)
        var approvalRuleTemplateNamesDecoded0:[Swift.String]? = nil
        if let approvalRuleTemplateNamesContainer = approvalRuleTemplateNamesContainer {
            approvalRuleTemplateNamesDecoded0 = [Swift.String]()
            for string0 in approvalRuleTemplateNamesContainer {
                if let string0 = string0 {
                    approvalRuleTemplateNamesDecoded0?.append(string0)
                }
            }
        }
        approvalRuleTemplateNames = approvalRuleTemplateNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBranchesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension ListBranchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a list branches operation.
public struct ListBranchesInput: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the results.
    public var nextToken: Swift.String?
    /// The name of the repository that contains the branches.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct ListBranchesInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let nextToken: Swift.String?
}

extension ListBranchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBranchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBranchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBranchesOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBranchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBranchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.branches = output.branches
            self.nextToken = output.nextToken
        } else {
            self.branches = nil
            self.nextToken = nil
        }
    }
}

/// Represents the output of a list branches operation.
public struct ListBranchesOutputResponse: Swift.Equatable {
    /// The list of branch names.
    public var branches: [Swift.String]?
    /// An enumeration token that returns the batch of the results.
    public var nextToken: Swift.String?

    public init (
        branches: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.branches = branches
        self.nextToken = nextToken
    }
}

struct ListBranchesOutputResponseBody: Swift.Equatable {
    let branches: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListBranchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branches
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .branches)
        var branchesDecoded0:[Swift.String]? = nil
        if let branchesContainer = branchesContainer {
            branchesDecoded0 = [Swift.String]()
            for string0 in branchesContainer {
                if let string0 = string0 {
                    branchesDecoded0?.append(string0)
                }
            }
        }
        branches = branchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPullRequestsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorArn
        case maxResults
        case nextToken
        case pullRequestStatus
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorArn = self.authorArn {
            try encodeContainer.encode(authorArn, forKey: .authorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pullRequestStatus = self.pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension ListPullRequestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPullRequestsInput: Swift.Equatable {
    /// Optional. The Amazon Resource Name (ARN) of the user who created the pull request. If used, this filters the results to pull requests created by that user.
    public var authorArn: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// Optional. The status of the pull request. If used, this refines the results to the pull requests that match the specified status.
    public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?
    /// The name of the repository for which you want to list pull requests.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        authorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.authorArn = authorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestStatus = pullRequestStatus
        self.repositoryName = repositoryName
    }
}

struct ListPullRequestsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let authorArn: Swift.String?
    let pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPullRequestsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorArn
        case maxResults
        case nextToken
        case pullRequestStatus
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let authorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorArn)
        authorArn = authorArnDecoded
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPullRequestsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPullRequestsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorDoesNotExistException" : self = .authorDoesNotExistException(try AuthorDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAuthorArnException" : self = .invalidAuthorArnException(try InvalidAuthorArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestStatusException" : self = .invalidPullRequestStatusException(try InvalidPullRequestStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPullRequestsOutputError: Swift.Error, Swift.Equatable {
    case authorDoesNotExistException(AuthorDoesNotExistException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidAuthorArnException(InvalidAuthorArnException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidPullRequestStatusException(InvalidPullRequestStatusException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPullRequestsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPullRequestsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pullRequestIds = output.pullRequestIds
        } else {
            self.nextToken = nil
            self.pullRequestIds = nil
        }
    }
}

public struct ListPullRequestsOutputResponse: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?
    /// The system-generated IDs of the pull requests.
    /// This member is required.
    public var pullRequestIds: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        pullRequestIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.pullRequestIds = pullRequestIds
    }
}

struct ListPullRequestsOutputResponseBody: Swift.Equatable {
    let pullRequestIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPullRequestsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case pullRequestIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pullRequestIds)
        var pullRequestIdsDecoded0:[Swift.String]? = nil
        if let pullRequestIdsContainer = pullRequestIdsContainer {
            pullRequestIdsDecoded0 = [Swift.String]()
            for string0 in pullRequestIdsContainer {
                if let string0 = string0 {
                    pullRequestIdsDecoded0?.append(string0)
                }
            }
        }
        pullRequestIds = pullRequestIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositoriesForApprovalRuleTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRepositoriesForApprovalRuleTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRepositoriesForApprovalRuleTemplateInput: Swift.Equatable {
    /// The name of the approval rule template for which you want to list repositories that are associated with that template.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// A non-zero, non-negative integer used to limit the number of returned results.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init (
        approvalRuleTemplateName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRepositoriesForApprovalRuleTemplateInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRepositoriesForApprovalRuleTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRepositoriesForApprovalRuleTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesForApprovalRuleTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRepositoriesForApprovalRuleTemplateOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesForApprovalRuleTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRepositoriesForApprovalRuleTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositoryNames = output.repositoryNames
        } else {
            self.nextToken = nil
            self.repositoryNames = nil
        }
    }
}

public struct ListRepositoriesForApprovalRuleTemplateOutputResponse: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?
    /// A list of repository names that are associated with the specified approval rule template.
    public var repositoryNames: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryNames = repositoryNames
    }
}

struct ListRepositoriesForApprovalRuleTemplateOutputResponseBody: Swift.Equatable {
    let repositoryNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListRepositoriesForApprovalRuleTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositoryNames
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case order
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
    }
}

extension ListRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a list repositories operation.
public struct ListRepositoriesInput: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit, another page of 1,000 records is retrieved.
    public var nextToken: Swift.String?
    /// The order in which to sort the results of a list repositories operation.
    public var order: CodeCommitClientTypes.OrderEnum?
    /// The criteria used to sort the results of a list repositories operation.
    public var sortBy: CodeCommitClientTypes.SortByEnum?

    public init (
        nextToken: Swift.String? = nil,
        order: CodeCommitClientTypes.OrderEnum? = nil,
        sortBy: CodeCommitClientTypes.SortByEnum? = nil
    )
    {
        self.nextToken = nextToken
        self.order = order
        self.sortBy = sortBy
    }
}

struct ListRepositoriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sortBy: CodeCommitClientTypes.SortByEnum?
    let order: CodeCommitClientTypes.OrderEnum?
}

extension ListRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case order
        case sortBy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.SortByEnum.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let orderDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.OrderEnum.self, forKey: .order)
        order = orderDecoded
    }
}

extension ListRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrderException" : self = .invalidOrderException(try InvalidOrderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSortByException" : self = .invalidSortByException(try InvalidSortByException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidOrderException(InvalidOrderException)
    case invalidSortByException(InvalidSortByException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

/// Represents the output of a list repositories operation.
public struct ListRepositoriesOutputResponse: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit, another page of 1,000 records is retrieved.
    public var nextToken: Swift.String?
    /// Lists the repositories called by the list repositories operation.
    public var repositories: [CodeCommitClientTypes.RepositoryNameIdPair]?

    public init (
        nextToken: Swift.String? = nil,
        repositories: [CodeCommitClientTypes.RepositoryNameIdPair]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesOutputResponseBody: Swift.Equatable {
    let repositories: [CodeCommitClientTypes.RepositoryNameIdPair]?
    let nextToken: Swift.String?
}

extension ListRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryNameIdPair?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeCommitClientTypes.RepositoryNameIdPair]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeCommitClientTypes.RepositoryNameIdPair]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to get information about tags, if any.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceArnException" : self = .invalidResourceArnException(try InvalidResourceArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceArnRequiredException" : self = .resourceArnRequiredException(try ResourceArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidResourceArnException(InvalidResourceArnException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case resourceArnRequiredException(ResourceArnRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// An enumeration token that allows the operation to batch the next results of the operation.
    public var nextToken: Swift.String?
    /// A list of tag key and value pairs associated with the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CodeCommitClientTypes.Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePath
        case filePosition
        case relativeFileVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let filePosition = self.filePosition {
            try encodeContainer.encode(filePosition, forKey: .filePosition)
        }
        if let relativeFileVersion = self.relativeFileVersion {
            try encodeContainer.encode(relativeFileVersion.rawValue, forKey: .relativeFileVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let filePositionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .filePosition)
        filePosition = filePositionDecoded
        let relativeFileVersionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.RelativeFileVersionEnum.self, forKey: .relativeFileVersion)
        relativeFileVersion = relativeFileVersionDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about the location of a change or comment in the comparison between two commits or a pull request.
    public struct Location: Swift.Equatable {
        /// The name of the file being compared, including its extension and subdirectory, if any.
        public var filePath: Swift.String?
        /// The position of a change in a compared file, in line number format.
        public var filePosition: Swift.Int?
        /// In a comparison of commits or a pull request, whether the change is in the before or after of that comparison.
        public var relativeFileVersion: CodeCommitClientTypes.RelativeFileVersionEnum?

        public init (
            filePath: Swift.String? = nil,
            filePosition: Swift.Int? = nil,
            relativeFileVersion: CodeCommitClientTypes.RelativeFileVersionEnum? = nil
        )
        {
            self.filePath = filePath
            self.filePosition = filePosition
            self.relativeFileVersion = relativeFileVersion
        }
    }

}

extension ManualMergeRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ManualMergeRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.
public struct ManualMergeRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ManualMergeRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ManualMergeRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumBranchesExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumBranchesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of branches for the trigger was exceeded.
public struct MaximumBranchesExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumBranchesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumBranchesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumConflictResolutionEntriesExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumConflictResolutionEntriesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of allowed conflict resolution entries was exceeded.
public struct MaximumConflictResolutionEntriesExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumConflictResolutionEntriesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumConflictResolutionEntriesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumFileContentToLoadExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumFileContentToLoadExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of files to load exceeds the allowed limit.
public struct MaximumFileContentToLoadExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumFileContentToLoadExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumFileContentToLoadExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumFileEntriesExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumFileEntriesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of specified files to change as part of this commit exceeds the maximum number of files that can be changed in a single commit. Consider using a Git client for these changes.
public struct MaximumFileEntriesExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumFileEntriesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumFileEntriesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumItemsToCompareExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumItemsToCompareExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.
public struct MaximumItemsToCompareExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumItemsToCompareExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumItemsToCompareExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumNumberOfApprovalsExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumNumberOfApprovalsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of approvals required for the approval rule exceeds the maximum number allowed.
public struct MaximumNumberOfApprovalsExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumNumberOfApprovalsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumNumberOfApprovalsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumOpenPullRequestsExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumOpenPullRequestsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot create the pull request because the repository has too many open pull requests. The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.
public struct MaximumOpenPullRequestsExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumOpenPullRequestsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumOpenPullRequestsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumRepositoryNamesExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumRepositoryNamesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of allowed repository names was exceeded. Currently, this number is 100.
public struct MaximumRepositoryNamesExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumRepositoryNamesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumRepositoryNamesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumRepositoryTriggersExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumRepositoryTriggersExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of triggers allowed for the repository was exceeded.
public struct MaximumRepositoryTriggersExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumRepositoryTriggersExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumRepositoryTriggersExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumRuleTemplatesAssociatedWithRepositoryException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaximumRuleTemplatesAssociatedWithRepositoryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25 approval rule templates with a repository.
public struct MaximumRuleTemplatesAssociatedWithRepositoryException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumRuleTemplatesAssociatedWithRepositoryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumRuleTemplatesAssociatedWithRepositoryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MergeBranchesByFastForwardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
        if let targetBranch = self.targetBranch {
            try encodeContainer.encode(targetBranch, forKey: .targetBranch)
        }
    }
}

extension MergeBranchesByFastForwardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergeBranchesByFastForwardInput: Swift.Equatable {
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The name of the repository where you want to merge two branches.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?
    /// The branch where the merge is applied.
    public var targetBranch: Swift.String?

    public init (
        destinationCommitSpecifier: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil,
        targetBranch: Swift.String? = nil
    )
    {
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

struct MergeBranchesByFastForwardInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let targetBranch: Swift.String?
}

extension MergeBranchesByFastForwardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let targetBranchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBranch)
        targetBranch = targetBranchDecoded
    }
}

extension MergeBranchesByFastForwardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeBranchesByFastForwardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetBranchException" : self = .invalidTargetBranchException(try InvalidTargetBranchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum MergeBranchesByFastForwardOutputError: Swift.Error, Swift.Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidCommitException(InvalidCommitException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidTargetBranchException(InvalidTargetBranchException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeBranchesByFastForwardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MergeBranchesByFastForwardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct MergeBranchesByFastForwardOutputResponse: Swift.Equatable {
    /// The commit ID of the merge in the destination or target branch.
    public var commitId: Swift.String?
    /// The tree ID of the merge in the destination or target branch.
    public var treeId: Swift.String?

    public init (
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct MergeBranchesByFastForwardOutputResponseBody: Swift.Equatable {
    let commitId: Swift.String?
    let treeId: Swift.String?
}

extension MergeBranchesByFastForwardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case treeId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

extension MergeBranchesBySquashInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
        if let targetBranch = self.targetBranch {
            try encodeContainer.encode(targetBranch, forKey: .targetBranch)
        }
    }
}

extension MergeBranchesBySquashInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergeBranchesBySquashInput: Swift.Equatable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If this is specified as true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool
    /// The name of the repository where you want to merge two branches.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?
    /// The branch where the merge is applied.
    public var targetBranch: Swift.String?

    public init (
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool = false,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil,
        targetBranch: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

struct MergeBranchesBySquashInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let targetBranch: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let authorName: Swift.String?
    let email: Swift.String?
    let commitMessage: Swift.String?
    let keepEmptyFolders: Swift.Bool
    let conflictResolution: CodeCommitClientTypes.ConflictResolution?
}

extension MergeBranchesBySquashInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let targetBranchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBranch)
        targetBranch = targetBranchDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders) ?? false
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergeBranchesBySquashOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeBranchesBySquashOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileModeRequiredException" : self = .fileModeRequiredException(try FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionException" : self = .invalidConflictResolutionException(try InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementContentException" : self = .invalidReplacementContentException(try InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementTypeException" : self = .invalidReplacementTypeException(try InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetBranchException" : self = .invalidTargetBranchException(try InvalidTargetBranchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumConflictResolutionEntriesExceededException" : self = .maximumConflictResolutionEntriesExceededException(try MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleConflictResolutionEntriesException" : self = .multipleConflictResolutionEntriesException(try MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementContentRequiredException" : self = .replacementContentRequiredException(try ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementTypeRequiredException" : self = .replacementTypeRequiredException(try ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum MergeBranchesBySquashOutputError: Swift.Error, Swift.Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case commitRequiredException(CommitRequiredException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case fileModeRequiredException(FileModeRequiredException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionException(InvalidConflictResolutionException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidPathException(InvalidPathException)
    case invalidReplacementContentException(InvalidReplacementContentException)
    case invalidReplacementTypeException(InvalidReplacementTypeException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidTargetBranchException(InvalidTargetBranchException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case maximumConflictResolutionEntriesExceededException(MaximumConflictResolutionEntriesExceededException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case multipleConflictResolutionEntriesException(MultipleConflictResolutionEntriesException)
    case nameLengthExceededException(NameLengthExceededException)
    case pathRequiredException(PathRequiredException)
    case replacementContentRequiredException(ReplacementContentRequiredException)
    case replacementTypeRequiredException(ReplacementTypeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeBranchesBySquashOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MergeBranchesBySquashOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct MergeBranchesBySquashOutputResponse: Swift.Equatable {
    /// The commit ID of the merge in the destination or target branch.
    public var commitId: Swift.String?
    /// The tree ID of the merge in the destination or target branch.
    public var treeId: Swift.String?

    public init (
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct MergeBranchesBySquashOutputResponseBody: Swift.Equatable {
    let commitId: Swift.String?
    let treeId: Swift.String?
}

extension MergeBranchesBySquashOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case treeId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

extension MergeBranchesByThreeWayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = self.destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = self.sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
        if let targetBranch = self.targetBranch {
            try encodeContainer.encode(targetBranch, forKey: .targetBranch)
        }
    }
}

extension MergeBranchesByThreeWayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergeBranchesByThreeWayInput: Swift.Equatable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message to include in the commit information for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var destinationCommitSpecifier: Swift.String?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool
    /// The name of the repository where you want to merge two branches.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit (for example, a branch name or a full commit ID).
    /// This member is required.
    public var sourceCommitSpecifier: Swift.String?
    /// The branch where the merge is applied.
    public var targetBranch: Swift.String?

    public init (
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: Swift.String? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool = false,
        repositoryName: Swift.String? = nil,
        sourceCommitSpecifier: Swift.String? = nil,
        targetBranch: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

struct MergeBranchesByThreeWayInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let sourceCommitSpecifier: Swift.String?
    let destinationCommitSpecifier: Swift.String?
    let targetBranch: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let authorName: Swift.String?
    let email: Swift.String?
    let commitMessage: Swift.String?
    let keepEmptyFolders: Swift.Bool
    let conflictResolution: CodeCommitClientTypes.ConflictResolution?
}

extension MergeBranchesByThreeWayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let targetBranchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBranch)
        targetBranch = targetBranchDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders) ?? false
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergeBranchesByThreeWayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeBranchesByThreeWayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileModeRequiredException" : self = .fileModeRequiredException(try FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionException" : self = .invalidConflictResolutionException(try InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementContentException" : self = .invalidReplacementContentException(try InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementTypeException" : self = .invalidReplacementTypeException(try InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetBranchException" : self = .invalidTargetBranchException(try InvalidTargetBranchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumConflictResolutionEntriesExceededException" : self = .maximumConflictResolutionEntriesExceededException(try MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleConflictResolutionEntriesException" : self = .multipleConflictResolutionEntriesException(try MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementContentRequiredException" : self = .replacementContentRequiredException(try ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementTypeRequiredException" : self = .replacementTypeRequiredException(try ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum MergeBranchesByThreeWayOutputError: Swift.Error, Swift.Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case commitRequiredException(CommitRequiredException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case fileModeRequiredException(FileModeRequiredException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionException(InvalidConflictResolutionException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidPathException(InvalidPathException)
    case invalidReplacementContentException(InvalidReplacementContentException)
    case invalidReplacementTypeException(InvalidReplacementTypeException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidTargetBranchException(InvalidTargetBranchException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case maximumConflictResolutionEntriesExceededException(MaximumConflictResolutionEntriesExceededException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case multipleConflictResolutionEntriesException(MultipleConflictResolutionEntriesException)
    case nameLengthExceededException(NameLengthExceededException)
    case pathRequiredException(PathRequiredException)
    case replacementContentRequiredException(ReplacementContentRequiredException)
    case replacementTypeRequiredException(ReplacementTypeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeBranchesByThreeWayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MergeBranchesByThreeWayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct MergeBranchesByThreeWayOutputResponse: Swift.Equatable {
    /// The commit ID of the merge in the destination or target branch.
    public var commitId: Swift.String?
    /// The tree ID of the merge in the destination or target branch.
    public var treeId: Swift.String?

    public init (
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct MergeBranchesByThreeWayOutputResponseBody: Swift.Equatable {
    let commitId: Swift.String?
    let treeId: Swift.String?
}

extension MergeBranchesByThreeWayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case treeId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

extension CodeCommitClientTypes.MergeHunk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case destination
        case isConflict
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = self.base {
            try encodeContainer.encode(base, forKey: .base)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if isConflict != false {
            try encodeContainer.encode(isConflict, forKey: .isConflict)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isConflictDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isConflict) ?? false
        isConflict = isConflictDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeHunkDetail.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeHunkDetail.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeHunkDetail.self, forKey: .base)
        base = baseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about merge hunks in a merge or pull request operation.
    public struct MergeHunk: Swift.Equatable {
        /// Information about the merge hunk in the base of a merge or pull request.
        public var base: CodeCommitClientTypes.MergeHunkDetail?
        /// Information about the merge hunk in the destination of a merge or pull request.
        public var destination: CodeCommitClientTypes.MergeHunkDetail?
        /// A Boolean value indicating whether a combination of hunks contains a conflict. Conflicts occur when the same file or the same lines in a file were modified in both the source and destination of a merge or pull request. Valid values include true, false, and null. True when the hunk represents a conflict and one or more files contains a line conflict. File mode conflicts in a merge do not set this to true.
        public var isConflict: Swift.Bool
        /// Information about the merge hunk in the source of a merge or pull request.
        public var source: CodeCommitClientTypes.MergeHunkDetail?

        public init (
            base: CodeCommitClientTypes.MergeHunkDetail? = nil,
            destination: CodeCommitClientTypes.MergeHunkDetail? = nil,
            isConflict: Swift.Bool = false,
            source: CodeCommitClientTypes.MergeHunkDetail? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.isConflict = isConflict
            self.source = source
        }
    }

}

extension CodeCommitClientTypes.MergeHunkDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endLine
        case hunkContent
        case startLine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endLine = self.endLine {
            try encodeContainer.encode(endLine, forKey: .endLine)
        }
        if let hunkContent = self.hunkContent {
            try encodeContainer.encode(hunkContent, forKey: .hunkContent)
        }
        if let startLine = self.startLine {
            try encodeContainer.encode(startLine, forKey: .startLine)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startLine)
        startLine = startLineDecoded
        let endLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endLine)
        endLine = endLineDecoded
        let hunkContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hunkContent)
        hunkContent = hunkContentDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the details of a merge hunk that contains a conflict in a merge or pull request operation.
    public struct MergeHunkDetail: Swift.Equatable {
        /// The end position of the hunk in the merge result.
        public var endLine: Swift.Int?
        /// The base-64 encoded content of the hunk merged region that might contain a conflict.
        public var hunkContent: Swift.String?
        /// The start position of the hunk in the merge result.
        public var startLine: Swift.Int?

        public init (
            endLine: Swift.Int? = nil,
            hunkContent: Swift.String? = nil,
            startLine: Swift.Int? = nil
        )
        {
            self.endLine = endLine
            self.hunkContent = hunkContent
            self.startLine = startLine
        }
    }

}

extension CodeCommitClientTypes.MergeMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isMerged
        case mergeCommitId
        case mergeOption
        case mergedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isMerged != false {
            try encodeContainer.encode(isMerged, forKey: .isMerged)
        }
        if let mergeCommitId = self.mergeCommitId {
            try encodeContainer.encode(mergeCommitId, forKey: .mergeCommitId)
        }
        if let mergeOption = self.mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let mergedBy = self.mergedBy {
            try encodeContainer.encode(mergedBy, forKey: .mergedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isMergedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMerged) ?? false
        isMerged = isMergedDecoded
        let mergedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedBy)
        mergedBy = mergedByDecoded
        let mergeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergeCommitId)
        mergeCommitId = mergeCommitIdDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a merge or potential merge between a source reference and a destination reference in a pull request.
    public struct MergeMetadata: Swift.Equatable {
        /// A Boolean value indicating whether the merge has been made.
        public var isMerged: Swift.Bool
        /// The commit ID for the merge commit, if any.
        public var mergeCommitId: Swift.String?
        /// The merge strategy used in the merge.
        public var mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum?
        /// The Amazon Resource Name (ARN) of the user who merged the branches.
        public var mergedBy: Swift.String?

        public init (
            isMerged: Swift.Bool = false,
            mergeCommitId: Swift.String? = nil,
            mergeOption: CodeCommitClientTypes.MergeOptionTypeEnum? = nil,
            mergedBy: Swift.String? = nil
        )
        {
            self.isMerged = isMerged
            self.mergeCommitId = mergeCommitId
            self.mergeOption = mergeOption
            self.mergedBy = mergedBy
        }
    }

}

extension CodeCommitClientTypes.MergeOperations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination.rawValue, forKey: .destination)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ChangeTypeEnum.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ChangeTypeEnum.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the file operation conflicts in a merge operation.
    public struct MergeOperations: Swift.Equatable {
        /// The operation on a file in the destination of a merge or pull request.
        public var destination: CodeCommitClientTypes.ChangeTypeEnum?
        /// The operation (add, modify, or delete) on a file in the source of a merge or pull request.
        public var source: CodeCommitClientTypes.ChangeTypeEnum?

        public init (
            destination: CodeCommitClientTypes.ChangeTypeEnum? = nil,
            source: CodeCommitClientTypes.ChangeTypeEnum? = nil
        )
        {
            self.destination = destination
            self.source = source
        }
    }

}

extension MergeOptionRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MergeOptionRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A merge option or stategy is required, and none was provided.
public struct MergeOptionRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MergeOptionRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MergeOptionRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum MergeOptionTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fastForwardMerge
        case squashMerge
        case threeWayMerge
        case sdkUnknown(Swift.String)

        public static var allCases: [MergeOptionTypeEnum] {
            return [
                .fastForwardMerge,
                .squashMerge,
                .threeWayMerge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fastForwardMerge: return "FAST_FORWARD_MERGE"
            case .squashMerge: return "SQUASH_MERGE"
            case .threeWayMerge: return "THREE_WAY_MERGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MergeOptionTypeEnum(rawValue: rawValue) ?? MergeOptionTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension MergePullRequestByFastForwardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = self.sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }
}

extension MergePullRequestByFastForwardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergePullRequestByFastForwardInput: Swift.Equatable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.
    public var sourceCommitId: Swift.String?

    public init (
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

struct MergePullRequestByFastForwardInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let repositoryName: Swift.String?
    let sourceCommitId: Swift.String?
}

extension MergePullRequestByFastForwardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
    }
}

extension MergePullRequestByFastForwardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergePullRequestByFastForwardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestApprovalRulesNotSatisfiedException" : self = .pullRequestApprovalRulesNotSatisfiedException(try PullRequestApprovalRulesNotSatisfiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferenceDoesNotExistException" : self = .referenceDoesNotExistException(try ReferenceDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotAssociatedWithPullRequestException" : self = .repositoryNotAssociatedWithPullRequestException(try RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipOfSourceReferenceIsDifferentException" : self = .tipOfSourceReferenceIsDifferentException(try TipOfSourceReferenceIsDifferentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum MergePullRequestByFastForwardOutputError: Swift.Error, Swift.Equatable {
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestApprovalRulesNotSatisfiedException(PullRequestApprovalRulesNotSatisfiedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case referenceDoesNotExistException(ReferenceDoesNotExistException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryNotAssociatedWithPullRequestException(RepositoryNotAssociatedWithPullRequestException)
    case tipOfSourceReferenceIsDifferentException(TipOfSourceReferenceIsDifferentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergePullRequestByFastForwardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MergePullRequestByFastForwardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct MergePullRequestByFastForwardOutputResponse: Swift.Equatable {
    /// Information about the specified pull request, including the merge.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init (
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct MergePullRequestByFastForwardOutputResponseBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension MergePullRequestByFastForwardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

extension MergePullRequestBySquashInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = self.sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }
}

extension MergePullRequestBySquashInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergePullRequestBySquashInput: Swift.Equatable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message to include in the commit information for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.
    public var sourceCommitId: Swift.String?

    public init (
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool = false,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

struct MergePullRequestBySquashInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let repositoryName: Swift.String?
    let sourceCommitId: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let commitMessage: Swift.String?
    let authorName: Swift.String?
    let email: Swift.String?
    let keepEmptyFolders: Swift.Bool
    let conflictResolution: CodeCommitClientTypes.ConflictResolution?
}

extension MergePullRequestBySquashInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders) ?? false
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergePullRequestBySquashOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergePullRequestBySquashOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionException" : self = .invalidConflictResolutionException(try InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementContentException" : self = .invalidReplacementContentException(try InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementTypeException" : self = .invalidReplacementTypeException(try InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumConflictResolutionEntriesExceededException" : self = .maximumConflictResolutionEntriesExceededException(try MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleConflictResolutionEntriesException" : self = .multipleConflictResolutionEntriesException(try MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestApprovalRulesNotSatisfiedException" : self = .pullRequestApprovalRulesNotSatisfiedException(try PullRequestApprovalRulesNotSatisfiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementContentRequiredException" : self = .replacementContentRequiredException(try ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementTypeRequiredException" : self = .replacementTypeRequiredException(try ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotAssociatedWithPullRequestException" : self = .repositoryNotAssociatedWithPullRequestException(try RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipOfSourceReferenceIsDifferentException" : self = .tipOfSourceReferenceIsDifferentException(try TipOfSourceReferenceIsDifferentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum MergePullRequestBySquashOutputError: Swift.Error, Swift.Equatable {
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionException(InvalidConflictResolutionException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidPathException(InvalidPathException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidReplacementContentException(InvalidReplacementContentException)
    case invalidReplacementTypeException(InvalidReplacementTypeException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case maximumConflictResolutionEntriesExceededException(MaximumConflictResolutionEntriesExceededException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case multipleConflictResolutionEntriesException(MultipleConflictResolutionEntriesException)
    case nameLengthExceededException(NameLengthExceededException)
    case pathRequiredException(PathRequiredException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestApprovalRulesNotSatisfiedException(PullRequestApprovalRulesNotSatisfiedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case replacementContentRequiredException(ReplacementContentRequiredException)
    case replacementTypeRequiredException(ReplacementTypeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryNotAssociatedWithPullRequestException(RepositoryNotAssociatedWithPullRequestException)
    case tipOfSourceReferenceIsDifferentException(TipOfSourceReferenceIsDifferentException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergePullRequestBySquashOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MergePullRequestBySquashOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct MergePullRequestBySquashOutputResponse: Swift.Equatable {
    /// Returns information about a pull request.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init (
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct MergePullRequestBySquashOutputResponseBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension MergePullRequestBySquashOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

extension MergePullRequestByThreeWayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = self.conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = self.conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = self.sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }
}

extension MergePullRequestByThreeWayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MergePullRequestByThreeWayInput: Swift.Equatable {
    /// The name of the author who created the commit. This information is used as both the author and committer for the commit.
    public var authorName: Swift.String?
    /// The commit message to include in the commit information for the merge.
    public var commitMessage: Swift.String?
    /// The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used, which returns a not-mergeable result if the same file has differences in both branches. If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in both branches has differences on the same line.
    public var conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    /// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when resolving conflicts during a merge.
    public var conflictResolution: CodeCommitClientTypes.ConflictResolution?
    /// Specifies which branch to use when resolving conflicts, or whether to attempt automatically merging two versions of a file. The default is NONE, which requires any conflicts to be resolved manually before the merge operation is successful.
    public var conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    /// The email address of the person merging the branches. This information is used in the commit information for the merge.
    public var email: Swift.String?
    /// If the commit contains deletions, whether to keep a folder or folder structure if the changes leave the folders empty. If true, a .gitkeep file is created for empty folders. The default is false.
    public var keepEmptyFolders: Swift.Bool
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where the pull request was created.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.
    public var sourceCommitId: Swift.String?

    public init (
        authorName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: CodeCommitClientTypes.ConflictResolution? = nil,
        conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum? = nil,
        email: Swift.String? = nil,
        keepEmptyFolders: Swift.Bool = false,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        sourceCommitId: Swift.String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

struct MergePullRequestByThreeWayInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let repositoryName: Swift.String?
    let sourceCommitId: Swift.String?
    let conflictDetailLevel: CodeCommitClientTypes.ConflictDetailLevelTypeEnum?
    let conflictResolutionStrategy: CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum?
    let commitMessage: Swift.String?
    let authorName: Swift.String?
    let email: Swift.String?
    let keepEmptyFolders: Swift.Bool
    let conflictResolution: CodeCommitClientTypes.ConflictResolution?
}

extension MergePullRequestByThreeWayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let keepEmptyFoldersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keepEmptyFolders) ?? false
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergePullRequestByThreeWayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergePullRequestByThreeWayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionException" : self = .invalidConflictResolutionException(try InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementContentException" : self = .invalidReplacementContentException(try InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementTypeException" : self = .invalidReplacementTypeException(try InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumConflictResolutionEntriesExceededException" : self = .maximumConflictResolutionEntriesExceededException(try MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleConflictResolutionEntriesException" : self = .multipleConflictResolutionEntriesException(try MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestApprovalRulesNotSatisfiedException" : self = .pullRequestApprovalRulesNotSatisfiedException(try PullRequestApprovalRulesNotSatisfiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementContentRequiredException" : self = .replacementContentRequiredException(try ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementTypeRequiredException" : self = .replacementTypeRequiredException(try ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotAssociatedWithPullRequestException" : self = .repositoryNotAssociatedWithPullRequestException(try RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipOfSourceReferenceIsDifferentException" : self = .tipOfSourceReferenceIsDifferentException(try TipOfSourceReferenceIsDifferentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum MergePullRequestByThreeWayOutputError: Swift.Error, Swift.Equatable {
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionException(InvalidConflictResolutionException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidPathException(InvalidPathException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidReplacementContentException(InvalidReplacementContentException)
    case invalidReplacementTypeException(InvalidReplacementTypeException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case maximumConflictResolutionEntriesExceededException(MaximumConflictResolutionEntriesExceededException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case multipleConflictResolutionEntriesException(MultipleConflictResolutionEntriesException)
    case nameLengthExceededException(NameLengthExceededException)
    case pathRequiredException(PathRequiredException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestApprovalRulesNotSatisfiedException(PullRequestApprovalRulesNotSatisfiedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case replacementContentRequiredException(ReplacementContentRequiredException)
    case replacementTypeRequiredException(ReplacementTypeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryNotAssociatedWithPullRequestException(RepositoryNotAssociatedWithPullRequestException)
    case tipOfSourceReferenceIsDifferentException(TipOfSourceReferenceIsDifferentException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergePullRequestByThreeWayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MergePullRequestByThreeWayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct MergePullRequestByThreeWayOutputResponse: Swift.Equatable {
    /// Returns information about a pull request.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init (
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct MergePullRequestByThreeWayOutputResponseBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension MergePullRequestByThreeWayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

extension MultipleConflictResolutionEntriesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MultipleConflictResolutionEntriesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.
public struct MultipleConflictResolutionEntriesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MultipleConflictResolutionEntriesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MultipleConflictResolutionEntriesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MultipleRepositoriesInPullRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MultipleRepositoriesInPullRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.
public struct MultipleRepositoriesInPullRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MultipleRepositoriesInPullRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MultipleRepositoriesInPullRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NameLengthExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NameLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user name is not valid because it has exceeded the character limit for author names.
public struct NameLengthExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NameLengthExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NameLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoChangeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoChangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.
public struct NoChangeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoChangeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoChangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NumberOfRuleTemplatesExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NumberOfRuleTemplatesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of approval rule templates has been exceeded for this AWS Region.
public struct NumberOfRuleTemplatesExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NumberOfRuleTemplatesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NumberOfRuleTemplatesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NumberOfRulesExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NumberOfRulesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.
public struct NumberOfRulesExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NumberOfRulesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NumberOfRulesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum ObjectTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directory
        case file
        case gitLink
        case symbolicLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectTypeEnum] {
            return [
                .directory,
                .file,
                .gitLink,
                .symbolicLink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directory: return "DIRECTORY"
            case .file: return "FILE"
            case .gitLink: return "GIT_LINK"
            case .symbolicLink: return "SYMBOLIC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectTypeEnum(rawValue: rawValue) ?? ObjectTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.ObjectTypes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = self.base {
            try encodeContainer.encode(base.rawValue, forKey: .base)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination.rawValue, forKey: .destination)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ObjectTypeEnum.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ObjectTypeEnum.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ObjectTypeEnum.self, forKey: .base)
        base = baseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the type of an object in a merge operation.
    public struct ObjectTypes: Swift.Equatable {
        /// The type of the object in the base commit of the merge.
        public var base: CodeCommitClientTypes.ObjectTypeEnum?
        /// The type of the object in the destination branch.
        public var destination: CodeCommitClientTypes.ObjectTypeEnum?
        /// The type of the object in the source branch.
        public var source: CodeCommitClientTypes.ObjectTypeEnum?

        public init (
            base: CodeCommitClientTypes.ObjectTypeEnum? = nil,
            destination: CodeCommitClientTypes.ObjectTypeEnum? = nil,
            source: CodeCommitClientTypes.ObjectTypeEnum? = nil
        )
        {
            self.base = base
            self.destination = destination
            self.source = source
        }
    }

}

extension CodeCommitClientTypes {
    public enum OrderEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderEnum] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ascending"
            case .descending: return "descending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderEnum(rawValue: rawValue) ?? OrderEnum.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.OriginApprovalRuleTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateId
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateId = self.approvalRuleTemplateId {
            try encodeContainer.encode(approvalRuleTemplateId, forKey: .approvalRuleTemplateId)
        }
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateId)
        approvalRuleTemplateId = approvalRuleTemplateIdDecoded
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about the template that created the approval rule for a pull request.
    public struct OriginApprovalRuleTemplate: Swift.Equatable {
        /// The ID of the template that created the approval rule.
        public var approvalRuleTemplateId: Swift.String?
        /// The name of the template that created the approval rule.
        public var approvalRuleTemplateName: Swift.String?

        public init (
            approvalRuleTemplateId: Swift.String? = nil,
            approvalRuleTemplateName: Swift.String? = nil
        )
        {
            self.approvalRuleTemplateId = approvalRuleTemplateId
            self.approvalRuleTemplateName = approvalRuleTemplateName
        }
    }

}

extension OverrideAlreadySetException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OverrideAlreadySetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pull request has already had its approval rules set to override.
public struct OverrideAlreadySetException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OverrideAlreadySetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OverrideAlreadySetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OverridePullRequestApprovalRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideStatus
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideStatus = self.overrideStatus {
            try encodeContainer.encode(overrideStatus.rawValue, forKey: .overrideStatus)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension OverridePullRequestApprovalRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct OverridePullRequestApprovalRulesInput: Swift.Equatable {
    /// Whether you want to set aside approval rule requirements for the pull request (OVERRIDE) or revoke a previous override and apply approval rule requirements (REVOKE). REVOKE status is not stored.
    /// This member is required.
    public var overrideStatus: CodeCommitClientTypes.OverrideStatus?
    /// The system-generated ID of the pull request for which you want to override all approval rule requirements. To get this information, use [GetPullRequest].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID of the most recent revision of the pull request. You cannot override approval rules for anything but the most recent revision of a pull request. To get the revision ID, use GetPullRequest.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        overrideStatus: CodeCommitClientTypes.OverrideStatus? = nil,
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.overrideStatus = overrideStatus
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct OverridePullRequestApprovalRulesInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let revisionId: Swift.String?
    let overrideStatus: CodeCommitClientTypes.OverrideStatus?
}

extension OverridePullRequestApprovalRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideStatus
        case pullRequestId
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let overrideStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.OverrideStatus.self, forKey: .overrideStatus)
        overrideStatus = overrideStatusDecoded
    }
}

extension OverridePullRequestApprovalRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension OverridePullRequestApprovalRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOverrideStatusException" : self = .invalidOverrideStatusException(try InvalidOverrideStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRevisionIdException" : self = .invalidRevisionIdException(try InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OverrideAlreadySetException" : self = .overrideAlreadySetException(try OverrideAlreadySetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OverrideStatusRequiredException" : self = .overrideStatusRequiredException(try OverrideStatusRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionIdRequiredException" : self = .revisionIdRequiredException(try RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionNotCurrentException" : self = .revisionNotCurrentException(try RevisionNotCurrentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum OverridePullRequestApprovalRulesOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidOverrideStatusException(InvalidOverrideStatusException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRevisionIdException(InvalidRevisionIdException)
    case overrideAlreadySetException(OverrideAlreadySetException)
    case overrideStatusRequiredException(OverrideStatusRequiredException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case revisionIdRequiredException(RevisionIdRequiredException)
    case revisionNotCurrentException(RevisionNotCurrentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension OverridePullRequestApprovalRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct OverridePullRequestApprovalRulesOutputResponse: Swift.Equatable {

    public init () { }
}

extension CodeCommitClientTypes {
    public enum OverrideStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `override`
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [OverrideStatus] {
            return [
                .override,
                .revoke,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .override: return "OVERRIDE"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OverrideStatus(rawValue: rawValue) ?? OverrideStatus.sdkUnknown(rawValue)
        }
    }
}

extension OverrideStatusRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OverrideStatusRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.
public struct OverrideStatusRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OverrideStatusRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OverrideStatusRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParentCommitDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ParentCommitDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.
public struct ParentCommitDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParentCommitDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParentCommitDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParentCommitIdOutdatedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ParentCommitIdOutdatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use [GetBranch].
public struct ParentCommitIdOutdatedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParentCommitIdOutdatedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParentCommitIdOutdatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParentCommitIdRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ParentCommitIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parent commit ID is required. To view the full commit ID of a branch in a repository, use [GetBranch] or a Git command (for example, git pull or git log).
public struct ParentCommitIdRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParentCommitIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParentCommitIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PathDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PathDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified path does not exist.
public struct PathDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PathDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PathDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PathRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PathRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The folderPath for a location cannot be null.
public struct PathRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PathRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PathRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PostCommentForComparedCommitInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PostCommentForComparedCommitInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PostCommentForComparedCommitInput: Swift.Equatable {
    /// To establish the directionality of the comparison, the full commit ID of the after commit.
    /// This member is required.
    public var afterCommitId: Swift.String?
    /// To establish the directionality of the comparison, the full commit ID of the before commit. Required for commenting on any commit unless that commit is the initial commit.
    public var beforeCommitId: Swift.String?
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
    public var clientRequestToken: Swift.String?
    /// The content of the comment you want to make.
    /// This member is required.
    public var content: Swift.String?
    /// The location of the comparison where you want to comment.
    public var location: CodeCommitClientTypes.Location?
    /// The name of the repository where you want to post a comment on the comparison between commits.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.location = location
        self.repositoryName = repositoryName
    }
}

struct PostCommentForComparedCommitInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let location: CodeCommitClientTypes.Location?
    let content: Swift.String?
    let clientRequestToken: Swift.String?
}

extension PostCommentForComparedCommitInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension PostCommentForComparedCommitOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostCommentForComparedCommitOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BeforeCommitIdAndAfterCommitIdAreSameException" : self = .beforeCommitIdAndAfterCommitIdAreSameException(try BeforeCommitIdAndAfterCommitIdAreSameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientRequestTokenRequiredException" : self = .clientRequestTokenRequiredException(try ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentRequiredException" : self = .commentContentRequiredException(try CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentSizeLimitExceededException" : self = .commentContentSizeLimitExceededException(try CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyParameterMismatchException" : self = .idempotencyParameterMismatchException(try IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientRequestTokenException" : self = .invalidClientRequestTokenException(try InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileLocationException" : self = .invalidFileLocationException(try InvalidFileLocationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilePositionException" : self = .invalidFilePositionException(try InvalidFilePositionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativeFileVersionEnumException" : self = .invalidRelativeFileVersionEnumException(try InvalidRelativeFileVersionEnumException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathDoesNotExistException" : self = .pathDoesNotExistException(try PathDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PostCommentForComparedCommitOutputError: Swift.Error, Swift.Equatable {
    case beforeCommitIdAndAfterCommitIdAreSameException(BeforeCommitIdAndAfterCommitIdAreSameException)
    case clientRequestTokenRequiredException(ClientRequestTokenRequiredException)
    case commentContentRequiredException(CommentContentRequiredException)
    case commentContentSizeLimitExceededException(CommentContentSizeLimitExceededException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case idempotencyParameterMismatchException(IdempotencyParameterMismatchException)
    case invalidClientRequestTokenException(InvalidClientRequestTokenException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidFileLocationException(InvalidFileLocationException)
    case invalidFilePositionException(InvalidFilePositionException)
    case invalidPathException(InvalidPathException)
    case invalidRelativeFileVersionEnumException(InvalidRelativeFileVersionEnumException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pathDoesNotExistException(PathDoesNotExistException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostCommentForComparedCommitOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PostCommentForComparedCommitOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.afterBlobId = output.afterBlobId
            self.afterCommitId = output.afterCommitId
            self.beforeBlobId = output.beforeBlobId
            self.beforeCommitId = output.beforeCommitId
            self.comment = output.comment
            self.location = output.location
            self.repositoryName = output.repositoryName
        } else {
            self.afterBlobId = nil
            self.afterCommitId = nil
            self.beforeBlobId = nil
            self.beforeCommitId = nil
            self.comment = nil
            self.location = nil
            self.repositoryName = nil
        }
    }
}

public struct PostCommentForComparedCommitOutputResponse: Swift.Equatable {
    /// In the directionality you established, the blob ID of the after blob.
    public var afterBlobId: Swift.String?
    /// In the directionality you established, the full commit ID of the after commit.
    public var afterCommitId: Swift.String?
    /// In the directionality you established, the blob ID of the before blob.
    public var beforeBlobId: Swift.String?
    /// In the directionality you established, the full commit ID of the before commit.
    public var beforeCommitId: Swift.String?
    /// The content of the comment you posted.
    public var comment: CodeCommitClientTypes.Comment?
    /// The location of the comment in the comparison between the two commits.
    public var location: CodeCommitClientTypes.Location?
    /// The name of the repository where you posted a comment on the comparison between commits.
    public var repositoryName: Swift.String?

    public init (
        afterBlobId: Swift.String? = nil,
        afterCommitId: Swift.String? = nil,
        beforeBlobId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        comment: CodeCommitClientTypes.Comment? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterBlobId = afterBlobId
        self.afterCommitId = afterCommitId
        self.beforeBlobId = beforeBlobId
        self.beforeCommitId = beforeCommitId
        self.comment = comment
        self.location = location
        self.repositoryName = repositoryName
    }
}

struct PostCommentForComparedCommitOutputResponseBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let beforeBlobId: Swift.String?
    let afterBlobId: Swift.String?
    let location: CodeCommitClientTypes.Location?
    let comment: CodeCommitClientTypes.Comment?
}

extension PostCommentForComparedCommitOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comment
        case location
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension PostCommentForPullRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case pullRequestId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PostCommentForPullRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PostCommentForPullRequestInput: Swift.Equatable {
    /// The full commit ID of the commit in the source branch that is the current tip of the branch for the pull request when you post the comment.
    /// This member is required.
    public var afterCommitId: Swift.String?
    /// The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was created.
    /// This member is required.
    public var beforeCommitId: Swift.String?
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
    public var clientRequestToken: Swift.String?
    /// The content of your comment on the change.
    /// This member is required.
    public var content: Swift.String?
    /// The location of the change where you want to post your comment. If no location is provided, the comment is posted as a general comment on the pull request difference between the before commit ID and the after commit ID.
    public var location: CodeCommitClientTypes.Location?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The name of the repository where you want to post a comment on a pull request.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        afterCommitId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.location = location
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

struct PostCommentForPullRequestInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let repositoryName: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let location: CodeCommitClientTypes.Location?
    let content: Swift.String?
    let clientRequestToken: Swift.String?
}

extension PostCommentForPullRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case pullRequestId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension PostCommentForPullRequestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostCommentForPullRequestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BeforeCommitIdAndAfterCommitIdAreSameException" : self = .beforeCommitIdAndAfterCommitIdAreSameException(try BeforeCommitIdAndAfterCommitIdAreSameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientRequestTokenRequiredException" : self = .clientRequestTokenRequiredException(try ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentRequiredException" : self = .commentContentRequiredException(try CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentSizeLimitExceededException" : self = .commentContentSizeLimitExceededException(try CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyParameterMismatchException" : self = .idempotencyParameterMismatchException(try IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientRequestTokenException" : self = .invalidClientRequestTokenException(try InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileLocationException" : self = .invalidFileLocationException(try InvalidFileLocationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilePositionException" : self = .invalidFilePositionException(try InvalidFilePositionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativeFileVersionEnumException" : self = .invalidRelativeFileVersionEnumException(try InvalidRelativeFileVersionEnumException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathDoesNotExistException" : self = .pathDoesNotExistException(try PathDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotAssociatedWithPullRequestException" : self = .repositoryNotAssociatedWithPullRequestException(try RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PostCommentForPullRequestOutputError: Swift.Error, Swift.Equatable {
    case beforeCommitIdAndAfterCommitIdAreSameException(BeforeCommitIdAndAfterCommitIdAreSameException)
    case clientRequestTokenRequiredException(ClientRequestTokenRequiredException)
    case commentContentRequiredException(CommentContentRequiredException)
    case commentContentSizeLimitExceededException(CommentContentSizeLimitExceededException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case idempotencyParameterMismatchException(IdempotencyParameterMismatchException)
    case invalidClientRequestTokenException(InvalidClientRequestTokenException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidFileLocationException(InvalidFileLocationException)
    case invalidFilePositionException(InvalidFilePositionException)
    case invalidPathException(InvalidPathException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRelativeFileVersionEnumException(InvalidRelativeFileVersionEnumException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pathDoesNotExistException(PathDoesNotExistException)
    case pathRequiredException(PathRequiredException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryNotAssociatedWithPullRequestException(RepositoryNotAssociatedWithPullRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostCommentForPullRequestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PostCommentForPullRequestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.afterBlobId = output.afterBlobId
            self.afterCommitId = output.afterCommitId
            self.beforeBlobId = output.beforeBlobId
            self.beforeCommitId = output.beforeCommitId
            self.comment = output.comment
            self.location = output.location
            self.pullRequestId = output.pullRequestId
            self.repositoryName = output.repositoryName
        } else {
            self.afterBlobId = nil
            self.afterCommitId = nil
            self.beforeBlobId = nil
            self.beforeCommitId = nil
            self.comment = nil
            self.location = nil
            self.pullRequestId = nil
            self.repositoryName = nil
        }
    }
}

public struct PostCommentForPullRequestOutputResponse: Swift.Equatable {
    /// In the directionality of the pull request, the blob ID of the after blob.
    public var afterBlobId: Swift.String?
    /// The full commit ID of the commit in the destination branch where the pull request is merged.
    public var afterCommitId: Swift.String?
    /// In the directionality of the pull request, the blob ID of the before blob.
    public var beforeBlobId: Swift.String?
    /// The full commit ID of the commit in the source branch used to create the pull request, or in the case of an updated pull request, the full commit ID of the commit used to update the pull request.
    public var beforeCommitId: Swift.String?
    /// The content of the comment you posted.
    public var comment: CodeCommitClientTypes.Comment?
    /// The location of the change where you posted your comment.
    public var location: CodeCommitClientTypes.Location?
    /// The system-generated ID of the pull request.
    public var pullRequestId: Swift.String?
    /// The name of the repository where you posted a comment on a pull request.
    public var repositoryName: Swift.String?

    public init (
        afterBlobId: Swift.String? = nil,
        afterCommitId: Swift.String? = nil,
        beforeBlobId: Swift.String? = nil,
        beforeCommitId: Swift.String? = nil,
        comment: CodeCommitClientTypes.Comment? = nil,
        location: CodeCommitClientTypes.Location? = nil,
        pullRequestId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.afterBlobId = afterBlobId
        self.afterCommitId = afterCommitId
        self.beforeBlobId = beforeBlobId
        self.beforeCommitId = beforeCommitId
        self.comment = comment
        self.location = location
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

struct PostCommentForPullRequestOutputResponseBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let pullRequestId: Swift.String?
    let beforeCommitId: Swift.String?
    let afterCommitId: Swift.String?
    let beforeBlobId: Swift.String?
    let afterBlobId: Swift.String?
    let location: CodeCommitClientTypes.Location?
    let comment: CodeCommitClientTypes.Comment?
}

extension PostCommentForPullRequestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comment
        case location
        case pullRequestId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension PostCommentReplyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case content
        case inReplyTo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let inReplyTo = self.inReplyTo {
            try encodeContainer.encode(inReplyTo, forKey: .inReplyTo)
        }
    }
}

extension PostCommentReplyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PostCommentReplyInput: Swift.Equatable {
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
    public var clientRequestToken: Swift.String?
    /// The contents of your reply to a comment.
    /// This member is required.
    public var content: Swift.String?
    /// The system-generated ID of the comment to which you want to reply. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var inReplyTo: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        inReplyTo: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.inReplyTo = inReplyTo
    }
}

struct PostCommentReplyInputBody: Swift.Equatable {
    let inReplyTo: Swift.String?
    let clientRequestToken: Swift.String?
    let content: Swift.String?
}

extension PostCommentReplyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case content
        case inReplyTo
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inReplyToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inReplyTo)
        inReplyTo = inReplyToDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension PostCommentReplyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostCommentReplyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientRequestTokenRequiredException" : self = .clientRequestTokenRequiredException(try ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentRequiredException" : self = .commentContentRequiredException(try CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentSizeLimitExceededException" : self = .commentContentSizeLimitExceededException(try CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyParameterMismatchException" : self = .idempotencyParameterMismatchException(try IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientRequestTokenException" : self = .invalidClientRequestTokenException(try InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PostCommentReplyOutputError: Swift.Error, Swift.Equatable {
    case clientRequestTokenRequiredException(ClientRequestTokenRequiredException)
    case commentContentRequiredException(CommentContentRequiredException)
    case commentContentSizeLimitExceededException(CommentContentSizeLimitExceededException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case idempotencyParameterMismatchException(IdempotencyParameterMismatchException)
    case invalidClientRequestTokenException(InvalidClientRequestTokenException)
    case invalidCommentIdException(InvalidCommentIdException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostCommentReplyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PostCommentReplyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct PostCommentReplyOutputResponse: Swift.Equatable {
    /// Information about the reply to a comment.
    public var comment: CodeCommitClientTypes.Comment?

    public init (
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct PostCommentReplyOutputResponseBody: Swift.Equatable {
    let comment: CodeCommitClientTypes.Comment?
}

extension PostCommentReplyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CodeCommitClientTypes.PullRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules
        case authorArn
        case clientRequestToken
        case creationDate
        case description
        case lastActivityDate
        case pullRequestId
        case pullRequestStatus
        case pullRequestTargets
        case revisionId
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            var approvalRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvalRules)
            for approvalrule0 in approvalRules {
                try approvalRulesContainer.encode(approvalrule0)
            }
        }
        if let authorArn = self.authorArn {
            try encodeContainer.encode(authorArn, forKey: .authorArn)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastActivityDate = self.lastActivityDate {
            try encodeContainer.encodeTimestamp(lastActivityDate, format: .epochSeconds, forKey: .lastActivityDate)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let pullRequestStatus = self.pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
        if let pullRequestTargets = pullRequestTargets {
            var pullRequestTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pullRequestTargets)
            for pullrequesttarget0 in pullRequestTargets {
                try pullRequestTargetsContainer.encode(pullrequesttarget0)
            }
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastActivityDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastActivityDate)
        lastActivityDate = lastActivityDateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
        let authorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorArn)
        authorArn = authorArnDecoded
        let pullRequestTargetsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.PullRequestTarget?].self, forKey: .pullRequestTargets)
        var pullRequestTargetsDecoded0:[CodeCommitClientTypes.PullRequestTarget]? = nil
        if let pullRequestTargetsContainer = pullRequestTargetsContainer {
            pullRequestTargetsDecoded0 = [CodeCommitClientTypes.PullRequestTarget]()
            for structure0 in pullRequestTargetsContainer {
                if let structure0 = structure0 {
                    pullRequestTargetsDecoded0?.append(structure0)
                }
            }
        }
        pullRequestTargets = pullRequestTargetsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let approvalRulesContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.ApprovalRule?].self, forKey: .approvalRules)
        var approvalRulesDecoded0:[CodeCommitClientTypes.ApprovalRule]? = nil
        if let approvalRulesContainer = approvalRulesContainer {
            approvalRulesDecoded0 = [CodeCommitClientTypes.ApprovalRule]()
            for structure0 in approvalRulesContainer {
                if let structure0 = structure0 {
                    approvalRulesDecoded0?.append(structure0)
                }
            }
        }
        approvalRules = approvalRulesDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a pull request.
    public struct PullRequest: Swift.Equatable {
        /// The approval rules applied to the pull request.
        public var approvalRules: [CodeCommitClientTypes.ApprovalRule]?
        /// The Amazon Resource Name (ARN) of the user who created the pull request.
        public var authorArn: Swift.String?
        /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.
        public var clientRequestToken: Swift.String?
        /// The date and time the pull request was originally created, in timestamp format.
        public var creationDate: ClientRuntime.Date?
        /// The user-defined description of the pull request. This description can be used to clarify what should be reviewed and other details of the request.
        public var description: Swift.String?
        /// The day and time of the last user or system activity on the pull request, in timestamp format.
        public var lastActivityDate: ClientRuntime.Date?
        /// The system-generated ID of the pull request.
        public var pullRequestId: Swift.String?
        /// The status of the pull request. Pull request status can only change from OPEN to CLOSED.
        public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?
        /// The targets of the pull request, including the source branch and destination branch for the pull request.
        public var pullRequestTargets: [CodeCommitClientTypes.PullRequestTarget]?
        /// The system-generated revision ID for the pull request.
        public var revisionId: Swift.String?
        /// The user-defined title of the pull request. This title is displayed in the list of pull requests to other repository users.
        public var title: Swift.String?

        public init (
            approvalRules: [CodeCommitClientTypes.ApprovalRule]? = nil,
            authorArn: Swift.String? = nil,
            clientRequestToken: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastActivityDate: ClientRuntime.Date? = nil,
            pullRequestId: Swift.String? = nil,
            pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil,
            pullRequestTargets: [CodeCommitClientTypes.PullRequestTarget]? = nil,
            revisionId: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.approvalRules = approvalRules
            self.authorArn = authorArn
            self.clientRequestToken = clientRequestToken
            self.creationDate = creationDate
            self.description = description
            self.lastActivityDate = lastActivityDate
            self.pullRequestId = pullRequestId
            self.pullRequestStatus = pullRequestStatus
            self.pullRequestTargets = pullRequestTargets
            self.revisionId = revisionId
            self.title = title
        }
    }

}

extension PullRequestAlreadyClosedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PullRequestAlreadyClosedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pull request status cannot be updated because it is already closed.
public struct PullRequestAlreadyClosedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestAlreadyClosedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestAlreadyClosedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullRequestApprovalRulesNotSatisfiedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PullRequestApprovalRulesNotSatisfiedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.
public struct PullRequestApprovalRulesNotSatisfiedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestApprovalRulesNotSatisfiedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestApprovalRulesNotSatisfiedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullRequestCannotBeApprovedByAuthorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PullRequestCannotBeApprovedByAuthorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull request that you created.
public struct PullRequestCannotBeApprovedByAuthorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestCannotBeApprovedByAuthorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestCannotBeApprovedByAuthorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.PullRequestCreatedEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCommitId
        case mergeBase
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommitId = self.destinationCommitId {
            try encodeContainer.encode(destinationCommitId, forKey: .destinationCommitId)
        }
        if let mergeBase = self.mergeBase {
            try encodeContainer.encode(mergeBase, forKey: .mergeBase)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = self.sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let mergeBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergeBase)
        mergeBase = mergeBaseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Metadata about the pull request that is used when comparing the pull request source with its destination.
    public struct PullRequestCreatedEventMetadata: Swift.Equatable {
        /// The commit ID of the tip of the branch specified as the destination branch when the pull request was created.
        public var destinationCommitId: Swift.String?
        /// The commit ID of the most recent commit that the source branch and the destination branch have in common.
        public var mergeBase: Swift.String?
        /// The name of the repository where the pull request was created.
        public var repositoryName: Swift.String?
        /// The commit ID on the source branch used when the pull request was created.
        public var sourceCommitId: Swift.String?

        public init (
            destinationCommitId: Swift.String? = nil,
            mergeBase: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            sourceCommitId: Swift.String? = nil
        )
        {
            self.destinationCommitId = destinationCommitId
            self.mergeBase = mergeBase
            self.repositoryName = repositoryName
            self.sourceCommitId = sourceCommitId
        }
    }

}

extension PullRequestDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PullRequestDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.
public struct PullRequestDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.PullRequestEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actorArn
        case approvalRuleEventMetadata
        case approvalRuleOverriddenEventMetadata
        case approvalStateChangedEventMetadata
        case eventDate
        case pullRequestCreatedEventMetadata
        case pullRequestEventType
        case pullRequestId
        case pullRequestMergedStateChangedEventMetadata
        case pullRequestSourceReferenceUpdatedEventMetadata
        case pullRequestStatusChangedEventMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actorArn = self.actorArn {
            try encodeContainer.encode(actorArn, forKey: .actorArn)
        }
        if let approvalRuleEventMetadata = self.approvalRuleEventMetadata {
            try encodeContainer.encode(approvalRuleEventMetadata, forKey: .approvalRuleEventMetadata)
        }
        if let approvalRuleOverriddenEventMetadata = self.approvalRuleOverriddenEventMetadata {
            try encodeContainer.encode(approvalRuleOverriddenEventMetadata, forKey: .approvalRuleOverriddenEventMetadata)
        }
        if let approvalStateChangedEventMetadata = self.approvalStateChangedEventMetadata {
            try encodeContainer.encode(approvalStateChangedEventMetadata, forKey: .approvalStateChangedEventMetadata)
        }
        if let eventDate = self.eventDate {
            try encodeContainer.encodeTimestamp(eventDate, format: .epochSeconds, forKey: .eventDate)
        }
        if let pullRequestCreatedEventMetadata = self.pullRequestCreatedEventMetadata {
            try encodeContainer.encode(pullRequestCreatedEventMetadata, forKey: .pullRequestCreatedEventMetadata)
        }
        if let pullRequestEventType = self.pullRequestEventType {
            try encodeContainer.encode(pullRequestEventType.rawValue, forKey: .pullRequestEventType)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let pullRequestMergedStateChangedEventMetadata = self.pullRequestMergedStateChangedEventMetadata {
            try encodeContainer.encode(pullRequestMergedStateChangedEventMetadata, forKey: .pullRequestMergedStateChangedEventMetadata)
        }
        if let pullRequestSourceReferenceUpdatedEventMetadata = self.pullRequestSourceReferenceUpdatedEventMetadata {
            try encodeContainer.encode(pullRequestSourceReferenceUpdatedEventMetadata, forKey: .pullRequestSourceReferenceUpdatedEventMetadata)
        }
        if let pullRequestStatusChangedEventMetadata = self.pullRequestStatusChangedEventMetadata {
            try encodeContainer.encode(pullRequestStatusChangedEventMetadata, forKey: .pullRequestStatusChangedEventMetadata)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let eventDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventDate)
        eventDate = eventDateDecoded
        let pullRequestEventTypeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestEventType.self, forKey: .pullRequestEventType)
        pullRequestEventType = pullRequestEventTypeDecoded
        let actorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actorArn)
        actorArn = actorArnDecoded
        let pullRequestCreatedEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestCreatedEventMetadata.self, forKey: .pullRequestCreatedEventMetadata)
        pullRequestCreatedEventMetadata = pullRequestCreatedEventMetadataDecoded
        let pullRequestStatusChangedEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestStatusChangedEventMetadata.self, forKey: .pullRequestStatusChangedEventMetadata)
        pullRequestStatusChangedEventMetadata = pullRequestStatusChangedEventMetadataDecoded
        let pullRequestSourceReferenceUpdatedEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata.self, forKey: .pullRequestSourceReferenceUpdatedEventMetadata)
        pullRequestSourceReferenceUpdatedEventMetadata = pullRequestSourceReferenceUpdatedEventMetadataDecoded
        let pullRequestMergedStateChangedEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata.self, forKey: .pullRequestMergedStateChangedEventMetadata)
        pullRequestMergedStateChangedEventMetadata = pullRequestMergedStateChangedEventMetadataDecoded
        let approvalRuleEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleEventMetadata.self, forKey: .approvalRuleEventMetadata)
        approvalRuleEventMetadata = approvalRuleEventMetadataDecoded
        let approvalStateChangedEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalStateChangedEventMetadata.self, forKey: .approvalStateChangedEventMetadata)
        approvalStateChangedEventMetadata = approvalStateChangedEventMetadataDecoded
        let approvalRuleOverriddenEventMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata.self, forKey: .approvalRuleOverriddenEventMetadata)
        approvalRuleOverriddenEventMetadata = approvalRuleOverriddenEventMetadataDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a pull request event.
    public struct PullRequestEvent: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the user whose actions resulted in the event. Examples include updating the pull request with more commits or changing the status of a pull request.
        public var actorArn: Swift.String?
        /// Information about a pull request event.
        public var approvalRuleEventMetadata: CodeCommitClientTypes.ApprovalRuleEventMetadata?
        /// Information about an approval rule override event for a pull request.
        public var approvalRuleOverriddenEventMetadata: CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata?
        /// Information about an approval state change for a pull request.
        public var approvalStateChangedEventMetadata: CodeCommitClientTypes.ApprovalStateChangedEventMetadata?
        /// The day and time of the pull request event, in timestamp format.
        public var eventDate: ClientRuntime.Date?
        /// Information about the source and destination branches for the pull request.
        public var pullRequestCreatedEventMetadata: CodeCommitClientTypes.PullRequestCreatedEventMetadata?
        /// The type of the pull request event (for example, a status change event (PULL_REQUEST_STATUS_CHANGED) or update event (PULL_REQUEST_SOURCE_REFERENCE_UPDATED)).
        public var pullRequestEventType: CodeCommitClientTypes.PullRequestEventType?
        /// The system-generated ID of the pull request.
        public var pullRequestId: Swift.String?
        /// Information about the change in mergability state for the pull request event.
        public var pullRequestMergedStateChangedEventMetadata: CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata?
        /// Information about the updated source branch for the pull request event.
        public var pullRequestSourceReferenceUpdatedEventMetadata: CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata?
        /// Information about the change in status for the pull request event.
        public var pullRequestStatusChangedEventMetadata: CodeCommitClientTypes.PullRequestStatusChangedEventMetadata?

        public init (
            actorArn: Swift.String? = nil,
            approvalRuleEventMetadata: CodeCommitClientTypes.ApprovalRuleEventMetadata? = nil,
            approvalRuleOverriddenEventMetadata: CodeCommitClientTypes.ApprovalRuleOverriddenEventMetadata? = nil,
            approvalStateChangedEventMetadata: CodeCommitClientTypes.ApprovalStateChangedEventMetadata? = nil,
            eventDate: ClientRuntime.Date? = nil,
            pullRequestCreatedEventMetadata: CodeCommitClientTypes.PullRequestCreatedEventMetadata? = nil,
            pullRequestEventType: CodeCommitClientTypes.PullRequestEventType? = nil,
            pullRequestId: Swift.String? = nil,
            pullRequestMergedStateChangedEventMetadata: CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata? = nil,
            pullRequestSourceReferenceUpdatedEventMetadata: CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata? = nil,
            pullRequestStatusChangedEventMetadata: CodeCommitClientTypes.PullRequestStatusChangedEventMetadata? = nil
        )
        {
            self.actorArn = actorArn
            self.approvalRuleEventMetadata = approvalRuleEventMetadata
            self.approvalRuleOverriddenEventMetadata = approvalRuleOverriddenEventMetadata
            self.approvalStateChangedEventMetadata = approvalStateChangedEventMetadata
            self.eventDate = eventDate
            self.pullRequestCreatedEventMetadata = pullRequestCreatedEventMetadata
            self.pullRequestEventType = pullRequestEventType
            self.pullRequestId = pullRequestId
            self.pullRequestMergedStateChangedEventMetadata = pullRequestMergedStateChangedEventMetadata
            self.pullRequestSourceReferenceUpdatedEventMetadata = pullRequestSourceReferenceUpdatedEventMetadata
            self.pullRequestStatusChangedEventMetadata = pullRequestStatusChangedEventMetadata
        }
    }

}

extension CodeCommitClientTypes {
    public enum PullRequestEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pullRequestApprovalRuleCreated
        case pullRequestApprovalRuleDeleted
        case pullRequestApprovalRuleOverridden
        case pullRequestApprovalRuleUpdated
        case pullRequestApprovalStateChanged
        case pullRequestCreated
        case pullRequestMergeStateChanged
        case pullRequestSourceReferenceUpdated
        case pullRequestStatusChanged
        case sdkUnknown(Swift.String)

        public static var allCases: [PullRequestEventType] {
            return [
                .pullRequestApprovalRuleCreated,
                .pullRequestApprovalRuleDeleted,
                .pullRequestApprovalRuleOverridden,
                .pullRequestApprovalRuleUpdated,
                .pullRequestApprovalStateChanged,
                .pullRequestCreated,
                .pullRequestMergeStateChanged,
                .pullRequestSourceReferenceUpdated,
                .pullRequestStatusChanged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pullRequestApprovalRuleCreated: return "PULL_REQUEST_APPROVAL_RULE_CREATED"
            case .pullRequestApprovalRuleDeleted: return "PULL_REQUEST_APPROVAL_RULE_DELETED"
            case .pullRequestApprovalRuleOverridden: return "PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN"
            case .pullRequestApprovalRuleUpdated: return "PULL_REQUEST_APPROVAL_RULE_UPDATED"
            case .pullRequestApprovalStateChanged: return "PULL_REQUEST_APPROVAL_STATE_CHANGED"
            case .pullRequestCreated: return "PULL_REQUEST_CREATED"
            case .pullRequestMergeStateChanged: return "PULL_REQUEST_MERGE_STATE_CHANGED"
            case .pullRequestSourceReferenceUpdated: return "PULL_REQUEST_SOURCE_REFERENCE_UPDATED"
            case .pullRequestStatusChanged: return "PULL_REQUEST_STATUS_CHANGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PullRequestEventType(rawValue: rawValue) ?? PullRequestEventType.sdkUnknown(rawValue)
        }
    }
}

extension PullRequestIdRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PullRequestIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A pull request ID is required, but none was provided.
public struct PullRequestIdRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.PullRequestMergedStateChangedEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationReference
        case mergeMetadata
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationReference = self.destinationReference {
            try encodeContainer.encode(destinationReference, forKey: .destinationReference)
        }
        if let mergeMetadata = self.mergeMetadata {
            try encodeContainer.encode(mergeMetadata, forKey: .mergeMetadata)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationReference)
        destinationReference = destinationReferenceDecoded
        let mergeMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeMetadata.self, forKey: .mergeMetadata)
        mergeMetadata = mergeMetadataDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about the change in the merge state for a pull request event.
    public struct PullRequestMergedStateChangedEventMetadata: Swift.Equatable {
        /// The name of the branch that the pull request is merged into.
        public var destinationReference: Swift.String?
        /// Information about the merge state change event.
        public var mergeMetadata: CodeCommitClientTypes.MergeMetadata?
        /// The name of the repository where the pull request was created.
        public var repositoryName: Swift.String?

        public init (
            destinationReference: Swift.String? = nil,
            mergeMetadata: CodeCommitClientTypes.MergeMetadata? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.destinationReference = destinationReference
            self.mergeMetadata = mergeMetadata
            self.repositoryName = repositoryName
        }
    }

}

extension CodeCommitClientTypes.PullRequestSourceReferenceUpdatedEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterCommitId
        case beforeCommitId
        case mergeBase
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = self.afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = self.beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let mergeBase = self.mergeBase {
            try encodeContainer.encode(mergeBase, forKey: .mergeBase)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let mergeBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergeBase)
        mergeBase = mergeBaseDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about an update to the source branch of a pull request.
    public struct PullRequestSourceReferenceUpdatedEventMetadata: Swift.Equatable {
        /// The full commit ID of the commit in the source branch that was the tip of the branch at the time the pull request was updated.
        public var afterCommitId: Swift.String?
        /// The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was updated.
        public var beforeCommitId: Swift.String?
        /// The commit ID of the most recent commit that the source branch and the destination branch have in common.
        public var mergeBase: Swift.String?
        /// The name of the repository where the pull request was updated.
        public var repositoryName: Swift.String?

        public init (
            afterCommitId: Swift.String? = nil,
            beforeCommitId: Swift.String? = nil,
            mergeBase: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.afterCommitId = afterCommitId
            self.beforeCommitId = beforeCommitId
            self.mergeBase = mergeBase
            self.repositoryName = repositoryName
        }
    }

}

extension CodeCommitClientTypes.PullRequestStatusChangedEventMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestStatus = self.pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a change to the status of a pull request.
    public struct PullRequestStatusChangedEventMetadata: Swift.Equatable {
        /// The changed status of the pull request.
        public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?

        public init (
            pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil
        )
        {
            self.pullRequestStatus = pullRequestStatus
        }
    }

}

extension CodeCommitClientTypes {
    public enum PullRequestStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [PullRequestStatusEnum] {
            return [
                .closed,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .open: return "OPEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PullRequestStatusEnum(rawValue: rawValue) ?? PullRequestStatusEnum.sdkUnknown(rawValue)
        }
    }
}

extension PullRequestStatusRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PullRequestStatusRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A pull request status is required, but none was provided.
public struct PullRequestStatusRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestStatusRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullRequestStatusRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.PullRequestTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCommit
        case destinationReference
        case mergeBase
        case mergeMetadata
        case repositoryName
        case sourceCommit
        case sourceReference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommit = self.destinationCommit {
            try encodeContainer.encode(destinationCommit, forKey: .destinationCommit)
        }
        if let destinationReference = self.destinationReference {
            try encodeContainer.encode(destinationReference, forKey: .destinationReference)
        }
        if let mergeBase = self.mergeBase {
            try encodeContainer.encode(mergeBase, forKey: .mergeBase)
        }
        if let mergeMetadata = self.mergeMetadata {
            try encodeContainer.encode(mergeMetadata, forKey: .mergeMetadata)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommit = self.sourceCommit {
            try encodeContainer.encode(sourceCommit, forKey: .sourceCommit)
        }
        if let sourceReference = self.sourceReference {
            try encodeContainer.encode(sourceReference, forKey: .sourceReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceReference)
        sourceReference = sourceReferenceDecoded
        let destinationReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationReference)
        destinationReference = destinationReferenceDecoded
        let destinationCommitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommit)
        destinationCommit = destinationCommitDecoded
        let sourceCommitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommit)
        sourceCommit = sourceCommitDecoded
        let mergeBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergeBase)
        mergeBase = mergeBaseDecoded
        let mergeMetadataDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.MergeMetadata.self, forKey: .mergeMetadata)
        mergeMetadata = mergeMetadataDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a pull request target.
    public struct PullRequestTarget: Swift.Equatable {
        /// The full commit ID that is the tip of the destination branch. This is the commit where the pull request was or will be merged.
        public var destinationCommit: Swift.String?
        /// The branch of the repository where the pull request changes are merged. Also known as the destination branch.
        public var destinationReference: Swift.String?
        /// The commit ID of the most recent commit that the source branch and the destination branch have in common.
        public var mergeBase: Swift.String?
        /// Returns metadata about the state of the merge, including whether the merge has been made.
        public var mergeMetadata: CodeCommitClientTypes.MergeMetadata?
        /// The name of the repository that contains the pull request source and destination branches.
        public var repositoryName: Swift.String?
        /// The full commit ID of the tip of the source branch used to create the pull request. If the pull request branch is updated by a push while the pull request is open, the commit ID changes to reflect the new tip of the branch.
        public var sourceCommit: Swift.String?
        /// The branch of the repository that contains the changes for the pull request. Also known as the source branch.
        public var sourceReference: Swift.String?

        public init (
            destinationCommit: Swift.String? = nil,
            destinationReference: Swift.String? = nil,
            mergeBase: Swift.String? = nil,
            mergeMetadata: CodeCommitClientTypes.MergeMetadata? = nil,
            repositoryName: Swift.String? = nil,
            sourceCommit: Swift.String? = nil,
            sourceReference: Swift.String? = nil
        )
        {
            self.destinationCommit = destinationCommit
            self.destinationReference = destinationReference
            self.mergeBase = mergeBase
            self.mergeMetadata = mergeMetadata
            self.repositoryName = repositoryName
            self.sourceCommit = sourceCommit
            self.sourceReference = sourceReference
        }
    }

}

extension PutCommentReactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case reactionValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let reactionValue = self.reactionValue {
            try encodeContainer.encode(reactionValue, forKey: .reactionValue)
        }
    }
}

extension PutCommentReactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutCommentReactionInput: Swift.Equatable {
    /// The ID of the comment to which you want to add or update a reaction.
    /// This member is required.
    public var commentId: Swift.String?
    /// The emoji reaction you want to add or update. To remove a reaction, provide a value of blank or null. You can also provide the value of none. For information about emoji reaction values supported in AWS CodeCommit, see the [AWS CodeCommit User Guide](https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-commit-comment.html#emoji-reaction-table).
    /// This member is required.
    public var reactionValue: Swift.String?

    public init (
        commentId: Swift.String? = nil,
        reactionValue: Swift.String? = nil
    )
    {
        self.commentId = commentId
        self.reactionValue = reactionValue
    }
}

struct PutCommentReactionInputBody: Swift.Equatable {
    let commentId: Swift.String?
    let reactionValue: Swift.String?
}

extension PutCommentReactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case reactionValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let reactionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reactionValue)
        reactionValue = reactionValueDecoded
    }
}

extension PutCommentReactionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutCommentReactionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommentDeletedException" : self = .commentDeletedException(try CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReactionValueException" : self = .invalidReactionValueException(try InvalidReactionValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReactionLimitExceededException" : self = .reactionLimitExceededException(try ReactionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReactionValueRequiredException" : self = .reactionValueRequiredException(try ReactionValueRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutCommentReactionOutputError: Swift.Error, Swift.Equatable {
    case commentDeletedException(CommentDeletedException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case invalidCommentIdException(InvalidCommentIdException)
    case invalidReactionValueException(InvalidReactionValueException)
    case reactionLimitExceededException(ReactionLimitExceededException)
    case reactionValueRequiredException(ReactionValueRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutCommentReactionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutCommentReactionOutputResponse: Swift.Equatable {

    public init () { }
}

extension CodeCommitClientTypes.PutFileEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileContent
        case fileMode
        case filePath
        case sourceFile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileContent = self.fileContent {
            try encodeContainer.encode(fileContent.base64EncodedString(), forKey: .fileContent)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let sourceFile = self.sourceFile {
            try encodeContainer.encode(sourceFile, forKey: .sourceFile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let fileContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .fileContent)
        fileContent = fileContentDecoded
        let sourceFileDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.SourceFileSpecifier.self, forKey: .sourceFile)
        sourceFile = sourceFileDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a file added or updated as part of a commit.
    public struct PutFileEntry: Swift.Equatable {
        /// The content of the file, if a source file is not specified.
        public var fileContent: ClientRuntime.Data?
        /// The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The full path to the file in the repository, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?
        /// The name and full path of the file that contains the changes you want to make as part of the commit, if you are not providing the file content directly.
        public var sourceFile: CodeCommitClientTypes.SourceFileSpecifier?

        public init (
            fileContent: ClientRuntime.Data? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            filePath: Swift.String? = nil,
            sourceFile: CodeCommitClientTypes.SourceFileSpecifier? = nil
        )
        {
            self.fileContent = fileContent
            self.fileMode = fileMode
            self.filePath = filePath
            self.sourceFile = sourceFile
        }
    }

}

extension PutFileEntryConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutFileEntryConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit cannot be created because one or more files specified in the commit reference both a file and a folder.
public struct PutFileEntryConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PutFileEntryConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PutFileEntryConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutFileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitMessage
        case email
        case fileContent
        case fileMode
        case filePath
        case name
        case parentCommitId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let fileContent = self.fileContent {
            try encodeContainer.encode(fileContent.base64EncodedString(), forKey: .fileContent)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentCommitId = self.parentCommitId {
            try encodeContainer.encode(parentCommitId, forKey: .parentCommitId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PutFileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutFileInput: Swift.Equatable {
    /// The name of the branch where you want to add or update the file. If this is an empty repository, this branch is created.
    /// This member is required.
    public var branchName: Swift.String?
    /// A message about why this file was added or updated. Although it is optional, a message makes the commit history for your repository more useful.
    public var commitMessage: Swift.String?
    /// An email address for the person adding or updating the file.
    public var email: Swift.String?
    /// The content of the file, in binary object format.
    /// This member is required.
    public var fileContent: ClientRuntime.Data?
    /// The file mode permissions of the blob. Valid file mode permissions are listed here.
    public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
    /// The name of the file you want to add or update, including the relative path to the file in the repository. If the path does not currently exist in the repository, the path is created as part of adding the file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The name of the person adding or updating the file. Although it is optional, a name makes the commit history for your repository more useful.
    public var name: Swift.String?
    /// The full commit ID of the head commit in the branch where you want to add or update the file. If this is an empty repository, no commit ID is required. If this is not an empty repository, a commit ID is required. The commit ID must match the ID of the head commit at the time of the operation. Otherwise, an error occurs, and the file is not added or updated.
    public var parentCommitId: Swift.String?
    /// The name of the repository where you want to add or update the file.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        branchName: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        email: Swift.String? = nil,
        fileContent: ClientRuntime.Data? = nil,
        fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
        filePath: Swift.String? = nil,
        name: Swift.String? = nil,
        parentCommitId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.email = email
        self.fileContent = fileContent
        self.fileMode = fileMode
        self.filePath = filePath
        self.name = name
        self.parentCommitId = parentCommitId
        self.repositoryName = repositoryName
    }
}

struct PutFileInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let branchName: Swift.String?
    let fileContent: ClientRuntime.Data?
    let filePath: Swift.String?
    let fileMode: CodeCommitClientTypes.FileModeTypeEnum?
    let parentCommitId: Swift.String?
    let commitMessage: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
}

extension PutFileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case commitMessage
        case email
        case fileContent
        case fileMode
        case filePath
        case name
        case parentCommitId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let fileContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .fileContent)
        fileContent = fileContentDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let parentCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentCommitId)
        parentCommitId = parentCommitIdDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension PutFileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNameConflictsWithFileNameException" : self = .directoryNameConflictsWithFileNameException(try DirectoryNameConflictsWithFileNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentRequiredException" : self = .fileContentRequiredException(try FileContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileNameConflictsWithDirectoryNameException" : self = .fileNameConflictsWithDirectoryNameException(try FileNameConflictsWithDirectoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilePathConflictsWithSubmodulePathException" : self = .filePathConflictsWithSubmodulePathException(try FilePathConflictsWithSubmodulePathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeletionParameterException" : self = .invalidDeletionParameterException(try InvalidDeletionParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParentCommitIdException" : self = .invalidParentCommitIdException(try InvalidParentCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitDoesNotExistException" : self = .parentCommitDoesNotExistException(try ParentCommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdOutdatedException" : self = .parentCommitIdOutdatedException(try ParentCommitIdOutdatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdRequiredException" : self = .parentCommitIdRequiredException(try ParentCommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SameFileContentException" : self = .sameFileContentException(try SameFileContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutFileOutputError: Swift.Error, Swift.Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case directoryNameConflictsWithFileNameException(DirectoryNameConflictsWithFileNameException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentRequiredException(FileContentRequiredException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case fileNameConflictsWithDirectoryNameException(FileNameConflictsWithDirectoryNameException)
    case filePathConflictsWithSubmodulePathException(FilePathConflictsWithSubmodulePathException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidDeletionParameterException(InvalidDeletionParameterException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidParentCommitIdException(InvalidParentCommitIdException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case nameLengthExceededException(NameLengthExceededException)
    case parentCommitDoesNotExistException(ParentCommitDoesNotExistException)
    case parentCommitIdOutdatedException(ParentCommitIdOutdatedException)
    case parentCommitIdRequiredException(ParentCommitIdRequiredException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case sameFileContentException(SameFileContentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutFileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.blobId = output.blobId
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.blobId = nil
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct PutFileOutputResponse: Swift.Equatable {
    /// The ID of the blob, which is its SHA-1 pointer.
    /// This member is required.
    public var blobId: Swift.String?
    /// The full SHA ID of the commit that contains this file change.
    /// This member is required.
    public var commitId: Swift.String?
    /// The full SHA-1 pointer of the tree information for the commit that contains this file change.
    /// This member is required.
    public var treeId: Swift.String?

    public init (
        blobId: Swift.String? = nil,
        commitId: Swift.String? = nil,
        treeId: Swift.String? = nil
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct PutFileOutputResponseBody: Swift.Equatable {
    let commitId: Swift.String?
    let blobId: Swift.String?
    let treeId: Swift.String?
}

extension PutFileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobId
        case commitId
        case treeId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

extension PutRepositoryTriggersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case triggers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for repositorytrigger0 in triggers {
                try triggersContainer.encode(repositorytrigger0)
            }
        }
    }
}

extension PutRepositoryTriggersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a put repository triggers operation.
public struct PutRepositoryTriggersInput: Swift.Equatable {
    /// The name of the repository where you want to create or update the trigger.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The JSON block of configuration information for each trigger.
    /// This member is required.
    public var triggers: [CodeCommitClientTypes.RepositoryTrigger]?

    public init (
        repositoryName: Swift.String? = nil,
        triggers: [CodeCommitClientTypes.RepositoryTrigger]? = nil
    )
    {
        self.repositoryName = repositoryName
        self.triggers = triggers
    }
}

struct PutRepositoryTriggersInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let triggers: [CodeCommitClientTypes.RepositoryTrigger]?
}

extension PutRepositoryTriggersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case triggers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let triggersContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[CodeCommitClientTypes.RepositoryTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [CodeCommitClientTypes.RepositoryTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

extension PutRepositoryTriggersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRepositoryTriggersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerBranchNameException" : self = .invalidRepositoryTriggerBranchNameException(try InvalidRepositoryTriggerBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerCustomDataException" : self = .invalidRepositoryTriggerCustomDataException(try InvalidRepositoryTriggerCustomDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerDestinationArnException" : self = .invalidRepositoryTriggerDestinationArnException(try InvalidRepositoryTriggerDestinationArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerEventsException" : self = .invalidRepositoryTriggerEventsException(try InvalidRepositoryTriggerEventsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerNameException" : self = .invalidRepositoryTriggerNameException(try InvalidRepositoryTriggerNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerRegionException" : self = .invalidRepositoryTriggerRegionException(try InvalidRepositoryTriggerRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumBranchesExceededException" : self = .maximumBranchesExceededException(try MaximumBranchesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRepositoryTriggersExceededException" : self = .maximumRepositoryTriggersExceededException(try MaximumRepositoryTriggersExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerBranchNameListRequiredException" : self = .repositoryTriggerBranchNameListRequiredException(try RepositoryTriggerBranchNameListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerDestinationArnRequiredException" : self = .repositoryTriggerDestinationArnRequiredException(try RepositoryTriggerDestinationArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerEventsListRequiredException" : self = .repositoryTriggerEventsListRequiredException(try RepositoryTriggerEventsListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerNameRequiredException" : self = .repositoryTriggerNameRequiredException(try RepositoryTriggerNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggersListRequiredException" : self = .repositoryTriggersListRequiredException(try RepositoryTriggersListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRepositoryTriggersOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidRepositoryTriggerBranchNameException(InvalidRepositoryTriggerBranchNameException)
    case invalidRepositoryTriggerCustomDataException(InvalidRepositoryTriggerCustomDataException)
    case invalidRepositoryTriggerDestinationArnException(InvalidRepositoryTriggerDestinationArnException)
    case invalidRepositoryTriggerEventsException(InvalidRepositoryTriggerEventsException)
    case invalidRepositoryTriggerNameException(InvalidRepositoryTriggerNameException)
    case invalidRepositoryTriggerRegionException(InvalidRepositoryTriggerRegionException)
    case maximumBranchesExceededException(MaximumBranchesExceededException)
    case maximumRepositoryTriggersExceededException(MaximumRepositoryTriggersExceededException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryTriggerBranchNameListRequiredException(RepositoryTriggerBranchNameListRequiredException)
    case repositoryTriggerDestinationArnRequiredException(RepositoryTriggerDestinationArnRequiredException)
    case repositoryTriggerEventsListRequiredException(RepositoryTriggerEventsListRequiredException)
    case repositoryTriggerNameRequiredException(RepositoryTriggerNameRequiredException)
    case repositoryTriggersListRequiredException(RepositoryTriggersListRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRepositoryTriggersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutRepositoryTriggersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
        } else {
            self.configurationId = nil
        }
    }
}

/// Represents the output of a put repository triggers operation.
public struct PutRepositoryTriggersOutputResponse: Swift.Equatable {
    /// The system-generated unique ID for the create or update operation.
    public var configurationId: Swift.String?

    public init (
        configurationId: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

struct PutRepositoryTriggersOutputResponseBody: Swift.Equatable {
    let configurationId: Swift.String?
}

extension PutRepositoryTriggersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
    }
}

extension CodeCommitClientTypes.ReactionForComment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reaction
        case reactionUsers
        case reactionsFromDeletedUsersCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reaction = self.reaction {
            try encodeContainer.encode(reaction, forKey: .reaction)
        }
        if let reactionUsers = reactionUsers {
            var reactionUsersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reactionUsers)
            for arn0 in reactionUsers {
                try reactionUsersContainer.encode(arn0)
            }
        }
        if let reactionsFromDeletedUsersCount = self.reactionsFromDeletedUsersCount {
            try encodeContainer.encode(reactionsFromDeletedUsersCount, forKey: .reactionsFromDeletedUsersCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactionDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ReactionValueFormats.self, forKey: .reaction)
        reaction = reactionDecoded
        let reactionUsersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reactionUsers)
        var reactionUsersDecoded0:[Swift.String]? = nil
        if let reactionUsersContainer = reactionUsersContainer {
            reactionUsersDecoded0 = [Swift.String]()
            for string0 in reactionUsersContainer {
                if let string0 = string0 {
                    reactionUsersDecoded0?.append(string0)
                }
            }
        }
        reactionUsers = reactionUsersDecoded0
        let reactionsFromDeletedUsersCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reactionsFromDeletedUsersCount)
        reactionsFromDeletedUsersCount = reactionsFromDeletedUsersCountDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the reaction values provided by users on a comment.
    public struct ReactionForComment: Swift.Equatable {
        /// The reaction for a specified comment.
        public var reaction: CodeCommitClientTypes.ReactionValueFormats?
        /// The Amazon Resource Names (ARNs) of users who have provided reactions to the comment.
        public var reactionUsers: [Swift.String]?
        /// A numerical count of users who reacted with the specified emoji whose identities have been subsequently deleted from IAM. While these IAM users or roles no longer exist, the reactions might still appear in total reaction counts.
        public var reactionsFromDeletedUsersCount: Swift.Int?

        public init (
            reaction: CodeCommitClientTypes.ReactionValueFormats? = nil,
            reactionUsers: [Swift.String]? = nil,
            reactionsFromDeletedUsersCount: Swift.Int? = nil
        )
        {
            self.reaction = reaction
            self.reactionUsers = reactionUsers
            self.reactionsFromDeletedUsersCount = reactionsFromDeletedUsersCount
        }
    }

}

extension ReactionLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReactionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.
public struct ReactionLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReactionLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReactionLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.ReactionValueFormats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emoji
        case shortCode
        case unicode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emoji = self.emoji {
            try encodeContainer.encode(emoji, forKey: .emoji)
        }
        if let shortCode = self.shortCode {
            try encodeContainer.encode(shortCode, forKey: .shortCode)
        }
        if let unicode = self.unicode {
            try encodeContainer.encode(unicode, forKey: .unicode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emojiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emoji)
        emoji = emojiDecoded
        let shortCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortCode)
        shortCode = shortCodeDecoded
        let unicodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unicode)
        unicode = unicodeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the values for reactions to a comment. AWS CodeCommit supports a limited set of reactions.
    public struct ReactionValueFormats: Swift.Equatable {
        /// The Emoji Version 1.0 graphic of the reaction. These graphics are interpreted slightly differently on different operating systems.
        public var emoji: Swift.String?
        /// The emoji short code for the reaction. Short codes are interpreted slightly differently on different operating systems.
        public var shortCode: Swift.String?
        /// The Unicode codepoint for the reaction.
        public var unicode: Swift.String?

        public init (
            emoji: Swift.String? = nil,
            shortCode: Swift.String? = nil,
            unicode: Swift.String? = nil
        )
        {
            self.emoji = emoji
            self.shortCode = shortCode
            self.unicode = unicode
        }
    }

}

extension ReactionValueRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReactionValueRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A reaction value is required.
public struct ReactionValueRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReactionValueRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReactionValueRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReferenceDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReferenceDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified reference does not exist. You must provide a full commit ID.
public struct ReferenceDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReferenceDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReferenceDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReferenceNameRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReferenceNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A reference name is required, but none was provided.
public struct ReferenceNameRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReferenceNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReferenceNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReferenceTypeNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReferenceTypeNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified reference is not a supported type.
public struct ReferenceTypeNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReferenceTypeNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReferenceTypeNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum RelativeFileVersionEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case after
        case before
        case sdkUnknown(Swift.String)

        public static var allCases: [RelativeFileVersionEnum] {
            return [
                .after,
                .before,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .after: return "AFTER"
            case .before: return "BEFORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelativeFileVersionEnum(rawValue: rawValue) ?? RelativeFileVersionEnum.sdkUnknown(rawValue)
        }
    }
}

extension CodeCommitClientTypes.ReplaceContentEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case fileMode
        case filePath
        case replacementType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content.base64EncodedString(), forKey: .content)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let replacementType = self.replacementType {
            try encodeContainer.encode(replacementType.rawValue, forKey: .replacementType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let replacementTypeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ReplacementTypeEnum.self, forKey: .replacementType)
        replacementType = replacementTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a replacement content entry in the conflict of a merge or pull request operation.
    public struct ReplaceContentEntry: Swift.Equatable {
        /// The base-64 encoded content to use when the replacement type is USE_NEW_CONTENT.
        public var content: ClientRuntime.Data?
        /// The file mode to apply during conflict resoltion.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The path of the conflicting file.
        /// This member is required.
        public var filePath: Swift.String?
        /// The replacement type to use when determining how to resolve the conflict.
        /// This member is required.
        public var replacementType: CodeCommitClientTypes.ReplacementTypeEnum?

        public init (
            content: ClientRuntime.Data? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            filePath: Swift.String? = nil,
            replacementType: CodeCommitClientTypes.ReplacementTypeEnum? = nil
        )
        {
            self.content = content
            self.fileMode = fileMode
            self.filePath = filePath
            self.replacementType = replacementType
        }
    }

}

extension ReplacementContentRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReplacementContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// USE_NEW_CONTENT was specified, but no replacement content has been provided.
public struct ReplacementContentRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReplacementContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReplacementContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum ReplacementTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case keepBase
        case keepDestination
        case keepSource
        case useNewContent
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplacementTypeEnum] {
            return [
                .keepBase,
                .keepDestination,
                .keepSource,
                .useNewContent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .keepBase: return "KEEP_BASE"
            case .keepDestination: return "KEEP_DESTINATION"
            case .keepSource: return "KEEP_SOURCE"
            case .useNewContent: return "USE_NEW_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplacementTypeEnum(rawValue: rawValue) ?? ReplacementTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension ReplacementTypeRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReplacementTypeRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A replacement type is required.
public struct ReplacementTypeRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReplacementTypeRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReplacementTypeRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository does not exist.
public struct RepositoryDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A repository resource limit was exceeded.
public struct RepositoryLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.RepositoryMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case accountId
        case cloneUrlHttp
        case cloneUrlSsh
        case creationDate
        case defaultBranch
        case lastModifiedDate
        case repositoryDescription
        case repositoryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let cloneUrlHttp = self.cloneUrlHttp {
            try encodeContainer.encode(cloneUrlHttp, forKey: .cloneUrlHttp)
        }
        if let cloneUrlSsh = self.cloneUrlSsh {
            try encodeContainer.encode(cloneUrlSsh, forKey: .cloneUrlSsh)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let defaultBranch = self.defaultBranch {
            try encodeContainer.encode(defaultBranch, forKey: .defaultBranch)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let repositoryDescription = self.repositoryDescription {
            try encodeContainer.encode(repositoryDescription, forKey: .repositoryDescription)
        }
        if let repositoryId = self.repositoryId {
            try encodeContainer.encode(repositoryId, forKey: .repositoryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let repositoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryDescription)
        repositoryDescription = repositoryDescriptionDecoded
        let defaultBranchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultBranch)
        defaultBranch = defaultBranchDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let cloneUrlHttpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloneUrlHttp)
        cloneUrlHttp = cloneUrlHttpDecoded
        let cloneUrlSshDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloneUrlSsh)
        cloneUrlSsh = cloneUrlSshDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a repository.
    public struct RepositoryMetadata: Swift.Equatable {
        /// The ID of the AWS account associated with the repository.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the repository.
        public var arn: Swift.String?
        /// The URL to use for cloning the repository over HTTPS.
        public var cloneUrlHttp: Swift.String?
        /// The URL to use for cloning the repository over SSH.
        public var cloneUrlSsh: Swift.String?
        /// The date and time the repository was created, in timestamp format.
        public var creationDate: ClientRuntime.Date?
        /// The repository's default branch name.
        public var defaultBranch: Swift.String?
        /// The date and time the repository was last modified, in timestamp format.
        public var lastModifiedDate: ClientRuntime.Date?
        /// A comment or description about the repository.
        public var repositoryDescription: Swift.String?
        /// The ID of the repository.
        public var repositoryId: Swift.String?
        /// The repository's name.
        public var repositoryName: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            cloneUrlHttp: Swift.String? = nil,
            cloneUrlSsh: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            defaultBranch: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            repositoryDescription: Swift.String? = nil,
            repositoryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.cloneUrlHttp = cloneUrlHttp
            self.cloneUrlSsh = cloneUrlSsh
            self.creationDate = creationDate
            self.defaultBranch = defaultBranch
            self.lastModifiedDate = lastModifiedDate
            self.repositoryDescription = repositoryDescription
            self.repositoryId = repositoryId
            self.repositoryName = repositoryName
        }
    }

}

extension RepositoryNameExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryNameExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository name already exists.
public struct RepositoryNameExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNameExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNameExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.RepositoryNameIdPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryId = self.repositoryId {
            try encodeContainer.encode(repositoryId, forKey: .repositoryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a repository name and ID.
    public struct RepositoryNameIdPair: Swift.Equatable {
        /// The ID associated with the repository.
        public var repositoryId: Swift.String?
        /// The name associated with the repository.
        public var repositoryName: Swift.String?

        public init (
            repositoryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.repositoryId = repositoryId
            self.repositoryName = repositoryName
        }
    }

}

extension RepositoryNameRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A repository name is required, but was not specified.
public struct RepositoryNameRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNamesRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryNamesRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// At least one repository name object is required, but was not specified.
public struct RepositoryNamesRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNamesRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNamesRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotAssociatedWithPullRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryNotAssociatedWithPullRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.
public struct RepositoryNotAssociatedWithPullRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotAssociatedWithPullRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNotAssociatedWithPullRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.RepositoryTrigger: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branches
        case customData
        case destinationArn
        case events
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branches = branches {
            var branchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .branches)
            for branchname0 in branches {
                try branchesContainer.encode(branchname0)
            }
        }
        if let customData = self.customData {
            try encodeContainer.encode(customData, forKey: .customData)
        }
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for repositorytriggereventenum0 in events {
                try eventsContainer.encode(repositorytriggereventenum0.rawValue)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let customDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customData)
        customData = customDataDecoded
        let branchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .branches)
        var branchesDecoded0:[Swift.String]? = nil
        if let branchesContainer = branchesContainer {
            branchesDecoded0 = [Swift.String]()
            for string0 in branchesContainer {
                if let string0 = string0 {
                    branchesDecoded0?.append(string0)
                }
            }
        }
        branches = branchesDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryTriggerEventEnum?].self, forKey: .events)
        var eventsDecoded0:[CodeCommitClientTypes.RepositoryTriggerEventEnum]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [CodeCommitClientTypes.RepositoryTriggerEventEnum]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension CodeCommitClientTypes {
    /// Information about a trigger for a repository.
    public struct RepositoryTrigger: Swift.Equatable {
        /// The branches to be included in the trigger configuration. If you specify an empty array, the trigger applies to all branches. Although no content is required in the array, you must include the array itself.
        public var branches: [Swift.String]?
        /// Any custom data associated with the trigger to be included in the information sent to the target of the trigger.
        public var customData: Swift.String?
        /// The ARN of the resource that is the target for a trigger (for example, the ARN of a topic in Amazon SNS).
        /// This member is required.
        public var destinationArn: Swift.String?
        /// The repository events that cause the trigger to run actions in another service, such as sending a notification through Amazon SNS. The valid value "all" cannot be used with any other values.
        /// This member is required.
        public var events: [CodeCommitClientTypes.RepositoryTriggerEventEnum]?
        /// The name of the trigger.
        /// This member is required.
        public var name: Swift.String?

        public init (
            branches: [Swift.String]? = nil,
            customData: Swift.String? = nil,
            destinationArn: Swift.String? = nil,
            events: [CodeCommitClientTypes.RepositoryTriggerEventEnum]? = nil,
            name: Swift.String? = nil
        )
        {
            self.branches = branches
            self.customData = customData
            self.destinationArn = destinationArn
            self.events = events
            self.name = name
        }
    }

}

extension RepositoryTriggerBranchNameListRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryTriggerBranchNameListRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// At least one branch name is required, but was not specified in the trigger configuration.
public struct RepositoryTriggerBranchNameListRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryTriggerBranchNameListRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryTriggerBranchNameListRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryTriggerDestinationArnRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryTriggerDestinationArnRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A destination ARN for the target service for the trigger is required, but was not specified.
public struct RepositoryTriggerDestinationArnRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryTriggerDestinationArnRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryTriggerDestinationArnRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes {
    public enum RepositoryTriggerEventEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case createReference
        case deleteReference
        case updateReference
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositoryTriggerEventEnum] {
            return [
                .all,
                .createReference,
                .deleteReference,
                .updateReference,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .createReference: return "createReference"
            case .deleteReference: return "deleteReference"
            case .updateReference: return "updateReference"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositoryTriggerEventEnum(rawValue: rawValue) ?? RepositoryTriggerEventEnum.sdkUnknown(rawValue)
        }
    }
}

extension RepositoryTriggerEventsListRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryTriggerEventsListRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// At least one event for the trigger is required, but was not specified.
public struct RepositoryTriggerEventsListRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryTriggerEventsListRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryTriggerEventsListRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.RepositoryTriggerExecutionFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureMessage
        case trigger
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let trigger = self.trigger {
            try encodeContainer.encode(trigger, forKey: .trigger)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trigger)
        trigger = triggerDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension CodeCommitClientTypes {
    /// A trigger failed to run.
    public struct RepositoryTriggerExecutionFailure: Swift.Equatable {
        /// Message information about the trigger that did not run.
        public var failureMessage: Swift.String?
        /// The name of the trigger that did not run.
        public var trigger: Swift.String?

        public init (
            failureMessage: Swift.String? = nil,
            trigger: Swift.String? = nil
        )
        {
            self.failureMessage = failureMessage
            self.trigger = trigger
        }
    }

}

extension RepositoryTriggerNameRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryTriggerNameRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A name for the trigger is required, but was not specified.
public struct RepositoryTriggerNameRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryTriggerNameRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryTriggerNameRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryTriggersListRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryTriggersListRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The list of triggers for the repository is required, but was not specified.
public struct RepositoryTriggersListRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryTriggersListRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryTriggersListRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceArnRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceArnRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see [CodeCommit Resources and Operations](https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats) in the AWS CodeCommit User Guide.
public struct ResourceArnRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceArnRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceArnRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestrictedSourceFileException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RestrictedSourceFileExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.
public struct RestrictedSourceFileException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RestrictedSourceFileExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RestrictedSourceFileExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RevisionIdRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RevisionIdRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A revision ID is required, but was not provided.
public struct RevisionIdRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RevisionIdRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RevisionIdRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RevisionNotCurrentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RevisionNotCurrentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.
public struct RevisionNotCurrentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RevisionNotCurrentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RevisionNotCurrentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SameFileContentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SameFileContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch that you specified.
public struct SameFileContentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SameFileContentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SameFileContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SamePathRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SamePathRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example, you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same file as part of the same commit.
public struct SamePathRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SamePathRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SamePathRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.SetFileModeEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileMode
        case filePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the file mode changes.
    public struct SetFileModeEntry: Swift.Equatable {
        /// The file mode for the file.
        /// This member is required.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The full path to the file, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?

        public init (
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            filePath: Swift.String? = nil
        )
        {
            self.fileMode = fileMode
            self.filePath = filePath
        }
    }

}

extension CodeCommitClientTypes {
    public enum SortByEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case modifiedDate
        case repositoryName
        case sdkUnknown(Swift.String)

        public static var allCases: [SortByEnum] {
            return [
                .modifiedDate,
                .repositoryName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .modifiedDate: return "lastModifiedDate"
            case .repositoryName: return "repositoryName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortByEnum(rawValue: rawValue) ?? SortByEnum.sdkUnknown(rawValue)
        }
    }
}

extension SourceAndDestinationAreSameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SourceAndDestinationAreSameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The source branch and destination branch for the pull request are the same. You must specify different branches for the source and destination.
public struct SourceAndDestinationAreSameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SourceAndDestinationAreSameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SourceAndDestinationAreSameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceFileOrContentRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SourceFileOrContentRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The commit cannot be created because no source files or file content have been specified for the commit.
public struct SourceFileOrContentRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SourceFileOrContentRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SourceFileOrContentRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.SourceFileSpecifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePath
        case isMove
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if isMove != false {
            try encodeContainer.encode(isMove, forKey: .isMove)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let isMoveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMove) ?? false
        isMove = isMoveDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about a source file that is part of changes made in a commit.
    public struct SourceFileSpecifier: Swift.Equatable {
        /// The full path to the file, including the name of the file.
        /// This member is required.
        public var filePath: Swift.String?
        /// Whether to remove the source file from the parent commit.
        public var isMove: Swift.Bool

        public init (
            filePath: Swift.String? = nil,
            isMove: Swift.Bool = false
        )
        {
            self.filePath = filePath
            self.isMove = isMove
        }
    }

}

extension CodeCommitClientTypes.SubModule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutePath
        case commitId
        case relativePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = self.absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let relativePath = self.relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a submodule reference in a repository folder.
    public struct SubModule: Swift.Equatable {
        /// The fully qualified path to the folder that contains the reference to the submodule.
        public var absolutePath: Swift.String?
        /// The commit ID that contains the reference to the submodule.
        public var commitId: Swift.String?
        /// The relative path of the submodule from the folder where the query originated.
        public var relativePath: Swift.String?

        public init (
            absolutePath: Swift.String? = nil,
            commitId: Swift.String? = nil,
            relativePath: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.commitId = commitId
            self.relativePath = relativePath
        }
    }

}

extension CodeCommitClientTypes.SymbolicLink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absolutePath
        case blobId
        case fileMode
        case relativePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = self.absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let blobId = self.blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let fileMode = self.fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let relativePath = self.relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a symbolic link in a repository folder.
    public struct SymbolicLink: Swift.Equatable {
        /// The fully qualified path to the folder that contains the symbolic link.
        public var absolutePath: Swift.String?
        /// The blob ID that contains the information about the symbolic link.
        public var blobId: Swift.String?
        /// The file mode permissions of the blob that cotains information about the symbolic link.
        public var fileMode: CodeCommitClientTypes.FileModeTypeEnum?
        /// The relative path of the symbolic link from the folder where the query originated.
        public var relativePath: Swift.String?

        public init (
            absolutePath: Swift.String? = nil,
            blobId: Swift.String? = nil,
            fileMode: CodeCommitClientTypes.FileModeTypeEnum? = nil,
            relativePath: Swift.String? = nil
        )
        {
            self.absolutePath = absolutePath
            self.blobId = blobId
            self.fileMode = fileMode
            self.relativePath = relativePath
        }
    }

}

extension TagKeysListRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagKeysListRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A list of tag keys is required. The list cannot be empty or null.
public struct TagKeysListRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagKeysListRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagKeysListRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The tag policy is not valid.
public struct TagPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which you want to add or update tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair to use when tagging this repository.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceArnException" : self = .invalidResourceArnException(try InvalidResourceArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSystemTagUsageException" : self = .invalidSystemTagUsageException(try InvalidSystemTagUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsMapException" : self = .invalidTagsMapException(try InvalidTagsMapException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceArnRequiredException" : self = .resourceArnRequiredException(try ResourceArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsMapRequiredException" : self = .tagsMapRequiredException(try TagsMapRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidResourceArnException(InvalidResourceArnException)
    case invalidSystemTagUsageException(InvalidSystemTagUsageException)
    case invalidTagsMapException(InvalidTagsMapException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case resourceArnRequiredException(ResourceArnRequiredException)
    case tagPolicyException(TagPolicyException)
    case tagsMapRequiredException(TagsMapRequiredException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagsMapRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagsMapRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A map of tags is required.
public struct TagsMapRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagsMapRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagsMapRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCommitClientTypes.Target: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationReference
        case repositoryName
        case sourceReference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationReference = self.destinationReference {
            try encodeContainer.encode(destinationReference, forKey: .destinationReference)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceReference = self.sourceReference {
            try encodeContainer.encode(sourceReference, forKey: .sourceReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceReference)
        sourceReference = sourceReferenceDecoded
        let destinationReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationReference)
        destinationReference = destinationReferenceDecoded
    }
}

extension CodeCommitClientTypes {
    /// Returns information about a target for a pull request.
    public struct Target: Swift.Equatable {
        /// The branch of the repository where the pull request changes are merged. Also known as the destination branch.
        public var destinationReference: Swift.String?
        /// The name of the repository that contains the pull request.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// The branch of the repository that contains the changes for the pull request. Also known as the source branch.
        /// This member is required.
        public var sourceReference: Swift.String?

        public init (
            destinationReference: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            sourceReference: Swift.String? = nil
        )
        {
            self.destinationReference = destinationReference
            self.repositoryName = repositoryName
            self.sourceReference = sourceReference
        }
    }

}

extension TargetRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TargetRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.
public struct TargetRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TargetRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TargetRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TargetsRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TargetsRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An array of target objects is required. It cannot be empty or null.
public struct TargetsRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TargetsRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TargetsRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TestRepositoryTriggersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case triggers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for repositorytrigger0 in triggers {
                try triggersContainer.encode(repositorytrigger0)
            }
        }
    }
}

extension TestRepositoryTriggersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a test repository triggers operation.
public struct TestRepositoryTriggersInput: Swift.Equatable {
    /// The name of the repository in which to test the triggers.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The list of triggers to test.
    /// This member is required.
    public var triggers: [CodeCommitClientTypes.RepositoryTrigger]?

    public init (
        repositoryName: Swift.String? = nil,
        triggers: [CodeCommitClientTypes.RepositoryTrigger]? = nil
    )
    {
        self.repositoryName = repositoryName
        self.triggers = triggers
    }
}

struct TestRepositoryTriggersInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let triggers: [CodeCommitClientTypes.RepositoryTrigger]?
}

extension TestRepositoryTriggersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case triggers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let triggersContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[CodeCommitClientTypes.RepositoryTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [CodeCommitClientTypes.RepositoryTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

extension TestRepositoryTriggersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestRepositoryTriggersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerBranchNameException" : self = .invalidRepositoryTriggerBranchNameException(try InvalidRepositoryTriggerBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerCustomDataException" : self = .invalidRepositoryTriggerCustomDataException(try InvalidRepositoryTriggerCustomDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerDestinationArnException" : self = .invalidRepositoryTriggerDestinationArnException(try InvalidRepositoryTriggerDestinationArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerEventsException" : self = .invalidRepositoryTriggerEventsException(try InvalidRepositoryTriggerEventsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerNameException" : self = .invalidRepositoryTriggerNameException(try InvalidRepositoryTriggerNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerRegionException" : self = .invalidRepositoryTriggerRegionException(try InvalidRepositoryTriggerRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumBranchesExceededException" : self = .maximumBranchesExceededException(try MaximumBranchesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRepositoryTriggersExceededException" : self = .maximumRepositoryTriggersExceededException(try MaximumRepositoryTriggersExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerBranchNameListRequiredException" : self = .repositoryTriggerBranchNameListRequiredException(try RepositoryTriggerBranchNameListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerDestinationArnRequiredException" : self = .repositoryTriggerDestinationArnRequiredException(try RepositoryTriggerDestinationArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerEventsListRequiredException" : self = .repositoryTriggerEventsListRequiredException(try RepositoryTriggerEventsListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerNameRequiredException" : self = .repositoryTriggerNameRequiredException(try RepositoryTriggerNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggersListRequiredException" : self = .repositoryTriggersListRequiredException(try RepositoryTriggersListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TestRepositoryTriggersOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidRepositoryTriggerBranchNameException(InvalidRepositoryTriggerBranchNameException)
    case invalidRepositoryTriggerCustomDataException(InvalidRepositoryTriggerCustomDataException)
    case invalidRepositoryTriggerDestinationArnException(InvalidRepositoryTriggerDestinationArnException)
    case invalidRepositoryTriggerEventsException(InvalidRepositoryTriggerEventsException)
    case invalidRepositoryTriggerNameException(InvalidRepositoryTriggerNameException)
    case invalidRepositoryTriggerRegionException(InvalidRepositoryTriggerRegionException)
    case maximumBranchesExceededException(MaximumBranchesExceededException)
    case maximumRepositoryTriggersExceededException(MaximumRepositoryTriggersExceededException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryTriggerBranchNameListRequiredException(RepositoryTriggerBranchNameListRequiredException)
    case repositoryTriggerDestinationArnRequiredException(RepositoryTriggerDestinationArnRequiredException)
    case repositoryTriggerEventsListRequiredException(RepositoryTriggerEventsListRequiredException)
    case repositoryTriggerNameRequiredException(RepositoryTriggerNameRequiredException)
    case repositoryTriggersListRequiredException(RepositoryTriggersListRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestRepositoryTriggersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TestRepositoryTriggersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedExecutions = output.failedExecutions
            self.successfulExecutions = output.successfulExecutions
        } else {
            self.failedExecutions = nil
            self.successfulExecutions = nil
        }
    }
}

/// Represents the output of a test repository triggers operation.
public struct TestRepositoryTriggersOutputResponse: Swift.Equatable {
    /// The list of triggers that were not tested. This list provides the names of the triggers that could not be tested, separated by commas.
    public var failedExecutions: [CodeCommitClientTypes.RepositoryTriggerExecutionFailure]?
    /// The list of triggers that were successfully tested. This list provides the names of the triggers that were successfully tested, separated by commas.
    public var successfulExecutions: [Swift.String]?

    public init (
        failedExecutions: [CodeCommitClientTypes.RepositoryTriggerExecutionFailure]? = nil,
        successfulExecutions: [Swift.String]? = nil
    )
    {
        self.failedExecutions = failedExecutions
        self.successfulExecutions = successfulExecutions
    }
}

struct TestRepositoryTriggersOutputResponseBody: Swift.Equatable {
    let successfulExecutions: [Swift.String]?
    let failedExecutions: [CodeCommitClientTypes.RepositoryTriggerExecutionFailure]?
}

extension TestRepositoryTriggersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedExecutions
        case successfulExecutions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulExecutionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .successfulExecutions)
        var successfulExecutionsDecoded0:[Swift.String]? = nil
        if let successfulExecutionsContainer = successfulExecutionsContainer {
            successfulExecutionsDecoded0 = [Swift.String]()
            for string0 in successfulExecutionsContainer {
                if let string0 = string0 {
                    successfulExecutionsDecoded0?.append(string0)
                }
            }
        }
        successfulExecutions = successfulExecutionsDecoded0
        let failedExecutionsContainer = try containerValues.decodeIfPresent([CodeCommitClientTypes.RepositoryTriggerExecutionFailure?].self, forKey: .failedExecutions)
        var failedExecutionsDecoded0:[CodeCommitClientTypes.RepositoryTriggerExecutionFailure]? = nil
        if let failedExecutionsContainer = failedExecutionsContainer {
            failedExecutionsDecoded0 = [CodeCommitClientTypes.RepositoryTriggerExecutionFailure]()
            for structure0 in failedExecutionsContainer {
                if let structure0 = structure0 {
                    failedExecutionsDecoded0?.append(structure0)
                }
            }
        }
        failedExecutions = failedExecutionsDecoded0
    }
}

extension TipOfSourceReferenceIsDifferentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TipOfSourceReferenceIsDifferentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.
public struct TipOfSourceReferenceIsDifferentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TipOfSourceReferenceIsDifferentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TipOfSourceReferenceIsDifferentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TipsDivergenceExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TipsDivergenceExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using git diff or a diff tool.
public struct TipsDivergenceExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TipsDivergenceExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TipsDivergenceExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TitleRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TitleRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A pull request title is required. It cannot be empty or null.
public struct TitleRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TitleRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TitleRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of tags for an AWS CodeCommit resource has been exceeded.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which you want to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key for each tag that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceArnException" : self = .invalidResourceArnException(try InvalidResourceArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSystemTagUsageException" : self = .invalidSystemTagUsageException(try InvalidSystemTagUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagKeysListException" : self = .invalidTagKeysListException(try InvalidTagKeysListException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceArnRequiredException" : self = .resourceArnRequiredException(try ResourceArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagKeysListRequiredException" : self = .tagKeysListRequiredException(try TagKeysListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidResourceArnException(InvalidResourceArnException)
    case invalidSystemTagUsageException(InvalidSystemTagUsageException)
    case invalidTagKeysListException(InvalidTagKeysListException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case resourceArnRequiredException(ResourceArnRequiredException)
    case tagKeysListRequiredException(TagKeysListRequiredException)
    case tagPolicyException(TagPolicyException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateApprovalRuleTemplateContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case existingRuleContentSha256
        case newRuleContent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let existingRuleContentSha256 = self.existingRuleContentSha256 {
            try encodeContainer.encode(existingRuleContentSha256, forKey: .existingRuleContentSha256)
        }
        if let newRuleContent = self.newRuleContent {
            try encodeContainer.encode(newRuleContent, forKey: .newRuleContent)
        }
    }
}

extension UpdateApprovalRuleTemplateContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApprovalRuleTemplateContentInput: Swift.Equatable {
    /// The name of the approval rule template where you want to update the content of the rule.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?
    /// The SHA-256 hash signature for the content of the approval rule. You can retrieve this information by using [GetPullRequest].
    public var existingRuleContentSha256: Swift.String?
    /// The content that replaces the existing content of the rule. Content statements must be complete. You cannot provide only the changes.
    /// This member is required.
    public var newRuleContent: Swift.String?

    public init (
        approvalRuleTemplateName: Swift.String? = nil,
        existingRuleContentSha256: Swift.String? = nil,
        newRuleContent: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.existingRuleContentSha256 = existingRuleContentSha256
        self.newRuleContent = newRuleContent
    }
}

struct UpdateApprovalRuleTemplateContentInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let newRuleContent: Swift.String?
    let existingRuleContentSha256: Swift.String?
}

extension UpdateApprovalRuleTemplateContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateName
        case existingRuleContentSha256
        case newRuleContent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let newRuleContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newRuleContent)
        newRuleContent = newRuleContentDecoded
        let existingRuleContentSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingRuleContentSha256)
        existingRuleContentSha256 = existingRuleContentSha256Decoded
    }
}

extension UpdateApprovalRuleTemplateContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApprovalRuleTemplateContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateContentRequiredException" : self = .approvalRuleTemplateContentRequiredException(try ApprovalRuleTemplateContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateContentException" : self = .invalidApprovalRuleTemplateContentException(try InvalidApprovalRuleTemplateContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleContentSha256Exception" : self = .invalidRuleContentSha256Exception(try InvalidRuleContentSha256Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApprovalRuleTemplateContentOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateContentRequiredException(ApprovalRuleTemplateContentRequiredException)
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateContentException(InvalidApprovalRuleTemplateContentException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case invalidRuleContentSha256Exception(InvalidRuleContentSha256Exception)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApprovalRuleTemplateContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateApprovalRuleTemplateContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct UpdateApprovalRuleTemplateContentOutputResponse: Swift.Equatable {
    /// Returns information about an approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init (
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct UpdateApprovalRuleTemplateContentOutputResponseBody: Swift.Equatable {
    let approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?
}

extension UpdateApprovalRuleTemplateContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

extension UpdateApprovalRuleTemplateDescriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateDescription = self.approvalRuleTemplateDescription {
            try encodeContainer.encode(approvalRuleTemplateDescription, forKey: .approvalRuleTemplateDescription)
        }
        if let approvalRuleTemplateName = self.approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

extension UpdateApprovalRuleTemplateDescriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApprovalRuleTemplateDescriptionInput: Swift.Equatable {
    /// The updated description of the approval rule template.
    /// This member is required.
    public var approvalRuleTemplateDescription: Swift.String?
    /// The name of the template for which you want to update the description.
    /// This member is required.
    public var approvalRuleTemplateName: Swift.String?

    public init (
        approvalRuleTemplateDescription: Swift.String? = nil,
        approvalRuleTemplateName: Swift.String? = nil
    )
    {
        self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct UpdateApprovalRuleTemplateDescriptionInputBody: Swift.Equatable {
    let approvalRuleTemplateName: Swift.String?
    let approvalRuleTemplateDescription: Swift.String?
}

extension UpdateApprovalRuleTemplateDescriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let approvalRuleTemplateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleTemplateDescription)
        approvalRuleTemplateDescription = approvalRuleTemplateDescriptionDecoded
    }
}

extension UpdateApprovalRuleTemplateDescriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApprovalRuleTemplateDescriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateDescriptionException" : self = .invalidApprovalRuleTemplateDescriptionException(try InvalidApprovalRuleTemplateDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApprovalRuleTemplateDescriptionOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateDescriptionException(InvalidApprovalRuleTemplateDescriptionException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApprovalRuleTemplateDescriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateApprovalRuleTemplateDescriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct UpdateApprovalRuleTemplateDescriptionOutputResponse: Swift.Equatable {
    /// The structure and content of the updated approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init (
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct UpdateApprovalRuleTemplateDescriptionOutputResponseBody: Swift.Equatable {
    let approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?
}

extension UpdateApprovalRuleTemplateDescriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

extension UpdateApprovalRuleTemplateNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newApprovalRuleTemplateName
        case oldApprovalRuleTemplateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newApprovalRuleTemplateName = self.newApprovalRuleTemplateName {
            try encodeContainer.encode(newApprovalRuleTemplateName, forKey: .newApprovalRuleTemplateName)
        }
        if let oldApprovalRuleTemplateName = self.oldApprovalRuleTemplateName {
            try encodeContainer.encode(oldApprovalRuleTemplateName, forKey: .oldApprovalRuleTemplateName)
        }
    }
}

extension UpdateApprovalRuleTemplateNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApprovalRuleTemplateNameInput: Swift.Equatable {
    /// The new name you want to apply to the approval rule template.
    /// This member is required.
    public var newApprovalRuleTemplateName: Swift.String?
    /// The current name of the approval rule template.
    /// This member is required.
    public var oldApprovalRuleTemplateName: Swift.String?

    public init (
        newApprovalRuleTemplateName: Swift.String? = nil,
        oldApprovalRuleTemplateName: Swift.String? = nil
    )
    {
        self.newApprovalRuleTemplateName = newApprovalRuleTemplateName
        self.oldApprovalRuleTemplateName = oldApprovalRuleTemplateName
    }
}

struct UpdateApprovalRuleTemplateNameInputBody: Swift.Equatable {
    let oldApprovalRuleTemplateName: Swift.String?
    let newApprovalRuleTemplateName: Swift.String?
}

extension UpdateApprovalRuleTemplateNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newApprovalRuleTemplateName
        case oldApprovalRuleTemplateName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oldApprovalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oldApprovalRuleTemplateName)
        oldApprovalRuleTemplateName = oldApprovalRuleTemplateNameDecoded
        let newApprovalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newApprovalRuleTemplateName)
        newApprovalRuleTemplateName = newApprovalRuleTemplateNameDecoded
    }
}

extension UpdateApprovalRuleTemplateNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApprovalRuleTemplateNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameAlreadyExistsException" : self = .approvalRuleTemplateNameAlreadyExistsException(try ApprovalRuleTemplateNameAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApprovalRuleTemplateNameOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameAlreadyExistsException(ApprovalRuleTemplateNameAlreadyExistsException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApprovalRuleTemplateNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateApprovalRuleTemplateNameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct UpdateApprovalRuleTemplateNameOutputResponse: Swift.Equatable {
    /// The structure and content of the updated approval rule template.
    /// This member is required.
    public var approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?

    public init (
        approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct UpdateApprovalRuleTemplateNameOutputResponseBody: Swift.Equatable {
    let approvalRuleTemplate: CodeCommitClientTypes.ApprovalRuleTemplate?
}

extension UpdateApprovalRuleTemplateNameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

extension UpdateCommentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case content
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = self.commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

extension UpdateCommentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCommentInput: Swift.Equatable {
    /// The system-generated ID of the comment you want to update. To get this ID, use [GetCommentsForComparedCommit] or [GetCommentsForPullRequest].
    /// This member is required.
    public var commentId: Swift.String?
    /// The updated content to replace the existing content of the comment.
    /// This member is required.
    public var content: Swift.String?

    public init (
        commentId: Swift.String? = nil,
        content: Swift.String? = nil
    )
    {
        self.commentId = commentId
        self.content = content
    }
}

struct UpdateCommentInputBody: Swift.Equatable {
    let commentId: Swift.String?
    let content: Swift.String?
}

extension UpdateCommentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId
        case content
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateCommentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCommentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CommentContentRequiredException" : self = .commentContentRequiredException(try CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentSizeLimitExceededException" : self = .commentContentSizeLimitExceededException(try CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDeletedException" : self = .commentDeletedException(try CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentNotCreatedByCallerException" : self = .commentNotCreatedByCallerException(try CommentNotCreatedByCallerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCommentOutputError: Swift.Error, Swift.Equatable {
    case commentContentRequiredException(CommentContentRequiredException)
    case commentContentSizeLimitExceededException(CommentContentSizeLimitExceededException)
    case commentDeletedException(CommentDeletedException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case commentNotCreatedByCallerException(CommentNotCreatedByCallerException)
    case invalidCommentIdException(InvalidCommentIdException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCommentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCommentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct UpdateCommentOutputResponse: Swift.Equatable {
    /// Information about the updated comment.
    public var comment: CodeCommitClientTypes.Comment?

    public init (
        comment: CodeCommitClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct UpdateCommentOutputResponseBody: Swift.Equatable {
    let comment: CodeCommitClientTypes.Comment?
}

extension UpdateCommentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension UpdateDefaultBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultBranchName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultBranchName = self.defaultBranchName {
            try encodeContainer.encode(defaultBranchName, forKey: .defaultBranchName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension UpdateDefaultBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of an update default branch operation.
public struct UpdateDefaultBranchInput: Swift.Equatable {
    /// The name of the branch to set as the default.
    /// This member is required.
    public var defaultBranchName: Swift.String?
    /// The name of the repository to set or change the default branch for.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        defaultBranchName: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.defaultBranchName = defaultBranchName
        self.repositoryName = repositoryName
    }
}

struct UpdateDefaultBranchInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let defaultBranchName: Swift.String?
}

extension UpdateDefaultBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultBranchName
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let defaultBranchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultBranchName)
        defaultBranchName = defaultBranchNameDecoded
    }
}

extension UpdateDefaultBranchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDefaultBranchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDefaultBranchOutputError: Swift.Error, Swift.Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameRequiredException(BranchNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDefaultBranchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDefaultBranchOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdatePullRequestApprovalRuleContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleName
        case existingRuleContentSha256
        case newRuleContent
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleName = self.approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let existingRuleContentSha256 = self.existingRuleContentSha256 {
            try encodeContainer.encode(existingRuleContentSha256, forKey: .existingRuleContentSha256)
        }
        if let newRuleContent = self.newRuleContent {
            try encodeContainer.encode(newRuleContent, forKey: .newRuleContent)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension UpdatePullRequestApprovalRuleContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePullRequestApprovalRuleContentInput: Swift.Equatable {
    /// The name of the approval rule you want to update.
    /// This member is required.
    public var approvalRuleName: Swift.String?
    /// The SHA-256 hash signature for the content of the approval rule. You can retrieve this information by using [GetPullRequest].
    public var existingRuleContentSha256: Swift.String?
    /// The updated content for the approval rule. When you update the content of the approval rule, you can specify approvers in an approval pool in one of two ways:
    ///
    /// * CodeCommitApprovers: This option only requires an AWS account and a resource. It can be used for both IAM users and federated access users whose name matches the provided resource name. This is a very powerful option that offers a great deal of flexibility. For example, if you specify the AWS account 123456789012 and Mary_Major, all of the following are counted as approvals coming from that user:
    ///
    /// * An IAM user in the account (arn:aws:iam::123456789012:user/Mary_Major)
    ///
    /// * A federated user identified in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
    ///
    ///
    /// This option does not recognize an active session of someone assuming the role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major) unless you include a wildcard (*Mary_Major).
    ///
    /// * Fully qualified ARN: This option allows you to specify the fully qualified Amazon Resource Name (ARN) of the IAM user or role.
    ///
    ///
    /// For more information about IAM ARNs, wildcards, and formats, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
    /// This member is required.
    public var newRuleContent: Swift.String?
    /// The system-generated ID of the pull request.
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init (
        approvalRuleName: Swift.String? = nil,
        existingRuleContentSha256: Swift.String? = nil,
        newRuleContent: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.approvalRuleName = approvalRuleName
        self.existingRuleContentSha256 = existingRuleContentSha256
        self.newRuleContent = newRuleContent
        self.pullRequestId = pullRequestId
    }
}

struct UpdatePullRequestApprovalRuleContentInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let approvalRuleName: Swift.String?
    let existingRuleContentSha256: Swift.String?
    let newRuleContent: Swift.String?
}

extension UpdatePullRequestApprovalRuleContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRuleName
        case existingRuleContentSha256
        case newRuleContent
        case pullRequestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let existingRuleContentSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingRuleContentSha256)
        existingRuleContentSha256 = existingRuleContentSha256Decoded
        let newRuleContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newRuleContent)
        newRuleContent = newRuleContentDecoded
    }
}

extension UpdatePullRequestApprovalRuleContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePullRequestApprovalRuleContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalRuleContentRequiredException" : self = .approvalRuleContentRequiredException(try ApprovalRuleContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleDoesNotExistException" : self = .approvalRuleDoesNotExistException(try ApprovalRuleDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleNameRequiredException" : self = .approvalRuleNameRequiredException(try ApprovalRuleNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotModifyApprovalRuleFromTemplateException" : self = .cannotModifyApprovalRuleFromTemplateException(try CannotModifyApprovalRuleFromTemplateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleContentException" : self = .invalidApprovalRuleContentException(try InvalidApprovalRuleContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleNameException" : self = .invalidApprovalRuleNameException(try InvalidApprovalRuleNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleContentSha256Exception" : self = .invalidRuleContentSha256Exception(try InvalidRuleContentSha256Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePullRequestApprovalRuleContentOutputError: Swift.Error, Swift.Equatable {
    case approvalRuleContentRequiredException(ApprovalRuleContentRequiredException)
    case approvalRuleDoesNotExistException(ApprovalRuleDoesNotExistException)
    case approvalRuleNameRequiredException(ApprovalRuleNameRequiredException)
    case cannotModifyApprovalRuleFromTemplateException(CannotModifyApprovalRuleFromTemplateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleContentException(InvalidApprovalRuleContentException)
    case invalidApprovalRuleNameException(InvalidApprovalRuleNameException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRuleContentSha256Exception(InvalidRuleContentSha256Exception)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePullRequestApprovalRuleContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePullRequestApprovalRuleContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRule = output.approvalRule
        } else {
            self.approvalRule = nil
        }
    }
}

public struct UpdatePullRequestApprovalRuleContentOutputResponse: Swift.Equatable {
    /// Information about the updated approval rule.
    /// This member is required.
    public var approvalRule: CodeCommitClientTypes.ApprovalRule?

    public init (
        approvalRule: CodeCommitClientTypes.ApprovalRule? = nil
    )
    {
        self.approvalRule = approvalRule
    }
}

struct UpdatePullRequestApprovalRuleContentOutputResponseBody: Swift.Equatable {
    let approvalRule: CodeCommitClientTypes.ApprovalRule?
}

extension UpdatePullRequestApprovalRuleContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRule
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalRule.self, forKey: .approvalRule)
        approvalRule = approvalRuleDecoded
    }
}

extension UpdatePullRequestApprovalStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalState
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalState = self.approvalState {
            try encodeContainer.encode(approvalState.rawValue, forKey: .approvalState)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension UpdatePullRequestApprovalStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePullRequestApprovalStateInput: Swift.Equatable {
    /// The approval state to associate with the user on the pull request.
    /// This member is required.
    public var approvalState: CodeCommitClientTypes.ApprovalState?
    /// The system-generated ID of the pull request.
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The system-generated ID of the revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        approvalState: CodeCommitClientTypes.ApprovalState? = nil,
        pullRequestId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.approvalState = approvalState
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct UpdatePullRequestApprovalStateInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let revisionId: Swift.String?
    let approvalState: CodeCommitClientTypes.ApprovalState?
}

extension UpdatePullRequestApprovalStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalState
        case pullRequestId
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let approvalStateDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.ApprovalState.self, forKey: .approvalState)
        approvalState = approvalStateDecoded
    }
}

extension UpdatePullRequestApprovalStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePullRequestApprovalStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ApprovalStateRequiredException" : self = .approvalStateRequiredException(try ApprovalStateRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalStateException" : self = .invalidApprovalStateException(try InvalidApprovalStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRevisionIdException" : self = .invalidRevisionIdException(try InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumNumberOfApprovalsExceededException" : self = .maximumNumberOfApprovalsExceededException(try MaximumNumberOfApprovalsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestCannotBeApprovedByAuthorException" : self = .pullRequestCannotBeApprovedByAuthorException(try PullRequestCannotBeApprovedByAuthorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionIdRequiredException" : self = .revisionIdRequiredException(try RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionNotCurrentException" : self = .revisionNotCurrentException(try RevisionNotCurrentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePullRequestApprovalStateOutputError: Swift.Error, Swift.Equatable {
    case approvalStateRequiredException(ApprovalStateRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalStateException(InvalidApprovalStateException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRevisionIdException(InvalidRevisionIdException)
    case maximumNumberOfApprovalsExceededException(MaximumNumberOfApprovalsExceededException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestCannotBeApprovedByAuthorException(PullRequestCannotBeApprovedByAuthorException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case revisionIdRequiredException(RevisionIdRequiredException)
    case revisionNotCurrentException(RevisionNotCurrentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePullRequestApprovalStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePullRequestApprovalStateOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdatePullRequestDescriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case pullRequestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

extension UpdatePullRequestDescriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePullRequestDescriptionInput: Swift.Equatable {
    /// The updated content of the description for the pull request. This content replaces the existing description.
    /// This member is required.
    public var description: Swift.String?
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?

    public init (
        description: Swift.String? = nil,
        pullRequestId: Swift.String? = nil
    )
    {
        self.description = description
        self.pullRequestId = pullRequestId
    }
}

struct UpdatePullRequestDescriptionInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let description: Swift.String?
}

extension UpdatePullRequestDescriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case pullRequestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdatePullRequestDescriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePullRequestDescriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidDescriptionException" : self = .invalidDescriptionException(try InvalidDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePullRequestDescriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidDescriptionException(InvalidDescriptionException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePullRequestDescriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePullRequestDescriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct UpdatePullRequestDescriptionOutputResponse: Swift.Equatable {
    /// Information about the updated pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init (
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct UpdatePullRequestDescriptionOutputResponseBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension UpdatePullRequestDescriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

extension UpdatePullRequestStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case pullRequestStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let pullRequestStatus = self.pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
    }
}

extension UpdatePullRequestStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePullRequestStatusInput: Swift.Equatable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The status of the pull request. The only valid operations are to update the status from OPEN to OPEN, OPEN to CLOSED or from CLOSED to CLOSED.
    /// This member is required.
    public var pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?

    public init (
        pullRequestId: Swift.String? = nil,
        pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.pullRequestStatus = pullRequestStatus
    }
}

struct UpdatePullRequestStatusInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let pullRequestStatus: CodeCommitClientTypes.PullRequestStatusEnum?
}

extension UpdatePullRequestStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case pullRequestStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
    }
}

extension UpdatePullRequestStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePullRequestStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestStatusException" : self = .invalidPullRequestStatusException(try InvalidPullRequestStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestStatusUpdateException" : self = .invalidPullRequestStatusUpdateException(try InvalidPullRequestStatusUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestStatusRequiredException" : self = .pullRequestStatusRequiredException(try PullRequestStatusRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePullRequestStatusOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidPullRequestStatusException(InvalidPullRequestStatusException)
    case invalidPullRequestStatusUpdateException(InvalidPullRequestStatusUpdateException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case pullRequestStatusRequiredException(PullRequestStatusRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePullRequestStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePullRequestStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct UpdatePullRequestStatusOutputResponse: Swift.Equatable {
    /// Information about the pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init (
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct UpdatePullRequestStatusOutputResponseBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension UpdatePullRequestStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

extension UpdatePullRequestTitleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = self.pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension UpdatePullRequestTitleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePullRequestTitleInput: Swift.Equatable {
    /// The system-generated ID of the pull request. To get this ID, use [ListPullRequests].
    /// This member is required.
    public var pullRequestId: Swift.String?
    /// The updated title of the pull request. This replaces the existing title.
    /// This member is required.
    public var title: Swift.String?

    public init (
        pullRequestId: Swift.String? = nil,
        title: Swift.String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.title = title
    }
}

struct UpdatePullRequestTitleInputBody: Swift.Equatable {
    let pullRequestId: Swift.String?
    let title: Swift.String?
}

extension UpdatePullRequestTitleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequestId
        case title
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
    }
}

extension UpdatePullRequestTitleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePullRequestTitleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTitleException" : self = .invalidTitleException(try InvalidTitleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TitleRequiredException" : self = .titleRequiredException(try TitleRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePullRequestTitleOutputError: Swift.Error, Swift.Equatable {
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidTitleException(InvalidTitleException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case titleRequiredException(TitleRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePullRequestTitleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePullRequestTitleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct UpdatePullRequestTitleOutputResponse: Swift.Equatable {
    /// Information about the updated pull request.
    /// This member is required.
    public var pullRequest: CodeCommitClientTypes.PullRequest?

    public init (
        pullRequest: CodeCommitClientTypes.PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct UpdatePullRequestTitleOutputResponseBody: Swift.Equatable {
    let pullRequest: CodeCommitClientTypes.PullRequest?
}

extension UpdatePullRequestTitleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pullRequest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(CodeCommitClientTypes.PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

extension UpdateRepositoryDescriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryDescription
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryDescription = self.repositoryDescription {
            try encodeContainer.encode(repositoryDescription, forKey: .repositoryDescription)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension UpdateRepositoryDescriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of an update repository description operation.
public struct UpdateRepositoryDescriptionInput: Swift.Equatable {
    /// The new comment or description for the specified repository. Repository descriptions are limited to 1,000 characters.
    public var repositoryDescription: Swift.String?
    /// The name of the repository to set or change the comment or description for.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        repositoryDescription: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.repositoryDescription = repositoryDescription
        self.repositoryName = repositoryName
    }
}

struct UpdateRepositoryDescriptionInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let repositoryDescription: Swift.String?
}

extension UpdateRepositoryDescriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryDescription
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryDescription)
        repositoryDescription = repositoryDescriptionDecoded
    }
}

extension UpdateRepositoryDescriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRepositoryDescriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryDescriptionException" : self = .invalidRepositoryDescriptionException(try InvalidRepositoryDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRepositoryDescriptionOutputError: Swift.Error, Swift.Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryDescriptionException(InvalidRepositoryDescriptionException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRepositoryDescriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRepositoryDescriptionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateRepositoryNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newName
        case oldName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newName = self.newName {
            try encodeContainer.encode(newName, forKey: .newName)
        }
        if let oldName = self.oldName {
            try encodeContainer.encode(oldName, forKey: .oldName)
        }
    }
}

extension UpdateRepositoryNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of an update repository description operation.
public struct UpdateRepositoryNameInput: Swift.Equatable {
    /// The new name for the repository.
    /// This member is required.
    public var newName: Swift.String?
    /// The current name of the repository.
    /// This member is required.
    public var oldName: Swift.String?

    public init (
        newName: Swift.String? = nil,
        oldName: Swift.String? = nil
    )
    {
        self.newName = newName
        self.oldName = oldName
    }
}

struct UpdateRepositoryNameInputBody: Swift.Equatable {
    let oldName: Swift.String?
    let newName: Swift.String?
}

extension UpdateRepositoryNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newName
        case oldName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oldName)
        oldName = oldNameDecoded
        let newNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newName)
        newName = newNameDecoded
    }
}

extension UpdateRepositoryNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRepositoryNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameExistsException" : self = .repositoryNameExistsException(try RepositoryNameExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRepositoryNameOutputError: Swift.Error, Swift.Equatable {
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameExistsException(RepositoryNameExistsException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRepositoryNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRepositoryNameOutputResponse: Swift.Equatable {

    public init () { }
}

extension CodeCommitClientTypes.UserInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date
        case email
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = self.date {
            try encodeContainer.encode(date, forKey: .date)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let dateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .date)
        date = dateDecoded
    }
}

extension CodeCommitClientTypes {
    /// Information about the user who made a specified commit.
    public struct UserInfo: Swift.Equatable {
        /// The date when the specified commit was commited, in timestamp format with GMT offset.
        public var date: Swift.String?
        /// The email address associated with the user who made the commit, if any.
        public var email: Swift.String?
        /// The name of the user who made the specified commit.
        public var name: Swift.String?

        public init (
            date: Swift.String? = nil,
            email: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.date = date
            self.email = email
            self.name = name
        }
    }

}
