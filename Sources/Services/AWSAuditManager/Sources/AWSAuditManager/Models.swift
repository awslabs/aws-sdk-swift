//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// Your account isn't registered with Audit Manager. Check the delegated administrator setup on the Audit Manager settings page, and try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AuditManagerClientTypes {

    public enum AccountStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case pendingActivation
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountStatus] {
            return [
                .active,
                .inactive,
                .pendingActivation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pendingActivation: return "PENDING_ACTIVATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    public enum ActionEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case create
        case delete
        case importEvidence
        case inactive
        case reviewed
        case underReview
        case updateMetadata
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionEnum] {
            return [
                .active,
                .create,
                .delete,
                .importEvidence,
                .inactive,
                .reviewed,
                .underReview,
                .updateMetadata
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .importEvidence: return "IMPORT_EVIDENCE"
            case .inactive: return "INACTIVE"
            case .reviewed: return "REVIEWED"
            case .underReview: return "UNDER_REVIEW"
            case .updateMetadata: return "UPDATE_METADATA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The wrapper of Amazon Web Services account details, such as account ID or email address.
    public struct AWSAccount: Swift.Sendable {
        /// The email address that's associated with the Amazon Web Services account.
        public var emailAddress: Swift.String?
        /// The identifier for the Amazon Web Services account.
        public var id: Swift.String?
        /// The name of the Amazon Web Services account.
        public var name: Swift.String?

        public init(
            emailAddress: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.emailAddress = emailAddress
            self.id = id
            self.name = name
        }
    }
}

extension AuditManagerClientTypes.AWSAccount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AWSAccount(id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), emailAddress: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    /// A comment that's posted by a user on a control. This includes the author's name, the comment text, and a timestamp.
    public struct ControlComment: Swift.Sendable {
        /// The name of the user who authored the comment.
        public var authorName: Swift.String?
        /// The body text of a control comment.
        public var commentBody: Swift.String?
        /// The time when the comment was posted.
        public var postedDate: Foundation.Date?

        public init(
            authorName: Swift.String? = nil,
            commentBody: Swift.String? = nil,
            postedDate: Foundation.Date? = nil
        )
        {
            self.authorName = authorName
            self.commentBody = commentBody
            self.postedDate = postedDate
        }
    }
}

extension AuditManagerClientTypes.ControlComment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ControlComment(postedDate: \(Swift.String(describing: postedDate)), authorName: \"CONTENT_REDACTED\", commentBody: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    public enum ControlResponse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automate
        case `defer`
        case ignore
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlResponse] {
            return [
                .automate,
                .defer,
                .ignore,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automate: return "AUTOMATE"
            case .defer: return "DEFER"
            case .ignore: return "IGNORE"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    public enum ControlStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inactive
        case reviewed
        case underReview
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlStatus] {
            return [
                .inactive,
                .reviewed,
                .underReview
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inactive: return "INACTIVE"
            case .reviewed: return "REVIEWED"
            case .underReview: return "UNDER_REVIEW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The control entity that represents a standard control or a custom control in an Audit Manager assessment.
    public struct AssessmentControl: Swift.Sendable {
        /// The amount of evidence in the assessment report.
        public var assessmentReportEvidenceCount: Swift.Int
        /// The list of comments that's attached to the control.
        public var comments: [AuditManagerClientTypes.ControlComment]?
        /// The description of the control.
        public var description: Swift.String?
        /// The amount of evidence that's collected for the control.
        public var evidenceCount: Swift.Int
        /// The list of data sources for the evidence.
        public var evidenceSources: [Swift.String]?
        /// The identifier for the control.
        public var id: Swift.String?
        /// The name of the control.
        public var name: Swift.String?
        /// The response of the control.
        public var response: AuditManagerClientTypes.ControlResponse?
        /// The status of the control.
        public var status: AuditManagerClientTypes.ControlStatus?

        public init(
            assessmentReportEvidenceCount: Swift.Int = 0,
            comments: [AuditManagerClientTypes.ControlComment]? = nil,
            description: Swift.String? = nil,
            evidenceCount: Swift.Int = 0,
            evidenceSources: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            response: AuditManagerClientTypes.ControlResponse? = nil,
            status: AuditManagerClientTypes.ControlStatus? = nil
        )
        {
            self.assessmentReportEvidenceCount = assessmentReportEvidenceCount
            self.comments = comments
            self.description = description
            self.evidenceCount = evidenceCount
            self.evidenceSources = evidenceSources
            self.id = id
            self.name = name
            self.response = response
            self.status = status
        }
    }
}

extension AuditManagerClientTypes.AssessmentControl: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentControl(assessmentReportEvidenceCount: \(Swift.String(describing: assessmentReportEvidenceCount)), comments: \(Swift.String(describing: comments)), evidenceCount: \(Swift.String(describing: evidenceCount)), evidenceSources: \(Swift.String(describing: evidenceSources)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), response: \(Swift.String(describing: response)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    public enum RoleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case processOwner
        case resourceOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [RoleType] {
            return [
                .processOwner,
                .resourceOwner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .processOwner: return "PROCESS_OWNER"
            case .resourceOwner: return "RESOURCE_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    public enum DelegationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case inProgress
        case underReview
        case sdkUnknown(Swift.String)

        public static var allCases: [DelegationStatus] {
            return [
                .complete,
                .inProgress,
                .underReview
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inProgress: return "IN_PROGRESS"
            case .underReview: return "UNDER_REVIEW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The assignment of a control set to a delegate for review.
    public struct Delegation: Swift.Sendable {
        /// The identifier for the assessment that's associated with the delegation.
        public var assessmentId: Swift.String?
        /// The name of the assessment that's associated with the delegation.
        public var assessmentName: Swift.String?
        /// The comment that's related to the delegation.
        public var comment: Swift.String?
        /// The identifier for the control set that's associated with the delegation.
        public var controlSetId: Swift.String?
        /// The user or role that created the delegation.
        public var createdBy: Swift.String?
        /// Specifies when the delegation was created.
        public var creationTime: Foundation.Date?
        /// The unique identifier for the delegation.
        public var id: Swift.String?
        /// Specifies when the delegation was last updated.
        public var lastUpdated: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the IAM role.
        public var roleArn: Swift.String?
        /// The type of customer persona. In CreateAssessment, roleType can only be PROCESS_OWNER. In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public var roleType: AuditManagerClientTypes.RoleType?
        /// The status of the delegation.
        public var status: AuditManagerClientTypes.DelegationStatus?

        public init(
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            comment: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            roleArn: Swift.String? = nil,
            roleType: AuditManagerClientTypes.RoleType? = nil,
            status: AuditManagerClientTypes.DelegationStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.comment = comment
            self.controlSetId = controlSetId
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.id = id
            self.lastUpdated = lastUpdated
            self.roleArn = roleArn
            self.roleType = roleType
            self.status = status
        }
    }
}

extension AuditManagerClientTypes.Delegation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AuditManagerClientTypes {

    /// The wrapper that contains the Audit Manager role information of the current user. This includes the role type and IAM Amazon Resource Name (ARN).
    public struct Role: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the IAM role.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The type of customer persona. In CreateAssessment, roleType can only be PROCESS_OWNER. In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        /// This member is required.
        public var roleType: AuditManagerClientTypes.RoleType?

        public init(
            roleArn: Swift.String? = nil,
            roleType: AuditManagerClientTypes.RoleType? = nil
        )
        {
            self.roleArn = roleArn
            self.roleType = roleType
        }
    }
}

extension AuditManagerClientTypes {

    public enum ControlSetStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case reviewed
        case underReview
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlSetStatus] {
            return [
                .active,
                .reviewed,
                .underReview
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .reviewed: return "REVIEWED"
            case .underReview: return "UNDER_REVIEW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// Represents a set of controls in an Audit Manager assessment.
    public struct AssessmentControlSet: Swift.Sendable {
        /// The list of controls that's contained with the control set.
        public var controls: [AuditManagerClientTypes.AssessmentControl]?
        /// The delegations that are associated with the control set.
        public var delegations: [AuditManagerClientTypes.Delegation]?
        /// The description for the control set.
        public var description: Swift.String?
        /// The identifier of the control set in the assessment. This is the control set name in a plain string format.
        public var id: Swift.String?
        /// The total number of evidence objects that are uploaded manually to the control set.
        public var manualEvidenceCount: Swift.Int
        /// The roles that are associated with the control set.
        public var roles: [AuditManagerClientTypes.Role]?
        /// The current status of the control set.
        public var status: AuditManagerClientTypes.ControlSetStatus?
        /// The total number of evidence objects that are retrieved automatically for the control set.
        public var systemEvidenceCount: Swift.Int

        public init(
            controls: [AuditManagerClientTypes.AssessmentControl]? = nil,
            delegations: [AuditManagerClientTypes.Delegation]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            manualEvidenceCount: Swift.Int = 0,
            roles: [AuditManagerClientTypes.Role]? = nil,
            status: AuditManagerClientTypes.ControlSetStatus? = nil,
            systemEvidenceCount: Swift.Int = 0
        )
        {
            self.controls = controls
            self.delegations = delegations
            self.description = description
            self.id = id
            self.manualEvidenceCount = manualEvidenceCount
            self.roles = roles
            self.status = status
            self.systemEvidenceCount = systemEvidenceCount
        }
    }
}

extension AuditManagerClientTypes.AssessmentControlSet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentControlSet(controls: \(Swift.String(describing: controls)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), manualEvidenceCount: \(Swift.String(describing: manualEvidenceCount)), status: \(Swift.String(describing: status)), systemEvidenceCount: \(Swift.String(describing: systemEvidenceCount)), delegations: \"CONTENT_REDACTED\", roles: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    /// The metadata of a framework, such as the name, ID, or description.
    public struct FrameworkMetadata: Swift.Sendable {
        /// The compliance standard that's associated with the framework. For example, this could be PCI DSS or HIPAA.
        public var complianceType: Swift.String?
        /// The description of the framework.
        public var description: Swift.String?
        /// The logo that's associated with the framework.
        public var logo: Swift.String?
        /// The name of the framework.
        public var name: Swift.String?

        public init(
            complianceType: Swift.String? = nil,
            description: Swift.String? = nil,
            logo: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.complianceType = complianceType
            self.description = description
            self.logo = logo
            self.name = name
        }
    }
}

extension AuditManagerClientTypes.FrameworkMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FrameworkMetadata(description: \(Swift.String(describing: description)), logo: \(Swift.String(describing: logo)), complianceType: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    /// The file used to structure and automate Audit Manager assessments for a given compliance standard.
    public struct AssessmentFramework: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the framework.
        public var arn: Swift.String?
        /// The control sets that are associated with the framework.
        public var controlSets: [AuditManagerClientTypes.AssessmentControlSet]?
        /// The unique identifier for the framework.
        public var id: Swift.String?
        /// The metadata of a framework, such as the name, ID, or description.
        public var metadata: AuditManagerClientTypes.FrameworkMetadata?

        public init(
            arn: Swift.String? = nil,
            controlSets: [AuditManagerClientTypes.AssessmentControlSet]? = nil,
            id: Swift.String? = nil,
            metadata: AuditManagerClientTypes.FrameworkMetadata? = nil
        )
        {
            self.arn = arn
            self.controlSets = controlSets
            self.id = id
            self.metadata = metadata
        }
    }
}

extension AuditManagerClientTypes.AssessmentFramework: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AuditManagerClientTypes {

    public enum AssessmentReportDestinationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentReportDestinationType] {
            return [
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The location where Audit Manager saves assessment reports for the given assessment.
    public struct AssessmentReportsDestination: Swift.Sendable {
        /// The destination bucket where Audit Manager stores assessment reports.
        public var destination: Swift.String?
        /// The destination type, such as Amazon S3.
        public var destinationType: AuditManagerClientTypes.AssessmentReportDestinationType?

        public init(
            destination: Swift.String? = nil,
            destinationType: AuditManagerClientTypes.AssessmentReportDestinationType? = nil
        )
        {
            self.destination = destination
            self.destinationType = destinationType
        }
    }
}

extension AuditManagerClientTypes.AssessmentReportsDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AuditManagerClientTypes {

    /// An Amazon Web Service such as Amazon S3 or CloudTrail. For an example of how to find an Amazon Web Service name and how to define it in your assessment scope, see the following:
    ///
    /// * [Finding an Amazon Web Service name to use in your assessment scope](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_GetServicesInScope.html#API_GetServicesInScope_Example_2)
    ///
    /// * [Defining an Amazon Web Service name in your assessment scope](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_GetServicesInScope.html#API_GetServicesInScope_Example_3)
    public struct AWSService: Swift.Sendable {
        /// The name of the Amazon Web Service.
        public var serviceName: Swift.String?

        public init(
            serviceName: Swift.String? = nil
        )
        {
            self.serviceName = serviceName
        }
    }
}

extension AuditManagerClientTypes {

    /// The wrapper that contains the Amazon Web Services accounts that are in scope for the assessment. You no longer need to specify which Amazon Web Services are in scope when you create or update an assessment. Audit Manager infers the services in scope by examining your assessment controls and their data sources, and then mapping this information to the relevant Amazon Web Services. If an underlying data source changes for your assessment, we automatically update the services scope as needed to reflect the correct Amazon Web Services. This ensures that your assessment collects accurate and comprehensive evidence about all of the relevant services in your AWS environment.
    public struct Scope: Swift.Sendable {
        /// The Amazon Web Services accounts that are included in the scope of the assessment.
        public var awsAccounts: [AuditManagerClientTypes.AWSAccount]?
        /// The Amazon Web Services services that are included in the scope of the assessment. This API parameter is no longer supported. If you use this parameter to specify one or more Amazon Web Services, Audit Manager ignores this input. Instead, the value for awsServices will show as empty.
        @available(*, deprecated, message: "You can't specify services in scope when creating/updating an assessment. If you use the parameter to specify one or more AWS services, Audit Manager ignores the input. Instead the value of the parameter will show as empty indicating that the services are defined and managed by Audit Manager.")
        public var awsServices: [AuditManagerClientTypes.AWSService]?

        public init(
            awsAccounts: [AuditManagerClientTypes.AWSAccount]? = nil,
            awsServices: [AuditManagerClientTypes.AWSService]? = nil
        )
        {
            self.awsAccounts = awsAccounts
            self.awsServices = awsServices
        }
    }
}

extension AuditManagerClientTypes.Scope: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AuditManagerClientTypes {

    public enum AssessmentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The metadata that's associated with the specified assessment.
    public struct AssessmentMetadata: Swift.Sendable {
        /// The destination that evidence reports are stored in for the assessment.
        public var assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
        /// The name of the compliance standard that's related to the assessment, such as PCI-DSS.
        public var complianceType: Swift.String?
        /// Specifies when the assessment was created.
        public var creationTime: Foundation.Date?
        /// The delegations that are associated with the assessment.
        public var delegations: [AuditManagerClientTypes.Delegation]?
        /// The description of the assessment.
        public var description: Swift.String?
        /// The unique identifier for the assessment.
        public var id: Swift.String?
        /// The time of the most recent update.
        public var lastUpdated: Foundation.Date?
        /// The name of the assessment.
        public var name: Swift.String?
        /// The roles that are associated with the assessment.
        public var roles: [AuditManagerClientTypes.Role]?
        /// The wrapper of Amazon Web Services accounts and services that are in scope for the assessment.
        public var scope: AuditManagerClientTypes.Scope?
        /// The overall status of the assessment.
        public var status: AuditManagerClientTypes.AssessmentStatus?

        public init(
            assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
            complianceType: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            delegations: [AuditManagerClientTypes.Delegation]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            name: Swift.String? = nil,
            roles: [AuditManagerClientTypes.Role]? = nil,
            scope: AuditManagerClientTypes.Scope? = nil,
            status: AuditManagerClientTypes.AssessmentStatus? = nil
        )
        {
            self.assessmentReportsDestination = assessmentReportsDestination
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.delegations = delegations
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.roles = roles
            self.scope = scope
            self.status = status
        }
    }
}

extension AuditManagerClientTypes.AssessmentMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentMetadata(creationTime: \(Swift.String(describing: creationTime)), id: \(Swift.String(describing: id)), lastUpdated: \(Swift.String(describing: lastUpdated)), status: \(Swift.String(describing: status)), assessmentReportsDestination: \"CONTENT_REDACTED\", complianceType: \"CONTENT_REDACTED\", delegations: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", roles: \"CONTENT_REDACTED\", scope: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    /// An entity that defines the scope of audit evidence collected by Audit Manager. An Audit Manager assessment is an implementation of an Audit Manager framework.
    public struct Assessment: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the assessment.
        public var arn: Swift.String?
        /// The Amazon Web Services account that's associated with the assessment.
        public var awsAccount: AuditManagerClientTypes.AWSAccount?
        /// The framework that the assessment was created from.
        public var framework: AuditManagerClientTypes.AssessmentFramework?
        /// The metadata for the assessment.
        public var metadata: AuditManagerClientTypes.AssessmentMetadata?
        /// The tags that are associated with the assessment.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            awsAccount: AuditManagerClientTypes.AWSAccount? = nil,
            framework: AuditManagerClientTypes.AssessmentFramework? = nil,
            metadata: AuditManagerClientTypes.AssessmentMetadata? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.awsAccount = awsAccount
            self.framework = framework
            self.metadata = metadata
            self.tags = tags
        }
    }
}

extension AuditManagerClientTypes.Assessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Assessment(arn: \(Swift.String(describing: arn)), awsAccount: \(Swift.String(describing: awsAccount)), metadata: \(Swift.String(describing: metadata)), tags: \(Swift.String(describing: tags)), framework: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    /// The folder where Audit Manager stores evidence for an assessment.
    public struct AssessmentEvidenceFolder: Swift.Sendable {
        /// The identifier for the assessment.
        public var assessmentId: Swift.String?
        /// The total count of evidence that's included in the assessment report.
        public var assessmentReportSelectionCount: Swift.Int
        /// The name of the user who created the evidence folder.
        public var author: Swift.String?
        /// The unique identifier for the control.
        public var controlId: Swift.String?
        /// The name of the control.
        public var controlName: Swift.String?
        /// The identifier for the control set.
        public var controlSetId: Swift.String?
        /// The Amazon Web Service that the evidence was collected from.
        public var dataSource: Swift.String?
        /// The date when the first evidence was added to the evidence folder.
        public var date: Foundation.Date?
        /// The total number of Amazon Web Services resources that were assessed to generate the evidence.
        public var evidenceAwsServiceSourceCount: Swift.Int
        /// The number of evidence that falls under the compliance check category. This evidence is collected from Config or Security Hub.
        public var evidenceByTypeComplianceCheckCount: Swift.Int
        /// The total number of issues that were reported directly from Security Hub, Config, or both.
        public var evidenceByTypeComplianceCheckIssuesCount: Swift.Int
        /// The number of evidence that falls under the configuration data category. This evidence is collected from configuration snapshots of other Amazon Web Services such as Amazon EC2, Amazon S3, or IAM.
        public var evidenceByTypeConfigurationDataCount: Swift.Int
        /// The number of evidence that falls under the manual category. This evidence is imported manually.
        public var evidenceByTypeManualCount: Swift.Int
        /// The number of evidence that falls under the user activity category. This evidence is collected from CloudTrail logs.
        public var evidenceByTypeUserActivityCount: Swift.Int
        /// The amount of evidence that's included in the evidence folder.
        public var evidenceResourcesIncludedCount: Swift.Int
        /// The identifier for the folder that the evidence is stored in.
        public var id: Swift.String?
        /// The name of the evidence folder.
        public var name: Swift.String?
        /// The total amount of evidence in the evidence folder.
        public var totalEvidence: Swift.Int

        public init(
            assessmentId: Swift.String? = nil,
            assessmentReportSelectionCount: Swift.Int = 0,
            author: Swift.String? = nil,
            controlId: Swift.String? = nil,
            controlName: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            dataSource: Swift.String? = nil,
            date: Foundation.Date? = nil,
            evidenceAwsServiceSourceCount: Swift.Int = 0,
            evidenceByTypeComplianceCheckCount: Swift.Int = 0,
            evidenceByTypeComplianceCheckIssuesCount: Swift.Int = 0,
            evidenceByTypeConfigurationDataCount: Swift.Int = 0,
            evidenceByTypeManualCount: Swift.Int = 0,
            evidenceByTypeUserActivityCount: Swift.Int = 0,
            evidenceResourcesIncludedCount: Swift.Int = 0,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            totalEvidence: Swift.Int = 0
        )
        {
            self.assessmentId = assessmentId
            self.assessmentReportSelectionCount = assessmentReportSelectionCount
            self.author = author
            self.controlId = controlId
            self.controlName = controlName
            self.controlSetId = controlSetId
            self.dataSource = dataSource
            self.date = date
            self.evidenceAwsServiceSourceCount = evidenceAwsServiceSourceCount
            self.evidenceByTypeComplianceCheckCount = evidenceByTypeComplianceCheckCount
            self.evidenceByTypeComplianceCheckIssuesCount = evidenceByTypeComplianceCheckIssuesCount
            self.evidenceByTypeConfigurationDataCount = evidenceByTypeConfigurationDataCount
            self.evidenceByTypeManualCount = evidenceByTypeManualCount
            self.evidenceByTypeUserActivityCount = evidenceByTypeUserActivityCount
            self.evidenceResourcesIncludedCount = evidenceResourcesIncludedCount
            self.id = id
            self.name = name
            self.totalEvidence = totalEvidence
        }
    }
}

extension AuditManagerClientTypes {

    public enum FrameworkType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [FrameworkType] {
            return [
                .custom,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The metadata that's associated with a standard framework or a custom framework.
    public struct AssessmentFrameworkMetadata: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the framework.
        public var arn: Swift.String?
        /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public var complianceType: Swift.String?
        /// The number of control sets that are associated with the framework.
        public var controlSetsCount: Swift.Int
        /// The number of controls that are associated with the framework.
        public var controlsCount: Swift.Int
        /// The time when the framework was created.
        public var createdAt: Foundation.Date?
        /// The description of the framework.
        public var description: Swift.String?
        /// The unique identifier for the framework.
        public var id: Swift.String?
        /// The time when the framework was most recently updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The logo that's associated with the framework.
        public var logo: Swift.String?
        /// The name of the framework.
        public var name: Swift.String?
        /// The framework type, such as a standard framework or a custom framework.
        public var type: AuditManagerClientTypes.FrameworkType?

        public init(
            arn: Swift.String? = nil,
            complianceType: Swift.String? = nil,
            controlSetsCount: Swift.Int = 0,
            controlsCount: Swift.Int = 0,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            logo: Swift.String? = nil,
            name: Swift.String? = nil,
            type: AuditManagerClientTypes.FrameworkType? = nil
        )
        {
            self.arn = arn
            self.complianceType = complianceType
            self.controlSetsCount = controlSetsCount
            self.controlsCount = controlsCount
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.logo = logo
            self.name = name
            self.type = type
        }
    }
}

extension AuditManagerClientTypes.AssessmentFrameworkMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentFrameworkMetadata(arn: \(Swift.String(describing: arn)), controlSetsCount: \(Swift.String(describing: controlSetsCount)), controlsCount: \(Swift.String(describing: controlsCount)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), logo: \(Swift.String(describing: logo)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)), complianceType: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    public enum ShareRequestStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case declined
        case expired
        case expiring
        case failed
        case replicating
        case revoked
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareRequestStatus] {
            return [
                .active,
                .declined,
                .expired,
                .expiring,
                .failed,
                .replicating,
                .revoked,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .declined: return "DECLINED"
            case .expired: return "EXPIRED"
            case .expiring: return "EXPIRING"
            case .failed: return "FAILED"
            case .replicating: return "REPLICATING"
            case .revoked: return "REVOKED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// Represents a share request for a custom framework in Audit Manager.
    public struct AssessmentFrameworkShareRequest: Swift.Sendable {
        /// An optional comment from the sender about the share request.
        public var comment: Swift.String?
        /// The compliance type that the shared custom framework supports, such as CIS or HIPAA.
        public var complianceType: Swift.String?
        /// The time when the share request was created.
        public var creationTime: Foundation.Date?
        /// The number of custom controls that are part of the shared custom framework.
        public var customControlsCount: Swift.Int?
        /// The Amazon Web Services account of the recipient.
        public var destinationAccount: Swift.String?
        /// The Amazon Web Services Region of the recipient.
        public var destinationRegion: Swift.String?
        /// The time when the share request expires.
        public var expirationTime: Foundation.Date?
        /// The description of the shared custom framework.
        public var frameworkDescription: Swift.String?
        /// The unique identifier for the shared custom framework.
        public var frameworkId: Swift.String?
        /// The name of the custom framework that the share request is for.
        public var frameworkName: Swift.String?
        /// The unique identifier for the share request.
        public var id: Swift.String?
        /// Specifies when the share request was last updated.
        public var lastUpdated: Foundation.Date?
        /// The Amazon Web Services account of the sender.
        public var sourceAccount: Swift.String?
        /// The number of standard controls that are part of the shared custom framework.
        public var standardControlsCount: Swift.Int?
        /// The status of the share request.
        public var status: AuditManagerClientTypes.ShareRequestStatus?

        public init(
            comment: Swift.String? = nil,
            complianceType: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            customControlsCount: Swift.Int? = nil,
            destinationAccount: Swift.String? = nil,
            destinationRegion: Swift.String? = nil,
            expirationTime: Foundation.Date? = nil,
            frameworkDescription: Swift.String? = nil,
            frameworkId: Swift.String? = nil,
            frameworkName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            sourceAccount: Swift.String? = nil,
            standardControlsCount: Swift.Int? = nil,
            status: AuditManagerClientTypes.ShareRequestStatus? = nil
        )
        {
            self.comment = comment
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.customControlsCount = customControlsCount
            self.destinationAccount = destinationAccount
            self.destinationRegion = destinationRegion
            self.expirationTime = expirationTime
            self.frameworkDescription = frameworkDescription
            self.frameworkId = frameworkId
            self.frameworkName = frameworkName
            self.id = id
            self.lastUpdated = lastUpdated
            self.sourceAccount = sourceAccount
            self.standardControlsCount = standardControlsCount
            self.status = status
        }
    }
}

extension AuditManagerClientTypes.AssessmentFrameworkShareRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentFrameworkShareRequest(comment: \(Swift.String(describing: comment)), creationTime: \(Swift.String(describing: creationTime)), customControlsCount: \(Swift.String(describing: customControlsCount)), destinationAccount: \(Swift.String(describing: destinationAccount)), destinationRegion: \(Swift.String(describing: destinationRegion)), expirationTime: \(Swift.String(describing: expirationTime)), frameworkDescription: \(Swift.String(describing: frameworkDescription)), frameworkId: \(Swift.String(describing: frameworkId)), frameworkName: \(Swift.String(describing: frameworkName)), id: \(Swift.String(describing: id)), lastUpdated: \(Swift.String(describing: lastUpdated)), sourceAccount: \(Swift.String(describing: sourceAccount)), standardControlsCount: \(Swift.String(describing: standardControlsCount)), status: \(Swift.String(describing: status)), complianceType: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    /// A metadata object that's associated with an assessment in Audit Manager.
    public struct AssessmentMetadataItem: Swift.Sendable {
        /// The name of the compliance standard that's related to the assessment, such as PCI-DSS.
        public var complianceType: Swift.String?
        /// Specifies when the assessment was created.
        public var creationTime: Foundation.Date?
        /// The delegations that are associated with the assessment.
        public var delegations: [AuditManagerClientTypes.Delegation]?
        /// The unique identifier for the assessment.
        public var id: Swift.String?
        /// The time of the most recent update.
        public var lastUpdated: Foundation.Date?
        /// The name of the assessment.
        public var name: Swift.String?
        /// The roles that are associated with the assessment.
        public var roles: [AuditManagerClientTypes.Role]?
        /// The current status of the assessment.
        public var status: AuditManagerClientTypes.AssessmentStatus?

        public init(
            complianceType: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            delegations: [AuditManagerClientTypes.Delegation]? = nil,
            id: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            name: Swift.String? = nil,
            roles: [AuditManagerClientTypes.Role]? = nil,
            status: AuditManagerClientTypes.AssessmentStatus? = nil
        )
        {
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.delegations = delegations
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.roles = roles
            self.status = status
        }
    }
}

extension AuditManagerClientTypes.AssessmentMetadataItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentMetadataItem(creationTime: \(Swift.String(describing: creationTime)), id: \(Swift.String(describing: id)), lastUpdated: \(Swift.String(describing: lastUpdated)), status: \(Swift.String(describing: status)), complianceType: \"CONTENT_REDACTED\", delegations: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", roles: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    public enum AssessmentReportStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentReportStatus] {
            return [
                .complete,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// A finalized document that's generated from an Audit Manager assessment. These reports summarize the relevant evidence that was collected for your audit, and link to the relevant evidence folders. These evidence folders are named and organized according to the controls that are specified in your assessment.
    public struct AssessmentReport: Swift.Sendable {
        /// The identifier for the specified assessment.
        public var assessmentId: Swift.String?
        /// The name of the associated assessment.
        public var assessmentName: Swift.String?
        /// The name of the user who created the assessment report.
        public var author: Swift.String?
        /// The identifier for the specified Amazon Web Services account.
        public var awsAccountId: Swift.String?
        /// Specifies when the assessment report was created.
        public var creationTime: Foundation.Date?
        /// The description of the specified assessment report.
        public var description: Swift.String?
        /// The unique identifier for the assessment report.
        public var id: Swift.String?
        /// The name that's given to the assessment report.
        public var name: Swift.String?
        /// The current status of the specified assessment report.
        public var status: AuditManagerClientTypes.AssessmentReportStatus?

        public init(
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            author: Swift.String? = nil,
            awsAccountId: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: AuditManagerClientTypes.AssessmentReportStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.author = author
            self.awsAccountId = awsAccountId
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

extension AuditManagerClientTypes.AssessmentReport: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentReport(assessmentId: \(Swift.String(describing: assessmentId)), awsAccountId: \(Swift.String(describing: awsAccountId)), creationTime: \(Swift.String(describing: creationTime)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), assessmentName: \"CONTENT_REDACTED\", author: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    /// An error entity for assessment report evidence errors. This is used to provide more meaningful errors than a simple string message.
    public struct AssessmentReportEvidenceError: Swift.Sendable {
        /// The error code that was returned.
        public var errorCode: Swift.String?
        /// The error message that was returned.
        public var errorMessage: Swift.String?
        /// The identifier for the evidence.
        public var evidenceId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            evidenceId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.evidenceId = evidenceId
        }
    }
}

extension AuditManagerClientTypes {

    /// The metadata objects that are associated with the specified assessment report.
    public struct AssessmentReportMetadata: Swift.Sendable {
        /// The unique identifier for the associated assessment.
        public var assessmentId: Swift.String?
        /// The name of the associated assessment.
        public var assessmentName: Swift.String?
        /// The name of the user who created the assessment report.
        public var author: Swift.String?
        /// Specifies when the assessment report was created.
        public var creationTime: Foundation.Date?
        /// The description of the assessment report.
        public var description: Swift.String?
        /// The unique identifier for the assessment report.
        public var id: Swift.String?
        /// The name of the assessment report.
        public var name: Swift.String?
        /// The current status of the assessment report.
        public var status: AuditManagerClientTypes.AssessmentReportStatus?

        public init(
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            author: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: AuditManagerClientTypes.AssessmentReportStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

extension AuditManagerClientTypes.AssessmentReportMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentReportMetadata(assessmentId: \(Swift.String(describing: assessmentId)), creationTime: \(Swift.String(describing: creationTime)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), assessmentName: \"CONTENT_REDACTED\", author: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

/// An internal service error occurred during the processing of your request. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource that's specified in the request can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that's affected by the error.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension AuditManagerClientTypes {

    /// Indicates that the request has invalid or missing parameters for the field.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The body of the error message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation error.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension AuditManagerClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that caused the error, if applicable.
        public internal(set) var fields: [AuditManagerClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the request failed validation.
        public internal(set) var reason: AuditManagerClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [AuditManagerClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AuditManagerClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateAssessmentReportEvidenceFolderInput: Swift.Sendable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
    }
}

public struct AssociateAssessmentReportEvidenceFolderOutput: Swift.Sendable {

    public init() { }
}

public struct BatchAssociateAssessmentReportEvidenceInput: Swift.Sendable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// The list of evidence identifiers.
    /// This member is required.
    public var evidenceIds: [Swift.String]?

    public init(
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceIds = evidenceIds
    }
}

public struct BatchAssociateAssessmentReportEvidenceOutput: Swift.Sendable {
    /// A list of errors that the BatchAssociateAssessmentReportEvidence API returned.
    public var errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]?
    /// The list of evidence identifiers.
    public var evidenceIds: [Swift.String]?

    public init(
        errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.evidenceIds = evidenceIds
    }
}

extension AuditManagerClientTypes {

    /// A collection of attributes that's used to create a delegation for an assessment in Audit Manager.
    public struct CreateDelegationRequest: Swift.Sendable {
        /// A comment that's related to the delegation request.
        public var comment: Swift.String?
        /// The unique identifier for the control set.
        public var controlSetId: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role.
        public var roleArn: Swift.String?
        /// The type of customer persona. In CreateAssessment, roleType can only be PROCESS_OWNER. In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public var roleType: AuditManagerClientTypes.RoleType?

        public init(
            comment: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            roleType: AuditManagerClientTypes.RoleType? = nil
        )
        {
            self.comment = comment
            self.controlSetId = controlSetId
            self.roleArn = roleArn
            self.roleType = roleType
        }
    }
}

extension AuditManagerClientTypes.CreateDelegationRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDelegationRequest(controlSetId: \(Swift.String(describing: controlSetId)), roleArn: \(Swift.String(describing: roleArn)), roleType: \(Swift.String(describing: roleType)), comment: \"CONTENT_REDACTED\")"}
}

public struct BatchCreateDelegationByAssessmentInput: Swift.Sendable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The API request to batch create delegations in Audit Manager.
    /// This member is required.
    public var createDelegationRequests: [AuditManagerClientTypes.CreateDelegationRequest]?

    public init(
        assessmentId: Swift.String? = nil,
        createDelegationRequests: [AuditManagerClientTypes.CreateDelegationRequest]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.createDelegationRequests = createDelegationRequests
    }
}

extension BatchCreateDelegationByAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateDelegationByAssessmentInput(assessmentId: \(Swift.String(describing: assessmentId)), createDelegationRequests: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    /// An error entity for the BatchCreateDelegationByAssessment API. This is used to provide more meaningful errors than a simple string message.
    public struct BatchCreateDelegationByAssessmentError: Swift.Sendable {
        /// The API request to batch create delegations in Audit Manager.
        public var createDelegationRequest: AuditManagerClientTypes.CreateDelegationRequest?
        /// The error code that the BatchCreateDelegationByAssessment API returned.
        public var errorCode: Swift.String?
        /// The error message that the BatchCreateDelegationByAssessment API returned.
        public var errorMessage: Swift.String?

        public init(
            createDelegationRequest: AuditManagerClientTypes.CreateDelegationRequest? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.createDelegationRequest = createDelegationRequest
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

public struct BatchCreateDelegationByAssessmentOutput: Swift.Sendable {
    /// The delegations that are associated with the assessment.
    public var delegations: [AuditManagerClientTypes.Delegation]?
    /// A list of errors that the BatchCreateDelegationByAssessment API returned.
    public var errors: [AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]?

    public init(
        delegations: [AuditManagerClientTypes.Delegation]? = nil,
        errors: [AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]? = nil
    )
    {
        self.delegations = delegations
        self.errors = errors
    }
}

extension BatchCreateDelegationByAssessmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateDelegationByAssessmentOutput(delegations: \"CONTENT_REDACTED\", errors: \"CONTENT_REDACTED\")"}
}

public struct BatchDeleteDelegationByAssessmentInput: Swift.Sendable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifiers for the delegations.
    /// This member is required.
    public var delegationIds: [Swift.String]?

    public init(
        assessmentId: Swift.String? = nil,
        delegationIds: [Swift.String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.delegationIds = delegationIds
    }
}

extension AuditManagerClientTypes {

    /// An error entity for the BatchDeleteDelegationByAssessment API. This is used to provide more meaningful errors than a simple string message.
    public struct BatchDeleteDelegationByAssessmentError: Swift.Sendable {
        /// The identifier for the delegation.
        public var delegationId: Swift.String?
        /// The error code that the BatchDeleteDelegationByAssessment API returned.
        public var errorCode: Swift.String?
        /// The error message that the BatchDeleteDelegationByAssessment API returned.
        public var errorMessage: Swift.String?

        public init(
            delegationId: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.delegationId = delegationId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

public struct BatchDeleteDelegationByAssessmentOutput: Swift.Sendable {
    /// A list of errors that the BatchDeleteDelegationByAssessment API returned.
    public var errors: [AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]?

    public init(
        errors: [AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]? = nil
    )
    {
        self.errors = errors
    }
}

extension BatchDeleteDelegationByAssessmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteDelegationByAssessmentOutput(errors: \"CONTENT_REDACTED\")"}
}

public struct BatchDisassociateAssessmentReportEvidenceInput: Swift.Sendable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// The list of evidence identifiers.
    /// This member is required.
    public var evidenceIds: [Swift.String]?

    public init(
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceIds = evidenceIds
    }
}

public struct BatchDisassociateAssessmentReportEvidenceOutput: Swift.Sendable {
    /// A list of errors that the BatchDisassociateAssessmentReportEvidence API returned.
    public var errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]?
    /// The identifier for the evidence.
    public var evidenceIds: [Swift.String]?

    public init(
        errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.evidenceIds = evidenceIds
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AuditManagerClientTypes {

    /// Evidence that's manually added to a control in Audit Manager. manualEvidence can be one of the following: evidenceFileName, s3ResourcePath, or textResponse.
    public struct ManualEvidence: Swift.Sendable {
        /// The name of the file that's uploaded as manual evidence. This name is populated using the evidenceFileName value from the [GetEvidenceFileUploadUrl](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_GetEvidenceFileUploadUrl.html) API response.
        public var evidenceFileName: Swift.String?
        /// The S3 URL of the object that's imported as manual evidence.
        public var s3ResourcePath: Swift.String?
        /// The plain text response that's entered and saved as manual evidence.
        public var textResponse: Swift.String?

        public init(
            evidenceFileName: Swift.String? = nil,
            s3ResourcePath: Swift.String? = nil,
            textResponse: Swift.String? = nil
        )
        {
            self.evidenceFileName = evidenceFileName
            self.s3ResourcePath = s3ResourcePath
            self.textResponse = textResponse
        }
    }
}

extension AuditManagerClientTypes.ManualEvidence: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ManualEvidence(s3ResourcePath: \(Swift.String(describing: s3ResourcePath)), evidenceFileName: \"CONTENT_REDACTED\", textResponse: \"CONTENT_REDACTED\")"}
}

public struct BatchImportEvidenceToAssessmentControlInput: Swift.Sendable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The list of manual evidence objects.
    /// This member is required.
    public var manualEvidence: [AuditManagerClientTypes.ManualEvidence]?

    public init(
        assessmentId: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        manualEvidence: [AuditManagerClientTypes.ManualEvidence]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.manualEvidence = manualEvidence
    }
}

extension AuditManagerClientTypes {

    /// An error entity for the BatchImportEvidenceToAssessmentControl API. This is used to provide more meaningful errors than a simple string message.
    public struct BatchImportEvidenceToAssessmentControlError: Swift.Sendable {
        /// The error code that the BatchImportEvidenceToAssessmentControl API returned.
        public var errorCode: Swift.String?
        /// The error message that the BatchImportEvidenceToAssessmentControl API returned.
        public var errorMessage: Swift.String?
        /// Manual evidence that can't be collected automatically by Audit Manager.
        public var manualEvidence: AuditManagerClientTypes.ManualEvidence?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            manualEvidence: AuditManagerClientTypes.ManualEvidence? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.manualEvidence = manualEvidence
        }
    }
}

public struct BatchImportEvidenceToAssessmentControlOutput: Swift.Sendable {
    /// A list of errors that the BatchImportEvidenceToAssessmentControl API returned.
    public var errors: [AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]?

    public init(
        errors: [AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]? = nil
    )
    {
        self.errors = errors
    }
}

/// You've reached your account quota for this resource type. To perform the requested action, delete some existing resources or [request a quota increase](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) from the Service Quotas console. For a list of Audit Manager service quotas, see [Quotas and restrictions for Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/service-quotas.html).
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateAssessmentInput: Swift.Sendable {
    /// The assessment report storage destination for the assessment that's being created.
    /// This member is required.
    public var assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    /// The optional description of the assessment to be created.
    public var description: Swift.String?
    /// The identifier for the framework that the assessment will be created from.
    /// This member is required.
    public var frameworkId: Swift.String?
    /// The name of the assessment to be created.
    /// This member is required.
    public var name: Swift.String?
    /// The list of roles for the assessment.
    /// This member is required.
    public var roles: [AuditManagerClientTypes.Role]?
    /// The wrapper that contains the Amazon Web Services accounts that are in scope for the assessment. You no longer need to specify which Amazon Web Services are in scope when you create or update an assessment. Audit Manager infers the services in scope by examining your assessment controls and their data sources, and then mapping this information to the relevant Amazon Web Services. If an underlying data source changes for your assessment, we automatically update the services scope as needed to reflect the correct Amazon Web Services. This ensures that your assessment collects accurate and comprehensive evidence about all of the relevant services in your AWS environment.
    /// This member is required.
    public var scope: AuditManagerClientTypes.Scope?
    /// The tags that are associated with the assessment.
    public var tags: [Swift.String: Swift.String]?

    public init(
        assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
        description: Swift.String? = nil,
        frameworkId: Swift.String? = nil,
        name: Swift.String? = nil,
        roles: [AuditManagerClientTypes.Role]? = nil,
        scope: AuditManagerClientTypes.Scope? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.assessmentReportsDestination = assessmentReportsDestination
        self.description = description
        self.frameworkId = frameworkId
        self.name = name
        self.roles = roles
        self.scope = scope
        self.tags = tags
    }
}

extension CreateAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssessmentInput(frameworkId: \(Swift.String(describing: frameworkId)), tags: \(Swift.String(describing: tags)), assessmentReportsDestination: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", roles: \"CONTENT_REDACTED\", scope: \"CONTENT_REDACTED\")"}
}

public struct CreateAssessmentOutput: Swift.Sendable {
    /// An entity that defines the scope of audit evidence collected by Audit Manager. An Audit Manager assessment is an implementation of an Audit Manager framework.
    public var assessment: AuditManagerClientTypes.Assessment?

    public init(
        assessment: AuditManagerClientTypes.Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

extension AuditManagerClientTypes {

    /// The control entity attributes that uniquely identify an existing control to be added to a framework in Audit Manager.
    public struct CreateAssessmentFrameworkControl: Swift.Sendable {
        /// The unique identifier of the control.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

extension AuditManagerClientTypes {

    /// A controlSet entity that represents a collection of controls in Audit Manager. This doesn't contain the control set ID.
    public struct CreateAssessmentFrameworkControlSet: Swift.Sendable {
        /// The list of controls within the control set. This doesn't contain the control set ID.
        public var controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]?
        /// The name of the control set.
        /// This member is required.
        public var name: Swift.String?

        public init(
            controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]? = nil,
            name: Swift.String? = nil
        )
        {
            self.controls = controls
            self.name = name
        }
    }
}

public struct CreateAssessmentFrameworkInput: Swift.Sendable {
    /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
    public var complianceType: Swift.String?
    /// The control sets that are associated with the framework.
    /// This member is required.
    public var controlSets: [AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]?
    /// An optional description for the new custom framework.
    public var description: Swift.String?
    /// The name of the new custom framework.
    /// This member is required.
    public var name: Swift.String?
    /// The tags that are associated with the framework.
    public var tags: [Swift.String: Swift.String]?

    public init(
        complianceType: Swift.String? = nil,
        controlSets: [AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.complianceType = complianceType
        self.controlSets = controlSets
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension CreateAssessmentFrameworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssessmentFrameworkInput(controlSets: \(Swift.String(describing: controlSets)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), complianceType: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    public enum SourceFrequency: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daily
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceFrequency] {
            return [
                .daily,
                .monthly,
                .weekly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    public enum KeywordInputType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inputText
        case selectFromList
        case uploadFile
        case sdkUnknown(Swift.String)

        public static var allCases: [KeywordInputType] {
            return [
                .inputText,
                .selectFromList,
                .uploadFile
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inputText: return "INPUT_TEXT"
            case .selectFromList: return "SELECT_FROM_LIST"
            case .uploadFile: return "UPLOAD_FILE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// A keyword that relates to the control data source. For manual evidence, this keyword indicates if the manual evidence is a file or text. For automated evidence, this keyword identifies a specific CloudTrail event, Config rule, Security Hub control, or Amazon Web Services API name. To learn more about the supported keywords that you can use when mapping a control data source, see the following pages in the Audit Manager User Guide:
    ///
    /// * [Config rules supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html)
    ///
    /// * [Security Hub controls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html)
    ///
    /// * [API calls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html)
    ///
    /// * [CloudTrail event names supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-cloudtrail.html)
    public struct SourceKeyword: Swift.Sendable {
        /// The input method for the keyword.
        ///
        /// * SELECT_FROM_LIST is used when mapping a data source for automated evidence.
        ///
        /// * When keywordInputType is SELECT_FROM_LIST, a keyword must be selected to collect automated evidence. For example, this keyword can be a CloudTrail event name, a rule name for Config, a Security Hub control, or the name of an Amazon Web Services API call.
        ///
        ///
        ///
        ///
        /// * UPLOAD_FILE and INPUT_TEXT are only used when mapping a data source for manual evidence.
        ///
        /// * When keywordInputType is UPLOAD_FILE, a file must be uploaded as manual evidence.
        ///
        /// * When keywordInputType is INPUT_TEXT, text must be entered as manual evidence.
        public var keywordInputType: AuditManagerClientTypes.KeywordInputType?
        /// The value of the keyword that's used when mapping a control data source. For example, this can be a CloudTrail event name, a rule name for Config, a Security Hub control, or the name of an Amazon Web Services API call. If you’re mapping a data source to a rule in Config, the keywordValue that you specify depends on the type of rule:
        ///
        /// * For [managed rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html), you can use the rule identifier as the keywordValue. You can find the rule identifier from the [list of Config managed rules](https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html). For some rules, the rule identifier is different from the rule name. For example, the rule name restricted-ssh has the following rule identifier: INCOMING_SSH_DISABLED. Make sure to use the rule identifier, not the rule name. Keyword example for managed rules:
        ///
        /// * Managed rule name: [s3-bucket-acl-prohibited](https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-acl-prohibited.html)keywordValue: S3_BUCKET_ACL_PROHIBITED
        ///
        ///
        ///
        ///
        /// * For [custom rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html), you form the keywordValue by adding the Custom_ prefix to the rule name. This prefix distinguishes the custom rule from a managed rule. Keyword example for custom rules:
        ///
        /// * Custom rule name: my-custom-config-rule keywordValue: Custom_my-custom-config-rule
        ///
        ///
        ///
        ///
        /// * For [service-linked rules](https://docs.aws.amazon.com/config/latest/developerguide/service-linked-awsconfig-rules.html), you form the keywordValue by adding the Custom_ prefix to the rule name. In addition, you remove the suffix ID that appears at the end of the rule name. Keyword examples for service-linked rules:
        ///
        /// * Service-linked rule name: CustomRuleForAccount-conformance-pack-szsm1uv0w keywordValue: Custom_CustomRuleForAccount-conformance-pack
        ///
        /// * Service-linked rule name: OrgConfigRule-s3-bucket-versioning-enabled-dbgzf8ba keywordValue: Custom_OrgConfigRule-s3-bucket-versioning-enabled
        ///
        ///
        ///
        ///
        ///
        /// The keywordValue is case sensitive. If you enter a value incorrectly, Audit Manager might not recognize the data source mapping. As a result, you might not successfully collect evidence from that data source as intended. Keep in mind the following requirements, depending on the data source type that you're using.
        ///
        /// * For Config:
        ///
        /// * For managed rules, make sure that the keywordValue is the rule identifier in ALL_CAPS_WITH_UNDERSCORES. For example, CLOUDWATCH_LOG_GROUP_ENCRYPTED. For accuracy, we recommend that you reference the list of [supported Config managed rules](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html).
        ///
        /// * For custom rules, make sure that the keywordValue has the Custom_ prefix followed by the custom rule name. The format of the custom rule name itself may vary. For accuracy, we recommend that you visit the [Config console](https://console.aws.amazon.com/config/) to verify your custom rule name.
        ///
        ///
        ///
        ///
        /// * For Security Hub: The format varies for Security Hub control names. For accuracy, we recommend that you reference the list of [supported Security Hub controls](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html).
        ///
        /// * For Amazon Web Services API calls: Make sure that the keywordValue is written as serviceprefix_ActionName. For example, iam_ListGroups. For accuracy, we recommend that you reference the list of [supported API calls](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html).
        ///
        /// * For CloudTrail: Make sure that the keywordValue is written as serviceprefix_ActionName. For example, cloudtrail_StartLogging. For accuracy, we recommend that you review the Amazon Web Service prefix and action names in the [Service Authorization Reference](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html).
        public var keywordValue: Swift.String?

        public init(
            keywordInputType: AuditManagerClientTypes.KeywordInputType? = nil,
            keywordValue: Swift.String? = nil
        )
        {
            self.keywordInputType = keywordInputType
            self.keywordValue = keywordValue
        }
    }
}

extension AuditManagerClientTypes {

    public enum SourceSetUpOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case proceduralControlsMapping
        case systemControlsMapping
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceSetUpOption] {
            return [
                .proceduralControlsMapping,
                .systemControlsMapping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .proceduralControlsMapping: return "Procedural_Controls_Mapping"
            case .systemControlsMapping: return "System_Controls_Mapping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    public enum SourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsApiCall
        case awsCloudtrail
        case awsConfig
        case awsSecurityHub
        case commonControl
        case coreControl
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .awsApiCall,
                .awsCloudtrail,
                .awsConfig,
                .awsSecurityHub,
                .commonControl,
                .coreControl,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsApiCall: return "AWS_API_Call"
            case .awsCloudtrail: return "AWS_Cloudtrail"
            case .awsConfig: return "AWS_Config"
            case .awsSecurityHub: return "AWS_Security_Hub"
            case .commonControl: return "Common_Control"
            case .coreControl: return "Core_Control"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The data source that determines where Audit Manager collects evidence from for the control.
    public struct ControlMappingSource: Swift.Sendable {
        /// The description of the source.
        public var sourceDescription: Swift.String?
        /// Specifies how often evidence is collected from the control mapping source.
        public var sourceFrequency: AuditManagerClientTypes.SourceFrequency?
        /// The unique identifier for the source.
        public var sourceId: Swift.String?
        /// A keyword that relates to the control data source. For manual evidence, this keyword indicates if the manual evidence is a file or text. For automated evidence, this keyword identifies a specific CloudTrail event, Config rule, Security Hub control, or Amazon Web Services API name. To learn more about the supported keywords that you can use when mapping a control data source, see the following pages in the Audit Manager User Guide:
        ///
        /// * [Config rules supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html)
        ///
        /// * [Security Hub controls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html)
        ///
        /// * [API calls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html)
        ///
        /// * [CloudTrail event names supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-cloudtrail.html)
        public var sourceKeyword: AuditManagerClientTypes.SourceKeyword?
        /// The name of the source.
        public var sourceName: Swift.String?
        /// The setup option for the data source. This option reflects if the evidence collection method is automated or manual. If you don’t provide a value for sourceSetUpOption, Audit Manager automatically infers and populates the correct value based on the sourceType that you specify.
        public var sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption?
        /// Specifies which type of data source is used to collect evidence.
        ///
        /// * The source can be an individual data source type, such as AWS_Cloudtrail, AWS_Config, AWS_Security_Hub, AWS_API_Call, or MANUAL.
        ///
        /// * The source can also be a managed grouping of data sources, such as a Core_Control or a Common_Control.
        public var sourceType: AuditManagerClientTypes.SourceType?
        /// The instructions for troubleshooting the control.
        public var troubleshootingText: Swift.String?

        public init(
            sourceDescription: Swift.String? = nil,
            sourceFrequency: AuditManagerClientTypes.SourceFrequency? = nil,
            sourceId: Swift.String? = nil,
            sourceKeyword: AuditManagerClientTypes.SourceKeyword? = nil,
            sourceName: Swift.String? = nil,
            sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption? = nil,
            sourceType: AuditManagerClientTypes.SourceType? = nil,
            troubleshootingText: Swift.String? = nil
        )
        {
            self.sourceDescription = sourceDescription
            self.sourceFrequency = sourceFrequency
            self.sourceId = sourceId
            self.sourceKeyword = sourceKeyword
            self.sourceName = sourceName
            self.sourceSetUpOption = sourceSetUpOption
            self.sourceType = sourceType
            self.troubleshootingText = troubleshootingText
        }
    }
}

extension AuditManagerClientTypes.ControlMappingSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ControlMappingSource(sourceDescription: \(Swift.String(describing: sourceDescription)), sourceFrequency: \(Swift.String(describing: sourceFrequency)), sourceId: \(Swift.String(describing: sourceId)), sourceKeyword: \(Swift.String(describing: sourceKeyword)), sourceName: \(Swift.String(describing: sourceName)), sourceSetUpOption: \(Swift.String(describing: sourceSetUpOption)), sourceType: \(Swift.String(describing: sourceType)), troubleshootingText: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    public enum ControlState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case endOfSupport
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlState] {
            return [
                .active,
                .endOfSupport
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .endOfSupport: return "END_OF_SUPPORT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    public enum ControlType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case core
        case custom
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlType] {
            return [
                .core,
                .custom,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .core: return "Core"
            case .custom: return "Custom"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// A control in Audit Manager.
    public struct Control: Swift.Sendable {
        /// The recommended actions to carry out if the control isn't fulfilled.
        public var actionPlanInstructions: Swift.String?
        /// The title of the action plan for remediating the control.
        public var actionPlanTitle: Swift.String?
        /// The Amazon Resource Name (ARN) of the control.
        public var arn: Swift.String?
        /// The data mapping sources for the control.
        public var controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]?
        /// The data source types that determine where Audit Manager collects evidence from for the control.
        public var controlSources: Swift.String?
        /// The time when the control was created.
        public var createdAt: Foundation.Date?
        /// The user or role that created the control.
        public var createdBy: Swift.String?
        /// The description of the control.
        public var description: Swift.String?
        /// The unique identifier for the control.
        public var id: Swift.String?
        /// The time when the control was most recently updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The user or role that most recently updated the control.
        public var lastUpdatedBy: Swift.String?
        /// The name of the control.
        public var name: Swift.String?
        /// The state of the control. The END_OF_SUPPORT state is applicable to standard controls only. This state indicates that the standard control can still be used to collect evidence, but Audit Manager is no longer updating or maintaining that control.
        public var state: AuditManagerClientTypes.ControlState?
        /// The tags associated with the control.
        public var tags: [Swift.String: Swift.String]?
        /// The steps that you should follow to determine if the control has been satisfied.
        public var testingInformation: Swift.String?
        /// Specifies whether the control is a standard control or a custom control.
        public var type: AuditManagerClientTypes.ControlType?

        public init(
            actionPlanInstructions: Swift.String? = nil,
            actionPlanTitle: Swift.String? = nil,
            arn: Swift.String? = nil,
            controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]? = nil,
            controlSources: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            name: Swift.String? = nil,
            state: AuditManagerClientTypes.ControlState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            testingInformation: Swift.String? = nil,
            type: AuditManagerClientTypes.ControlType? = nil
        )
        {
            self.actionPlanInstructions = actionPlanInstructions
            self.actionPlanTitle = actionPlanTitle
            self.arn = arn
            self.controlMappingSources = controlMappingSources
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.state = state
            self.tags = tags
            self.testingInformation = testingInformation
            self.type = type
        }
    }
}

extension AuditManagerClientTypes.Control: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Control(arn: \(Swift.String(describing: arn)), controlMappingSources: \(Swift.String(describing: controlMappingSources)), controlSources: \(Swift.String(describing: controlSources)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), actionPlanInstructions: \"CONTENT_REDACTED\", actionPlanTitle: \"CONTENT_REDACTED\", createdBy: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", lastUpdatedBy: \"CONTENT_REDACTED\", testingInformation: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {

    /// A set of controls in Audit Manager.
    public struct ControlSet: Swift.Sendable {
        /// The list of controls within the control set.
        public var controls: [AuditManagerClientTypes.Control]?
        /// The identifier of the control set in the assessment. This is the control set name in a plain string format.
        public var id: Swift.String?
        /// The name of the control set.
        public var name: Swift.String?

        public init(
            controls: [AuditManagerClientTypes.Control]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.controls = controls
            self.id = id
            self.name = name
        }
    }
}

extension AuditManagerClientTypes {

    /// The file that's used to structure and automate Audit Manager assessments for a given compliance standard.
    public struct Framework: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the framework.
        public var arn: Swift.String?
        /// The compliance type that the framework supports, such as CIS or HIPAA.
        public var complianceType: Swift.String?
        /// The control sets that are associated with the framework.
        public var controlSets: [AuditManagerClientTypes.ControlSet]?
        /// The control data sources where Audit Manager collects evidence from.
        public var controlSources: Swift.String?
        /// The time when the framework was created.
        public var createdAt: Foundation.Date?
        /// The user or role that created the framework.
        public var createdBy: Swift.String?
        /// The description of the framework.
        public var description: Swift.String?
        /// The unique identifier for the framework.
        public var id: Swift.String?
        /// The time when the framework was most recently updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The user or role that most recently updated the framework.
        public var lastUpdatedBy: Swift.String?
        /// The logo that's associated with the framework.
        public var logo: Swift.String?
        /// The name of the framework.
        public var name: Swift.String?
        /// The tags that are associated with the framework.
        public var tags: [Swift.String: Swift.String]?
        /// Specifies whether the framework is a standard framework or a custom framework.
        public var type: AuditManagerClientTypes.FrameworkType?

        public init(
            arn: Swift.String? = nil,
            complianceType: Swift.String? = nil,
            controlSets: [AuditManagerClientTypes.ControlSet]? = nil,
            controlSources: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            logo: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: AuditManagerClientTypes.FrameworkType? = nil
        )
        {
            self.arn = arn
            self.complianceType = complianceType
            self.controlSets = controlSets
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.logo = logo
            self.name = name
            self.tags = tags
            self.type = type
        }
    }
}

extension AuditManagerClientTypes.Framework: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Framework(arn: \(Swift.String(describing: arn)), controlSources: \(Swift.String(describing: controlSources)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), logo: \(Swift.String(describing: logo)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), complianceType: \"CONTENT_REDACTED\", controlSets: \"CONTENT_REDACTED\", createdBy: \"CONTENT_REDACTED\", lastUpdatedBy: \"CONTENT_REDACTED\")"}
}

public struct CreateAssessmentFrameworkOutput: Swift.Sendable {
    /// The name of the new framework that the CreateAssessmentFramework API returned.
    public var framework: AuditManagerClientTypes.Framework?

    public init(
        framework: AuditManagerClientTypes.Framework? = nil
    )
    {
        self.framework = framework
    }
}

public struct CreateAssessmentReportInput: Swift.Sendable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The description of the assessment report.
    public var description: Swift.String?
    /// The name of the new assessment report.
    /// This member is required.
    public var name: Swift.String?
    /// A SQL statement that represents an evidence finder query. Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually [added to a report using the console](https://docs.aws.amazon.com/audit-manager/latest/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence), or [associated with a report using the API](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_BatchAssociateAssessmentReportEvidence.html). To use this parameter, the [enablementStatus](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_EvidenceFinderEnablement.html#auditmanager-Type-EvidenceFinderEnablement-enablementStatus) of evidence finder must be ENABLED. For examples and help resolving queryStatement validation exceptions, see [Troubleshooting evidence finder issues](https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions) in the Audit Manager User Guide.
    public var queryStatement: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        queryStatement: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.description = description
        self.name = name
        self.queryStatement = queryStatement
    }
}

extension CreateAssessmentReportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssessmentReportInput(assessmentId: \(Swift.String(describing: assessmentId)), name: \(Swift.String(describing: name)), queryStatement: \(Swift.String(describing: queryStatement)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateAssessmentReportOutput: Swift.Sendable {
    /// The new assessment report that the CreateAssessmentReport API returned.
    public var assessmentReport: AuditManagerClientTypes.AssessmentReport?

    public init(
        assessmentReport: AuditManagerClientTypes.AssessmentReport? = nil
    )
    {
        self.assessmentReport = assessmentReport
    }
}

extension AuditManagerClientTypes {

    /// The mapping attributes that determine the evidence source for a given control, along with related parameters and metadata. This doesn't contain mappingID.
    public struct CreateControlMappingSource: Swift.Sendable {
        /// The description of the data source that determines where Audit Manager collects evidence from for the control.
        public var sourceDescription: Swift.String?
        /// Specifies how often evidence is collected from the control mapping source.
        public var sourceFrequency: AuditManagerClientTypes.SourceFrequency?
        /// A keyword that relates to the control data source. For manual evidence, this keyword indicates if the manual evidence is a file or text. For automated evidence, this keyword identifies a specific CloudTrail event, Config rule, Security Hub control, or Amazon Web Services API name. To learn more about the supported keywords that you can use when mapping a control data source, see the following pages in the Audit Manager User Guide:
        ///
        /// * [Config rules supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html)
        ///
        /// * [Security Hub controls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html)
        ///
        /// * [API calls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html)
        ///
        /// * [CloudTrail event names supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-cloudtrail.html)
        public var sourceKeyword: AuditManagerClientTypes.SourceKeyword?
        /// The name of the control mapping data source.
        public var sourceName: Swift.String?
        /// The setup option for the data source. This option reflects if the evidence collection method is automated or manual. If you don’t provide a value for sourceSetUpOption, Audit Manager automatically infers and populates the correct value based on the sourceType that you specify.
        public var sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption?
        /// Specifies which type of data source is used to collect evidence.
        ///
        /// * The source can be an individual data source type, such as AWS_Cloudtrail, AWS_Config, AWS_Security_Hub, AWS_API_Call, or MANUAL.
        ///
        /// * The source can also be a managed grouping of data sources, such as a Core_Control or a Common_Control.
        public var sourceType: AuditManagerClientTypes.SourceType?
        /// The instructions for troubleshooting the control.
        public var troubleshootingText: Swift.String?

        public init(
            sourceDescription: Swift.String? = nil,
            sourceFrequency: AuditManagerClientTypes.SourceFrequency? = nil,
            sourceKeyword: AuditManagerClientTypes.SourceKeyword? = nil,
            sourceName: Swift.String? = nil,
            sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption? = nil,
            sourceType: AuditManagerClientTypes.SourceType? = nil,
            troubleshootingText: Swift.String? = nil
        )
        {
            self.sourceDescription = sourceDescription
            self.sourceFrequency = sourceFrequency
            self.sourceKeyword = sourceKeyword
            self.sourceName = sourceName
            self.sourceSetUpOption = sourceSetUpOption
            self.sourceType = sourceType
            self.troubleshootingText = troubleshootingText
        }
    }
}

extension AuditManagerClientTypes.CreateControlMappingSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateControlMappingSource(sourceDescription: \(Swift.String(describing: sourceDescription)), sourceFrequency: \(Swift.String(describing: sourceFrequency)), sourceKeyword: \(Swift.String(describing: sourceKeyword)), sourceName: \(Swift.String(describing: sourceName)), sourceSetUpOption: \(Swift.String(describing: sourceSetUpOption)), sourceType: \(Swift.String(describing: sourceType)), troubleshootingText: \"CONTENT_REDACTED\")"}
}

public struct CreateControlInput: Swift.Sendable {
    /// The recommended actions to carry out if the control isn't fulfilled.
    public var actionPlanInstructions: Swift.String?
    /// The title of the action plan for remediating the control.
    public var actionPlanTitle: Swift.String?
    /// The data mapping sources for the control.
    /// This member is required.
    public var controlMappingSources: [AuditManagerClientTypes.CreateControlMappingSource]?
    /// The description of the control.
    public var description: Swift.String?
    /// The name of the control.
    /// This member is required.
    public var name: Swift.String?
    /// The tags that are associated with the control.
    public var tags: [Swift.String: Swift.String]?
    /// The steps to follow to determine if the control is satisfied.
    public var testingInformation: Swift.String?

    public init(
        actionPlanInstructions: Swift.String? = nil,
        actionPlanTitle: Swift.String? = nil,
        controlMappingSources: [AuditManagerClientTypes.CreateControlMappingSource]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        testingInformation: Swift.String? = nil
    )
    {
        self.actionPlanInstructions = actionPlanInstructions
        self.actionPlanTitle = actionPlanTitle
        self.controlMappingSources = controlMappingSources
        self.description = description
        self.name = name
        self.tags = tags
        self.testingInformation = testingInformation
    }
}

extension CreateControlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateControlInput(controlMappingSources: \(Swift.String(describing: controlMappingSources)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), actionPlanInstructions: \"CONTENT_REDACTED\", actionPlanTitle: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", testingInformation: \"CONTENT_REDACTED\")"}
}

public struct CreateControlOutput: Swift.Sendable {
    /// The new control that the CreateControl API returned.
    public var control: AuditManagerClientTypes.Control?

    public init(
        control: AuditManagerClientTypes.Control? = nil
    )
    {
        self.control = control
    }
}

public struct DeleteAssessmentInput: Swift.Sendable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

public struct DeleteAssessmentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAssessmentFrameworkInput: Swift.Sendable {
    /// The identifier for the custom framework.
    /// This member is required.
    public var frameworkId: Swift.String?

    public init(
        frameworkId: Swift.String? = nil
    )
    {
        self.frameworkId = frameworkId
    }
}

public struct DeleteAssessmentFrameworkOutput: Swift.Sendable {

    public init() { }
}

extension AuditManagerClientTypes {

    public enum ShareRequestType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case received
        case sent
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareRequestType] {
            return [
                .received,
                .sent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .received: return "RECEIVED"
            case .sent: return "SENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteAssessmentFrameworkShareInput: Swift.Sendable {
    /// The unique identifier for the share request to be deleted.
    /// This member is required.
    public var requestId: Swift.String?
    /// Specifies whether the share request is a sent request or a received request.
    /// This member is required.
    public var requestType: AuditManagerClientTypes.ShareRequestType?

    public init(
        requestId: Swift.String? = nil,
        requestType: AuditManagerClientTypes.ShareRequestType? = nil
    )
    {
        self.requestId = requestId
        self.requestType = requestType
    }
}

public struct DeleteAssessmentFrameworkShareOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAssessmentReportInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the assessment report.
    /// This member is required.
    public var assessmentReportId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        assessmentReportId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentReportId = assessmentReportId
    }
}

public struct DeleteAssessmentReportOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteControlInput: Swift.Sendable {
    /// The unique identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?

    public init(
        controlId: Swift.String? = nil
    )
    {
        self.controlId = controlId
    }
}

public struct DeleteControlOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterAccountInput: Swift.Sendable {

    public init() { }
}

public struct DeregisterAccountOutput: Swift.Sendable {
    /// The registration status of the account.
    public var status: AuditManagerClientTypes.AccountStatus?

    public init(
        status: AuditManagerClientTypes.AccountStatus? = nil
    )
    {
        self.status = status
    }
}

public struct DeregisterOrganizationAdminAccountInput: Swift.Sendable {
    /// The identifier for the administrator account.
    public var adminAccountId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

public struct DeregisterOrganizationAdminAccountOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateAssessmentReportEvidenceFolderInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
    }
}

public struct DisassociateAssessmentReportEvidenceFolderOutput: Swift.Sendable {

    public init() { }
}

public struct GetAccountStatusInput: Swift.Sendable {

    public init() { }
}

public struct GetAccountStatusOutput: Swift.Sendable {
    /// The status of the Amazon Web Services account.
    public var status: AuditManagerClientTypes.AccountStatus?

    public init(
        status: AuditManagerClientTypes.AccountStatus? = nil
    )
    {
        self.status = status
    }
}

public struct GetAssessmentInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

public struct GetAssessmentOutput: Swift.Sendable {
    /// An entity that defines the scope of audit evidence collected by Audit Manager. An Audit Manager assessment is an implementation of an Audit Manager framework.
    public var assessment: AuditManagerClientTypes.Assessment?
    /// The wrapper that contains the Audit Manager role information of the current user. This includes the role type and IAM Amazon Resource Name (ARN).
    public var userRole: AuditManagerClientTypes.Role?

    public init(
        assessment: AuditManagerClientTypes.Assessment? = nil,
        userRole: AuditManagerClientTypes.Role? = nil
    )
    {
        self.assessment = assessment
        self.userRole = userRole
    }
}

public struct GetAssessmentFrameworkInput: Swift.Sendable {
    /// The identifier for the framework.
    /// This member is required.
    public var frameworkId: Swift.String?

    public init(
        frameworkId: Swift.String? = nil
    )
    {
        self.frameworkId = frameworkId
    }
}

public struct GetAssessmentFrameworkOutput: Swift.Sendable {
    /// The framework that the GetAssessmentFramework API returned.
    public var framework: AuditManagerClientTypes.Framework?

    public init(
        framework: AuditManagerClientTypes.Framework? = nil
    )
    {
        self.framework = framework
    }
}

public struct GetAssessmentReportUrlInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the assessment report.
    /// This member is required.
    public var assessmentReportId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        assessmentReportId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentReportId = assessmentReportId
    }
}

extension AuditManagerClientTypes {

    /// Short for uniform resource locator. A URL is used as a unique identifier to locate a resource on the internet.
    public struct URL: Swift.Sendable {
        /// The name or word that's used as a hyperlink to the URL.
        public var hyperlinkName: Swift.String?
        /// The unique identifier for the internet resource.
        public var link: Swift.String?

        public init(
            hyperlinkName: Swift.String? = nil,
            link: Swift.String? = nil
        )
        {
            self.hyperlinkName = hyperlinkName
            self.link = link
        }
    }
}

public struct GetAssessmentReportUrlOutput: Swift.Sendable {
    /// Short for uniform resource locator. A URL is used as a unique identifier to locate a resource on the internet.
    public var preSignedUrl: AuditManagerClientTypes.URL?

    public init(
        preSignedUrl: AuditManagerClientTypes.URL? = nil
    )
    {
        self.preSignedUrl = preSignedUrl
    }
}

public struct GetChangeLogsInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control.
    public var controlId: Swift.String?
    /// The unique identifier for the control set.
    public var controlSetId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AuditManagerClientTypes {

    public enum ObjectTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assessment
        case assessmentReport
        case control
        case controlSet
        case delegation
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectTypeEnum] {
            return [
                .assessment,
                .assessmentReport,
                .control,
                .controlSet,
                .delegation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assessment: return "ASSESSMENT"
            case .assessmentReport: return "ASSESSMENT_REPORT"
            case .control: return "CONTROL"
            case .controlSet: return "CONTROL_SET"
            case .delegation: return "DELEGATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The record of a change within Audit Manager. For example, this could be the status change of an assessment or the delegation of a control set.
    public struct ChangeLog: Swift.Sendable {
        /// The action that was performed.
        public var action: AuditManagerClientTypes.ActionEnum?
        /// The time when the action was performed and the changelog record was created.
        public var createdAt: Foundation.Date?
        /// The user or role that performed the action.
        public var createdBy: Swift.String?
        /// The name of the object that changed. This could be the name of an assessment, control, or control set.
        public var objectName: Swift.String?
        /// The object that was changed, such as an assessment, control, or control set.
        public var objectType: AuditManagerClientTypes.ObjectTypeEnum?

        public init(
            action: AuditManagerClientTypes.ActionEnum? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            objectName: Swift.String? = nil,
            objectType: AuditManagerClientTypes.ObjectTypeEnum? = nil
        )
        {
            self.action = action
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.objectName = objectName
            self.objectType = objectType
        }
    }
}

public struct GetChangeLogsOutput: Swift.Sendable {
    /// The list of user activity for the control.
    public var changeLogs: [AuditManagerClientTypes.ChangeLog]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        changeLogs: [AuditManagerClientTypes.ChangeLog]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.changeLogs = changeLogs
        self.nextToken = nextToken
    }
}

public struct GetControlInput: Swift.Sendable {
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?

    public init(
        controlId: Swift.String? = nil
    )
    {
        self.controlId = controlId
    }
}

public struct GetControlOutput: Swift.Sendable {
    /// The details of the control that the GetControl API returned.
    public var control: AuditManagerClientTypes.Control?

    public init(
        control: AuditManagerClientTypes.Control? = nil
    )
    {
        self.control = control
    }
}

public struct GetDelegationsInput: Swift.Sendable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AuditManagerClientTypes {

    /// The metadata that's associated with the delegation.
    public struct DelegationMetadata: Swift.Sendable {
        /// The unique identifier for the assessment.
        public var assessmentId: Swift.String?
        /// The name of the associated assessment.
        public var assessmentName: Swift.String?
        /// Specifies the name of the control set that was delegated for review.
        public var controlSetName: Swift.String?
        /// Specifies when the delegation was created.
        public var creationTime: Foundation.Date?
        /// The unique identifier for the delegation.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role.
        public var roleArn: Swift.String?
        /// The current status of the delegation.
        public var status: AuditManagerClientTypes.DelegationStatus?

        public init(
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            controlSetName: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: AuditManagerClientTypes.DelegationStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.controlSetName = controlSetName
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.status = status
        }
    }
}

extension AuditManagerClientTypes.DelegationMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DelegationMetadata(assessmentId: \(Swift.String(describing: assessmentId)), controlSetName: \(Swift.String(describing: controlSetName)), creationTime: \(Swift.String(describing: creationTime)), id: \(Swift.String(describing: id)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), assessmentName: \"CONTENT_REDACTED\")"}
}

public struct GetDelegationsOutput: Swift.Sendable {
    /// The list of delegations that the GetDelegations API returned.
    public var delegations: [AuditManagerClientTypes.DelegationMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        delegations: [AuditManagerClientTypes.DelegationMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.delegations = delegations
        self.nextToken = nextToken
    }
}

public struct GetEvidenceInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// The unique identifier for the evidence.
    /// This member is required.
    public var evidenceId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        evidenceId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceId = evidenceId
    }
}

extension AuditManagerClientTypes {

    /// A system asset that's evaluated in an Audit Manager assessment.
    public struct Resource: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the resource.
        public var arn: Swift.String?
        /// The evaluation status for a resource that was assessed when collecting compliance check evidence.
        ///
        /// * Audit Manager classes the resource as non-compliant if Security Hub reports a Fail result, or if Config reports a Non-compliant result.
        ///
        /// * Audit Manager classes the resource as compliant if Security Hub reports a Pass result, or if Config reports a Compliant result.
        ///
        /// * If a compliance check isn't available or applicable, then no compliance evaluation can be made for that resource. This is the case if a resource assessment uses Config or Security Hub as the underlying data source type, but those services aren't enabled. This is also the case if the resource assessment uses an underlying data source type that doesn't support compliance checks (such as manual evidence, Amazon Web Services API calls, or CloudTrail).
        public var complianceCheck: Swift.String?
        /// The value of the resource.
        public var value: Swift.String?

        public init(
            arn: Swift.String? = nil,
            complianceCheck: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.arn = arn
            self.complianceCheck = complianceCheck
            self.value = value
        }
    }
}

extension AuditManagerClientTypes {

    /// A record that contains the information needed to demonstrate compliance with the requirements specified by a control. Examples of evidence include change activity invoked by a user, or a system configuration snapshot.
    public struct Evidence: Swift.Sendable {
        /// Specifies whether the evidence is included in the assessment report.
        public var assessmentReportSelection: Swift.String?
        /// The names and values that are used by the evidence event. This includes an attribute name (such as allowUsersToChangePassword) and value (such as true or false).
        public var attributes: [Swift.String: Swift.String]?
        /// The identifier for the Amazon Web Services account.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services account that the evidence is collected from, and its organization path.
        public var awsOrganization: Swift.String?
        /// The evaluation status for automated evidence that falls under the compliance check category.
        ///
        /// * Audit Manager classes evidence as non-compliant if Security Hub reports a Fail result, or if Config reports a Non-compliant result.
        ///
        /// * Audit Manager classes evidence as compliant if Security Hub reports a Pass result, or if Config reports a Compliant result.
        ///
        /// * If a compliance check isn't available or applicable, then no compliance evaluation can be made for that evidence. This is the case if the evidence uses Config or Security Hub as the underlying data source type, but those services aren't enabled. This is also the case if the evidence uses an underlying data source type that doesn't support compliance checks (such as manual evidence, Amazon Web Services API calls, or CloudTrail).
        public var complianceCheck: Swift.String?
        /// The data source where the evidence was collected from.
        public var dataSource: Swift.String?
        /// The name of the evidence event.
        public var eventName: Swift.String?
        /// The Amazon Web Service that the evidence is collected from.
        public var eventSource: Swift.String?
        /// The identifier for the Amazon Web Services account.
        public var evidenceAwsAccountId: Swift.String?
        /// The type of automated evidence.
        public var evidenceByType: Swift.String?
        /// The identifier for the folder that the evidence is stored in.
        public var evidenceFolderId: Swift.String?
        /// The unique identifier for the user or role that's associated with the evidence.
        public var iamId: Swift.String?
        /// The identifier for the evidence.
        public var id: Swift.String?
        /// The list of resources that are assessed to generate the evidence.
        public var resourcesIncluded: [AuditManagerClientTypes.Resource]?
        /// The timestamp that represents when the evidence was collected.
        public var time: Foundation.Date?

        public init(
            assessmentReportSelection: Swift.String? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            awsAccountId: Swift.String? = nil,
            awsOrganization: Swift.String? = nil,
            complianceCheck: Swift.String? = nil,
            dataSource: Swift.String? = nil,
            eventName: Swift.String? = nil,
            eventSource: Swift.String? = nil,
            evidenceAwsAccountId: Swift.String? = nil,
            evidenceByType: Swift.String? = nil,
            evidenceFolderId: Swift.String? = nil,
            iamId: Swift.String? = nil,
            id: Swift.String? = nil,
            resourcesIncluded: [AuditManagerClientTypes.Resource]? = nil,
            time: Foundation.Date? = nil
        )
        {
            self.assessmentReportSelection = assessmentReportSelection
            self.attributes = attributes
            self.awsAccountId = awsAccountId
            self.awsOrganization = awsOrganization
            self.complianceCheck = complianceCheck
            self.dataSource = dataSource
            self.eventName = eventName
            self.eventSource = eventSource
            self.evidenceAwsAccountId = evidenceAwsAccountId
            self.evidenceByType = evidenceByType
            self.evidenceFolderId = evidenceFolderId
            self.iamId = iamId
            self.id = id
            self.resourcesIncluded = resourcesIncluded
            self.time = time
        }
    }
}

public struct GetEvidenceOutput: Swift.Sendable {
    /// The evidence that the GetEvidence API returned.
    public var evidence: AuditManagerClientTypes.Evidence?

    public init(
        evidence: AuditManagerClientTypes.Evidence? = nil
    )
    {
        self.evidence = evidence
    }
}

public struct GetEvidenceByEvidenceFolderInput: Swift.Sendable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetEvidenceByEvidenceFolderOutput: Swift.Sendable {
    /// The list of evidence that the GetEvidenceByEvidenceFolder API returned.
    public var evidence: [AuditManagerClientTypes.Evidence]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        evidence: [AuditManagerClientTypes.Evidence]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evidence = evidence
        self.nextToken = nextToken
    }
}

public struct GetEvidenceFileUploadUrlInput: Swift.Sendable {
    /// The file that you want to upload. For a list of supported file formats, see [Supported file types for manual evidence](https://docs.aws.amazon.com/audit-manager/latest/userguide/upload-evidence.html#supported-manual-evidence-files) in the Audit Manager User Guide.
    /// This member is required.
    public var fileName: Swift.String?

    public init(
        fileName: Swift.String? = nil
    )
    {
        self.fileName = fileName
    }
}

extension GetEvidenceFileUploadUrlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEvidenceFileUploadUrlInput(fileName: \"CONTENT_REDACTED\")"}
}

public struct GetEvidenceFileUploadUrlOutput: Swift.Sendable {
    /// The name of the uploaded manual evidence file that the presigned URL was generated for.
    public var evidenceFileName: Swift.String?
    /// The presigned URL that was generated.
    public var uploadUrl: Swift.String?

    public init(
        evidenceFileName: Swift.String? = nil,
        uploadUrl: Swift.String? = nil
    )
    {
        self.evidenceFileName = evidenceFileName
        self.uploadUrl = uploadUrl
    }
}

extension GetEvidenceFileUploadUrlOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct GetEvidenceFolderInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
    }
}

public struct GetEvidenceFolderOutput: Swift.Sendable {
    /// The folder that the evidence is stored in.
    public var evidenceFolder: AuditManagerClientTypes.AssessmentEvidenceFolder?

    public init(
        evidenceFolder: AuditManagerClientTypes.AssessmentEvidenceFolder? = nil
    )
    {
        self.evidenceFolder = evidenceFolder
    }
}

public struct GetEvidenceFoldersByAssessmentInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetEvidenceFoldersByAssessmentOutput: Swift.Sendable {
    /// The list of evidence folders that the GetEvidenceFoldersByAssessment API returned.
    public var evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evidenceFolders = evidenceFolders
        self.nextToken = nextToken
    }
}

public struct GetEvidenceFoldersByAssessmentControlInput: Swift.Sendable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetEvidenceFoldersByAssessmentControlOutput: Swift.Sendable {
    /// The list of evidence folders that the GetEvidenceFoldersByAssessmentControl API returned.
    public var evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evidenceFolders = evidenceFolders
        self.nextToken = nextToken
    }
}

public struct GetInsightsInput: Swift.Sendable {

    public init() { }
}

extension AuditManagerClientTypes {

    /// A summary of the latest analytics data for all your active assessments. This summary is a snapshot of the data that your active assessments collected on the lastUpdated date. It’s important to understand that the following totals are daily counts based on this date — they aren’t a total sum to date. The Insights data is eventually consistent. This means that, when you read data from Insights, the response might not instantly reflect the results of a recently completed write or update operation. If you repeat your read request after a few hours, the response should return the latest data. If you delete an assessment or change its status to inactive, InsightsByAssessment includes data for that assessment as follows.
    ///
    /// * Inactive assessments - If Audit Manager collected evidence for your assessment before you changed it inactive, that evidence is included in the InsightsByAssessment counts for that day.
    ///
    /// * Deleted assessments - If Audit Manager collected evidence for your assessment before you deleted it, that evidence isn't included in the InsightsByAssessment counts for that day.
    public struct Insights: Swift.Sendable {
        /// The number of active assessments in Audit Manager.
        public var activeAssessmentsCount: Swift.Int?
        /// The number of assessment controls that collected non-compliant evidence on the lastUpdated date.
        public var assessmentControlsCountByNoncompliantEvidence: Swift.Int?
        /// The number of compliance check evidence that Audit Manager classified as compliant on the lastUpdated date. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public var compliantEvidenceCount: Swift.Int?
        /// The number of evidence without a compliance check ruling. Evidence is inconclusive when the associated control uses Security Hub or Config as a data source but you didn't enable those services. This is also the case when a control uses a data source that doesn’t support compliance checks (for example: manual evidence, API calls, or CloudTrail). If evidence has a compliance check status of not applicable, it's classed as inconclusive in Insights data.
        public var inconclusiveEvidenceCount: Swift.Int?
        /// The time when the cross-assessment insights were last updated.
        public var lastUpdated: Foundation.Date?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant on the lastUpdated date. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public var noncompliantEvidenceCount: Swift.Int?
        /// The total number of controls across all active assessments.
        public var totalAssessmentControlsCount: Swift.Int?

        public init(
            activeAssessmentsCount: Swift.Int? = nil,
            assessmentControlsCountByNoncompliantEvidence: Swift.Int? = nil,
            compliantEvidenceCount: Swift.Int? = nil,
            inconclusiveEvidenceCount: Swift.Int? = nil,
            lastUpdated: Foundation.Date? = nil,
            noncompliantEvidenceCount: Swift.Int? = nil,
            totalAssessmentControlsCount: Swift.Int? = nil
        )
        {
            self.activeAssessmentsCount = activeAssessmentsCount
            self.assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidence
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.lastUpdated = lastUpdated
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
            self.totalAssessmentControlsCount = totalAssessmentControlsCount
        }
    }
}

public struct GetInsightsOutput: Swift.Sendable {
    /// The analytics data that the GetInsights API returned.
    public var insights: AuditManagerClientTypes.Insights?

    public init(
        insights: AuditManagerClientTypes.Insights? = nil
    )
    {
        self.insights = insights
    }
}

public struct GetInsightsByAssessmentInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

extension AuditManagerClientTypes {

    /// A summary of the latest analytics data for a specific active assessment. This summary is a snapshot of the data that was collected on the lastUpdated date. It’s important to understand that the totals in InsightsByAssessment are daily counts based on this date — they aren’t a total sum to date. The InsightsByAssessment data is eventually consistent. This means that when you read data from InsightsByAssessment, the response might not instantly reflect the results of a recently completed write or update operation. If you repeat your read request after a few hours, the response returns the latest data. If you delete an assessment or change its status to inactive, InsightsByAssessment includes data for that assessment as follows.
    ///
    /// * Inactive assessments - If Audit Manager collected evidence for your assessment before you changed it inactive, that evidence is included in the InsightsByAssessment counts for that day.
    ///
    /// * Deleted assessments - If Audit Manager collected evidence for your assessment before you deleted it, that evidence isn't included in the InsightsByAssessment counts for that day.
    public struct InsightsByAssessment: Swift.Sendable {
        /// The number of assessment controls that collected non-compliant evidence on the lastUpdated date.
        public var assessmentControlsCountByNoncompliantEvidence: Swift.Int?
        /// The number of compliance check evidence that Audit Manager classified as compliant. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public var compliantEvidenceCount: Swift.Int?
        /// The amount of evidence without a compliance check ruling. Evidence is inconclusive if the associated control uses Security Hub or Config as a data source and you didn't enable those services. This is also the case if a control uses a data source that doesn’t support compliance checks (for example, manual evidence, API calls, or CloudTrail). If evidence has a compliance check status of not applicable, it's classified as inconclusive in InsightsByAssessment data.
        public var inconclusiveEvidenceCount: Swift.Int?
        /// The time when the assessment insights were last updated.
        public var lastUpdated: Foundation.Date?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public var noncompliantEvidenceCount: Swift.Int?
        /// The total number of controls in the assessment.
        public var totalAssessmentControlsCount: Swift.Int?

        public init(
            assessmentControlsCountByNoncompliantEvidence: Swift.Int? = nil,
            compliantEvidenceCount: Swift.Int? = nil,
            inconclusiveEvidenceCount: Swift.Int? = nil,
            lastUpdated: Foundation.Date? = nil,
            noncompliantEvidenceCount: Swift.Int? = nil,
            totalAssessmentControlsCount: Swift.Int? = nil
        )
        {
            self.assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidence
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.lastUpdated = lastUpdated
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
            self.totalAssessmentControlsCount = totalAssessmentControlsCount
        }
    }
}

public struct GetInsightsByAssessmentOutput: Swift.Sendable {
    /// The assessment analytics data that the GetInsightsByAssessment API returned.
    public var insights: AuditManagerClientTypes.InsightsByAssessment?

    public init(
        insights: AuditManagerClientTypes.InsightsByAssessment? = nil
    )
    {
        self.insights = insights
    }
}

public struct GetOrganizationAdminAccountInput: Swift.Sendable {

    public init() { }
}

public struct GetOrganizationAdminAccountOutput: Swift.Sendable {
    /// The identifier for the administrator account.
    public var adminAccountId: Swift.String?
    /// The identifier for the organization.
    public var organizationId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.organizationId = organizationId
    }
}

public struct GetServicesInScopeInput: Swift.Sendable {

    public init() { }
}

extension AuditManagerClientTypes {

    /// The metadata that's associated with the Amazon Web Service.
    public struct ServiceMetadata: Swift.Sendable {
        /// The category that the Amazon Web Service belongs to, such as compute, storage, or database.
        public var category: Swift.String?
        /// The description of the Amazon Web Service.
        public var description: Swift.String?
        /// The display name of the Amazon Web Service.
        public var displayName: Swift.String?
        /// The name of the Amazon Web Service.
        public var name: Swift.String?

        public init(
            category: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.category = category
            self.description = description
            self.displayName = displayName
            self.name = name
        }
    }
}

public struct GetServicesInScopeOutput: Swift.Sendable {
    /// The metadata that's associated with the Amazon Web Service.
    public var serviceMetadata: [AuditManagerClientTypes.ServiceMetadata]?

    public init(
        serviceMetadata: [AuditManagerClientTypes.ServiceMetadata]? = nil
    )
    {
        self.serviceMetadata = serviceMetadata
    }
}

extension AuditManagerClientTypes {

    public enum SettingAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case defaultAssessmentReportsDestination
        case defaultExportDestination
        case defaultProcessOwners
        case deregistrationPolicy
        case evidenceFinderEnablement
        case isAwsOrgEnabled
        case snsTopic
        case sdkUnknown(Swift.String)

        public static var allCases: [SettingAttribute] {
            return [
                .all,
                .defaultAssessmentReportsDestination,
                .defaultExportDestination,
                .defaultProcessOwners,
                .deregistrationPolicy,
                .evidenceFinderEnablement,
                .isAwsOrgEnabled,
                .snsTopic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .defaultAssessmentReportsDestination: return "DEFAULT_ASSESSMENT_REPORTS_DESTINATION"
            case .defaultExportDestination: return "DEFAULT_EXPORT_DESTINATION"
            case .defaultProcessOwners: return "DEFAULT_PROCESS_OWNERS"
            case .deregistrationPolicy: return "DEREGISTRATION_POLICY"
            case .evidenceFinderEnablement: return "EVIDENCE_FINDER_ENABLEMENT"
            case .isAwsOrgEnabled: return "IS_AWS_ORG_ENABLED"
            case .snsTopic: return "SNS_TOPIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSettingsInput: Swift.Sendable {
    /// The list of setting attribute enum values.
    /// This member is required.
    public var attribute: AuditManagerClientTypes.SettingAttribute?

    public init(
        attribute: AuditManagerClientTypes.SettingAttribute? = nil
    )
    {
        self.attribute = attribute
    }
}

extension AuditManagerClientTypes {

    public enum ExportDestinationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportDestinationType] {
            return [
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The default s3 bucket where Audit Manager saves the files that you export from evidence finder.
    public struct DefaultExportDestination: Swift.Sendable {
        /// The destination bucket where Audit Manager stores exported files.
        public var destination: Swift.String?
        /// The destination type, such as Amazon S3.
        public var destinationType: AuditManagerClientTypes.ExportDestinationType?

        public init(
            destination: Swift.String? = nil,
            destinationType: AuditManagerClientTypes.ExportDestinationType? = nil
        )
        {
            self.destination = destination
            self.destinationType = destinationType
        }
    }
}

extension AuditManagerClientTypes {

    public enum DeleteResources: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [DeleteResources] {
            return [
                .all,
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The deregistration policy for the data that's stored in Audit Manager. You can use this attribute to determine how your data is handled when you [deregister Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html). By default, Audit Manager retains evidence data for two years from the time of its creation. Other Audit Manager resources (including assessments, custom controls, and custom frameworks) remain in Audit Manager indefinitely, and are available if you [re-register Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html) in the future. For more information about data retention, see [Data Protection](https://docs.aws.amazon.com/audit-manager/latest/userguide/data-protection.html) in the Audit Manager User Guide. If you choose to delete all data, this action permanently deletes all evidence data in your account within seven days. It also deletes all of the Audit Manager resources that you created, including assessments, custom controls, and custom frameworks. Your data will not be available if you re-register Audit Manager in the future.
    public struct DeregistrationPolicy: Swift.Sendable {
        /// Specifies which Audit Manager data will be deleted when you deregister Audit Manager.
        ///
        /// * If you set the value to ALL, all of your data is deleted within seven days of deregistration.
        ///
        /// * If you set the value to DEFAULT, none of your data is deleted at the time of deregistration. However, keep in mind that the Audit Manager data retention policy still applies. As a result, any evidence data will be deleted two years after its creation date. Your other Audit Manager resources will continue to exist indefinitely.
        public var deleteResources: AuditManagerClientTypes.DeleteResources?

        public init(
            deleteResources: AuditManagerClientTypes.DeleteResources? = nil
        )
        {
            self.deleteResources = deleteResources
        }
    }
}

extension AuditManagerClientTypes {

    public enum EvidenceFinderBackfillStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [EvidenceFinderBackfillStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    public enum EvidenceFinderEnablementStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case disableInProgress
        case enabled
        case enableInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [EvidenceFinderEnablementStatus] {
            return [
                .disabled,
                .disableInProgress,
                .enabled,
                .enableInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case .enableInProgress: return "ENABLE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AuditManagerClientTypes {

    /// The settings object that specifies whether evidence finder is enabled. This object also describes the related event data store, and the backfill status for populating the event data store with evidence data.
    public struct EvidenceFinderEnablement: Swift.Sendable {
        /// The current status of the evidence data backfill process. The backfill starts after you enable evidence finder. During this task, Audit Manager populates an event data store with your past two years’ worth of evidence data so that your evidence can be queried.
        ///
        /// * NOT_STARTED means that the backfill hasn’t started yet.
        ///
        /// * IN_PROGRESS means that the backfill is in progress. This can take up to 7 days to complete, depending on the amount of evidence data.
        ///
        /// * COMPLETED means that the backfill is complete. All of your past evidence is now queryable.
        public var backfillStatus: AuditManagerClientTypes.EvidenceFinderBackfillStatus?
        /// The current status of the evidence finder feature and the related event data store.
        ///
        /// * ENABLE_IN_PROGRESS means that you requested to enable evidence finder. An event data store is currently being created to support evidence finder queries.
        ///
        /// * ENABLED means that an event data store was successfully created and evidence finder is enabled. We recommend that you wait 7 days until the event data store is backfilled with your past two years’ worth of evidence data. You can use evidence finder in the meantime, but not all data might be available until the backfill is complete.
        ///
        /// * DISABLE_IN_PROGRESS means that you requested to disable evidence finder, and your request is pending the deletion of the event data store.
        ///
        /// * DISABLED means that you have permanently disabled evidence finder and the event data store has been deleted. You can't re-enable evidence finder after this point.
        public var enablementStatus: AuditManagerClientTypes.EvidenceFinderEnablementStatus?
        /// Represents any errors that occurred when enabling or disabling evidence finder.
        public var error: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudTrail Lake event data store that’s used by evidence finder. The event data store is the lake of evidence data that evidence finder runs queries against.
        public var eventDataStoreArn: Swift.String?

        public init(
            backfillStatus: AuditManagerClientTypes.EvidenceFinderBackfillStatus? = nil,
            enablementStatus: AuditManagerClientTypes.EvidenceFinderEnablementStatus? = nil,
            error: Swift.String? = nil,
            eventDataStoreArn: Swift.String? = nil
        )
        {
            self.backfillStatus = backfillStatus
            self.enablementStatus = enablementStatus
            self.error = error
            self.eventDataStoreArn = eventDataStoreArn
        }
    }
}

extension AuditManagerClientTypes {

    /// The settings object that holds all supported Audit Manager settings.
    public struct Settings: Swift.Sendable {
        /// The default S3 destination bucket for storing assessment reports.
        public var defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
        /// The default S3 destination bucket for storing evidence finder exports.
        public var defaultExportDestination: AuditManagerClientTypes.DefaultExportDestination?
        /// The designated default audit owners.
        public var defaultProcessOwners: [AuditManagerClientTypes.Role]?
        /// The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.
        public var deregistrationPolicy: AuditManagerClientTypes.DeregistrationPolicy?
        /// The current evidence finder status and event data store details.
        public var evidenceFinderEnablement: AuditManagerClientTypes.EvidenceFinderEnablement?
        /// Specifies whether Organizations is enabled.
        public var isAwsOrgEnabled: Swift.Bool?
        /// The KMS key details.
        public var kmsKey: Swift.String?
        /// The designated Amazon Simple Notification Service (Amazon SNS) topic.
        public var snsTopic: Swift.String?

        public init(
            defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
            defaultExportDestination: AuditManagerClientTypes.DefaultExportDestination? = nil,
            defaultProcessOwners: [AuditManagerClientTypes.Role]? = nil,
            deregistrationPolicy: AuditManagerClientTypes.DeregistrationPolicy? = nil,
            evidenceFinderEnablement: AuditManagerClientTypes.EvidenceFinderEnablement? = nil,
            isAwsOrgEnabled: Swift.Bool? = nil,
            kmsKey: Swift.String? = nil,
            snsTopic: Swift.String? = nil
        )
        {
            self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
            self.defaultExportDestination = defaultExportDestination
            self.defaultProcessOwners = defaultProcessOwners
            self.deregistrationPolicy = deregistrationPolicy
            self.evidenceFinderEnablement = evidenceFinderEnablement
            self.isAwsOrgEnabled = isAwsOrgEnabled
            self.kmsKey = kmsKey
            self.snsTopic = snsTopic
        }
    }
}

extension AuditManagerClientTypes.Settings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Settings(defaultExportDestination: \(Swift.String(describing: defaultExportDestination)), deregistrationPolicy: \(Swift.String(describing: deregistrationPolicy)), evidenceFinderEnablement: \(Swift.String(describing: evidenceFinderEnablement)), isAwsOrgEnabled: \(Swift.String(describing: isAwsOrgEnabled)), kmsKey: \(Swift.String(describing: kmsKey)), defaultAssessmentReportsDestination: \"CONTENT_REDACTED\", defaultProcessOwners: \"CONTENT_REDACTED\", snsTopic: \"CONTENT_REDACTED\")"}
}

public struct GetSettingsOutput: Swift.Sendable {
    /// The settings object that holds all supported Audit Manager settings.
    public var settings: AuditManagerClientTypes.Settings?

    public init(
        settings: AuditManagerClientTypes.Settings? = nil
    )
    {
        self.settings = settings
    }
}

public struct ListAssessmentControlInsightsByControlDomainInput: Swift.Sendable {
    /// The unique identifier for the active assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control domain. Audit Manager supports the control domains that are provided by Amazon Web Services Control Catalog. For information about how to find a list of available control domains, see [ListDomains](https://docs.aws.amazon.com/controlcatalog/latest/APIReference/API_ListDomains.html) in the Amazon Web Services Control Catalog API Reference.
    /// This member is required.
    public var controlDomainId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlDomainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlDomainId = controlDomainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AuditManagerClientTypes {

    /// A breakdown of the latest compliance check status for the evidence in your Audit Manager assessments.
    public struct EvidenceInsights: Swift.Sendable {
        /// The number of compliance check evidence that Audit Manager classified as compliant. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public var compliantEvidenceCount: Swift.Int?
        /// The number of evidence that a compliance check ruling isn't available for. Evidence is inconclusive when the associated control uses Security Hub or Config as a data source but you didn't enable those services. This is also the case when a control uses a data source that doesn’t support compliance checks (for example, manual evidence, API calls, or CloudTrail). If evidence has a compliance check status of not applicable in the console, it's classified as inconclusive in EvidenceInsights data.
        public var inconclusiveEvidenceCount: Swift.Int?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public var noncompliantEvidenceCount: Swift.Int?

        public init(
            compliantEvidenceCount: Swift.Int? = nil,
            inconclusiveEvidenceCount: Swift.Int? = nil,
            noncompliantEvidenceCount: Swift.Int? = nil
        )
        {
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
        }
    }
}

extension AuditManagerClientTypes {

    /// A summary of the latest analytics data for a specific control in a specific active assessment. Control insights are grouped by control domain, and ranked by the highest total count of non-compliant evidence.
    public struct ControlInsightsMetadataByAssessmentItem: Swift.Sendable {
        /// The name of the control set that the assessment control belongs to.
        public var controlSetName: Swift.String?
        /// A breakdown of the compliance check status for the evidence that’s associated with the assessment control.
        public var evidenceInsights: AuditManagerClientTypes.EvidenceInsights?
        /// The unique identifier for the assessment control.
        public var id: Swift.String?
        /// The time when the assessment control insights were last updated.
        public var lastUpdated: Foundation.Date?
        /// The name of the assessment control.
        public var name: Swift.String?

        public init(
            controlSetName: Swift.String? = nil,
            evidenceInsights: AuditManagerClientTypes.EvidenceInsights? = nil,
            id: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.controlSetName = controlSetName
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
        }
    }
}

public struct ListAssessmentControlInsightsByControlDomainOutput: Swift.Sendable {
    /// The assessment control analytics data that the ListAssessmentControlInsightsByControlDomain API returned.
    public var controlInsightsByAssessment: [AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlInsightsByAssessment: [AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlInsightsByAssessment = controlInsightsByAssessment
        self.nextToken = nextToken
    }
}

public struct ListAssessmentFrameworksInput: Swift.Sendable {
    /// The type of framework, such as a standard framework or a custom framework.
    /// This member is required.
    public var frameworkType: AuditManagerClientTypes.FrameworkType?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        frameworkType: AuditManagerClientTypes.FrameworkType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.frameworkType = frameworkType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssessmentFrameworksOutput: Swift.Sendable {
    /// A list of metadata that the ListAssessmentFrameworks API returns for each framework.
    public var frameworkMetadataList: [AuditManagerClientTypes.AssessmentFrameworkMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        frameworkMetadataList: [AuditManagerClientTypes.AssessmentFrameworkMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.frameworkMetadataList = frameworkMetadataList
        self.nextToken = nextToken
    }
}

public struct ListAssessmentFrameworkShareRequestsInput: Swift.Sendable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// Specifies whether the share request is a sent request or a received request.
    /// This member is required.
    public var requestType: AuditManagerClientTypes.ShareRequestType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        requestType: AuditManagerClientTypes.ShareRequestType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.requestType = requestType
    }
}

public struct ListAssessmentFrameworkShareRequestsOutput: Swift.Sendable {
    /// The list of share requests that the ListAssessmentFrameworkShareRequests API returned.
    public var assessmentFrameworkShareRequests: [AuditManagerClientTypes.AssessmentFrameworkShareRequest]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentFrameworkShareRequests: [AuditManagerClientTypes.AssessmentFrameworkShareRequest]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentFrameworkShareRequests = assessmentFrameworkShareRequests
        self.nextToken = nextToken
    }
}

public struct ListAssessmentReportsInput: Swift.Sendable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssessmentReportsOutput: Swift.Sendable {
    /// The list of assessment reports that the ListAssessmentReports API returned.
    public var assessmentReports: [AuditManagerClientTypes.AssessmentReportMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentReports: [AuditManagerClientTypes.AssessmentReportMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentReports = assessmentReports
        self.nextToken = nextToken
    }
}

public struct ListAssessmentsInput: Swift.Sendable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The current status of the assessment.
    public var status: AuditManagerClientTypes.AssessmentStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: AuditManagerClientTypes.AssessmentStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListAssessmentsOutput: Swift.Sendable {
    /// The metadata that the ListAssessments API returns for each assessment.
    public var assessmentMetadata: [AuditManagerClientTypes.AssessmentMetadataItem]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentMetadata: [AuditManagerClientTypes.AssessmentMetadataItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentMetadata = assessmentMetadata
        self.nextToken = nextToken
    }
}

public struct ListControlDomainInsightsInput: Swift.Sendable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AuditManagerClientTypes {

    /// A summary of the latest analytics data for a specific control domain. Control domain insights are grouped by control domain, and ranked by the highest total count of non-compliant evidence.
    public struct ControlDomainInsights: Swift.Sendable {
        /// The number of controls in the control domain that collected non-compliant evidence on the lastUpdated date.
        public var controlsCountByNoncompliantEvidence: Swift.Int?
        /// A breakdown of the compliance check status for the evidence that’s associated with the control domain.
        public var evidenceInsights: AuditManagerClientTypes.EvidenceInsights?
        /// The unique identifier for the control domain. Audit Manager supports the control domains that are provided by Amazon Web Services Control Catalog. For information about how to find a list of available control domains, see [ListDomains](https://docs.aws.amazon.com/controlcatalog/latest/APIReference/API_ListDomains.html) in the Amazon Web Services Control Catalog API Reference.
        public var id: Swift.String?
        /// The time when the control domain insights were last updated.
        public var lastUpdated: Foundation.Date?
        /// The name of the control domain.
        public var name: Swift.String?
        /// The total number of controls in the control domain.
        public var totalControlsCount: Swift.Int?

        public init(
            controlsCountByNoncompliantEvidence: Swift.Int? = nil,
            evidenceInsights: AuditManagerClientTypes.EvidenceInsights? = nil,
            id: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            name: Swift.String? = nil,
            totalControlsCount: Swift.Int? = nil
        )
        {
            self.controlsCountByNoncompliantEvidence = controlsCountByNoncompliantEvidence
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.totalControlsCount = totalControlsCount
        }
    }
}

public struct ListControlDomainInsightsOutput: Swift.Sendable {
    /// The control domain analytics data that the ListControlDomainInsights API returned.
    public var controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlDomainInsights = controlDomainInsights
        self.nextToken = nextToken
    }
}

public struct ListControlDomainInsightsByAssessmentInput: Swift.Sendable {
    /// The unique identifier for the active assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListControlDomainInsightsByAssessmentOutput: Swift.Sendable {
    /// The control domain analytics data that the ListControlDomainInsightsByAssessment API returned.
    public var controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlDomainInsights = controlDomainInsights
        self.nextToken = nextToken
    }
}

public struct ListControlInsightsByControlDomainInput: Swift.Sendable {
    /// The unique identifier for the control domain. Audit Manager supports the control domains that are provided by Amazon Web Services Control Catalog. For information about how to find a list of available control domains, see [ListDomains](https://docs.aws.amazon.com/controlcatalog/latest/APIReference/API_ListDomains.html) in the Amazon Web Services Control Catalog API Reference.
    /// This member is required.
    public var controlDomainId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlDomainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlDomainId = controlDomainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AuditManagerClientTypes {

    /// A summary of the latest analytics data for a specific control. This data reflects the total counts for the specified control across all active assessments. Control insights are grouped by control domain, and ranked by the highest total count of non-compliant evidence.
    public struct ControlInsightsMetadataItem: Swift.Sendable {
        /// A breakdown of the compliance check status for the evidence that’s associated with the control.
        public var evidenceInsights: AuditManagerClientTypes.EvidenceInsights?
        /// The unique identifier for the control.
        public var id: Swift.String?
        /// The time when the control insights were last updated.
        public var lastUpdated: Foundation.Date?
        /// The name of the control.
        public var name: Swift.String?

        public init(
            evidenceInsights: AuditManagerClientTypes.EvidenceInsights? = nil,
            id: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
        }
    }
}

public struct ListControlInsightsByControlDomainOutput: Swift.Sendable {
    /// The control analytics data that the ListControlInsightsByControlDomain API returned.
    public var controlInsightsMetadata: [AuditManagerClientTypes.ControlInsightsMetadataItem]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlInsightsMetadata: [AuditManagerClientTypes.ControlInsightsMetadataItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlInsightsMetadata = controlInsightsMetadata
        self.nextToken = nextToken
    }
}

public struct ListControlsInput: Swift.Sendable {
    /// A filter that narrows the list of controls to a specific resource from the Amazon Web Services Control Catalog. To use this parameter, specify the ARN of the Control Catalog resource. You can specify either a control domain, a control objective, or a common control. For information about how to find the ARNs for these resources, see [ListDomains](https://docs.aws.amazon.com/controlcatalog/latest/APIReference/API_ListDomains.html), [ListObjectives](https://docs.aws.amazon.com/controlcatalog/latest/APIReference/API_ListObjectives.html), and [ListCommonControls](https://docs.aws.amazon.com/controlcatalog/latest/APIReference/API_ListCommonControls.html). You can only filter by one Control Catalog resource at a time. Specifying multiple resource ARNs isn’t currently supported. If you want to filter by more than one ARN, we recommend that you run the ListControls operation separately for each ARN. Alternatively, specify UNCATEGORIZED to list controls that aren't mapped to a Control Catalog resource. For example, this operation might return a list of custom controls that don't belong to any control domain or control objective.
    public var controlCatalogId: Swift.String?
    /// A filter that narrows the list of controls to a specific type.
    /// This member is required.
    public var controlType: AuditManagerClientTypes.ControlType?
    /// The maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlCatalogId: Swift.String? = nil,
        controlType: AuditManagerClientTypes.ControlType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlCatalogId = controlCatalogId
        self.controlType = controlType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AuditManagerClientTypes {

    /// The metadata that's associated with the standard control or custom control.
    public struct ControlMetadata: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the control.
        public var arn: Swift.String?
        /// The data source that determines where Audit Manager collects evidence from for the control.
        public var controlSources: Swift.String?
        /// The time when the control was created.
        public var createdAt: Foundation.Date?
        /// The unique identifier for the control.
        public var id: Swift.String?
        /// The time when the control was most recently updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the control.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            controlSources: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
        }
    }
}

public struct ListControlsOutput: Swift.Sendable {
    /// A list of metadata that the ListControls API returns for each control.
    public var controlMetadataList: [AuditManagerClientTypes.ControlMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlMetadataList: [AuditManagerClientTypes.ControlMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlMetadataList = controlMetadataList
        self.nextToken = nextToken
    }
}

extension AuditManagerClientTypes {

    public enum DataSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsApiCall
        case awsCloudtrail
        case awsConfig
        case awsSecurityHub
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .awsApiCall,
                .awsCloudtrail,
                .awsConfig,
                .awsSecurityHub,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsApiCall: return "AWS_API_Call"
            case .awsCloudtrail: return "AWS_Cloudtrail"
            case .awsConfig: return "AWS_Config"
            case .awsSecurityHub: return "AWS_Security_Hub"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListKeywordsForDataSourceInput: Swift.Sendable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The control mapping data source that the keywords apply to.
    /// This member is required.
    public var source: AuditManagerClientTypes.DataSourceType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        source: AuditManagerClientTypes.DataSourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.source = source
    }
}

public struct ListKeywordsForDataSourceOutput: Swift.Sendable {
    /// The list of keywords for the control mapping source.
    public var keywords: [Swift.String]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        keywords: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.nextToken = nextToken
    }
}

public struct ListNotificationsInput: Swift.Sendable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AuditManagerClientTypes {

    /// The notification that informs a user of an update in Audit Manager. For example, this includes the notification that's sent when a control set is delegated for review.
    public struct Notification: Swift.Sendable {
        /// The identifier for the assessment.
        public var assessmentId: Swift.String?
        /// The name of the related assessment.
        public var assessmentName: Swift.String?
        /// The identifier for the control set.
        public var controlSetId: Swift.String?
        /// Specifies the name of the control set that the notification is about.
        public var controlSetName: Swift.String?
        /// The description of the notification.
        public var description: Swift.String?
        /// The time when the notification was sent.
        public var eventTime: Foundation.Date?
        /// The unique identifier for the notification.
        public var id: Swift.String?
        /// The sender of the notification.
        public var source: Swift.String?

        public init(
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            controlSetName: Swift.String? = nil,
            description: Swift.String? = nil,
            eventTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.controlSetId = controlSetId
            self.controlSetName = controlSetName
            self.description = description
            self.eventTime = eventTime
            self.id = id
            self.source = source
        }
    }
}

extension AuditManagerClientTypes.Notification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Notification(assessmentId: \(Swift.String(describing: assessmentId)), controlSetId: \(Swift.String(describing: controlSetId)), controlSetName: \(Swift.String(describing: controlSetName)), description: \(Swift.String(describing: description)), eventTime: \(Swift.String(describing: eventTime)), id: \(Swift.String(describing: id)), source: \(Swift.String(describing: source)), assessmentName: \"CONTENT_REDACTED\")"}
}

public struct ListNotificationsOutput: Swift.Sendable {
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The returned list of notifications.
    public var notifications: [AuditManagerClientTypes.Notification]?

    public init(
        nextToken: Swift.String? = nil,
        notifications: [AuditManagerClientTypes.Notification]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags that the ListTagsForResource API returned.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct RegisterAccountInput: Swift.Sendable {
    /// The delegated administrator account for Audit Manager.
    public var delegatedAdminAccount: Swift.String?
    /// The KMS key details.
    public var kmsKey: Swift.String?

    public init(
        delegatedAdminAccount: Swift.String? = nil,
        kmsKey: Swift.String? = nil
    )
    {
        self.delegatedAdminAccount = delegatedAdminAccount
        self.kmsKey = kmsKey
    }
}

public struct RegisterAccountOutput: Swift.Sendable {
    /// The status of the account registration request.
    public var status: AuditManagerClientTypes.AccountStatus?

    public init(
        status: AuditManagerClientTypes.AccountStatus? = nil
    )
    {
        self.status = status
    }
}

public struct RegisterOrganizationAdminAccountInput: Swift.Sendable {
    /// The identifier for the delegated administrator account.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

public struct RegisterOrganizationAdminAccountOutput: Swift.Sendable {
    /// The identifier for the delegated administrator account.
    public var adminAccountId: Swift.String?
    /// The identifier for the organization.
    public var organizationId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.organizationId = organizationId
    }
}

public struct StartAssessmentFrameworkShareInput: Swift.Sendable {
    /// An optional comment from the sender about the share request.
    public var comment: Swift.String?
    /// The Amazon Web Services account of the recipient.
    /// This member is required.
    public var destinationAccount: Swift.String?
    /// The Amazon Web Services Region of the recipient.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// The unique identifier for the custom framework to be shared.
    /// This member is required.
    public var frameworkId: Swift.String?

    public init(
        comment: Swift.String? = nil,
        destinationAccount: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        frameworkId: Swift.String? = nil
    )
    {
        self.comment = comment
        self.destinationAccount = destinationAccount
        self.destinationRegion = destinationRegion
        self.frameworkId = frameworkId
    }
}

public struct StartAssessmentFrameworkShareOutput: Swift.Sendable {
    /// The share request that's created by the StartAssessmentFrameworkShare API.
    public var assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest?

    public init(
        assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest? = nil
    )
    {
        self.assessmentFrameworkShareRequest = assessmentFrameworkShareRequest
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags that are associated with the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the specified resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name or key of the tag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAssessmentInput: Swift.Sendable {
    /// The description of the assessment.
    public var assessmentDescription: Swift.String?
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The name of the assessment to be updated.
    public var assessmentName: Swift.String?
    /// The assessment report storage destination for the assessment that's being updated.
    public var assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    /// The list of roles for the assessment.
    public var roles: [AuditManagerClientTypes.Role]?
    /// The scope of the assessment.
    /// This member is required.
    public var scope: AuditManagerClientTypes.Scope?

    public init(
        assessmentDescription: Swift.String? = nil,
        assessmentId: Swift.String? = nil,
        assessmentName: Swift.String? = nil,
        assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
        roles: [AuditManagerClientTypes.Role]? = nil,
        scope: AuditManagerClientTypes.Scope? = nil
    )
    {
        self.assessmentDescription = assessmentDescription
        self.assessmentId = assessmentId
        self.assessmentName = assessmentName
        self.assessmentReportsDestination = assessmentReportsDestination
        self.roles = roles
        self.scope = scope
    }
}

extension UpdateAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssessmentInput(assessmentId: \(Swift.String(describing: assessmentId)), assessmentDescription: \"CONTENT_REDACTED\", assessmentName: \"CONTENT_REDACTED\", assessmentReportsDestination: \"CONTENT_REDACTED\", roles: \"CONTENT_REDACTED\", scope: \"CONTENT_REDACTED\")"}
}

public struct UpdateAssessmentOutput: Swift.Sendable {
    /// The response object for the UpdateAssessment API. This is the name of the updated assessment.
    public var assessment: AuditManagerClientTypes.Assessment?

    public init(
        assessment: AuditManagerClientTypes.Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

public struct UpdateAssessmentControlInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The comment body text for the control.
    public var commentBody: Swift.String?
    /// The unique identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The status of the control.
    public var controlStatus: AuditManagerClientTypes.ControlStatus?

    public init(
        assessmentId: Swift.String? = nil,
        commentBody: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        controlStatus: AuditManagerClientTypes.ControlStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.commentBody = commentBody
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.controlStatus = controlStatus
    }
}

extension UpdateAssessmentControlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssessmentControlInput(assessmentId: \(Swift.String(describing: assessmentId)), controlId: \(Swift.String(describing: controlId)), controlSetId: \(Swift.String(describing: controlSetId)), controlStatus: \(Swift.String(describing: controlStatus)), commentBody: \"CONTENT_REDACTED\")"}
}

public struct UpdateAssessmentControlOutput: Swift.Sendable {
    /// The name of the updated control set that the UpdateAssessmentControl API returned.
    public var control: AuditManagerClientTypes.AssessmentControl?

    public init(
        control: AuditManagerClientTypes.AssessmentControl? = nil
    )
    {
        self.control = control
    }
}

public struct UpdateAssessmentControlSetStatusInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The comment that's related to the status update.
    /// This member is required.
    public var comment: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The status of the control set that's being updated.
    /// This member is required.
    public var status: AuditManagerClientTypes.ControlSetStatus?

    public init(
        assessmentId: Swift.String? = nil,
        comment: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        status: AuditManagerClientTypes.ControlSetStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.comment = comment
        self.controlSetId = controlSetId
        self.status = status
    }
}

extension UpdateAssessmentControlSetStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssessmentControlSetStatusInput(assessmentId: \(Swift.String(describing: assessmentId)), controlSetId: \(Swift.String(describing: controlSetId)), status: \(Swift.String(describing: status)), comment: \"CONTENT_REDACTED\")"}
}

public struct UpdateAssessmentControlSetStatusOutput: Swift.Sendable {
    /// The name of the updated control set that the UpdateAssessmentControlSetStatus API returned.
    public var controlSet: AuditManagerClientTypes.AssessmentControlSet?

    public init(
        controlSet: AuditManagerClientTypes.AssessmentControlSet? = nil
    )
    {
        self.controlSet = controlSet
    }
}

extension AuditManagerClientTypes {

    /// A controlSet entity that represents a collection of controls in Audit Manager. This doesn't contain the control set ID.
    public struct UpdateAssessmentFrameworkControlSet: Swift.Sendable {
        /// The list of controls that are contained within the control set.
        /// This member is required.
        public var controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]?
        /// The unique identifier for the control set.
        public var id: Swift.String?
        /// The name of the control set.
        /// This member is required.
        public var name: Swift.String?

        public init(
            controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.controls = controls
            self.id = id
            self.name = name
        }
    }
}

public struct UpdateAssessmentFrameworkInput: Swift.Sendable {
    /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
    public var complianceType: Swift.String?
    /// The control sets that are associated with the framework.
    /// This member is required.
    public var controlSets: [AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]?
    /// The description of the updated framework.
    public var description: Swift.String?
    /// The unique identifier for the framework.
    /// This member is required.
    public var frameworkId: Swift.String?
    /// The name of the framework to be updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        complianceType: Swift.String? = nil,
        controlSets: [AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]? = nil,
        description: Swift.String? = nil,
        frameworkId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.complianceType = complianceType
        self.controlSets = controlSets
        self.description = description
        self.frameworkId = frameworkId
        self.name = name
    }
}

extension UpdateAssessmentFrameworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssessmentFrameworkInput(controlSets: \(Swift.String(describing: controlSets)), description: \(Swift.String(describing: description)), frameworkId: \(Swift.String(describing: frameworkId)), name: \(Swift.String(describing: name)), complianceType: \"CONTENT_REDACTED\")"}
}

public struct UpdateAssessmentFrameworkOutput: Swift.Sendable {
    /// The name of the framework.
    public var framework: AuditManagerClientTypes.Framework?

    public init(
        framework: AuditManagerClientTypes.Framework? = nil
    )
    {
        self.framework = framework
    }
}

extension AuditManagerClientTypes {

    public enum ShareRequestAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accept
        case decline
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareRequestAction] {
            return [
                .accept,
                .decline,
                .revoke
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .decline: return "DECLINE"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateAssessmentFrameworkShareInput: Swift.Sendable {
    /// Specifies the update action for the share request.
    /// This member is required.
    public var action: AuditManagerClientTypes.ShareRequestAction?
    /// The unique identifier for the share request.
    /// This member is required.
    public var requestId: Swift.String?
    /// Specifies whether the share request is a sent request or a received request.
    /// This member is required.
    public var requestType: AuditManagerClientTypes.ShareRequestType?

    public init(
        action: AuditManagerClientTypes.ShareRequestAction? = nil,
        requestId: Swift.String? = nil,
        requestType: AuditManagerClientTypes.ShareRequestType? = nil
    )
    {
        self.action = action
        self.requestId = requestId
        self.requestType = requestType
    }
}

public struct UpdateAssessmentFrameworkShareOutput: Swift.Sendable {
    /// The updated share request that's returned by the UpdateAssessmentFrameworkShare operation.
    public var assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest?

    public init(
        assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest? = nil
    )
    {
        self.assessmentFrameworkShareRequest = assessmentFrameworkShareRequest
    }
}

public struct UpdateAssessmentStatusInput: Swift.Sendable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The current status of the assessment.
    /// This member is required.
    public var status: AuditManagerClientTypes.AssessmentStatus?

    public init(
        assessmentId: Swift.String? = nil,
        status: AuditManagerClientTypes.AssessmentStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.status = status
    }
}

public struct UpdateAssessmentStatusOutput: Swift.Sendable {
    /// The name of the updated assessment that the UpdateAssessmentStatus API returned.
    public var assessment: AuditManagerClientTypes.Assessment?

    public init(
        assessment: AuditManagerClientTypes.Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

public struct UpdateControlInput: Swift.Sendable {
    /// The recommended actions to carry out if the control isn't fulfilled.
    public var actionPlanInstructions: Swift.String?
    /// The title of the action plan for remediating the control.
    public var actionPlanTitle: Swift.String?
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The data mapping sources for the control.
    /// This member is required.
    public var controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]?
    /// The optional description of the control.
    public var description: Swift.String?
    /// The name of the updated control.
    /// This member is required.
    public var name: Swift.String?
    /// The steps that you should follow to determine if the control is met.
    public var testingInformation: Swift.String?

    public init(
        actionPlanInstructions: Swift.String? = nil,
        actionPlanTitle: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        testingInformation: Swift.String? = nil
    )
    {
        self.actionPlanInstructions = actionPlanInstructions
        self.actionPlanTitle = actionPlanTitle
        self.controlId = controlId
        self.controlMappingSources = controlMappingSources
        self.description = description
        self.name = name
        self.testingInformation = testingInformation
    }
}

extension UpdateControlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateControlInput(controlId: \(Swift.String(describing: controlId)), controlMappingSources: \(Swift.String(describing: controlMappingSources)), name: \(Swift.String(describing: name)), actionPlanInstructions: \"CONTENT_REDACTED\", actionPlanTitle: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", testingInformation: \"CONTENT_REDACTED\")"}
}

public struct UpdateControlOutput: Swift.Sendable {
    /// The name of the updated control set that the UpdateControl API returned.
    public var control: AuditManagerClientTypes.Control?

    public init(
        control: AuditManagerClientTypes.Control? = nil
    )
    {
        self.control = control
    }
}

public struct UpdateSettingsInput: Swift.Sendable {
    /// The default S3 destination bucket for storing assessment reports.
    public var defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    /// The default S3 destination bucket for storing evidence finder exports.
    public var defaultExportDestination: AuditManagerClientTypes.DefaultExportDestination?
    /// A list of the default audit owners.
    public var defaultProcessOwners: [AuditManagerClientTypes.Role]?
    /// The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.
    public var deregistrationPolicy: AuditManagerClientTypes.DeregistrationPolicy?
    /// Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder. When you use this attribute to disable evidence finder, Audit Manager deletes the event data store that’s used to query your evidence data. As a result, you can’t re-enable evidence finder and use the feature again. Your only alternative is to [deregister](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html) and then [re-register](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html) Audit Manager.
    public var evidenceFinderEnabled: Swift.Bool?
    /// The KMS key details.
    public var kmsKey: Swift.String?
    /// The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to.
    public var snsTopic: Swift.String?

    public init(
        defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
        defaultExportDestination: AuditManagerClientTypes.DefaultExportDestination? = nil,
        defaultProcessOwners: [AuditManagerClientTypes.Role]? = nil,
        deregistrationPolicy: AuditManagerClientTypes.DeregistrationPolicy? = nil,
        evidenceFinderEnabled: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        snsTopic: Swift.String? = nil
    )
    {
        self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
        self.defaultExportDestination = defaultExportDestination
        self.defaultProcessOwners = defaultProcessOwners
        self.deregistrationPolicy = deregistrationPolicy
        self.evidenceFinderEnabled = evidenceFinderEnabled
        self.kmsKey = kmsKey
        self.snsTopic = snsTopic
    }
}

extension UpdateSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSettingsInput(defaultExportDestination: \(Swift.String(describing: defaultExportDestination)), deregistrationPolicy: \(Swift.String(describing: deregistrationPolicy)), evidenceFinderEnabled: \(Swift.String(describing: evidenceFinderEnabled)), kmsKey: \(Swift.String(describing: kmsKey)), snsTopic: \(Swift.String(describing: snsTopic)), defaultAssessmentReportsDestination: \"CONTENT_REDACTED\", defaultProcessOwners: \"CONTENT_REDACTED\")"}
}

public struct UpdateSettingsOutput: Swift.Sendable {
    /// The current list of settings.
    public var settings: AuditManagerClientTypes.Settings?

    public init(
        settings: AuditManagerClientTypes.Settings? = nil
    )
    {
        self.settings = settings
    }
}

public struct ValidateAssessmentReportIntegrityInput: Swift.Sendable {
    /// The relative path of the Amazon S3 bucket that the assessment report is stored in.
    /// This member is required.
    public var s3RelativePath: Swift.String?

    public init(
        s3RelativePath: Swift.String? = nil
    )
    {
        self.s3RelativePath = s3RelativePath
    }
}

public struct ValidateAssessmentReportIntegrityOutput: Swift.Sendable {
    /// The signature algorithm that's used to code sign the assessment report file.
    public var signatureAlgorithm: Swift.String?
    /// The date and time signature that specifies when the assessment report was created.
    public var signatureDateTime: Swift.String?
    /// The unique identifier for the validation signature key.
    public var signatureKeyId: Swift.String?
    /// Specifies whether the signature key is valid.
    public var signatureValid: Swift.Bool?
    /// Represents any errors that occurred when validating the assessment report.
    public var validationErrors: [Swift.String]?

    public init(
        signatureAlgorithm: Swift.String? = nil,
        signatureDateTime: Swift.String? = nil,
        signatureKeyId: Swift.String? = nil,
        signatureValid: Swift.Bool? = nil,
        validationErrors: [Swift.String]? = nil
    )
    {
        self.signatureAlgorithm = signatureAlgorithm
        self.signatureDateTime = signatureDateTime
        self.signatureKeyId = signatureKeyId
        self.signatureValid = signatureValid
        self.validationErrors = validationErrors
    }
}

extension AssociateAssessmentReportEvidenceFolderInput {

    static func urlPathProvider(_ value: AssociateAssessmentReportEvidenceFolderInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/associateToAssessmentReport"
    }
}

extension BatchAssociateAssessmentReportEvidenceInput {

    static func urlPathProvider(_ value: BatchAssociateAssessmentReportEvidenceInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/batchAssociateToAssessmentReport"
    }
}

extension BatchCreateDelegationByAssessmentInput {

    static func urlPathProvider(_ value: BatchCreateDelegationByAssessmentInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/delegations"
    }
}

extension BatchDeleteDelegationByAssessmentInput {

    static func urlPathProvider(_ value: BatchDeleteDelegationByAssessmentInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/delegations"
    }
}

extension BatchDisassociateAssessmentReportEvidenceInput {

    static func urlPathProvider(_ value: BatchDisassociateAssessmentReportEvidenceInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/batchDisassociateFromAssessmentReport"
    }
}

extension BatchImportEvidenceToAssessmentControlInput {

    static func urlPathProvider(_ value: BatchImportEvidenceToAssessmentControlInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        guard let controlSetId = value.controlSetId else {
            return nil
        }
        guard let controlId = value.controlId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/controls/\(controlId.urlPercentEncoding())/evidence"
    }
}

extension CreateAssessmentInput {

    static func urlPathProvider(_ value: CreateAssessmentInput) -> Swift.String? {
        return "/assessments"
    }
}

extension CreateAssessmentFrameworkInput {

    static func urlPathProvider(_ value: CreateAssessmentFrameworkInput) -> Swift.String? {
        return "/assessmentFrameworks"
    }
}

extension CreateAssessmentReportInput {

    static func urlPathProvider(_ value: CreateAssessmentReportInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/reports"
    }
}

extension CreateControlInput {

    static func urlPathProvider(_ value: CreateControlInput) -> Swift.String? {
        return "/controls"
    }
}

extension DeleteAssessmentInput {

    static func urlPathProvider(_ value: DeleteAssessmentInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

extension DeleteAssessmentFrameworkInput {

    static func urlPathProvider(_ value: DeleteAssessmentFrameworkInput) -> Swift.String? {
        guard let frameworkId = value.frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())"
    }
}

extension DeleteAssessmentFrameworkShareInput {

    static func urlPathProvider(_ value: DeleteAssessmentFrameworkShareInput) -> Swift.String? {
        guard let requestId = value.requestId else {
            return nil
        }
        return "/assessmentFrameworkShareRequests/\(requestId.urlPercentEncoding())"
    }
}

extension DeleteAssessmentFrameworkShareInput {

    static func queryItemProvider(_ value: DeleteAssessmentFrameworkShareInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let requestType = value.requestType else {
            let message = "Creating a URL Query Item failed. requestType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let requestTypeQueryItem = Smithy.URIQueryItem(name: "requestType".urlPercentEncoding(), value: Swift.String(requestType.rawValue).urlPercentEncoding())
        items.append(requestTypeQueryItem)
        return items
    }
}

extension DeleteAssessmentReportInput {

    static func urlPathProvider(_ value: DeleteAssessmentReportInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        guard let assessmentReportId = value.assessmentReportId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/reports/\(assessmentReportId.urlPercentEncoding())"
    }
}

extension DeleteControlInput {

    static func urlPathProvider(_ value: DeleteControlInput) -> Swift.String? {
        guard let controlId = value.controlId else {
            return nil
        }
        return "/controls/\(controlId.urlPercentEncoding())"
    }
}

extension DeregisterAccountInput {

    static func urlPathProvider(_ value: DeregisterAccountInput) -> Swift.String? {
        return "/account/deregisterAccount"
    }
}

extension DeregisterOrganizationAdminAccountInput {

    static func urlPathProvider(_ value: DeregisterOrganizationAdminAccountInput) -> Swift.String? {
        return "/account/deregisterOrganizationAdminAccount"
    }
}

extension DisassociateAssessmentReportEvidenceFolderInput {

    static func urlPathProvider(_ value: DisassociateAssessmentReportEvidenceFolderInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/disassociateFromAssessmentReport"
    }
}

extension GetAccountStatusInput {

    static func urlPathProvider(_ value: GetAccountStatusInput) -> Swift.String? {
        return "/account/status"
    }
}

extension GetAssessmentInput {

    static func urlPathProvider(_ value: GetAssessmentInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

extension GetAssessmentFrameworkInput {

    static func urlPathProvider(_ value: GetAssessmentFrameworkInput) -> Swift.String? {
        guard let frameworkId = value.frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())"
    }
}

extension GetAssessmentReportUrlInput {

    static func urlPathProvider(_ value: GetAssessmentReportUrlInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        guard let assessmentReportId = value.assessmentReportId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/reports/\(assessmentReportId.urlPercentEncoding())/url"
    }
}

extension GetChangeLogsInput {

    static func urlPathProvider(_ value: GetChangeLogsInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/changelogs"
    }
}

extension GetChangeLogsInput {

    static func queryItemProvider(_ value: GetChangeLogsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let controlSetId = value.controlSetId {
            let controlSetIdQueryItem = Smithy.URIQueryItem(name: "controlSetId".urlPercentEncoding(), value: Swift.String(controlSetId).urlPercentEncoding())
            items.append(controlSetIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let controlId = value.controlId {
            let controlIdQueryItem = Smithy.URIQueryItem(name: "controlId".urlPercentEncoding(), value: Swift.String(controlId).urlPercentEncoding())
            items.append(controlIdQueryItem)
        }
        return items
    }
}

extension GetControlInput {

    static func urlPathProvider(_ value: GetControlInput) -> Swift.String? {
        guard let controlId = value.controlId else {
            return nil
        }
        return "/controls/\(controlId.urlPercentEncoding())"
    }
}

extension GetDelegationsInput {

    static func urlPathProvider(_ value: GetDelegationsInput) -> Swift.String? {
        return "/delegations"
    }
}

extension GetDelegationsInput {

    static func queryItemProvider(_ value: GetDelegationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetEvidenceInput {

    static func urlPathProvider(_ value: GetEvidenceInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        guard let controlSetId = value.controlSetId else {
            return nil
        }
        guard let evidenceFolderId = value.evidenceFolderId else {
            return nil
        }
        guard let evidenceId = value.evidenceId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/evidenceFolders/\(evidenceFolderId.urlPercentEncoding())/evidence/\(evidenceId.urlPercentEncoding())"
    }
}

extension GetEvidenceByEvidenceFolderInput {

    static func urlPathProvider(_ value: GetEvidenceByEvidenceFolderInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        guard let controlSetId = value.controlSetId else {
            return nil
        }
        guard let evidenceFolderId = value.evidenceFolderId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/evidenceFolders/\(evidenceFolderId.urlPercentEncoding())/evidence"
    }
}

extension GetEvidenceByEvidenceFolderInput {

    static func queryItemProvider(_ value: GetEvidenceByEvidenceFolderInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetEvidenceFileUploadUrlInput {

    static func urlPathProvider(_ value: GetEvidenceFileUploadUrlInput) -> Swift.String? {
        return "/evidenceFileUploadUrl"
    }
}

extension GetEvidenceFileUploadUrlInput {

    static func queryItemProvider(_ value: GetEvidenceFileUploadUrlInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let fileName = value.fileName else {
            let message = "Creating a URL Query Item failed. fileName is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let fileNameQueryItem = Smithy.URIQueryItem(name: "fileName".urlPercentEncoding(), value: Swift.String(fileName).urlPercentEncoding())
        items.append(fileNameQueryItem)
        return items
    }
}

extension GetEvidenceFolderInput {

    static func urlPathProvider(_ value: GetEvidenceFolderInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        guard let controlSetId = value.controlSetId else {
            return nil
        }
        guard let evidenceFolderId = value.evidenceFolderId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/evidenceFolders/\(evidenceFolderId.urlPercentEncoding())"
    }
}

extension GetEvidenceFoldersByAssessmentInput {

    static func urlPathProvider(_ value: GetEvidenceFoldersByAssessmentInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/evidenceFolders"
    }
}

extension GetEvidenceFoldersByAssessmentInput {

    static func queryItemProvider(_ value: GetEvidenceFoldersByAssessmentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetEvidenceFoldersByAssessmentControlInput {

    static func urlPathProvider(_ value: GetEvidenceFoldersByAssessmentControlInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        guard let controlSetId = value.controlSetId else {
            return nil
        }
        guard let controlId = value.controlId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/evidenceFolders-by-assessment-control/\(controlSetId.urlPercentEncoding())/\(controlId.urlPercentEncoding())"
    }
}

extension GetEvidenceFoldersByAssessmentControlInput {

    static func queryItemProvider(_ value: GetEvidenceFoldersByAssessmentControlInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetInsightsInput {

    static func urlPathProvider(_ value: GetInsightsInput) -> Swift.String? {
        return "/insights"
    }
}

extension GetInsightsByAssessmentInput {

    static func urlPathProvider(_ value: GetInsightsByAssessmentInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/insights/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

extension GetOrganizationAdminAccountInput {

    static func urlPathProvider(_ value: GetOrganizationAdminAccountInput) -> Swift.String? {
        return "/account/organizationAdminAccount"
    }
}

extension GetServicesInScopeInput {

    static func urlPathProvider(_ value: GetServicesInScopeInput) -> Swift.String? {
        return "/services"
    }
}

extension GetSettingsInput {

    static func urlPathProvider(_ value: GetSettingsInput) -> Swift.String? {
        guard let attribute = value.attribute else {
            return nil
        }
        return "/settings/\(attribute.rawValue.urlPercentEncoding())"
    }
}

extension ListAssessmentControlInsightsByControlDomainInput {

    static func urlPathProvider(_ value: ListAssessmentControlInsightsByControlDomainInput) -> Swift.String? {
        return "/insights/controls-by-assessment"
    }
}

extension ListAssessmentControlInsightsByControlDomainInput {

    static func queryItemProvider(_ value: ListAssessmentControlInsightsByControlDomainInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let controlDomainId = value.controlDomainId else {
            let message = "Creating a URL Query Item failed. controlDomainId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let controlDomainIdQueryItem = Smithy.URIQueryItem(name: "controlDomainId".urlPercentEncoding(), value: Swift.String(controlDomainId).urlPercentEncoding())
        items.append(controlDomainIdQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let assessmentId = value.assessmentId else {
            let message = "Creating a URL Query Item failed. assessmentId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let assessmentIdQueryItem = Smithy.URIQueryItem(name: "assessmentId".urlPercentEncoding(), value: Swift.String(assessmentId).urlPercentEncoding())
        items.append(assessmentIdQueryItem)
        return items
    }
}

extension ListAssessmentFrameworksInput {

    static func urlPathProvider(_ value: ListAssessmentFrameworksInput) -> Swift.String? {
        return "/assessmentFrameworks"
    }
}

extension ListAssessmentFrameworksInput {

    static func queryItemProvider(_ value: ListAssessmentFrameworksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let frameworkType = value.frameworkType else {
            let message = "Creating a URL Query Item failed. frameworkType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let frameworkTypeQueryItem = Smithy.URIQueryItem(name: "frameworkType".urlPercentEncoding(), value: Swift.String(frameworkType.rawValue).urlPercentEncoding())
        items.append(frameworkTypeQueryItem)
        return items
    }
}

extension ListAssessmentFrameworkShareRequestsInput {

    static func urlPathProvider(_ value: ListAssessmentFrameworkShareRequestsInput) -> Swift.String? {
        return "/assessmentFrameworkShareRequests"
    }
}

extension ListAssessmentFrameworkShareRequestsInput {

    static func queryItemProvider(_ value: ListAssessmentFrameworkShareRequestsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let requestType = value.requestType else {
            let message = "Creating a URL Query Item failed. requestType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let requestTypeQueryItem = Smithy.URIQueryItem(name: "requestType".urlPercentEncoding(), value: Swift.String(requestType.rawValue).urlPercentEncoding())
        items.append(requestTypeQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAssessmentReportsInput {

    static func urlPathProvider(_ value: ListAssessmentReportsInput) -> Swift.String? {
        return "/assessmentReports"
    }
}

extension ListAssessmentReportsInput {

    static func queryItemProvider(_ value: ListAssessmentReportsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAssessmentsInput {

    static func urlPathProvider(_ value: ListAssessmentsInput) -> Swift.String? {
        return "/assessments"
    }
}

extension ListAssessmentsInput {

    static func queryItemProvider(_ value: ListAssessmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListControlDomainInsightsInput {

    static func urlPathProvider(_ value: ListControlDomainInsightsInput) -> Swift.String? {
        return "/insights/control-domains"
    }
}

extension ListControlDomainInsightsInput {

    static func queryItemProvider(_ value: ListControlDomainInsightsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListControlDomainInsightsByAssessmentInput {

    static func urlPathProvider(_ value: ListControlDomainInsightsByAssessmentInput) -> Swift.String? {
        return "/insights/control-domains-by-assessment"
    }
}

extension ListControlDomainInsightsByAssessmentInput {

    static func queryItemProvider(_ value: ListControlDomainInsightsByAssessmentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let assessmentId = value.assessmentId else {
            let message = "Creating a URL Query Item failed. assessmentId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let assessmentIdQueryItem = Smithy.URIQueryItem(name: "assessmentId".urlPercentEncoding(), value: Swift.String(assessmentId).urlPercentEncoding())
        items.append(assessmentIdQueryItem)
        return items
    }
}

extension ListControlInsightsByControlDomainInput {

    static func urlPathProvider(_ value: ListControlInsightsByControlDomainInput) -> Swift.String? {
        return "/insights/controls"
    }
}

extension ListControlInsightsByControlDomainInput {

    static func queryItemProvider(_ value: ListControlInsightsByControlDomainInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let controlDomainId = value.controlDomainId else {
            let message = "Creating a URL Query Item failed. controlDomainId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let controlDomainIdQueryItem = Smithy.URIQueryItem(name: "controlDomainId".urlPercentEncoding(), value: Swift.String(controlDomainId).urlPercentEncoding())
        items.append(controlDomainIdQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListControlsInput {

    static func urlPathProvider(_ value: ListControlsInput) -> Swift.String? {
        return "/controls"
    }
}

extension ListControlsInput {

    static func queryItemProvider(_ value: ListControlsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let controlType = value.controlType else {
            let message = "Creating a URL Query Item failed. controlType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let controlTypeQueryItem = Smithy.URIQueryItem(name: "controlType".urlPercentEncoding(), value: Swift.String(controlType.rawValue).urlPercentEncoding())
        items.append(controlTypeQueryItem)
        if let controlCatalogId = value.controlCatalogId {
            let controlCatalogIdQueryItem = Smithy.URIQueryItem(name: "controlCatalogId".urlPercentEncoding(), value: Swift.String(controlCatalogId).urlPercentEncoding())
            items.append(controlCatalogIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKeywordsForDataSourceInput {

    static func urlPathProvider(_ value: ListKeywordsForDataSourceInput) -> Swift.String? {
        return "/dataSourceKeywords"
    }
}

extension ListKeywordsForDataSourceInput {

    static func queryItemProvider(_ value: ListKeywordsForDataSourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let source = value.source else {
            let message = "Creating a URL Query Item failed. source is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sourceQueryItem = Smithy.URIQueryItem(name: "source".urlPercentEncoding(), value: Swift.String(source.rawValue).urlPercentEncoding())
        items.append(sourceQueryItem)
        return items
    }
}

extension ListNotificationsInput {

    static func urlPathProvider(_ value: ListNotificationsInput) -> Swift.String? {
        return "/notifications"
    }
}

extension ListNotificationsInput {

    static func queryItemProvider(_ value: ListNotificationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension RegisterAccountInput {

    static func urlPathProvider(_ value: RegisterAccountInput) -> Swift.String? {
        return "/account/registerAccount"
    }
}

extension RegisterOrganizationAdminAccountInput {

    static func urlPathProvider(_ value: RegisterOrganizationAdminAccountInput) -> Swift.String? {
        return "/account/registerOrganizationAdminAccount"
    }
}

extension StartAssessmentFrameworkShareInput {

    static func urlPathProvider(_ value: StartAssessmentFrameworkShareInput) -> Swift.String? {
        guard let frameworkId = value.frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())/shareRequests"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAssessmentInput {

    static func urlPathProvider(_ value: UpdateAssessmentInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

extension UpdateAssessmentControlInput {

    static func urlPathProvider(_ value: UpdateAssessmentControlInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        guard let controlSetId = value.controlSetId else {
            return nil
        }
        guard let controlId = value.controlId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/controls/\(controlId.urlPercentEncoding())"
    }
}

extension UpdateAssessmentControlSetStatusInput {

    static func urlPathProvider(_ value: UpdateAssessmentControlSetStatusInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        guard let controlSetId = value.controlSetId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/status"
    }
}

extension UpdateAssessmentFrameworkInput {

    static func urlPathProvider(_ value: UpdateAssessmentFrameworkInput) -> Swift.String? {
        guard let frameworkId = value.frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())"
    }
}

extension UpdateAssessmentFrameworkShareInput {

    static func urlPathProvider(_ value: UpdateAssessmentFrameworkShareInput) -> Swift.String? {
        guard let requestId = value.requestId else {
            return nil
        }
        return "/assessmentFrameworkShareRequests/\(requestId.urlPercentEncoding())"
    }
}

extension UpdateAssessmentStatusInput {

    static func urlPathProvider(_ value: UpdateAssessmentStatusInput) -> Swift.String? {
        guard let assessmentId = value.assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/status"
    }
}

extension UpdateControlInput {

    static func urlPathProvider(_ value: UpdateControlInput) -> Swift.String? {
        guard let controlId = value.controlId else {
            return nil
        }
        return "/controls/\(controlId.urlPercentEncoding())"
    }
}

extension UpdateSettingsInput {

    static func urlPathProvider(_ value: UpdateSettingsInput) -> Swift.String? {
        return "/settings"
    }
}

extension ValidateAssessmentReportIntegrityInput {

    static func urlPathProvider(_ value: ValidateAssessmentReportIntegrityInput) -> Swift.String? {
        return "/assessmentReports/integrity"
    }
}

extension AssociateAssessmentReportEvidenceFolderInput {

    static func write(value: AssociateAssessmentReportEvidenceFolderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["evidenceFolderId"].write(value.evidenceFolderId)
    }
}

extension BatchAssociateAssessmentReportEvidenceInput {

    static func write(value: BatchAssociateAssessmentReportEvidenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["evidenceFolderId"].write(value.evidenceFolderId)
        try writer["evidenceIds"].writeList(value.evidenceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchCreateDelegationByAssessmentInput {

    static func write(value: BatchCreateDelegationByAssessmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createDelegationRequests"].writeList(value.createDelegationRequests, memberWritingClosure: AuditManagerClientTypes.CreateDelegationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteDelegationByAssessmentInput {

    static func write(value: BatchDeleteDelegationByAssessmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["delegationIds"].writeList(value.delegationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDisassociateAssessmentReportEvidenceInput {

    static func write(value: BatchDisassociateAssessmentReportEvidenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["evidenceFolderId"].write(value.evidenceFolderId)
        try writer["evidenceIds"].writeList(value.evidenceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchImportEvidenceToAssessmentControlInput {

    static func write(value: BatchImportEvidenceToAssessmentControlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["manualEvidence"].writeList(value.manualEvidence, memberWritingClosure: AuditManagerClientTypes.ManualEvidence.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAssessmentInput {

    static func write(value: CreateAssessmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentReportsDestination"].write(value.assessmentReportsDestination, with: AuditManagerClientTypes.AssessmentReportsDestination.write(value:to:))
        try writer["description"].write(value.description)
        try writer["frameworkId"].write(value.frameworkId)
        try writer["name"].write(value.name)
        try writer["roles"].writeList(value.roles, memberWritingClosure: AuditManagerClientTypes.Role.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scope"].write(value.scope, with: AuditManagerClientTypes.Scope.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAssessmentFrameworkInput {

    static func write(value: CreateAssessmentFrameworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["complianceType"].write(value.complianceType)
        try writer["controlSets"].writeList(value.controlSets, memberWritingClosure: AuditManagerClientTypes.CreateAssessmentFrameworkControlSet.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAssessmentReportInput {

    static func write(value: CreateAssessmentReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["queryStatement"].write(value.queryStatement)
    }
}

extension CreateControlInput {

    static func write(value: CreateControlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionPlanInstructions"].write(value.actionPlanInstructions)
        try writer["actionPlanTitle"].write(value.actionPlanTitle)
        try writer["controlMappingSources"].writeList(value.controlMappingSources, memberWritingClosure: AuditManagerClientTypes.CreateControlMappingSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["testingInformation"].write(value.testingInformation)
    }
}

extension DeregisterOrganizationAdminAccountInput {

    static func write(value: DeregisterOrganizationAdminAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adminAccountId"].write(value.adminAccountId)
    }
}

extension DisassociateAssessmentReportEvidenceFolderInput {

    static func write(value: DisassociateAssessmentReportEvidenceFolderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["evidenceFolderId"].write(value.evidenceFolderId)
    }
}

extension RegisterAccountInput {

    static func write(value: RegisterAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["delegatedAdminAccount"].write(value.delegatedAdminAccount)
        try writer["kmsKey"].write(value.kmsKey)
    }
}

extension RegisterOrganizationAdminAccountInput {

    static func write(value: RegisterOrganizationAdminAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adminAccountId"].write(value.adminAccountId)
    }
}

extension StartAssessmentFrameworkShareInput {

    static func write(value: StartAssessmentFrameworkShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["destinationAccount"].write(value.destinationAccount)
        try writer["destinationRegion"].write(value.destinationRegion)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAssessmentInput {

    static func write(value: UpdateAssessmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentDescription"].write(value.assessmentDescription)
        try writer["assessmentName"].write(value.assessmentName)
        try writer["assessmentReportsDestination"].write(value.assessmentReportsDestination, with: AuditManagerClientTypes.AssessmentReportsDestination.write(value:to:))
        try writer["roles"].writeList(value.roles, memberWritingClosure: AuditManagerClientTypes.Role.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scope"].write(value.scope, with: AuditManagerClientTypes.Scope.write(value:to:))
    }
}

extension UpdateAssessmentControlInput {

    static func write(value: UpdateAssessmentControlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commentBody"].write(value.commentBody)
        try writer["controlStatus"].write(value.controlStatus)
    }
}

extension UpdateAssessmentControlSetStatusInput {

    static func write(value: UpdateAssessmentControlSetStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["status"].write(value.status)
    }
}

extension UpdateAssessmentFrameworkInput {

    static func write(value: UpdateAssessmentFrameworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["complianceType"].write(value.complianceType)
        try writer["controlSets"].writeList(value.controlSets, memberWritingClosure: AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension UpdateAssessmentFrameworkShareInput {

    static func write(value: UpdateAssessmentFrameworkShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["requestType"].write(value.requestType)
    }
}

extension UpdateAssessmentStatusInput {

    static func write(value: UpdateAssessmentStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension UpdateControlInput {

    static func write(value: UpdateControlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionPlanInstructions"].write(value.actionPlanInstructions)
        try writer["actionPlanTitle"].write(value.actionPlanTitle)
        try writer["controlMappingSources"].writeList(value.controlMappingSources, memberWritingClosure: AuditManagerClientTypes.ControlMappingSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["testingInformation"].write(value.testingInformation)
    }
}

extension UpdateSettingsInput {

    static func write(value: UpdateSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultAssessmentReportsDestination"].write(value.defaultAssessmentReportsDestination, with: AuditManagerClientTypes.AssessmentReportsDestination.write(value:to:))
        try writer["defaultExportDestination"].write(value.defaultExportDestination, with: AuditManagerClientTypes.DefaultExportDestination.write(value:to:))
        try writer["defaultProcessOwners"].writeList(value.defaultProcessOwners, memberWritingClosure: AuditManagerClientTypes.Role.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deregistrationPolicy"].write(value.deregistrationPolicy, with: AuditManagerClientTypes.DeregistrationPolicy.write(value:to:))
        try writer["evidenceFinderEnabled"].write(value.evidenceFinderEnabled)
        try writer["kmsKey"].write(value.kmsKey)
        try writer["snsTopic"].write(value.snsTopic)
    }
}

extension ValidateAssessmentReportIntegrityInput {

    static func write(value: ValidateAssessmentReportIntegrityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3RelativePath"].write(value.s3RelativePath)
    }
}

extension AssociateAssessmentReportEvidenceFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAssessmentReportEvidenceFolderOutput {
        return AssociateAssessmentReportEvidenceFolderOutput()
    }
}

extension BatchAssociateAssessmentReportEvidenceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchAssociateAssessmentReportEvidenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAssociateAssessmentReportEvidenceOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AssessmentReportEvidenceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.evidenceIds = try reader["evidenceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchCreateDelegationByAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateDelegationByAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateDelegationByAssessmentOutput()
        value.delegations = try reader["delegations"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Delegation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.BatchCreateDelegationByAssessmentError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteDelegationByAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteDelegationByAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteDelegationByAssessmentOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDisassociateAssessmentReportEvidenceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisassociateAssessmentReportEvidenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisassociateAssessmentReportEvidenceOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AssessmentReportEvidenceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.evidenceIds = try reader["evidenceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchImportEvidenceToAssessmentControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchImportEvidenceToAssessmentControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchImportEvidenceToAssessmentControlOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssessmentOutput()
        value.assessment = try reader["assessment"].readIfPresent(with: AuditManagerClientTypes.Assessment.read(from:))
        return value
    }
}

extension CreateAssessmentFrameworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssessmentFrameworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssessmentFrameworkOutput()
        value.framework = try reader["framework"].readIfPresent(with: AuditManagerClientTypes.Framework.read(from:))
        return value
    }
}

extension CreateAssessmentReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssessmentReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssessmentReportOutput()
        value.assessmentReport = try reader["assessmentReport"].readIfPresent(with: AuditManagerClientTypes.AssessmentReport.read(from:))
        return value
    }
}

extension CreateControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateControlOutput()
        value.control = try reader["control"].readIfPresent(with: AuditManagerClientTypes.Control.read(from:))
        return value
    }
}

extension DeleteAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssessmentOutput {
        return DeleteAssessmentOutput()
    }
}

extension DeleteAssessmentFrameworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssessmentFrameworkOutput {
        return DeleteAssessmentFrameworkOutput()
    }
}

extension DeleteAssessmentFrameworkShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssessmentFrameworkShareOutput {
        return DeleteAssessmentFrameworkShareOutput()
    }
}

extension DeleteAssessmentReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssessmentReportOutput {
        return DeleteAssessmentReportOutput()
    }
}

extension DeleteControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteControlOutput {
        return DeleteControlOutput()
    }
}

extension DeregisterAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterAccountOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeregisterOrganizationAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterOrganizationAdminAccountOutput {
        return DeregisterOrganizationAdminAccountOutput()
    }
}

extension DisassociateAssessmentReportEvidenceFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateAssessmentReportEvidenceFolderOutput {
        return DisassociateAssessmentReportEvidenceFolderOutput()
    }
}

extension GetAccountStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountStatusOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssessmentOutput()
        value.assessment = try reader["assessment"].readIfPresent(with: AuditManagerClientTypes.Assessment.read(from:))
        value.userRole = try reader["userRole"].readIfPresent(with: AuditManagerClientTypes.Role.read(from:))
        return value
    }
}

extension GetAssessmentFrameworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssessmentFrameworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssessmentFrameworkOutput()
        value.framework = try reader["framework"].readIfPresent(with: AuditManagerClientTypes.Framework.read(from:))
        return value
    }
}

extension GetAssessmentReportUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssessmentReportUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssessmentReportUrlOutput()
        value.preSignedUrl = try reader["preSignedUrl"].readIfPresent(with: AuditManagerClientTypes.URL.read(from:))
        return value
    }
}

extension GetChangeLogsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChangeLogsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChangeLogsOutput()
        value.changeLogs = try reader["changeLogs"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ChangeLog.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetControlOutput()
        value.control = try reader["control"].readIfPresent(with: AuditManagerClientTypes.Control.read(from:))
        return value
    }
}

extension GetDelegationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDelegationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDelegationsOutput()
        value.delegations = try reader["delegations"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.DelegationMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetEvidenceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEvidenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEvidenceOutput()
        value.evidence = try reader["evidence"].readIfPresent(with: AuditManagerClientTypes.Evidence.read(from:))
        return value
    }
}

extension GetEvidenceByEvidenceFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEvidenceByEvidenceFolderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEvidenceByEvidenceFolderOutput()
        value.evidence = try reader["evidence"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Evidence.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetEvidenceFileUploadUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEvidenceFileUploadUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEvidenceFileUploadUrlOutput()
        value.evidenceFileName = try reader["evidenceFileName"].readIfPresent()
        value.uploadUrl = try reader["uploadUrl"].readIfPresent()
        return value
    }
}

extension GetEvidenceFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEvidenceFolderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEvidenceFolderOutput()
        value.evidenceFolder = try reader["evidenceFolder"].readIfPresent(with: AuditManagerClientTypes.AssessmentEvidenceFolder.read(from:))
        return value
    }
}

extension GetEvidenceFoldersByAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEvidenceFoldersByAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEvidenceFoldersByAssessmentOutput()
        value.evidenceFolders = try reader["evidenceFolders"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AssessmentEvidenceFolder.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetEvidenceFoldersByAssessmentControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEvidenceFoldersByAssessmentControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEvidenceFoldersByAssessmentControlOutput()
        value.evidenceFolders = try reader["evidenceFolders"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AssessmentEvidenceFolder.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetInsightsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInsightsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInsightsOutput()
        value.insights = try reader["insights"].readIfPresent(with: AuditManagerClientTypes.Insights.read(from:))
        return value
    }
}

extension GetInsightsByAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInsightsByAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInsightsByAssessmentOutput()
        value.insights = try reader["insights"].readIfPresent(with: AuditManagerClientTypes.InsightsByAssessment.read(from:))
        return value
    }
}

extension GetOrganizationAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOrganizationAdminAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOrganizationAdminAccountOutput()
        value.adminAccountId = try reader["adminAccountId"].readIfPresent()
        value.organizationId = try reader["organizationId"].readIfPresent()
        return value
    }
}

extension GetServicesInScopeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServicesInScopeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServicesInScopeOutput()
        value.serviceMetadata = try reader["serviceMetadata"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ServiceMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSettingsOutput()
        value.settings = try reader["settings"].readIfPresent(with: AuditManagerClientTypes.Settings.read(from:))
        return value
    }
}

extension ListAssessmentControlInsightsByControlDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssessmentControlInsightsByControlDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssessmentControlInsightsByControlDomainOutput()
        value.controlInsightsByAssessment = try reader["controlInsightsByAssessment"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssessmentFrameworksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssessmentFrameworksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssessmentFrameworksOutput()
        value.frameworkMetadataList = try reader["frameworkMetadataList"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AssessmentFrameworkMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssessmentFrameworkShareRequestsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssessmentFrameworkShareRequestsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssessmentFrameworkShareRequestsOutput()
        value.assessmentFrameworkShareRequests = try reader["assessmentFrameworkShareRequests"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AssessmentFrameworkShareRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssessmentReportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssessmentReportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssessmentReportsOutput()
        value.assessmentReports = try reader["assessmentReports"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AssessmentReportMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssessmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssessmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssessmentsOutput()
        value.assessmentMetadata = try reader["assessmentMetadata"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AssessmentMetadataItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListControlDomainInsightsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListControlDomainInsightsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListControlDomainInsightsOutput()
        value.controlDomainInsights = try reader["controlDomainInsights"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ControlDomainInsights.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListControlDomainInsightsByAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListControlDomainInsightsByAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListControlDomainInsightsByAssessmentOutput()
        value.controlDomainInsights = try reader["controlDomainInsights"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ControlDomainInsights.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListControlInsightsByControlDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListControlInsightsByControlDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListControlInsightsByControlDomainOutput()
        value.controlInsightsMetadata = try reader["controlInsightsMetadata"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ControlInsightsMetadataItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListControlsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListControlsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListControlsOutput()
        value.controlMetadataList = try reader["controlMetadataList"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ControlMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListKeywordsForDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKeywordsForDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKeywordsForDataSourceOutput()
        value.keywords = try reader["keywords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListNotificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNotificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.notifications = try reader["notifications"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Notification.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RegisterAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterAccountOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension RegisterOrganizationAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterOrganizationAdminAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterOrganizationAdminAccountOutput()
        value.adminAccountId = try reader["adminAccountId"].readIfPresent()
        value.organizationId = try reader["organizationId"].readIfPresent()
        return value
    }
}

extension StartAssessmentFrameworkShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAssessmentFrameworkShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAssessmentFrameworkShareOutput()
        value.assessmentFrameworkShareRequest = try reader["assessmentFrameworkShareRequest"].readIfPresent(with: AuditManagerClientTypes.AssessmentFrameworkShareRequest.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssessmentOutput()
        value.assessment = try reader["assessment"].readIfPresent(with: AuditManagerClientTypes.Assessment.read(from:))
        return value
    }
}

extension UpdateAssessmentControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssessmentControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssessmentControlOutput()
        value.control = try reader["control"].readIfPresent(with: AuditManagerClientTypes.AssessmentControl.read(from:))
        return value
    }
}

extension UpdateAssessmentControlSetStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssessmentControlSetStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssessmentControlSetStatusOutput()
        value.controlSet = try reader["controlSet"].readIfPresent(with: AuditManagerClientTypes.AssessmentControlSet.read(from:))
        return value
    }
}

extension UpdateAssessmentFrameworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssessmentFrameworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssessmentFrameworkOutput()
        value.framework = try reader["framework"].readIfPresent(with: AuditManagerClientTypes.Framework.read(from:))
        return value
    }
}

extension UpdateAssessmentFrameworkShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssessmentFrameworkShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssessmentFrameworkShareOutput()
        value.assessmentFrameworkShareRequest = try reader["assessmentFrameworkShareRequest"].readIfPresent(with: AuditManagerClientTypes.AssessmentFrameworkShareRequest.read(from:))
        return value
    }
}

extension UpdateAssessmentStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssessmentStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssessmentStatusOutput()
        value.assessment = try reader["assessment"].readIfPresent(with: AuditManagerClientTypes.Assessment.read(from:))
        return value
    }
}

extension UpdateControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateControlOutput()
        value.control = try reader["control"].readIfPresent(with: AuditManagerClientTypes.Control.read(from:))
        return value
    }
}

extension UpdateSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSettingsOutput()
        value.settings = try reader["settings"].readIfPresent(with: AuditManagerClientTypes.Settings.read(from:))
        return value
    }
}

extension ValidateAssessmentReportIntegrityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ValidateAssessmentReportIntegrityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ValidateAssessmentReportIntegrityOutput()
        value.signatureAlgorithm = try reader["signatureAlgorithm"].readIfPresent()
        value.signatureDateTime = try reader["signatureDateTime"].readIfPresent()
        value.signatureKeyId = try reader["signatureKeyId"].readIfPresent()
        value.signatureValid = try reader["signatureValid"].readIfPresent()
        value.validationErrors = try reader["validationErrors"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

enum AssociateAssessmentReportEvidenceFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchAssociateAssessmentReportEvidenceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchCreateDelegationByAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteDelegationByAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisassociateAssessmentReportEvidenceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchImportEvidenceToAssessmentControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssessmentFrameworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssessmentReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssessmentFrameworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssessmentFrameworkShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssessmentReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterOrganizationAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateAssessmentReportEvidenceFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssessmentFrameworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssessmentReportUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChangeLogsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDelegationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEvidenceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEvidenceByEvidenceFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEvidenceFileUploadUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEvidenceFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEvidenceFoldersByAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEvidenceFoldersByAssessmentControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInsightsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInsightsByAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOrganizationAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServicesInScopeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssessmentControlInsightsByControlDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssessmentFrameworksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssessmentFrameworkShareRequestsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssessmentReportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssessmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListControlDomainInsightsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListControlDomainInsightsByAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListControlInsightsByControlDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListControlsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKeywordsForDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNotificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterOrganizationAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAssessmentFrameworkShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssessmentControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssessmentControlSetStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssessmentFrameworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssessmentFrameworkShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssessmentStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ValidateAssessmentReportIntegrityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["fields"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AuditManagerClientTypes.AssessmentReportEvidenceError {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentReportEvidenceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentReportEvidenceError()
        value.evidenceId = try reader["evidenceId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.Delegation {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Delegation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Delegation()
        value.id = try reader["id"].readIfPresent()
        value.assessmentName = try reader["assessmentName"].readIfPresent()
        value.assessmentId = try reader["assessmentId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.roleType = try reader["roleType"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["lastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.controlSetId = try reader["controlSetId"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.BatchCreateDelegationByAssessmentError {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.BatchCreateDelegationByAssessmentError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.BatchCreateDelegationByAssessmentError()
        value.createDelegationRequest = try reader["createDelegationRequest"].readIfPresent(with: AuditManagerClientTypes.CreateDelegationRequest.read(from:))
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.CreateDelegationRequest {

    static func write(value: AuditManagerClientTypes.CreateDelegationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["controlSetId"].write(value.controlSetId)
        try writer["roleArn"].write(value.roleArn)
        try writer["roleType"].write(value.roleType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.CreateDelegationRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.CreateDelegationRequest()
        value.comment = try reader["comment"].readIfPresent()
        value.controlSetId = try reader["controlSetId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.roleType = try reader["roleType"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError()
        value.delegationId = try reader["delegationId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError()
        value.manualEvidence = try reader["manualEvidence"].readIfPresent(with: AuditManagerClientTypes.ManualEvidence.read(from:))
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.ManualEvidence {

    static func write(value: AuditManagerClientTypes.ManualEvidence?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["evidenceFileName"].write(value.evidenceFileName)
        try writer["s3ResourcePath"].write(value.s3ResourcePath)
        try writer["textResponse"].write(value.textResponse)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ManualEvidence {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ManualEvidence()
        value.s3ResourcePath = try reader["s3ResourcePath"].readIfPresent()
        value.textResponse = try reader["textResponse"].readIfPresent()
        value.evidenceFileName = try reader["evidenceFileName"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.Assessment {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Assessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Assessment()
        value.arn = try reader["arn"].readIfPresent()
        value.awsAccount = try reader["awsAccount"].readIfPresent(with: AuditManagerClientTypes.AWSAccount.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: AuditManagerClientTypes.AssessmentMetadata.read(from:))
        value.framework = try reader["framework"].readIfPresent(with: AuditManagerClientTypes.AssessmentFramework.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AuditManagerClientTypes.AssessmentFramework {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentFramework {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentFramework()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.metadata = try reader["metadata"].readIfPresent(with: AuditManagerClientTypes.FrameworkMetadata.read(from:))
        value.controlSets = try reader["controlSets"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AssessmentControlSet.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AuditManagerClientTypes.AssessmentControlSet {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentControlSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentControlSet()
        value.id = try reader["id"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.roles = try reader["roles"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Role.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.controls = try reader["controls"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AssessmentControl.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.delegations = try reader["delegations"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Delegation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.systemEvidenceCount = try reader["systemEvidenceCount"].readIfPresent() ?? 0
        value.manualEvidenceCount = try reader["manualEvidenceCount"].readIfPresent() ?? 0
        return value
    }
}

extension AuditManagerClientTypes.AssessmentControl {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentControl()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.response = try reader["response"].readIfPresent()
        value.comments = try reader["comments"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ControlComment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.evidenceSources = try reader["evidenceSources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.evidenceCount = try reader["evidenceCount"].readIfPresent() ?? 0
        value.assessmentReportEvidenceCount = try reader["assessmentReportEvidenceCount"].readIfPresent() ?? 0
        return value
    }
}

extension AuditManagerClientTypes.ControlComment {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ControlComment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ControlComment()
        value.authorName = try reader["authorName"].readIfPresent()
        value.commentBody = try reader["commentBody"].readIfPresent()
        value.postedDate = try reader["postedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.Role {

    static func write(value: AuditManagerClientTypes.Role?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["roleType"].write(value.roleType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Role {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Role()
        value.roleType = try reader["roleType"].readIfPresent() ?? .sdkUnknown("")
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension AuditManagerClientTypes.FrameworkMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.FrameworkMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.FrameworkMetadata()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.logo = try reader["logo"].readIfPresent()
        value.complianceType = try reader["complianceType"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.AssessmentMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentMetadata()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.complianceType = try reader["complianceType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.assessmentReportsDestination = try reader["assessmentReportsDestination"].readIfPresent(with: AuditManagerClientTypes.AssessmentReportsDestination.read(from:))
        value.scope = try reader["scope"].readIfPresent(with: AuditManagerClientTypes.Scope.read(from:))
        value.roles = try reader["roles"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Role.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.delegations = try reader["delegations"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Delegation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["lastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.Scope {

    static func write(value: AuditManagerClientTypes.Scope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsAccounts"].writeList(value.awsAccounts, memberWritingClosure: AuditManagerClientTypes.AWSAccount.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["awsServices"].writeList(value.awsServices, memberWritingClosure: AuditManagerClientTypes.AWSService.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Scope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Scope()
        value.awsAccounts = try reader["awsAccounts"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AWSAccount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsServices = try reader["awsServices"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.AWSService.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AuditManagerClientTypes.AWSService {

    static func write(value: AuditManagerClientTypes.AWSService?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serviceName"].write(value.serviceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AWSService {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AWSService()
        value.serviceName = try reader["serviceName"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.AWSAccount {

    static func write(value: AuditManagerClientTypes.AWSAccount?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["emailAddress"].write(value.emailAddress)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AWSAccount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AWSAccount()
        value.id = try reader["id"].readIfPresent()
        value.emailAddress = try reader["emailAddress"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.AssessmentReportsDestination {

    static func write(value: AuditManagerClientTypes.AssessmentReportsDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destination"].write(value.destination)
        try writer["destinationType"].write(value.destinationType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentReportsDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentReportsDestination()
        value.destinationType = try reader["destinationType"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.Framework {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Framework {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Framework()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.complianceType = try reader["complianceType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.logo = try reader["logo"].readIfPresent()
        value.controlSources = try reader["controlSources"].readIfPresent()
        value.controlSets = try reader["controlSets"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ControlSet.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.lastUpdatedBy = try reader["lastUpdatedBy"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AuditManagerClientTypes.ControlSet {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ControlSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ControlSet()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.controls = try reader["controls"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Control.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AuditManagerClientTypes.Control {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Control {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Control()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.testingInformation = try reader["testingInformation"].readIfPresent()
        value.actionPlanTitle = try reader["actionPlanTitle"].readIfPresent()
        value.actionPlanInstructions = try reader["actionPlanInstructions"].readIfPresent()
        value.controlSources = try reader["controlSources"].readIfPresent()
        value.controlMappingSources = try reader["controlMappingSources"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.ControlMappingSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.lastUpdatedBy = try reader["lastUpdatedBy"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.ControlMappingSource {

    static func write(value: AuditManagerClientTypes.ControlMappingSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceDescription"].write(value.sourceDescription)
        try writer["sourceFrequency"].write(value.sourceFrequency)
        try writer["sourceId"].write(value.sourceId)
        try writer["sourceKeyword"].write(value.sourceKeyword, with: AuditManagerClientTypes.SourceKeyword.write(value:to:))
        try writer["sourceName"].write(value.sourceName)
        try writer["sourceSetUpOption"].write(value.sourceSetUpOption)
        try writer["sourceType"].write(value.sourceType)
        try writer["troubleshootingText"].write(value.troubleshootingText)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ControlMappingSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ControlMappingSource()
        value.sourceId = try reader["sourceId"].readIfPresent()
        value.sourceName = try reader["sourceName"].readIfPresent()
        value.sourceDescription = try reader["sourceDescription"].readIfPresent()
        value.sourceSetUpOption = try reader["sourceSetUpOption"].readIfPresent()
        value.sourceType = try reader["sourceType"].readIfPresent()
        value.sourceKeyword = try reader["sourceKeyword"].readIfPresent(with: AuditManagerClientTypes.SourceKeyword.read(from:))
        value.sourceFrequency = try reader["sourceFrequency"].readIfPresent()
        value.troubleshootingText = try reader["troubleshootingText"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.SourceKeyword {

    static func write(value: AuditManagerClientTypes.SourceKeyword?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keywordInputType"].write(value.keywordInputType)
        try writer["keywordValue"].write(value.keywordValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.SourceKeyword {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.SourceKeyword()
        value.keywordInputType = try reader["keywordInputType"].readIfPresent()
        value.keywordValue = try reader["keywordValue"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.AssessmentReport {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentReport()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.assessmentId = try reader["assessmentId"].readIfPresent()
        value.assessmentName = try reader["assessmentName"].readIfPresent()
        value.author = try reader["author"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.URL {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.URL {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.URL()
        value.hyperlinkName = try reader["hyperlinkName"].readIfPresent()
        value.link = try reader["link"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.ChangeLog {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ChangeLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ChangeLog()
        value.objectType = try reader["objectType"].readIfPresent()
        value.objectName = try reader["objectName"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.DelegationMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.DelegationMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.DelegationMetadata()
        value.id = try reader["id"].readIfPresent()
        value.assessmentName = try reader["assessmentName"].readIfPresent()
        value.assessmentId = try reader["assessmentId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.controlSetName = try reader["controlSetName"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.Evidence {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Evidence {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Evidence()
        value.dataSource = try reader["dataSource"].readIfPresent()
        value.evidenceAwsAccountId = try reader["evidenceAwsAccountId"].readIfPresent()
        value.time = try reader["time"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.eventSource = try reader["eventSource"].readIfPresent()
        value.eventName = try reader["eventName"].readIfPresent()
        value.evidenceByType = try reader["evidenceByType"].readIfPresent()
        value.resourcesIncluded = try reader["resourcesIncluded"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.iamId = try reader["iamId"].readIfPresent()
        value.complianceCheck = try reader["complianceCheck"].readIfPresent()
        value.awsOrganization = try reader["awsOrganization"].readIfPresent()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.evidenceFolderId = try reader["evidenceFolderId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.assessmentReportSelection = try reader["assessmentReportSelection"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Resource()
        value.arn = try reader["arn"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.complianceCheck = try reader["complianceCheck"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.AssessmentEvidenceFolder {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentEvidenceFolder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentEvidenceFolder()
        value.name = try reader["name"].readIfPresent()
        value.date = try reader["date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.assessmentId = try reader["assessmentId"].readIfPresent()
        value.controlSetId = try reader["controlSetId"].readIfPresent()
        value.controlId = try reader["controlId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.dataSource = try reader["dataSource"].readIfPresent()
        value.author = try reader["author"].readIfPresent()
        value.totalEvidence = try reader["totalEvidence"].readIfPresent() ?? 0
        value.assessmentReportSelectionCount = try reader["assessmentReportSelectionCount"].readIfPresent() ?? 0
        value.controlName = try reader["controlName"].readIfPresent()
        value.evidenceResourcesIncludedCount = try reader["evidenceResourcesIncludedCount"].readIfPresent() ?? 0
        value.evidenceByTypeConfigurationDataCount = try reader["evidenceByTypeConfigurationDataCount"].readIfPresent() ?? 0
        value.evidenceByTypeManualCount = try reader["evidenceByTypeManualCount"].readIfPresent() ?? 0
        value.evidenceByTypeComplianceCheckCount = try reader["evidenceByTypeComplianceCheckCount"].readIfPresent() ?? 0
        value.evidenceByTypeComplianceCheckIssuesCount = try reader["evidenceByTypeComplianceCheckIssuesCount"].readIfPresent() ?? 0
        value.evidenceByTypeUserActivityCount = try reader["evidenceByTypeUserActivityCount"].readIfPresent() ?? 0
        value.evidenceAwsServiceSourceCount = try reader["evidenceAwsServiceSourceCount"].readIfPresent() ?? 0
        return value
    }
}

extension AuditManagerClientTypes.Insights {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Insights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Insights()
        value.activeAssessmentsCount = try reader["activeAssessmentsCount"].readIfPresent()
        value.noncompliantEvidenceCount = try reader["noncompliantEvidenceCount"].readIfPresent()
        value.compliantEvidenceCount = try reader["compliantEvidenceCount"].readIfPresent()
        value.inconclusiveEvidenceCount = try reader["inconclusiveEvidenceCount"].readIfPresent()
        value.assessmentControlsCountByNoncompliantEvidence = try reader["assessmentControlsCountByNoncompliantEvidence"].readIfPresent()
        value.totalAssessmentControlsCount = try reader["totalAssessmentControlsCount"].readIfPresent()
        value.lastUpdated = try reader["lastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.InsightsByAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.InsightsByAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.InsightsByAssessment()
        value.noncompliantEvidenceCount = try reader["noncompliantEvidenceCount"].readIfPresent()
        value.compliantEvidenceCount = try reader["compliantEvidenceCount"].readIfPresent()
        value.inconclusiveEvidenceCount = try reader["inconclusiveEvidenceCount"].readIfPresent()
        value.assessmentControlsCountByNoncompliantEvidence = try reader["assessmentControlsCountByNoncompliantEvidence"].readIfPresent()
        value.totalAssessmentControlsCount = try reader["totalAssessmentControlsCount"].readIfPresent()
        value.lastUpdated = try reader["lastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.ServiceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ServiceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ServiceMetadata()
        value.name = try reader["name"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.category = try reader["category"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.Settings {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Settings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Settings()
        value.isAwsOrgEnabled = try reader["isAwsOrgEnabled"].readIfPresent()
        value.snsTopic = try reader["snsTopic"].readIfPresent()
        value.defaultAssessmentReportsDestination = try reader["defaultAssessmentReportsDestination"].readIfPresent(with: AuditManagerClientTypes.AssessmentReportsDestination.read(from:))
        value.defaultProcessOwners = try reader["defaultProcessOwners"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Role.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKey = try reader["kmsKey"].readIfPresent()
        value.evidenceFinderEnablement = try reader["evidenceFinderEnablement"].readIfPresent(with: AuditManagerClientTypes.EvidenceFinderEnablement.read(from:))
        value.deregistrationPolicy = try reader["deregistrationPolicy"].readIfPresent(with: AuditManagerClientTypes.DeregistrationPolicy.read(from:))
        value.defaultExportDestination = try reader["defaultExportDestination"].readIfPresent(with: AuditManagerClientTypes.DefaultExportDestination.read(from:))
        return value
    }
}

extension AuditManagerClientTypes.DefaultExportDestination {

    static func write(value: AuditManagerClientTypes.DefaultExportDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destination"].write(value.destination)
        try writer["destinationType"].write(value.destinationType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.DefaultExportDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.DefaultExportDestination()
        value.destinationType = try reader["destinationType"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.DeregistrationPolicy {

    static func write(value: AuditManagerClientTypes.DeregistrationPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deleteResources"].write(value.deleteResources)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.DeregistrationPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.DeregistrationPolicy()
        value.deleteResources = try reader["deleteResources"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.EvidenceFinderEnablement {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.EvidenceFinderEnablement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.EvidenceFinderEnablement()
        value.eventDataStoreArn = try reader["eventDataStoreArn"].readIfPresent()
        value.enablementStatus = try reader["enablementStatus"].readIfPresent()
        value.backfillStatus = try reader["backfillStatus"].readIfPresent()
        value.error = try reader["error"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.evidenceInsights = try reader["evidenceInsights"].readIfPresent(with: AuditManagerClientTypes.EvidenceInsights.read(from:))
        value.controlSetName = try reader["controlSetName"].readIfPresent()
        value.lastUpdated = try reader["lastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.EvidenceInsights {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.EvidenceInsights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.EvidenceInsights()
        value.noncompliantEvidenceCount = try reader["noncompliantEvidenceCount"].readIfPresent()
        value.compliantEvidenceCount = try reader["compliantEvidenceCount"].readIfPresent()
        value.inconclusiveEvidenceCount = try reader["inconclusiveEvidenceCount"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.AssessmentFrameworkMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentFrameworkMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentFrameworkMetadata()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.logo = try reader["logo"].readIfPresent()
        value.complianceType = try reader["complianceType"].readIfPresent()
        value.controlsCount = try reader["controlsCount"].readIfPresent() ?? 0
        value.controlSetsCount = try reader["controlSetsCount"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.AssessmentFrameworkShareRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentFrameworkShareRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentFrameworkShareRequest()
        value.id = try reader["id"].readIfPresent()
        value.frameworkId = try reader["frameworkId"].readIfPresent()
        value.frameworkName = try reader["frameworkName"].readIfPresent()
        value.frameworkDescription = try reader["frameworkDescription"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.sourceAccount = try reader["sourceAccount"].readIfPresent()
        value.destinationAccount = try reader["destinationAccount"].readIfPresent()
        value.destinationRegion = try reader["destinationRegion"].readIfPresent()
        value.expirationTime = try reader["expirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["lastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.comment = try reader["comment"].readIfPresent()
        value.standardControlsCount = try reader["standardControlsCount"].readIfPresent()
        value.customControlsCount = try reader["customControlsCount"].readIfPresent()
        value.complianceType = try reader["complianceType"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.AssessmentReportMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentReportMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentReportMetadata()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.assessmentId = try reader["assessmentId"].readIfPresent()
        value.assessmentName = try reader["assessmentName"].readIfPresent()
        value.author = try reader["author"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.AssessmentMetadataItem {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.AssessmentMetadataItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.AssessmentMetadataItem()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.complianceType = try reader["complianceType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.roles = try reader["roles"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Role.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.delegations = try reader["delegations"].readListIfPresent(memberReadingClosure: AuditManagerClientTypes.Delegation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["lastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.ControlDomainInsights {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ControlDomainInsights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ControlDomainInsights()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.controlsCountByNoncompliantEvidence = try reader["controlsCountByNoncompliantEvidence"].readIfPresent()
        value.totalControlsCount = try reader["totalControlsCount"].readIfPresent()
        value.evidenceInsights = try reader["evidenceInsights"].readIfPresent(with: AuditManagerClientTypes.EvidenceInsights.read(from:))
        value.lastUpdated = try reader["lastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.ControlInsightsMetadataItem {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ControlInsightsMetadataItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ControlInsightsMetadataItem()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.evidenceInsights = try reader["evidenceInsights"].readIfPresent(with: AuditManagerClientTypes.EvidenceInsights.read(from:))
        value.lastUpdated = try reader["lastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.ControlMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ControlMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ControlMetadata()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.controlSources = try reader["controlSources"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AuditManagerClientTypes.Notification {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.Notification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.Notification()
        value.id = try reader["id"].readIfPresent()
        value.assessmentId = try reader["assessmentId"].readIfPresent()
        value.assessmentName = try reader["assessmentName"].readIfPresent()
        value.controlSetId = try reader["controlSetId"].readIfPresent()
        value.controlSetName = try reader["controlSetName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.eventTime = try reader["eventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.source = try reader["source"].readIfPresent()
        return value
    }
}

extension AuditManagerClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> AuditManagerClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AuditManagerClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension AuditManagerClientTypes.CreateAssessmentFrameworkControlSet {

    static func write(value: AuditManagerClientTypes.CreateAssessmentFrameworkControlSet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["controls"].writeList(value.controls, memberWritingClosure: AuditManagerClientTypes.CreateAssessmentFrameworkControl.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension AuditManagerClientTypes.CreateAssessmentFrameworkControl {

    static func write(value: AuditManagerClientTypes.CreateAssessmentFrameworkControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

extension AuditManagerClientTypes.CreateControlMappingSource {

    static func write(value: AuditManagerClientTypes.CreateControlMappingSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceDescription"].write(value.sourceDescription)
        try writer["sourceFrequency"].write(value.sourceFrequency)
        try writer["sourceKeyword"].write(value.sourceKeyword, with: AuditManagerClientTypes.SourceKeyword.write(value:to:))
        try writer["sourceName"].write(value.sourceName)
        try writer["sourceSetUpOption"].write(value.sourceSetUpOption)
        try writer["sourceType"].write(value.sourceType)
        try writer["troubleshootingText"].write(value.troubleshootingText)
    }
}

extension AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet {

    static func write(value: AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["controls"].writeList(value.controls, memberWritingClosure: AuditManagerClientTypes.CreateAssessmentFrameworkControl.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
    }
}

public enum AuditManagerClientTypes {}
