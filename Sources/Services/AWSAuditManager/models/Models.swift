// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AuditManagerClientTypes.AWSAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AuditManagerClientTypes.AWSAccount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AWSAccount(id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), emailAddress: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The wrapper of Amazon Web Services account details, such as account ID or email address.
    public struct AWSAccount: Swift.Equatable {
        /// The email address that's associated with the Amazon Web Services account.
        public var emailAddress: Swift.String?
        /// The identifier for the Amazon Web Services account.
        public var id: Swift.String?
        /// The name of the Amazon Web Services account.
        public var name: Swift.String?

        public init(
            emailAddress: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.emailAddress = emailAddress
            self.id = id
            self.name = name
        }
    }

}

extension AuditManagerClientTypes.AWSService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension AuditManagerClientTypes {
    /// An Amazon Web Service such as Amazon S3 or CloudTrail. For an example of how to find an Amazon Web Service name and how to define it in your assessment scope, see the following:
    ///
    /// * [Finding an Amazon Web Service name to use in your assessment scope](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_GetServicesInScope.html#API_GetServicesInScope_Example_2)
    ///
    /// * [Defining an Amazon Web Service name in your assessment scope](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_GetServicesInScope.html#API_GetServicesInScope_Example_3)
    public struct AWSService: Swift.Equatable {
        /// The name of the Amazon Web Service.
        public var serviceName: Swift.String?

        public init(
            serviceName: Swift.String? = nil
        )
        {
            self.serviceName = serviceName
        }
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your account isn't registered with Audit Manager. Check the delegated administrator setup on the Audit Manager settings page, and try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditManagerClientTypes {
    public enum AccountStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case pendingActivation
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountStatus] {
            return [
                .active,
                .inactive,
                .pendingActivation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pendingActivation: return "PENDING_ACTIVATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountStatus(rawValue: rawValue) ?? AccountStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum ActionEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case create
        case delete
        case importEvidence
        case inactive
        case reviewed
        case underReview
        case updateMetadata
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionEnum] {
            return [
                .active,
                .create,
                .delete,
                .importEvidence,
                .inactive,
                .reviewed,
                .underReview,
                .updateMetadata,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .importEvidence: return "IMPORT_EVIDENCE"
            case .inactive: return "INACTIVE"
            case .reviewed: return "REVIEWED"
            case .underReview: return "UNDER_REVIEW"
            case .updateMetadata: return "UPDATE_METADATA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionEnum(rawValue: rawValue) ?? ActionEnum.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.Assessment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case awsAccount
        case framework
        case metadata
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsAccount = self.awsAccount {
            try encodeContainer.encode(awsAccount, forKey: .awsAccount)
        }
        if let framework = self.framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AWSAccount.self, forKey: .awsAccount)
        awsAccount = awsAccountDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let frameworkDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentFramework.self, forKey: .framework)
        framework = frameworkDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AuditManagerClientTypes.Assessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Assessment(arn: \(Swift.String(describing: arn)), awsAccount: \(Swift.String(describing: awsAccount)), metadata: \(Swift.String(describing: metadata)), tags: \(Swift.String(describing: tags)), framework: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// An entity that defines the scope of audit evidence collected by Audit Manager. An Audit Manager assessment is an implementation of an Audit Manager framework.
    public struct Assessment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the assessment.
        public var arn: Swift.String?
        /// The Amazon Web Services account that's associated with the assessment.
        public var awsAccount: AuditManagerClientTypes.AWSAccount?
        /// The framework that the assessment was created from.
        public var framework: AuditManagerClientTypes.AssessmentFramework?
        /// The metadata for the assessment.
        public var metadata: AuditManagerClientTypes.AssessmentMetadata?
        /// The tags that are associated with the assessment.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            awsAccount: AuditManagerClientTypes.AWSAccount? = nil,
            framework: AuditManagerClientTypes.AssessmentFramework? = nil,
            metadata: AuditManagerClientTypes.AssessmentMetadata? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.awsAccount = awsAccount
            self.framework = framework
            self.metadata = metadata
            self.tags = tags
        }
    }

}

extension AuditManagerClientTypes.AssessmentControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportEvidenceCount
        case comments
        case description
        case evidenceCount
        case evidenceSources
        case id
        case name
        case response
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assessmentReportEvidenceCount != 0 {
            try encodeContainer.encode(assessmentReportEvidenceCount, forKey: .assessmentReportEvidenceCount)
        }
        if let comments = comments {
            var commentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comments)
            for controlcomment0 in comments {
                try commentsContainer.encode(controlcomment0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if evidenceCount != 0 {
            try encodeContainer.encode(evidenceCount, forKey: .evidenceCount)
        }
        if let evidenceSources = evidenceSources {
            var evidenceSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evidenceSources)
            for nonemptystring0 in evidenceSources {
                try evidenceSourcesContainer.encode(nonemptystring0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let response = self.response {
            try encodeContainer.encode(response.rawValue, forKey: .response)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlStatus.self, forKey: .status)
        status = statusDecoded
        let responseDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlResponse.self, forKey: .response)
        response = responseDecoded
        let commentsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlComment?].self, forKey: .comments)
        var commentsDecoded0:[AuditManagerClientTypes.ControlComment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [AuditManagerClientTypes.ControlComment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
        let evidenceSourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .evidenceSources)
        var evidenceSourcesDecoded0:[Swift.String]? = nil
        if let evidenceSourcesContainer = evidenceSourcesContainer {
            evidenceSourcesDecoded0 = [Swift.String]()
            for string0 in evidenceSourcesContainer {
                if let string0 = string0 {
                    evidenceSourcesDecoded0?.append(string0)
                }
            }
        }
        evidenceSources = evidenceSourcesDecoded0
        let evidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceCount) ?? 0
        evidenceCount = evidenceCountDecoded
        let assessmentReportEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assessmentReportEvidenceCount) ?? 0
        assessmentReportEvidenceCount = assessmentReportEvidenceCountDecoded
    }
}

extension AuditManagerClientTypes {
    /// The control entity that represents a standard control or a custom control in an Audit Manager assessment.
    public struct AssessmentControl: Swift.Equatable {
        /// The amount of evidence in the assessment report.
        public var assessmentReportEvidenceCount: Swift.Int
        /// The list of comments that's attached to the control.
        public var comments: [AuditManagerClientTypes.ControlComment]?
        /// The description of the control.
        public var description: Swift.String?
        /// The amount of evidence that's collected for the control.
        public var evidenceCount: Swift.Int
        /// The list of data sources for the evidence.
        public var evidenceSources: [Swift.String]?
        /// The identifier for the control.
        public var id: Swift.String?
        /// The name of the control.
        public var name: Swift.String?
        /// The response of the control.
        public var response: AuditManagerClientTypes.ControlResponse?
        /// The status of the control.
        public var status: AuditManagerClientTypes.ControlStatus?

        public init(
            assessmentReportEvidenceCount: Swift.Int = 0,
            comments: [AuditManagerClientTypes.ControlComment]? = nil,
            description: Swift.String? = nil,
            evidenceCount: Swift.Int = 0,
            evidenceSources: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            response: AuditManagerClientTypes.ControlResponse? = nil,
            status: AuditManagerClientTypes.ControlStatus? = nil
        )
        {
            self.assessmentReportEvidenceCount = assessmentReportEvidenceCount
            self.comments = comments
            self.description = description
            self.evidenceCount = evidenceCount
            self.evidenceSources = evidenceSources
            self.id = id
            self.name = name
            self.response = response
            self.status = status
        }
    }

}

extension AuditManagerClientTypes.AssessmentControlSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controls
        case delegations
        case description
        case id
        case manualEvidenceCount
        case roles
        case status
        case systemEvidenceCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for assessmentcontrol0 in controls {
                try controlsContainer.encode(assessmentcontrol0)
            }
        }
        if let delegations = delegations {
            var delegationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegations)
            for delegation0 in delegations {
                try delegationsContainer.encode(delegation0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if manualEvidenceCount != 0 {
            try encodeContainer.encode(manualEvidenceCount, forKey: .manualEvidenceCount)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if systemEvidenceCount != 0 {
            try encodeContainer.encode(systemEvidenceCount, forKey: .systemEvidenceCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlSetStatus.self, forKey: .status)
        status = statusDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .roles)
        var rolesDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let controlsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentControl?].self, forKey: .controls)
        var controlsDecoded0:[AuditManagerClientTypes.AssessmentControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [AuditManagerClientTypes.AssessmentControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
        let delegationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[AuditManagerClientTypes.Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [AuditManagerClientTypes.Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let systemEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .systemEvidenceCount) ?? 0
        systemEvidenceCount = systemEvidenceCountDecoded
        let manualEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manualEvidenceCount) ?? 0
        manualEvidenceCount = manualEvidenceCountDecoded
    }
}

extension AuditManagerClientTypes.AssessmentControlSet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentControlSet(controls: \(Swift.String(describing: controls)), delegations: \(Swift.String(describing: delegations)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), manualEvidenceCount: \(Swift.String(describing: manualEvidenceCount)), status: \(Swift.String(describing: status)), systemEvidenceCount: \(Swift.String(describing: systemEvidenceCount)), roles: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// Represents a set of controls in an Audit Manager assessment.
    public struct AssessmentControlSet: Swift.Equatable {
        /// The list of controls that's contained with the control set.
        public var controls: [AuditManagerClientTypes.AssessmentControl]?
        /// The delegations that are associated with the control set.
        public var delegations: [AuditManagerClientTypes.Delegation]?
        /// The description for the control set.
        public var description: Swift.String?
        /// The identifier of the control set in the assessment. This is the control set name in a plain string format.
        public var id: Swift.String?
        /// The total number of evidence objects that are uploaded manually to the control set.
        public var manualEvidenceCount: Swift.Int
        /// The roles that are associated with the control set.
        public var roles: [AuditManagerClientTypes.Role]?
        /// The current status of the control set.
        public var status: AuditManagerClientTypes.ControlSetStatus?
        /// The total number of evidence objects that are retrieved automatically for the control set.
        public var systemEvidenceCount: Swift.Int

        public init(
            controls: [AuditManagerClientTypes.AssessmentControl]? = nil,
            delegations: [AuditManagerClientTypes.Delegation]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            manualEvidenceCount: Swift.Int = 0,
            roles: [AuditManagerClientTypes.Role]? = nil,
            status: AuditManagerClientTypes.ControlSetStatus? = nil,
            systemEvidenceCount: Swift.Int = 0
        )
        {
            self.controls = controls
            self.delegations = delegations
            self.description = description
            self.id = id
            self.manualEvidenceCount = manualEvidenceCount
            self.roles = roles
            self.status = status
            self.systemEvidenceCount = systemEvidenceCount
        }
    }

}

extension AuditManagerClientTypes.AssessmentEvidenceFolder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentReportSelectionCount
        case author
        case controlId
        case controlName
        case controlSetId
        case dataSource
        case date
        case evidenceAwsServiceSourceCount
        case evidenceByTypeComplianceCheckCount
        case evidenceByTypeComplianceCheckIssuesCount
        case evidenceByTypeConfigurationDataCount
        case evidenceByTypeManualCount
        case evidenceByTypeUserActivityCount
        case evidenceResourcesIncludedCount
        case id
        case name
        case totalEvidence
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if assessmentReportSelectionCount != 0 {
            try encodeContainer.encode(assessmentReportSelectionCount, forKey: .assessmentReportSelectionCount)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let controlId = self.controlId {
            try encodeContainer.encode(controlId, forKey: .controlId)
        }
        if let controlName = self.controlName {
            try encodeContainer.encode(controlName, forKey: .controlName)
        }
        if let controlSetId = self.controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .epochSeconds, forKey: .date)
        }
        if evidenceAwsServiceSourceCount != 0 {
            try encodeContainer.encode(evidenceAwsServiceSourceCount, forKey: .evidenceAwsServiceSourceCount)
        }
        if evidenceByTypeComplianceCheckCount != 0 {
            try encodeContainer.encode(evidenceByTypeComplianceCheckCount, forKey: .evidenceByTypeComplianceCheckCount)
        }
        if evidenceByTypeComplianceCheckIssuesCount != 0 {
            try encodeContainer.encode(evidenceByTypeComplianceCheckIssuesCount, forKey: .evidenceByTypeComplianceCheckIssuesCount)
        }
        if evidenceByTypeConfigurationDataCount != 0 {
            try encodeContainer.encode(evidenceByTypeConfigurationDataCount, forKey: .evidenceByTypeConfigurationDataCount)
        }
        if evidenceByTypeManualCount != 0 {
            try encodeContainer.encode(evidenceByTypeManualCount, forKey: .evidenceByTypeManualCount)
        }
        if evidenceByTypeUserActivityCount != 0 {
            try encodeContainer.encode(evidenceByTypeUserActivityCount, forKey: .evidenceByTypeUserActivityCount)
        }
        if evidenceResourcesIncludedCount != 0 {
            try encodeContainer.encode(evidenceResourcesIncludedCount, forKey: .evidenceResourcesIncludedCount)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if totalEvidence != 0 {
            try encodeContainer.encode(totalEvidence, forKey: .totalEvidence)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .date)
        date = dateDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let controlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlId)
        controlId = controlIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let totalEvidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalEvidence) ?? 0
        totalEvidence = totalEvidenceDecoded
        let assessmentReportSelectionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assessmentReportSelectionCount) ?? 0
        assessmentReportSelectionCount = assessmentReportSelectionCountDecoded
        let controlNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlName)
        controlName = controlNameDecoded
        let evidenceResourcesIncludedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceResourcesIncludedCount) ?? 0
        evidenceResourcesIncludedCount = evidenceResourcesIncludedCountDecoded
        let evidenceByTypeConfigurationDataCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceByTypeConfigurationDataCount) ?? 0
        evidenceByTypeConfigurationDataCount = evidenceByTypeConfigurationDataCountDecoded
        let evidenceByTypeManualCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceByTypeManualCount) ?? 0
        evidenceByTypeManualCount = evidenceByTypeManualCountDecoded
        let evidenceByTypeComplianceCheckCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceByTypeComplianceCheckCount) ?? 0
        evidenceByTypeComplianceCheckCount = evidenceByTypeComplianceCheckCountDecoded
        let evidenceByTypeComplianceCheckIssuesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceByTypeComplianceCheckIssuesCount) ?? 0
        evidenceByTypeComplianceCheckIssuesCount = evidenceByTypeComplianceCheckIssuesCountDecoded
        let evidenceByTypeUserActivityCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceByTypeUserActivityCount) ?? 0
        evidenceByTypeUserActivityCount = evidenceByTypeUserActivityCountDecoded
        let evidenceAwsServiceSourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceAwsServiceSourceCount) ?? 0
        evidenceAwsServiceSourceCount = evidenceAwsServiceSourceCountDecoded
    }
}

extension AuditManagerClientTypes {
    /// The folder where Audit Manager stores evidence for an assessment.
    public struct AssessmentEvidenceFolder: Swift.Equatable {
        /// The identifier for the assessment.
        public var assessmentId: Swift.String?
        /// The total count of evidence that's included in the assessment report.
        public var assessmentReportSelectionCount: Swift.Int
        /// The name of the user who created the evidence folder.
        public var author: Swift.String?
        /// The unique identifier for the control.
        public var controlId: Swift.String?
        /// The name of the control.
        public var controlName: Swift.String?
        /// The identifier for the control set.
        public var controlSetId: Swift.String?
        /// The Amazon Web Service that the evidence was collected from.
        public var dataSource: Swift.String?
        /// The date when the first evidence was added to the evidence folder.
        public var date: ClientRuntime.Date?
        /// The total number of Amazon Web Services resources that were assessed to generate the evidence.
        public var evidenceAwsServiceSourceCount: Swift.Int
        /// The number of evidence that falls under the compliance check category. This evidence is collected from Config or Security Hub.
        public var evidenceByTypeComplianceCheckCount: Swift.Int
        /// The total number of issues that were reported directly from Security Hub, Config, or both.
        public var evidenceByTypeComplianceCheckIssuesCount: Swift.Int
        /// The number of evidence that falls under the configuration data category. This evidence is collected from configuration snapshots of other Amazon Web Services such as Amazon EC2, Amazon S3, or IAM.
        public var evidenceByTypeConfigurationDataCount: Swift.Int
        /// The number of evidence that falls under the manual category. This evidence is imported manually.
        public var evidenceByTypeManualCount: Swift.Int
        /// The number of evidence that falls under the user activity category. This evidence is collected from CloudTrail logs.
        public var evidenceByTypeUserActivityCount: Swift.Int
        /// The amount of evidence that's included in the evidence folder.
        public var evidenceResourcesIncludedCount: Swift.Int
        /// The identifier for the folder that the evidence is stored in.
        public var id: Swift.String?
        /// The name of the evidence folder.
        public var name: Swift.String?
        /// The total amount of evidence in the evidence folder.
        public var totalEvidence: Swift.Int

        public init(
            assessmentId: Swift.String? = nil,
            assessmentReportSelectionCount: Swift.Int = 0,
            author: Swift.String? = nil,
            controlId: Swift.String? = nil,
            controlName: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            dataSource: Swift.String? = nil,
            date: ClientRuntime.Date? = nil,
            evidenceAwsServiceSourceCount: Swift.Int = 0,
            evidenceByTypeComplianceCheckCount: Swift.Int = 0,
            evidenceByTypeComplianceCheckIssuesCount: Swift.Int = 0,
            evidenceByTypeConfigurationDataCount: Swift.Int = 0,
            evidenceByTypeManualCount: Swift.Int = 0,
            evidenceByTypeUserActivityCount: Swift.Int = 0,
            evidenceResourcesIncludedCount: Swift.Int = 0,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            totalEvidence: Swift.Int = 0
        )
        {
            self.assessmentId = assessmentId
            self.assessmentReportSelectionCount = assessmentReportSelectionCount
            self.author = author
            self.controlId = controlId
            self.controlName = controlName
            self.controlSetId = controlSetId
            self.dataSource = dataSource
            self.date = date
            self.evidenceAwsServiceSourceCount = evidenceAwsServiceSourceCount
            self.evidenceByTypeComplianceCheckCount = evidenceByTypeComplianceCheckCount
            self.evidenceByTypeComplianceCheckIssuesCount = evidenceByTypeComplianceCheckIssuesCount
            self.evidenceByTypeConfigurationDataCount = evidenceByTypeConfigurationDataCount
            self.evidenceByTypeManualCount = evidenceByTypeManualCount
            self.evidenceByTypeUserActivityCount = evidenceByTypeUserActivityCount
            self.evidenceResourcesIncludedCount = evidenceResourcesIncludedCount
            self.id = id
            self.name = name
            self.totalEvidence = totalEvidence
        }
    }

}

extension AuditManagerClientTypes.AssessmentFramework: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case controlSets
        case id
        case metadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for assessmentcontrolset0 in controlSets {
                try controlSetsContainer.encode(assessmentcontrolset0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.FrameworkMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[AuditManagerClientTypes.AssessmentControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [AuditManagerClientTypes.AssessmentControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
    }
}

extension AuditManagerClientTypes.AssessmentFramework: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AuditManagerClientTypes {
    /// The file used to structure and automate Audit Manager assessments for a given compliance standard.
    public struct AssessmentFramework: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the framework.
        public var arn: Swift.String?
        /// The control sets that are associated with the framework.
        public var controlSets: [AuditManagerClientTypes.AssessmentControlSet]?
        /// The unique identifier for the framework.
        public var id: Swift.String?
        /// The metadata of a framework, such as the name, ID, or description.
        public var metadata: AuditManagerClientTypes.FrameworkMetadata?

        public init(
            arn: Swift.String? = nil,
            controlSets: [AuditManagerClientTypes.AssessmentControlSet]? = nil,
            id: Swift.String? = nil,
            metadata: AuditManagerClientTypes.FrameworkMetadata? = nil
        )
        {
            self.arn = arn
            self.controlSets = controlSets
            self.id = id
            self.metadata = metadata
        }
    }

}

extension AuditManagerClientTypes.AssessmentFrameworkMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case complianceType
        case controlSetsCount
        case controlsCount
        case createdAt
        case description
        case id
        case lastUpdatedAt
        case logo
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if controlSetsCount != 0 {
            try encodeContainer.encode(controlSetsCount, forKey: .controlSetsCount)
        }
        if controlsCount != 0 {
            try encodeContainer.encode(controlsCount, forKey: .controlsCount)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let logo = self.logo {
            try encodeContainer.encode(logo, forKey: .logo)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.FrameworkType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let logoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logo)
        logo = logoDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .controlsCount) ?? 0
        controlsCount = controlsCountDecoded
        let controlSetsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .controlSetsCount) ?? 0
        controlSetsCount = controlSetsCountDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AuditManagerClientTypes.AssessmentFrameworkMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentFrameworkMetadata(arn: \(Swift.String(describing: arn)), controlSetsCount: \(Swift.String(describing: controlSetsCount)), controlsCount: \(Swift.String(describing: controlsCount)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), logo: \(Swift.String(describing: logo)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)), complianceType: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The metadata that's associated with a standard framework or a custom framework.
    public struct AssessmentFrameworkMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the framework.
        public var arn: Swift.String?
        /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public var complianceType: Swift.String?
        /// The number of control sets that are associated with the framework.
        public var controlSetsCount: Swift.Int
        /// The number of controls that are associated with the framework.
        public var controlsCount: Swift.Int
        /// The time when the framework was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the framework.
        public var description: Swift.String?
        /// The unique identifier for the framework.
        public var id: Swift.String?
        /// The time when the framework was most recently updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The logo that's associated with the framework.
        public var logo: Swift.String?
        /// The name of the framework.
        public var name: Swift.String?
        /// The framework type, such as a standard framework or a custom framework.
        public var type: AuditManagerClientTypes.FrameworkType?

        public init(
            arn: Swift.String? = nil,
            complianceType: Swift.String? = nil,
            controlSetsCount: Swift.Int = 0,
            controlsCount: Swift.Int = 0,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            logo: Swift.String? = nil,
            name: Swift.String? = nil,
            type: AuditManagerClientTypes.FrameworkType? = nil
        )
        {
            self.arn = arn
            self.complianceType = complianceType
            self.controlSetsCount = controlSetsCount
            self.controlsCount = controlsCount
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.logo = logo
            self.name = name
            self.type = type
        }
    }

}

extension AuditManagerClientTypes.AssessmentFrameworkShareRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case complianceType
        case creationTime
        case customControlsCount
        case destinationAccount
        case destinationRegion
        case expirationTime
        case frameworkDescription
        case frameworkId
        case frameworkName
        case id
        case lastUpdated
        case sourceAccount
        case standardControlsCount
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let customControlsCount = self.customControlsCount {
            try encodeContainer.encode(customControlsCount, forKey: .customControlsCount)
        }
        if let destinationAccount = self.destinationAccount {
            try encodeContainer.encode(destinationAccount, forKey: .destinationAccount)
        }
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .epochSeconds, forKey: .expirationTime)
        }
        if let frameworkDescription = self.frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let frameworkId = self.frameworkId {
            try encodeContainer.encode(frameworkId, forKey: .frameworkId)
        }
        if let frameworkName = self.frameworkName {
            try encodeContainer.encode(frameworkName, forKey: .frameworkName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let sourceAccount = self.sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
        if let standardControlsCount = self.standardControlsCount {
            try encodeContainer.encode(standardControlsCount, forKey: .standardControlsCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let frameworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkId)
        frameworkId = frameworkIdDecoded
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ShareRequestStatus.self, forKey: .status)
        status = statusDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
        let destinationAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationAccount)
        destinationAccount = destinationAccountDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let standardControlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .standardControlsCount)
        standardControlsCount = standardControlsCountDecoded
        let customControlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .customControlsCount)
        customControlsCount = customControlsCountDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
    }
}

extension AuditManagerClientTypes.AssessmentFrameworkShareRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentFrameworkShareRequest(comment: \(Swift.String(describing: comment)), creationTime: \(Swift.String(describing: creationTime)), customControlsCount: \(Swift.String(describing: customControlsCount)), destinationAccount: \(Swift.String(describing: destinationAccount)), destinationRegion: \(Swift.String(describing: destinationRegion)), expirationTime: \(Swift.String(describing: expirationTime)), frameworkDescription: \(Swift.String(describing: frameworkDescription)), frameworkId: \(Swift.String(describing: frameworkId)), frameworkName: \(Swift.String(describing: frameworkName)), id: \(Swift.String(describing: id)), lastUpdated: \(Swift.String(describing: lastUpdated)), sourceAccount: \(Swift.String(describing: sourceAccount)), standardControlsCount: \(Swift.String(describing: standardControlsCount)), status: \(Swift.String(describing: status)), complianceType: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// Represents a share request for a custom framework in Audit Manager.
    public struct AssessmentFrameworkShareRequest: Swift.Equatable {
        /// An optional comment from the sender about the share request.
        public var comment: Swift.String?
        /// The compliance type that the shared custom framework supports, such as CIS or HIPAA.
        public var complianceType: Swift.String?
        /// The time when the share request was created.
        public var creationTime: ClientRuntime.Date?
        /// The number of custom controls that are part of the shared custom framework.
        public var customControlsCount: Swift.Int?
        /// The Amazon Web Services account of the recipient.
        public var destinationAccount: Swift.String?
        /// The Amazon Web Services Region of the recipient.
        public var destinationRegion: Swift.String?
        /// The time when the share request expires.
        public var expirationTime: ClientRuntime.Date?
        /// The description of the shared custom framework.
        public var frameworkDescription: Swift.String?
        /// The unique identifier for the shared custom framework.
        public var frameworkId: Swift.String?
        /// The name of the custom framework that the share request is for.
        public var frameworkName: Swift.String?
        /// The unique identifier for the share request.
        public var id: Swift.String?
        /// Specifies when the share request was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The Amazon Web Services account of the sender.
        public var sourceAccount: Swift.String?
        /// The number of standard controls that are part of the shared custom framework.
        public var standardControlsCount: Swift.Int?
        /// The status of the share request.
        public var status: AuditManagerClientTypes.ShareRequestStatus?

        public init(
            comment: Swift.String? = nil,
            complianceType: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            customControlsCount: Swift.Int? = nil,
            destinationAccount: Swift.String? = nil,
            destinationRegion: Swift.String? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            frameworkDescription: Swift.String? = nil,
            frameworkId: Swift.String? = nil,
            frameworkName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            sourceAccount: Swift.String? = nil,
            standardControlsCount: Swift.Int? = nil,
            status: AuditManagerClientTypes.ShareRequestStatus? = nil
        )
        {
            self.comment = comment
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.customControlsCount = customControlsCount
            self.destinationAccount = destinationAccount
            self.destinationRegion = destinationRegion
            self.expirationTime = expirationTime
            self.frameworkDescription = frameworkDescription
            self.frameworkId = frameworkId
            self.frameworkName = frameworkName
            self.id = id
            self.lastUpdated = lastUpdated
            self.sourceAccount = sourceAccount
            self.standardControlsCount = standardControlsCount
            self.status = status
        }
    }

}

extension AuditManagerClientTypes.AssessmentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportsDestination
        case complianceType
        case creationTime
        case delegations
        case description
        case id
        case lastUpdated
        case name
        case roles
        case scope
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentReportsDestination = self.assessmentReportsDestination {
            try encodeContainer.encode(assessmentReportsDestination, forKey: .assessmentReportsDestination)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let delegations = delegations {
            var delegationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegations)
            for delegation0 in delegations {
                try delegationsContainer.encode(delegation0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentStatus.self, forKey: .status)
        status = statusDecoded
        let assessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportsDestination.self, forKey: .assessmentReportsDestination)
        assessmentReportsDestination = assessmentReportsDestinationDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .roles)
        var rolesDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let delegationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[AuditManagerClientTypes.Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [AuditManagerClientTypes.Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes.AssessmentMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentMetadata(creationTime: \(Swift.String(describing: creationTime)), delegations: \(Swift.String(describing: delegations)), id: \(Swift.String(describing: id)), lastUpdated: \(Swift.String(describing: lastUpdated)), status: \(Swift.String(describing: status)), assessmentReportsDestination: \"CONTENT_REDACTED\", complianceType: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", roles: \"CONTENT_REDACTED\", scope: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The metadata that's associated with the specified assessment.
    public struct AssessmentMetadata: Swift.Equatable {
        /// The destination that evidence reports are stored in for the assessment.
        public var assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
        /// The name of the compliance standard that's related to the assessment, such as PCI-DSS.
        public var complianceType: Swift.String?
        /// Specifies when the assessment was created.
        public var creationTime: ClientRuntime.Date?
        /// The delegations that are associated with the assessment.
        public var delegations: [AuditManagerClientTypes.Delegation]?
        /// The description of the assessment.
        public var description: Swift.String?
        /// The unique identifier for the assessment.
        public var id: Swift.String?
        /// The time of the most recent update.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the assessment.
        public var name: Swift.String?
        /// The roles that are associated with the assessment.
        public var roles: [AuditManagerClientTypes.Role]?
        /// The wrapper of Amazon Web Services accounts and services that are in scope for the assessment.
        public var scope: AuditManagerClientTypes.Scope?
        /// The overall status of the assessment.
        public var status: AuditManagerClientTypes.AssessmentStatus?

        public init(
            assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
            complianceType: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            delegations: [AuditManagerClientTypes.Delegation]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roles: [AuditManagerClientTypes.Role]? = nil,
            scope: AuditManagerClientTypes.Scope? = nil,
            status: AuditManagerClientTypes.AssessmentStatus? = nil
        )
        {
            self.assessmentReportsDestination = assessmentReportsDestination
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.delegations = delegations
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.roles = roles
            self.scope = scope
            self.status = status
        }
    }

}

extension AuditManagerClientTypes.AssessmentMetadataItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case creationTime
        case delegations
        case id
        case lastUpdated
        case name
        case roles
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let delegations = delegations {
            var delegationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegations)
            for delegation0 in delegations {
                try delegationsContainer.encode(delegation0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentStatus.self, forKey: .status)
        status = statusDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .roles)
        var rolesDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let delegationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[AuditManagerClientTypes.Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [AuditManagerClientTypes.Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes.AssessmentMetadataItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentMetadataItem(creationTime: \(Swift.String(describing: creationTime)), delegations: \(Swift.String(describing: delegations)), id: \(Swift.String(describing: id)), lastUpdated: \(Swift.String(describing: lastUpdated)), status: \(Swift.String(describing: status)), complianceType: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", roles: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// A metadata object that's associated with an assessment in Audit Manager.
    public struct AssessmentMetadataItem: Swift.Equatable {
        /// The name of the compliance standard that's related to the assessment, such as PCI-DSS.
        public var complianceType: Swift.String?
        /// Specifies when the assessment was created.
        public var creationTime: ClientRuntime.Date?
        /// The delegations that are associated with the assessment.
        public var delegations: [AuditManagerClientTypes.Delegation]?
        /// The unique identifier for the assessment.
        public var id: Swift.String?
        /// The time of the most recent update.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the assessment.
        public var name: Swift.String?
        /// The roles that are associated with the assessment.
        public var roles: [AuditManagerClientTypes.Role]?
        /// The current status of the assessment.
        public var status: AuditManagerClientTypes.AssessmentStatus?

        public init(
            complianceType: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            delegations: [AuditManagerClientTypes.Delegation]? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roles: [AuditManagerClientTypes.Role]? = nil,
            status: AuditManagerClientTypes.AssessmentStatus? = nil
        )
        {
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.delegations = delegations
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.roles = roles
            self.status = status
        }
    }

}

extension AuditManagerClientTypes.AssessmentReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentName
        case author
        case awsAccountId
        case creationTime
        case description
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AuditManagerClientTypes.AssessmentReport: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentReport(assessmentId: \(Swift.String(describing: assessmentId)), awsAccountId: \(Swift.String(describing: awsAccountId)), creationTime: \(Swift.String(describing: creationTime)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), assessmentName: \"CONTENT_REDACTED\", author: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// A finalized document that's generated from an Audit Manager assessment. These reports summarize the relevant evidence that was collected for your audit, and link to the relevant evidence folders. These evidence folders are named and organized according to the controls that are specified in your assessment.
    public struct AssessmentReport: Swift.Equatable {
        /// The identifier for the specified assessment.
        public var assessmentId: Swift.String?
        /// The name of the associated assessment.
        public var assessmentName: Swift.String?
        /// The name of the user who created the assessment report.
        public var author: Swift.String?
        /// The identifier for the specified Amazon Web Services account.
        public var awsAccountId: Swift.String?
        /// Specifies when the assessment report was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the specified assessment report.
        public var description: Swift.String?
        /// The unique identifier for the assessment report.
        public var id: Swift.String?
        /// The name that's given to the assessment report.
        public var name: Swift.String?
        /// The current status of the specified assessment report.
        public var status: AuditManagerClientTypes.AssessmentReportStatus?

        public init(
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            author: Swift.String? = nil,
            awsAccountId: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: AuditManagerClientTypes.AssessmentReportStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.author = author
            self.awsAccountId = awsAccountId
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension AuditManagerClientTypes {
    public enum AssessmentReportDestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentReportDestinationType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentReportDestinationType(rawValue: rawValue) ?? AssessmentReportDestinationType.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.AssessmentReportEvidenceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case evidenceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let evidenceId = self.evidenceId {
            try encodeContainer.encode(evidenceId, forKey: .evidenceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceId)
        evidenceId = evidenceIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AuditManagerClientTypes {
    /// An error entity for assessment report evidence errors. This is used to provide more meaningful errors than a simple string message.
    public struct AssessmentReportEvidenceError: Swift.Equatable {
        /// The error code that was returned.
        public var errorCode: Swift.String?
        /// The error message that was returned.
        public var errorMessage: Swift.String?
        /// The identifier for the evidence.
        public var evidenceId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            evidenceId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.evidenceId = evidenceId
        }
    }

}

extension AuditManagerClientTypes.AssessmentReportMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentName
        case author
        case creationTime
        case description
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AuditManagerClientTypes.AssessmentReportMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssessmentReportMetadata(assessmentId: \(Swift.String(describing: assessmentId)), creationTime: \(Swift.String(describing: creationTime)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), assessmentName: \"CONTENT_REDACTED\", author: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The metadata objects that are associated with the specified assessment report.
    public struct AssessmentReportMetadata: Swift.Equatable {
        /// The unique identifier for the associated assessment.
        public var assessmentId: Swift.String?
        /// The name of the associated assessment.
        public var assessmentName: Swift.String?
        /// The name of the user who created the assessment report.
        public var author: Swift.String?
        /// Specifies when the assessment report was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the assessment report.
        public var description: Swift.String?
        /// The unique identifier for the assessment report.
        public var id: Swift.String?
        /// The name of the assessment report.
        public var name: Swift.String?
        /// The current status of the assessment report.
        public var status: AuditManagerClientTypes.AssessmentReportStatus?

        public init(
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            author: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: AuditManagerClientTypes.AssessmentReportStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension AuditManagerClientTypes {
    public enum AssessmentReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentReportStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentReportStatus(rawValue: rawValue) ?? AssessmentReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.AssessmentReportsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case destinationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportDestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension AuditManagerClientTypes.AssessmentReportsDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AuditManagerClientTypes {
    /// The location where Audit Manager saves assessment reports for the given assessment.
    public struct AssessmentReportsDestination: Swift.Equatable {
        /// The destination bucket where Audit Manager stores assessment reports.
        public var destination: Swift.String?
        /// The destination type, such as Amazon S3.
        public var destinationType: AuditManagerClientTypes.AssessmentReportDestinationType?

        public init(
            destination: Swift.String? = nil,
            destinationType: AuditManagerClientTypes.AssessmentReportDestinationType? = nil
        )
        {
            self.destination = destination
            self.destinationType = destinationType
        }
    }

}

extension AuditManagerClientTypes {
    public enum AssessmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentStatus(rawValue: rawValue) ?? AssessmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociateAssessmentReportEvidenceFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = self.evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
    }
}

extension AssociateAssessmentReportEvidenceFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/associateToAssessmentReport"
    }
}

public struct AssociateAssessmentReportEvidenceFolderInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
    }
}

struct AssociateAssessmentReportEvidenceFolderInputBody: Swift.Equatable {
    let evidenceFolderId: Swift.String?
}

extension AssociateAssessmentReportEvidenceFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
    }
}

extension AssociateAssessmentReportEvidenceFolderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateAssessmentReportEvidenceFolderOutput: Swift.Equatable {

    public init() { }
}

enum AssociateAssessmentReportEvidenceFolderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchAssociateAssessmentReportEvidenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = self.evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
        if let evidenceIds = evidenceIds {
            var evidenceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evidenceIds)
            for uuid0 in evidenceIds {
                try evidenceIdsContainer.encode(uuid0)
            }
        }
    }
}

extension BatchAssociateAssessmentReportEvidenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/batchAssociateToAssessmentReport"
    }
}

public struct BatchAssociateAssessmentReportEvidenceInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// The list of evidence identifiers.
    /// This member is required.
    public var evidenceIds: [Swift.String]?

    public init(
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceIds = evidenceIds
    }
}

struct BatchAssociateAssessmentReportEvidenceInputBody: Swift.Equatable {
    let evidenceFolderId: Swift.String?
    let evidenceIds: [Swift.String]?
}

extension BatchAssociateAssessmentReportEvidenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
        let evidenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[Swift.String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [Swift.String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
    }
}

extension BatchAssociateAssessmentReportEvidenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchAssociateAssessmentReportEvidenceOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.evidenceIds = output.evidenceIds
        } else {
            self.errors = nil
            self.evidenceIds = nil
        }
    }
}

public struct BatchAssociateAssessmentReportEvidenceOutput: Swift.Equatable {
    /// A list of errors that the BatchAssociateAssessmentReportEvidence API returned.
    public var errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]?
    /// The list of evidence identifiers.
    public var evidenceIds: [Swift.String]?

    public init(
        errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.evidenceIds = evidenceIds
    }
}

struct BatchAssociateAssessmentReportEvidenceOutputBody: Swift.Equatable {
    let evidenceIds: [Swift.String]?
    let errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]?
}

extension BatchAssociateAssessmentReportEvidenceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case evidenceIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[Swift.String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [Swift.String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentReportEvidenceError?].self, forKey: .errors)
        var errorsDecoded0:[AuditManagerClientTypes.AssessmentReportEvidenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AuditManagerClientTypes.AssessmentReportEvidenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchAssociateAssessmentReportEvidenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.BatchCreateDelegationByAssessmentError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDelegationRequest
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDelegationRequest = self.createDelegationRequest {
            try encodeContainer.encode(createDelegationRequest, forKey: .createDelegationRequest)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDelegationRequestDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.CreateDelegationRequest.self, forKey: .createDelegationRequest)
        createDelegationRequest = createDelegationRequestDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AuditManagerClientTypes {
    /// An error entity for the BatchCreateDelegationByAssessment API. This is used to provide more meaningful errors than a simple string message.
    public struct BatchCreateDelegationByAssessmentError: Swift.Equatable {
        /// The API request to batch create delegations in Audit Manager.
        public var createDelegationRequest: AuditManagerClientTypes.CreateDelegationRequest?
        /// The error code that the BatchCreateDelegationByAssessment API returned.
        public var errorCode: Swift.String?
        /// The error message that the BatchCreateDelegationByAssessment API returned.
        public var errorMessage: Swift.String?

        public init(
            createDelegationRequest: AuditManagerClientTypes.CreateDelegationRequest? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.createDelegationRequest = createDelegationRequest
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension BatchCreateDelegationByAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateDelegationByAssessmentInput(assessmentId: \(Swift.String(describing: assessmentId)), createDelegationRequests: \"CONTENT_REDACTED\")"}
}

extension BatchCreateDelegationByAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDelegationRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDelegationRequests = createDelegationRequests {
            var createDelegationRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createDelegationRequests)
            for createdelegationrequest0 in createDelegationRequests {
                try createDelegationRequestsContainer.encode(createdelegationrequest0)
            }
        }
    }
}

extension BatchCreateDelegationByAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/delegations"
    }
}

public struct BatchCreateDelegationByAssessmentInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The API request to batch create delegations in Audit Manager.
    /// This member is required.
    public var createDelegationRequests: [AuditManagerClientTypes.CreateDelegationRequest]?

    public init(
        assessmentId: Swift.String? = nil,
        createDelegationRequests: [AuditManagerClientTypes.CreateDelegationRequest]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.createDelegationRequests = createDelegationRequests
    }
}

struct BatchCreateDelegationByAssessmentInputBody: Swift.Equatable {
    let createDelegationRequests: [AuditManagerClientTypes.CreateDelegationRequest]?
}

extension BatchCreateDelegationByAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDelegationRequests
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDelegationRequestsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.CreateDelegationRequest?].self, forKey: .createDelegationRequests)
        var createDelegationRequestsDecoded0:[AuditManagerClientTypes.CreateDelegationRequest]? = nil
        if let createDelegationRequestsContainer = createDelegationRequestsContainer {
            createDelegationRequestsDecoded0 = [AuditManagerClientTypes.CreateDelegationRequest]()
            for structure0 in createDelegationRequestsContainer {
                if let structure0 = structure0 {
                    createDelegationRequestsDecoded0?.append(structure0)
                }
            }
        }
        createDelegationRequests = createDelegationRequestsDecoded0
    }
}

extension BatchCreateDelegationByAssessmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateDelegationByAssessmentOutput(delegations: \(Swift.String(describing: delegations)), errors: \"CONTENT_REDACTED\")"}
}

extension BatchCreateDelegationByAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchCreateDelegationByAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.delegations = output.delegations
            self.errors = output.errors
        } else {
            self.delegations = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateDelegationByAssessmentOutput: Swift.Equatable {
    /// The delegations that are associated with the assessment.
    public var delegations: [AuditManagerClientTypes.Delegation]?
    /// A list of errors that the BatchCreateDelegationByAssessment API returned.
    public var errors: [AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]?

    public init(
        delegations: [AuditManagerClientTypes.Delegation]? = nil,
        errors: [AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]? = nil
    )
    {
        self.delegations = delegations
        self.errors = errors
    }
}

struct BatchCreateDelegationByAssessmentOutputBody: Swift.Equatable {
    let delegations: [AuditManagerClientTypes.Delegation]?
    let errors: [AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]?
}

extension BatchCreateDelegationByAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegations
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[AuditManagerClientTypes.Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [AuditManagerClientTypes.Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.BatchCreateDelegationByAssessmentError?].self, forKey: .errors)
        var errorsDecoded0:[AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchCreateDelegationByAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegationId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegationId = self.delegationId {
            try encodeContainer.encode(delegationId, forKey: .delegationId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegationId)
        delegationId = delegationIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AuditManagerClientTypes {
    /// An error entity for the BatchDeleteDelegationByAssessment API. This is used to provide more meaningful errors than a simple string message.
    public struct BatchDeleteDelegationByAssessmentError: Swift.Equatable {
        /// The identifier for the delegation.
        public var delegationId: Swift.String?
        /// The error code that the BatchDeleteDelegationByAssessment API returned.
        public var errorCode: Swift.String?
        /// The error message that the BatchDeleteDelegationByAssessment API returned.
        public var errorMessage: Swift.String?

        public init(
            delegationId: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.delegationId = delegationId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension BatchDeleteDelegationByAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegationIds = delegationIds {
            var delegationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegationIds)
            for uuid0 in delegationIds {
                try delegationIdsContainer.encode(uuid0)
            }
        }
    }
}

extension BatchDeleteDelegationByAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/delegations"
    }
}

public struct BatchDeleteDelegationByAssessmentInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifiers for the delegations.
    /// This member is required.
    public var delegationIds: [Swift.String]?

    public init(
        assessmentId: Swift.String? = nil,
        delegationIds: [Swift.String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.delegationIds = delegationIds
    }
}

struct BatchDeleteDelegationByAssessmentInputBody: Swift.Equatable {
    let delegationIds: [Swift.String]?
}

extension BatchDeleteDelegationByAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegationIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .delegationIds)
        var delegationIdsDecoded0:[Swift.String]? = nil
        if let delegationIdsContainer = delegationIdsContainer {
            delegationIdsDecoded0 = [Swift.String]()
            for string0 in delegationIdsContainer {
                if let string0 = string0 {
                    delegationIdsDecoded0?.append(string0)
                }
            }
        }
        delegationIds = delegationIdsDecoded0
    }
}

extension BatchDeleteDelegationByAssessmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteDelegationByAssessmentOutput(errors: \"CONTENT_REDACTED\")"}
}

extension BatchDeleteDelegationByAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteDelegationByAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteDelegationByAssessmentOutput: Swift.Equatable {
    /// A list of errors that the BatchDeleteDelegationByAssessment API returned.
    public var errors: [AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]?

    public init(
        errors: [AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteDelegationByAssessmentOutputBody: Swift.Equatable {
    let errors: [AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]?
}

extension BatchDeleteDelegationByAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError?].self, forKey: .errors)
        var errorsDecoded0:[AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDeleteDelegationByAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDisassociateAssessmentReportEvidenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = self.evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
        if let evidenceIds = evidenceIds {
            var evidenceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evidenceIds)
            for uuid0 in evidenceIds {
                try evidenceIdsContainer.encode(uuid0)
            }
        }
    }
}

extension BatchDisassociateAssessmentReportEvidenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/batchDisassociateFromAssessmentReport"
    }
}

public struct BatchDisassociateAssessmentReportEvidenceInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// The list of evidence identifiers.
    /// This member is required.
    public var evidenceIds: [Swift.String]?

    public init(
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceIds = evidenceIds
    }
}

struct BatchDisassociateAssessmentReportEvidenceInputBody: Swift.Equatable {
    let evidenceFolderId: Swift.String?
    let evidenceIds: [Swift.String]?
}

extension BatchDisassociateAssessmentReportEvidenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
        let evidenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[Swift.String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [Swift.String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
    }
}

extension BatchDisassociateAssessmentReportEvidenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDisassociateAssessmentReportEvidenceOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.evidenceIds = output.evidenceIds
        } else {
            self.errors = nil
            self.evidenceIds = nil
        }
    }
}

public struct BatchDisassociateAssessmentReportEvidenceOutput: Swift.Equatable {
    /// A list of errors that the BatchDisassociateAssessmentReportEvidence API returned.
    public var errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]?
    /// The identifier for the evidence.
    public var evidenceIds: [Swift.String]?

    public init(
        errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.evidenceIds = evidenceIds
    }
}

struct BatchDisassociateAssessmentReportEvidenceOutputBody: Swift.Equatable {
    let evidenceIds: [Swift.String]?
    let errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]?
}

extension BatchDisassociateAssessmentReportEvidenceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case evidenceIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[Swift.String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [Swift.String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentReportEvidenceError?].self, forKey: .errors)
        var errorsDecoded0:[AuditManagerClientTypes.AssessmentReportEvidenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AuditManagerClientTypes.AssessmentReportEvidenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDisassociateAssessmentReportEvidenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case manualEvidence
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let manualEvidence = self.manualEvidence {
            try encodeContainer.encode(manualEvidence, forKey: .manualEvidence)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manualEvidenceDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ManualEvidence.self, forKey: .manualEvidence)
        manualEvidence = manualEvidenceDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AuditManagerClientTypes {
    /// An error entity for the BatchImportEvidenceToAssessmentControl API. This is used to provide more meaningful errors than a simple string message.
    public struct BatchImportEvidenceToAssessmentControlError: Swift.Equatable {
        /// The error code that the BatchImportEvidenceToAssessmentControl API returned.
        public var errorCode: Swift.String?
        /// The error message that the BatchImportEvidenceToAssessmentControl API returned.
        public var errorMessage: Swift.String?
        /// Manual evidence that can't be collected automatically by Audit Manager.
        public var manualEvidence: AuditManagerClientTypes.ManualEvidence?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            manualEvidence: AuditManagerClientTypes.ManualEvidence? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.manualEvidence = manualEvidence
        }
    }

}

extension BatchImportEvidenceToAssessmentControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manualEvidence
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manualEvidence = manualEvidence {
            var manualEvidenceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .manualEvidence)
            for manualevidence0 in manualEvidence {
                try manualEvidenceContainer.encode(manualevidence0)
            }
        }
    }
}

extension BatchImportEvidenceToAssessmentControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let controlId = controlId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/controls/\(controlId.urlPercentEncoding())/evidence"
    }
}

public struct BatchImportEvidenceToAssessmentControlInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The list of manual evidence objects.
    /// This member is required.
    public var manualEvidence: [AuditManagerClientTypes.ManualEvidence]?

    public init(
        assessmentId: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        manualEvidence: [AuditManagerClientTypes.ManualEvidence]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.manualEvidence = manualEvidence
    }
}

struct BatchImportEvidenceToAssessmentControlInputBody: Swift.Equatable {
    let manualEvidence: [AuditManagerClientTypes.ManualEvidence]?
}

extension BatchImportEvidenceToAssessmentControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manualEvidence
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manualEvidenceContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ManualEvidence?].self, forKey: .manualEvidence)
        var manualEvidenceDecoded0:[AuditManagerClientTypes.ManualEvidence]? = nil
        if let manualEvidenceContainer = manualEvidenceContainer {
            manualEvidenceDecoded0 = [AuditManagerClientTypes.ManualEvidence]()
            for structure0 in manualEvidenceContainer {
                if let structure0 = structure0 {
                    manualEvidenceDecoded0?.append(structure0)
                }
            }
        }
        manualEvidence = manualEvidenceDecoded0
    }
}

extension BatchImportEvidenceToAssessmentControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchImportEvidenceToAssessmentControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchImportEvidenceToAssessmentControlOutput: Swift.Equatable {
    /// A list of errors that the BatchImportEvidenceToAssessmentControl API returned.
    public var errors: [AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]?

    public init(
        errors: [AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchImportEvidenceToAssessmentControlOutputBody: Swift.Equatable {
    let errors: [AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]?
}

extension BatchImportEvidenceToAssessmentControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError?].self, forKey: .errors)
        var errorsDecoded0:[AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchImportEvidenceToAssessmentControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.ChangeLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case createdAt
        case createdBy
        case objectName
        case objectType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let objectName = self.objectName {
            try encodeContainer.encode(objectName, forKey: .objectName)
        }
        if let objectType = self.objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ObjectTypeEnum.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let objectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectName)
        objectName = objectNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ActionEnum.self, forKey: .action)
        action = actionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension AuditManagerClientTypes {
    /// The record of a change within Audit Manager. For example, this could be the status change of an assessment or the delegation of a control set.
    public struct ChangeLog: Swift.Equatable {
        /// The action that was performed.
        public var action: AuditManagerClientTypes.ActionEnum?
        /// The time when the action was performed and the changelog record was created.
        public var createdAt: ClientRuntime.Date?
        /// The user or role that performed the action.
        public var createdBy: Swift.String?
        /// The name of the object that changed. This could be the name of an assessment, control, or control set.
        public var objectName: Swift.String?
        /// The object that was changed, such as an assessment, control, or control set.
        public var objectType: AuditManagerClientTypes.ObjectTypeEnum?

        public init(
            action: AuditManagerClientTypes.ActionEnum? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            objectName: Swift.String? = nil,
            objectType: AuditManagerClientTypes.ObjectTypeEnum? = nil
        )
        {
            self.action = action
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.objectName = objectName
            self.objectType = objectType
        }
    }

}

extension AuditManagerClientTypes.Control: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case arn
        case controlMappingSources
        case controlSources
        case createdAt
        case createdBy
        case description
        case id
        case lastUpdatedAt
        case lastUpdatedBy
        case name
        case tags
        case testingInformation
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionPlanInstructions = self.actionPlanInstructions {
            try encodeContainer.encode(actionPlanInstructions, forKey: .actionPlanInstructions)
        }
        if let actionPlanTitle = self.actionPlanTitle {
            try encodeContainer.encode(actionPlanTitle, forKey: .actionPlanTitle)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlMappingSources = controlMappingSources {
            var controlMappingSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlMappingSources)
            for controlmappingsource0 in controlMappingSources {
                try controlMappingSourcesContainer.encode(controlmappingsource0)
            }
        }
        if let controlSources = self.controlSources {
            try encodeContainer.encode(controlSources, forKey: .controlSources)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = self.lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let testingInformation = self.testingInformation {
            try encodeContainer.encode(testingInformation, forKey: .testingInformation)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let testingInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testingInformation)
        testingInformation = testingInformationDecoded
        let actionPlanTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanTitle)
        actionPlanTitle = actionPlanTitleDecoded
        let actionPlanInstructionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanInstructions)
        actionPlanInstructions = actionPlanInstructionsDecoded
        let controlSourcesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSources)
        controlSources = controlSourcesDecoded
        let controlMappingSourcesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlMappingSource?].self, forKey: .controlMappingSources)
        var controlMappingSourcesDecoded0:[AuditManagerClientTypes.ControlMappingSource]? = nil
        if let controlMappingSourcesContainer = controlMappingSourcesContainer {
            controlMappingSourcesDecoded0 = [AuditManagerClientTypes.ControlMappingSource]()
            for structure0 in controlMappingSourcesContainer {
                if let structure0 = structure0 {
                    controlMappingSourcesDecoded0?.append(structure0)
                }
            }
        }
        controlMappingSources = controlMappingSourcesDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AuditManagerClientTypes.Control: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Control(arn: \(Swift.String(describing: arn)), controlMappingSources: \(Swift.String(describing: controlMappingSources)), controlSources: \(Swift.String(describing: controlSources)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), actionPlanInstructions: \"CONTENT_REDACTED\", actionPlanTitle: \"CONTENT_REDACTED\", createdBy: \"CONTENT_REDACTED\", lastUpdatedBy: \"CONTENT_REDACTED\", testingInformation: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// A control in Audit Manager.
    public struct Control: Swift.Equatable {
        /// The recommended actions to carry out if the control isn't fulfilled.
        public var actionPlanInstructions: Swift.String?
        /// The title of the action plan for remediating the control.
        public var actionPlanTitle: Swift.String?
        /// The Amazon Resource Name (ARN) of the control.
        public var arn: Swift.String?
        /// The data mapping sources for the control.
        public var controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]?
        /// The data source types that determine where Audit Manager collects evidence from for the control.
        public var controlSources: Swift.String?
        /// The time when the control was created.
        public var createdAt: ClientRuntime.Date?
        /// The user or role that created the control.
        public var createdBy: Swift.String?
        /// The description of the control.
        public var description: Swift.String?
        /// The unique identifier for the control.
        public var id: Swift.String?
        /// The time when the control was most recently updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The user or role that most recently updated the control.
        public var lastUpdatedBy: Swift.String?
        /// The name of the control.
        public var name: Swift.String?
        /// The tags associated with the control.
        public var tags: [Swift.String:Swift.String]?
        /// The steps that you should follow to determine if the control has been satisfied.
        public var testingInformation: Swift.String?
        /// Specifies whether the control is a standard control or a custom control.
        public var type: AuditManagerClientTypes.ControlType?

        public init(
            actionPlanInstructions: Swift.String? = nil,
            actionPlanTitle: Swift.String? = nil,
            arn: Swift.String? = nil,
            controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]? = nil,
            controlSources: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            testingInformation: Swift.String? = nil,
            type: AuditManagerClientTypes.ControlType? = nil
        )
        {
            self.actionPlanInstructions = actionPlanInstructions
            self.actionPlanTitle = actionPlanTitle
            self.arn = arn
            self.controlMappingSources = controlMappingSources
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.tags = tags
            self.testingInformation = testingInformation
            self.type = type
        }
    }

}

extension AuditManagerClientTypes.ControlComment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commentBody
        case postedDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commentBody = self.commentBody {
            try encodeContainer.encode(commentBody, forKey: .commentBody)
        }
        if let postedDate = self.postedDate {
            try encodeContainer.encodeTimestamp(postedDate, format: .epochSeconds, forKey: .postedDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let commentBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentBody)
        commentBody = commentBodyDecoded
        let postedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .postedDate)
        postedDate = postedDateDecoded
    }
}

extension AuditManagerClientTypes.ControlComment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ControlComment(postedDate: \(Swift.String(describing: postedDate)), authorName: \"CONTENT_REDACTED\", commentBody: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// A comment that's posted by a user on a control. This includes the author's name, the comment text, and a timestamp.
    public struct ControlComment: Swift.Equatable {
        /// The name of the user who authored the comment.
        public var authorName: Swift.String?
        /// The body text of a control comment.
        public var commentBody: Swift.String?
        /// The time when the comment was posted.
        public var postedDate: ClientRuntime.Date?

        public init(
            authorName: Swift.String? = nil,
            commentBody: Swift.String? = nil,
            postedDate: ClientRuntime.Date? = nil
        )
        {
            self.authorName = authorName
            self.commentBody = commentBody
            self.postedDate = postedDate
        }
    }

}

extension AuditManagerClientTypes.ControlDomainInsights: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlsCountByNoncompliantEvidence
        case evidenceInsights
        case id
        case lastUpdated
        case name
        case totalControlsCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlsCountByNoncompliantEvidence = self.controlsCountByNoncompliantEvidence {
            try encodeContainer.encode(controlsCountByNoncompliantEvidence, forKey: .controlsCountByNoncompliantEvidence)
        }
        if let evidenceInsights = self.evidenceInsights {
            try encodeContainer.encode(evidenceInsights, forKey: .evidenceInsights)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let totalControlsCount = self.totalControlsCount {
            try encodeContainer.encode(totalControlsCount, forKey: .totalControlsCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let controlsCountByNoncompliantEvidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .controlsCountByNoncompliantEvidence)
        controlsCountByNoncompliantEvidence = controlsCountByNoncompliantEvidenceDecoded
        let totalControlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalControlsCount)
        totalControlsCount = totalControlsCountDecoded
        let evidenceInsightsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceInsights.self, forKey: .evidenceInsights)
        evidenceInsights = evidenceInsightsDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A summary of the latest analytics data for a specific control domain. Control domain insights are grouped by control domain, and ranked by the highest total count of non-compliant evidence.
    public struct ControlDomainInsights: Swift.Equatable {
        /// The number of controls in the control domain that collected non-compliant evidence on the lastUpdated date.
        public var controlsCountByNoncompliantEvidence: Swift.Int?
        /// A breakdown of the compliance check status for the evidence thats associated with the control domain.
        public var evidenceInsights: AuditManagerClientTypes.EvidenceInsights?
        /// The unique identifier for the control domain.
        public var id: Swift.String?
        /// The time when the control domain insights were last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the control domain.
        public var name: Swift.String?
        /// The total number of controls in the control domain.
        public var totalControlsCount: Swift.Int?

        public init(
            controlsCountByNoncompliantEvidence: Swift.Int? = nil,
            evidenceInsights: AuditManagerClientTypes.EvidenceInsights? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            totalControlsCount: Swift.Int? = nil
        )
        {
            self.controlsCountByNoncompliantEvidence = controlsCountByNoncompliantEvidence
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.totalControlsCount = totalControlsCount
        }
    }

}

extension AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlSetName
        case evidenceInsights
        case id
        case lastUpdated
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlSetName = self.controlSetName {
            try encodeContainer.encode(controlSetName, forKey: .controlSetName)
        }
        if let evidenceInsights = self.evidenceInsights {
            try encodeContainer.encode(evidenceInsights, forKey: .evidenceInsights)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let evidenceInsightsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceInsights.self, forKey: .evidenceInsights)
        evidenceInsights = evidenceInsightsDecoded
        let controlSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetName)
        controlSetName = controlSetNameDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A summary of the latest analytics data for a specific control in a specific active assessment. Control insights are grouped by control domain, and ranked by the highest total count of non-compliant evidence.
    public struct ControlInsightsMetadataByAssessmentItem: Swift.Equatable {
        /// The name of the control set that the assessment control belongs to.
        public var controlSetName: Swift.String?
        /// A breakdown of the compliance check status for the evidence thats associated with the assessment control.
        public var evidenceInsights: AuditManagerClientTypes.EvidenceInsights?
        /// The unique identifier for the assessment control.
        public var id: Swift.String?
        /// The time when the assessment control insights were last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the assessment control.
        public var name: Swift.String?

        public init(
            controlSetName: Swift.String? = nil,
            evidenceInsights: AuditManagerClientTypes.EvidenceInsights? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.controlSetName = controlSetName
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
        }
    }

}

extension AuditManagerClientTypes.ControlInsightsMetadataItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceInsights
        case id
        case lastUpdated
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceInsights = self.evidenceInsights {
            try encodeContainer.encode(evidenceInsights, forKey: .evidenceInsights)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let evidenceInsightsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceInsights.self, forKey: .evidenceInsights)
        evidenceInsights = evidenceInsightsDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A summary of the latest analytics data for a specific control. This data reflects the total counts for the specified control across all active assessments. Control insights are grouped by control domain, and ranked by the highest total count of non-compliant evidence.
    public struct ControlInsightsMetadataItem: Swift.Equatable {
        /// A breakdown of the compliance check status for the evidence thats associated with the control.
        public var evidenceInsights: AuditManagerClientTypes.EvidenceInsights?
        /// The unique identifier for the control.
        public var id: Swift.String?
        /// The time when the control insights were last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the control.
        public var name: Swift.String?

        public init(
            evidenceInsights: AuditManagerClientTypes.EvidenceInsights? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
        }
    }

}

extension AuditManagerClientTypes.ControlMappingSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceDescription
        case sourceFrequency
        case sourceId
        case sourceKeyword
        case sourceName
        case sourceSetUpOption
        case sourceType
        case troubleshootingText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceDescription = self.sourceDescription {
            try encodeContainer.encode(sourceDescription, forKey: .sourceDescription)
        }
        if let sourceFrequency = self.sourceFrequency {
            try encodeContainer.encode(sourceFrequency.rawValue, forKey: .sourceFrequency)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let sourceKeyword = self.sourceKeyword {
            try encodeContainer.encode(sourceKeyword, forKey: .sourceKeyword)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceSetUpOption = self.sourceSetUpOption {
            try encodeContainer.encode(sourceSetUpOption.rawValue, forKey: .sourceSetUpOption)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let troubleshootingText = self.troubleshootingText {
            try encodeContainer.encode(troubleshootingText, forKey: .troubleshootingText)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDescription)
        sourceDescription = sourceDescriptionDecoded
        let sourceSetUpOptionDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceSetUpOption.self, forKey: .sourceSetUpOption)
        sourceSetUpOption = sourceSetUpOptionDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceKeywordDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceKeyword.self, forKey: .sourceKeyword)
        sourceKeyword = sourceKeywordDecoded
        let sourceFrequencyDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceFrequency.self, forKey: .sourceFrequency)
        sourceFrequency = sourceFrequencyDecoded
        let troubleshootingTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .troubleshootingText)
        troubleshootingText = troubleshootingTextDecoded
    }
}

extension AuditManagerClientTypes.ControlMappingSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ControlMappingSource(sourceDescription: \(Swift.String(describing: sourceDescription)), sourceFrequency: \(Swift.String(describing: sourceFrequency)), sourceId: \(Swift.String(describing: sourceId)), sourceKeyword: \(Swift.String(describing: sourceKeyword)), sourceName: \(Swift.String(describing: sourceName)), sourceSetUpOption: \(Swift.String(describing: sourceSetUpOption)), sourceType: \(Swift.String(describing: sourceType)), troubleshootingText: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The data source that determines where Audit Manager collects evidence from for the control.
    public struct ControlMappingSource: Swift.Equatable {
        /// The description of the source.
        public var sourceDescription: Swift.String?
        /// Specifies how often evidence is collected from the control mapping source.
        public var sourceFrequency: AuditManagerClientTypes.SourceFrequency?
        /// The unique identifier for the source.
        public var sourceId: Swift.String?
        /// A keyword that relates to the control data source. For manual evidence, this keyword indicates if the manual evidence is a file or text. For automated evidence, this keyword identifies a specific CloudTrail event, Config rule, Security Hub control, or Amazon Web Services API name. To learn more about the supported keywords that you can use when mapping a control data source, see the following pages in the Audit Manager User Guide:
        ///
        /// * [Config rules supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html)
        ///
        /// * [Security Hub controls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html)
        ///
        /// * [API calls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html)
        ///
        /// * [CloudTrail event names supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-cloudtrail.html)
        public var sourceKeyword: AuditManagerClientTypes.SourceKeyword?
        /// The name of the source.
        public var sourceName: Swift.String?
        /// The setup option for the data source. This option reflects if the evidence collection is automated or manual.
        public var sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption?
        /// Specifies one of the five data source types for evidence collection.
        public var sourceType: AuditManagerClientTypes.SourceType?
        /// The instructions for troubleshooting the control.
        public var troubleshootingText: Swift.String?

        public init(
            sourceDescription: Swift.String? = nil,
            sourceFrequency: AuditManagerClientTypes.SourceFrequency? = nil,
            sourceId: Swift.String? = nil,
            sourceKeyword: AuditManagerClientTypes.SourceKeyword? = nil,
            sourceName: Swift.String? = nil,
            sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption? = nil,
            sourceType: AuditManagerClientTypes.SourceType? = nil,
            troubleshootingText: Swift.String? = nil
        )
        {
            self.sourceDescription = sourceDescription
            self.sourceFrequency = sourceFrequency
            self.sourceId = sourceId
            self.sourceKeyword = sourceKeyword
            self.sourceName = sourceName
            self.sourceSetUpOption = sourceSetUpOption
            self.sourceType = sourceType
            self.troubleshootingText = troubleshootingText
        }
    }

}

extension AuditManagerClientTypes.ControlMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case controlSources
        case createdAt
        case id
        case lastUpdatedAt
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlSources = self.controlSources {
            try encodeContainer.encode(controlSources, forKey: .controlSources)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let controlSourcesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSources)
        controlSources = controlSourcesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AuditManagerClientTypes {
    /// The metadata that's associated with the standard control or custom control.
    public struct ControlMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the control.
        public var arn: Swift.String?
        /// The data source that determines where Audit Manager collects evidence from for the control.
        public var controlSources: Swift.String?
        /// The time when the control was created.
        public var createdAt: ClientRuntime.Date?
        /// The unique identifier for the control.
        public var id: Swift.String?
        /// The time when the control was most recently updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the control.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            controlSources: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
        }
    }

}

extension AuditManagerClientTypes {
    public enum ControlResponse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automate
        case `defer`
        case ignore
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlResponse] {
            return [
                .automate,
                .defer,
                .ignore,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automate: return "AUTOMATE"
            case .defer: return "DEFER"
            case .ignore: return "IGNORE"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlResponse(rawValue: rawValue) ?? ControlResponse.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.ControlSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controls
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for control0 in controls {
                try controlsContainer.encode(control0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let controlsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Control?].self, forKey: .controls)
        var controlsDecoded0:[AuditManagerClientTypes.Control]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [AuditManagerClientTypes.Control]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension AuditManagerClientTypes {
    /// A set of controls in Audit Manager.
    public struct ControlSet: Swift.Equatable {
        /// The list of controls within the control set.
        public var controls: [AuditManagerClientTypes.Control]?
        /// The identifier of the control set in the assessment. This is the control set name in a plain string format.
        public var id: Swift.String?
        /// The name of the control set.
        public var name: Swift.String?

        public init(
            controls: [AuditManagerClientTypes.Control]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.controls = controls
            self.id = id
            self.name = name
        }
    }

}

extension AuditManagerClientTypes {
    public enum ControlSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case reviewed
        case underReview
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlSetStatus] {
            return [
                .active,
                .reviewed,
                .underReview,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .reviewed: return "REVIEWED"
            case .underReview: return "UNDER_REVIEW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlSetStatus(rawValue: rawValue) ?? ControlSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum ControlStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inactive
        case reviewed
        case underReview
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlStatus] {
            return [
                .inactive,
                .reviewed,
                .underReview,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inactive: return "INACTIVE"
            case .reviewed: return "REVIEWED"
            case .underReview: return "UNDER_REVIEW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlStatus(rawValue: rawValue) ?? ControlStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum ControlType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlType] {
            return [
                .custom,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlType(rawValue: rawValue) ?? ControlType.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.CreateAssessmentFrameworkControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension AuditManagerClientTypes {
    /// The control entity attributes that uniquely identify an existing control to be added to a framework in Audit Manager.
    public struct CreateAssessmentFrameworkControl: Swift.Equatable {
        /// The unique identifier of the control.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension AuditManagerClientTypes.CreateAssessmentFrameworkControlSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controls
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for createassessmentframeworkcontrol0 in controls {
                try controlsContainer.encode(createassessmentframeworkcontrol0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let controlsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.CreateAssessmentFrameworkControl?].self, forKey: .controls)
        var controlsDecoded0:[AuditManagerClientTypes.CreateAssessmentFrameworkControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [AuditManagerClientTypes.CreateAssessmentFrameworkControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension AuditManagerClientTypes {
    /// A controlSet entity that represents a collection of controls in Audit Manager. This doesn't contain the control set ID.
    public struct CreateAssessmentFrameworkControlSet: Swift.Equatable {
        /// The list of controls within the control set. This doesn't contain the control set ID.
        public var controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]?
        /// The name of the control set.
        /// This member is required.
        public var name: Swift.String?

        public init(
            controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]? = nil,
            name: Swift.String? = nil
        )
        {
            self.controls = controls
            self.name = name
        }
    }

}

extension CreateAssessmentFrameworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssessmentFrameworkInput(controlSets: \(Swift.String(describing: controlSets)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), complianceType: \"CONTENT_REDACTED\")"}
}

extension CreateAssessmentFrameworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case controlSets
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for createassessmentframeworkcontrolset0 in controlSets {
                try controlSetsContainer.encode(createassessmentframeworkcontrolset0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssessmentFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessmentFrameworks"
    }
}

public struct CreateAssessmentFrameworkInput: Swift.Equatable {
    /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
    public var complianceType: Swift.String?
    /// The control sets that are associated with the framework.
    /// This member is required.
    public var controlSets: [AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]?
    /// An optional description for the new custom framework.
    public var description: Swift.String?
    /// The name of the new custom framework.
    /// This member is required.
    public var name: Swift.String?
    /// The tags that are associated with the framework.
    public var tags: [Swift.String:Swift.String]?

    public init(
        complianceType: Swift.String? = nil,
        controlSets: [AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.complianceType = complianceType
        self.controlSets = controlSets
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateAssessmentFrameworkInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let complianceType: Swift.String?
    let controlSets: [AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAssessmentFrameworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case controlSets
        case description
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.CreateAssessmentFrameworkControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssessmentFrameworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssessmentFrameworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.framework = output.framework
        } else {
            self.framework = nil
        }
    }
}

public struct CreateAssessmentFrameworkOutput: Swift.Equatable {
    /// The name of the new framework that the CreateAssessmentFramework API returned.
    public var framework: AuditManagerClientTypes.Framework?

    public init(
        framework: AuditManagerClientTypes.Framework? = nil
    )
    {
        self.framework = framework
    }
}

struct CreateAssessmentFrameworkOutputBody: Swift.Equatable {
    let framework: AuditManagerClientTypes.Framework?
}

extension CreateAssessmentFrameworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case framework
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Framework.self, forKey: .framework)
        framework = frameworkDecoded
    }
}

enum CreateAssessmentFrameworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssessmentInput(frameworkId: \(Swift.String(describing: frameworkId)), tags: \(Swift.String(describing: tags)), assessmentReportsDestination: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", roles: \"CONTENT_REDACTED\", scope: \"CONTENT_REDACTED\")"}
}

extension CreateAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportsDestination
        case description
        case frameworkId
        case name
        case roles
        case scope
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentReportsDestination = self.assessmentReportsDestination {
            try encodeContainer.encode(assessmentReportsDestination, forKey: .assessmentReportsDestination)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let frameworkId = self.frameworkId {
            try encodeContainer.encode(frameworkId, forKey: .frameworkId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessments"
    }
}

public struct CreateAssessmentInput: Swift.Equatable {
    /// The assessment report storage destination for the assessment that's being created.
    /// This member is required.
    public var assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    /// The optional description of the assessment to be created.
    public var description: Swift.String?
    /// The identifier for the framework that the assessment will be created from.
    /// This member is required.
    public var frameworkId: Swift.String?
    /// The name of the assessment to be created.
    /// This member is required.
    public var name: Swift.String?
    /// The list of roles for the assessment.
    /// This member is required.
    public var roles: [AuditManagerClientTypes.Role]?
    /// The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment.
    /// This member is required.
    public var scope: AuditManagerClientTypes.Scope?
    /// The tags that are associated with the assessment.
    public var tags: [Swift.String:Swift.String]?

    public init(
        assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
        description: Swift.String? = nil,
        frameworkId: Swift.String? = nil,
        name: Swift.String? = nil,
        roles: [AuditManagerClientTypes.Role]? = nil,
        scope: AuditManagerClientTypes.Scope? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assessmentReportsDestination = assessmentReportsDestination
        self.description = description
        self.frameworkId = frameworkId
        self.name = name
        self.roles = roles
        self.scope = scope
        self.tags = tags
    }
}

struct CreateAssessmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    let scope: AuditManagerClientTypes.Scope?
    let roles: [AuditManagerClientTypes.Role]?
    let frameworkId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportsDestination
        case description
        case frameworkId
        case name
        case roles
        case scope
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let assessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportsDestination.self, forKey: .assessmentReportsDestination)
        assessmentReportsDestination = assessmentReportsDestinationDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .roles)
        var rolesDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let frameworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkId)
        frameworkId = frameworkIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct CreateAssessmentOutput: Swift.Equatable {
    /// An entity that defines the scope of audit evidence collected by Audit Manager. An Audit Manager assessment is an implementation of an Audit Manager framework.
    public var assessment: AuditManagerClientTypes.Assessment?

    public init(
        assessment: AuditManagerClientTypes.Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct CreateAssessmentOutputBody: Swift.Equatable {
    let assessment: AuditManagerClientTypes.Assessment?
}

extension CreateAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

enum CreateAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAssessmentReportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssessmentReportInput(assessmentId: \(Swift.String(describing: assessmentId)), name: \(Swift.String(describing: name)), queryStatement: \(Swift.String(describing: queryStatement)), description: \"CONTENT_REDACTED\")"}
}

extension CreateAssessmentReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case queryStatement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
    }
}

extension CreateAssessmentReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/reports"
    }
}

public struct CreateAssessmentReportInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The description of the assessment report.
    public var description: Swift.String?
    /// The name of the new assessment report.
    /// This member is required.
    public var name: Swift.String?
    /// A SQL statement that represents an evidence finder query. Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually [added to a report using the console](https://docs.aws.amazon.com/audit-manager/latest/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence), or [associated with a report using the API](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_BatchAssociateAssessmentReportEvidence.html). To use this parameter, the [enablementStatus](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_EvidenceFinderEnablement.html#auditmanager-Type-EvidenceFinderEnablement-enablementStatus) of evidence finder must be ENABLED. For examples and help resolving queryStatement validation exceptions, see [Troubleshooting evidence finder issues](https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions) in the Audit Manager User Guide.
    public var queryStatement: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        queryStatement: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.description = description
        self.name = name
        self.queryStatement = queryStatement
    }
}

struct CreateAssessmentReportInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let queryStatement: Swift.String?
}

extension CreateAssessmentReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case queryStatement
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
    }
}

extension CreateAssessmentReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssessmentReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentReport = output.assessmentReport
        } else {
            self.assessmentReport = nil
        }
    }
}

public struct CreateAssessmentReportOutput: Swift.Equatable {
    /// The new assessment report that the CreateAssessmentReport API returned.
    public var assessmentReport: AuditManagerClientTypes.AssessmentReport?

    public init(
        assessmentReport: AuditManagerClientTypes.AssessmentReport? = nil
    )
    {
        self.assessmentReport = assessmentReport
    }
}

struct CreateAssessmentReportOutputBody: Swift.Equatable {
    let assessmentReport: AuditManagerClientTypes.AssessmentReport?
}

extension CreateAssessmentReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReport
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentReportDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReport.self, forKey: .assessmentReport)
        assessmentReport = assessmentReportDecoded
    }
}

enum CreateAssessmentReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateControlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateControlInput(controlMappingSources: \(Swift.String(describing: controlMappingSources)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), actionPlanInstructions: \"CONTENT_REDACTED\", actionPlanTitle: \"CONTENT_REDACTED\", testingInformation: \"CONTENT_REDACTED\")"}
}

extension CreateControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case tags
        case testingInformation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionPlanInstructions = self.actionPlanInstructions {
            try encodeContainer.encode(actionPlanInstructions, forKey: .actionPlanInstructions)
        }
        if let actionPlanTitle = self.actionPlanTitle {
            try encodeContainer.encode(actionPlanTitle, forKey: .actionPlanTitle)
        }
        if let controlMappingSources = controlMappingSources {
            var controlMappingSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlMappingSources)
            for createcontrolmappingsource0 in controlMappingSources {
                try controlMappingSourcesContainer.encode(createcontrolmappingsource0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let testingInformation = self.testingInformation {
            try encodeContainer.encode(testingInformation, forKey: .testingInformation)
        }
    }
}

extension CreateControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/controls"
    }
}

public struct CreateControlInput: Swift.Equatable {
    /// The recommended actions to carry out if the control isn't fulfilled.
    public var actionPlanInstructions: Swift.String?
    /// The title of the action plan for remediating the control.
    public var actionPlanTitle: Swift.String?
    /// The data mapping sources for the control.
    /// This member is required.
    public var controlMappingSources: [AuditManagerClientTypes.CreateControlMappingSource]?
    /// The description of the control.
    public var description: Swift.String?
    /// The name of the control.
    /// This member is required.
    public var name: Swift.String?
    /// The tags that are associated with the control.
    public var tags: [Swift.String:Swift.String]?
    /// The steps to follow to determine if the control is satisfied.
    public var testingInformation: Swift.String?

    public init(
        actionPlanInstructions: Swift.String? = nil,
        actionPlanTitle: Swift.String? = nil,
        controlMappingSources: [AuditManagerClientTypes.CreateControlMappingSource]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        testingInformation: Swift.String? = nil
    )
    {
        self.actionPlanInstructions = actionPlanInstructions
        self.actionPlanTitle = actionPlanTitle
        self.controlMappingSources = controlMappingSources
        self.description = description
        self.name = name
        self.tags = tags
        self.testingInformation = testingInformation
    }
}

struct CreateControlInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let testingInformation: Swift.String?
    let actionPlanTitle: Swift.String?
    let actionPlanInstructions: Swift.String?
    let controlMappingSources: [AuditManagerClientTypes.CreateControlMappingSource]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case tags
        case testingInformation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let testingInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testingInformation)
        testingInformation = testingInformationDecoded
        let actionPlanTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanTitle)
        actionPlanTitle = actionPlanTitleDecoded
        let actionPlanInstructionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanInstructions)
        actionPlanInstructions = actionPlanInstructionsDecoded
        let controlMappingSourcesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.CreateControlMappingSource?].self, forKey: .controlMappingSources)
        var controlMappingSourcesDecoded0:[AuditManagerClientTypes.CreateControlMappingSource]? = nil
        if let controlMappingSourcesContainer = controlMappingSourcesContainer {
            controlMappingSourcesDecoded0 = [AuditManagerClientTypes.CreateControlMappingSource]()
            for structure0 in controlMappingSourcesContainer {
                if let structure0 = structure0 {
                    controlMappingSourcesDecoded0?.append(structure0)
                }
            }
        }
        controlMappingSources = controlMappingSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AuditManagerClientTypes.CreateControlMappingSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceDescription
        case sourceFrequency
        case sourceKeyword
        case sourceName
        case sourceSetUpOption
        case sourceType
        case troubleshootingText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceDescription = self.sourceDescription {
            try encodeContainer.encode(sourceDescription, forKey: .sourceDescription)
        }
        if let sourceFrequency = self.sourceFrequency {
            try encodeContainer.encode(sourceFrequency.rawValue, forKey: .sourceFrequency)
        }
        if let sourceKeyword = self.sourceKeyword {
            try encodeContainer.encode(sourceKeyword, forKey: .sourceKeyword)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceSetUpOption = self.sourceSetUpOption {
            try encodeContainer.encode(sourceSetUpOption.rawValue, forKey: .sourceSetUpOption)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let troubleshootingText = self.troubleshootingText {
            try encodeContainer.encode(troubleshootingText, forKey: .troubleshootingText)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDescription)
        sourceDescription = sourceDescriptionDecoded
        let sourceSetUpOptionDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceSetUpOption.self, forKey: .sourceSetUpOption)
        sourceSetUpOption = sourceSetUpOptionDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceKeywordDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceKeyword.self, forKey: .sourceKeyword)
        sourceKeyword = sourceKeywordDecoded
        let sourceFrequencyDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceFrequency.self, forKey: .sourceFrequency)
        sourceFrequency = sourceFrequencyDecoded
        let troubleshootingTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .troubleshootingText)
        troubleshootingText = troubleshootingTextDecoded
    }
}

extension AuditManagerClientTypes.CreateControlMappingSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateControlMappingSource(sourceDescription: \(Swift.String(describing: sourceDescription)), sourceFrequency: \(Swift.String(describing: sourceFrequency)), sourceKeyword: \(Swift.String(describing: sourceKeyword)), sourceName: \(Swift.String(describing: sourceName)), sourceSetUpOption: \(Swift.String(describing: sourceSetUpOption)), sourceType: \(Swift.String(describing: sourceType)), troubleshootingText: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The control mapping fields that represent the source for evidence collection, along with related parameters and metadata. This doesn't contain mappingID.
    public struct CreateControlMappingSource: Swift.Equatable {
        /// The description of the data source that determines where Audit Manager collects evidence from for the control.
        public var sourceDescription: Swift.String?
        /// Specifies how often evidence is collected from the control mapping source.
        public var sourceFrequency: AuditManagerClientTypes.SourceFrequency?
        /// A keyword that relates to the control data source. For manual evidence, this keyword indicates if the manual evidence is a file or text. For automated evidence, this keyword identifies a specific CloudTrail event, Config rule, Security Hub control, or Amazon Web Services API name. To learn more about the supported keywords that you can use when mapping a control data source, see the following pages in the Audit Manager User Guide:
        ///
        /// * [Config rules supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html)
        ///
        /// * [Security Hub controls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html)
        ///
        /// * [API calls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html)
        ///
        /// * [CloudTrail event names supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-cloudtrail.html)
        public var sourceKeyword: AuditManagerClientTypes.SourceKeyword?
        /// The name of the control mapping data source.
        public var sourceName: Swift.String?
        /// The setup option for the data source, which reflects if the evidence collection is automated or manual.
        public var sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption?
        /// Specifies one of the five types of data sources for evidence collection.
        public var sourceType: AuditManagerClientTypes.SourceType?
        /// The instructions for troubleshooting the control.
        public var troubleshootingText: Swift.String?

        public init(
            sourceDescription: Swift.String? = nil,
            sourceFrequency: AuditManagerClientTypes.SourceFrequency? = nil,
            sourceKeyword: AuditManagerClientTypes.SourceKeyword? = nil,
            sourceName: Swift.String? = nil,
            sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption? = nil,
            sourceType: AuditManagerClientTypes.SourceType? = nil,
            troubleshootingText: Swift.String? = nil
        )
        {
            self.sourceDescription = sourceDescription
            self.sourceFrequency = sourceFrequency
            self.sourceKeyword = sourceKeyword
            self.sourceName = sourceName
            self.sourceSetUpOption = sourceSetUpOption
            self.sourceType = sourceType
            self.troubleshootingText = troubleshootingText
        }
    }

}

extension CreateControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct CreateControlOutput: Swift.Equatable {
    /// The new control that the CreateControl API returned.
    public var control: AuditManagerClientTypes.Control?

    public init(
        control: AuditManagerClientTypes.Control? = nil
    )
    {
        self.control = control
    }
}

struct CreateControlOutputBody: Swift.Equatable {
    let control: AuditManagerClientTypes.Control?
}

extension CreateControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case control
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Control.self, forKey: .control)
        control = controlDecoded
    }
}

enum CreateControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.CreateDelegationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case controlSetId
        case roleArn
        case roleType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let controlSetId = self.controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let roleType = self.roleType {
            try encodeContainer.encode(roleType.rawValue, forKey: .roleType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let roleTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.RoleType.self, forKey: .roleType)
        roleType = roleTypeDecoded
    }
}

extension AuditManagerClientTypes.CreateDelegationRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDelegationRequest(controlSetId: \(Swift.String(describing: controlSetId)), roleArn: \(Swift.String(describing: roleArn)), roleType: \(Swift.String(describing: roleType)), comment: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// A collection of attributes that's used to create a delegation for an assessment in Audit Manager.
    public struct CreateDelegationRequest: Swift.Equatable {
        /// A comment that's related to the delegation request.
        public var comment: Swift.String?
        /// The unique identifier for the control set.
        public var controlSetId: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role.
        public var roleArn: Swift.String?
        /// The type of customer persona. In CreateAssessment, roleType can only be PROCESS_OWNER. In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public var roleType: AuditManagerClientTypes.RoleType?

        public init(
            comment: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            roleType: AuditManagerClientTypes.RoleType? = nil
        )
        {
            self.comment = comment
            self.controlSetId = controlSetId
            self.roleArn = roleArn
            self.roleType = roleType
        }
    }

}

extension AuditManagerClientTypes.DefaultExportDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case destinationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ExportDestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension AuditManagerClientTypes {
    /// The default s3 bucket where Audit Manager saves the files that you export from evidence finder.
    public struct DefaultExportDestination: Swift.Equatable {
        /// The destination bucket where Audit Manager stores exported files.
        public var destination: Swift.String?
        /// The destination type, such as Amazon S3.
        public var destinationType: AuditManagerClientTypes.ExportDestinationType?

        public init(
            destination: Swift.String? = nil,
            destinationType: AuditManagerClientTypes.ExportDestinationType? = nil
        )
        {
            self.destination = destination
            self.destinationType = destinationType
        }
    }

}

extension AuditManagerClientTypes.Delegation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentName
        case comment
        case controlSetId
        case createdBy
        case creationTime
        case id
        case lastUpdated
        case roleArn
        case roleType
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let controlSetId = self.controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let roleType = self.roleType {
            try encodeContainer.encode(roleType.rawValue, forKey: .roleType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.DelegationStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let roleTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.RoleType.self, forKey: .roleType)
        roleType = roleTypeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension AuditManagerClientTypes.Delegation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AuditManagerClientTypes {
    /// The assignment of a control set to a delegate for review.
    public struct Delegation: Swift.Equatable {
        /// The identifier for the assessment that's associated with the delegation.
        public var assessmentId: Swift.String?
        /// The name of the assessment that's associated with the delegation.
        public var assessmentName: Swift.String?
        /// The comment that's related to the delegation.
        public var comment: Swift.String?
        /// The identifier for the control set that's associated with the delegation.
        public var controlSetId: Swift.String?
        /// The user or role that created the delegation.
        public var createdBy: Swift.String?
        /// Specifies when the delegation was created.
        public var creationTime: ClientRuntime.Date?
        /// The unique identifier for the delegation.
        public var id: Swift.String?
        /// Specifies when the delegation was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM role.
        public var roleArn: Swift.String?
        /// The type of customer persona. In CreateAssessment, roleType can only be PROCESS_OWNER. In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public var roleType: AuditManagerClientTypes.RoleType?
        /// The status of the delegation.
        public var status: AuditManagerClientTypes.DelegationStatus?

        public init(
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            comment: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            roleType: AuditManagerClientTypes.RoleType? = nil,
            status: AuditManagerClientTypes.DelegationStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.comment = comment
            self.controlSetId = controlSetId
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.id = id
            self.lastUpdated = lastUpdated
            self.roleArn = roleArn
            self.roleType = roleType
            self.status = status
        }
    }

}

extension AuditManagerClientTypes.DelegationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentName
        case controlSetName
        case creationTime
        case id
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let controlSetName = self.controlSetName {
            try encodeContainer.encode(controlSetName, forKey: .controlSetName)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.DelegationStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let controlSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetName)
        controlSetName = controlSetNameDecoded
    }
}

extension AuditManagerClientTypes.DelegationMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DelegationMetadata(assessmentId: \(Swift.String(describing: assessmentId)), controlSetName: \(Swift.String(describing: controlSetName)), creationTime: \(Swift.String(describing: creationTime)), id: \(Swift.String(describing: id)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), assessmentName: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The metadata that's associated with the delegation.
    public struct DelegationMetadata: Swift.Equatable {
        /// The unique identifier for the assessment.
        public var assessmentId: Swift.String?
        /// The name of the associated assessment.
        public var assessmentName: Swift.String?
        /// Specifies the name of the control set that was delegated for review.
        public var controlSetName: Swift.String?
        /// Specifies when the delegation was created.
        public var creationTime: ClientRuntime.Date?
        /// The unique identifier for the delegation.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role.
        public var roleArn: Swift.String?
        /// The current status of the delegation.
        public var status: AuditManagerClientTypes.DelegationStatus?

        public init(
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            controlSetName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: AuditManagerClientTypes.DelegationStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.controlSetName = controlSetName
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension AuditManagerClientTypes {
    public enum DelegationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inProgress
        case underReview
        case sdkUnknown(Swift.String)

        public static var allCases: [DelegationStatus] {
            return [
                .complete,
                .inProgress,
                .underReview,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inProgress: return "IN_PROGRESS"
            case .underReview: return "UNDER_REVIEW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DelegationStatus(rawValue: rawValue) ?? DelegationStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAssessmentFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkId = frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())"
    }
}

public struct DeleteAssessmentFrameworkInput: Swift.Equatable {
    /// The identifier for the custom framework.
    /// This member is required.
    public var frameworkId: Swift.String?

    public init(
        frameworkId: Swift.String? = nil
    )
    {
        self.frameworkId = frameworkId
    }
}

struct DeleteAssessmentFrameworkInputBody: Swift.Equatable {
}

extension DeleteAssessmentFrameworkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssessmentFrameworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssessmentFrameworkOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssessmentFrameworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAssessmentFrameworkShareInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let requestType = requestType else {
                let message = "Creating a URL Query Item failed. requestType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let requestTypeQueryItem = ClientRuntime.URLQueryItem(name: "requestType".urlPercentEncoding(), value: Swift.String(requestType.rawValue).urlPercentEncoding())
            items.append(requestTypeQueryItem)
            return items
        }
    }
}

extension DeleteAssessmentFrameworkShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let requestId = requestId else {
            return nil
        }
        return "/assessmentFrameworkShareRequests/\(requestId.urlPercentEncoding())"
    }
}

public struct DeleteAssessmentFrameworkShareInput: Swift.Equatable {
    /// The unique identifier for the share request to be deleted.
    /// This member is required.
    public var requestId: Swift.String?
    /// Specifies whether the share request is a sent request or a received request.
    /// This member is required.
    public var requestType: AuditManagerClientTypes.ShareRequestType?

    public init(
        requestId: Swift.String? = nil,
        requestType: AuditManagerClientTypes.ShareRequestType? = nil
    )
    {
        self.requestId = requestId
        self.requestType = requestType
    }
}

struct DeleteAssessmentFrameworkShareInputBody: Swift.Equatable {
}

extension DeleteAssessmentFrameworkShareInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssessmentFrameworkShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssessmentFrameworkShareOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssessmentFrameworkShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

public struct DeleteAssessmentInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct DeleteAssessmentInputBody: Swift.Equatable {
}

extension DeleteAssessmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssessmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAssessmentReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let assessmentReportId = assessmentReportId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/reports/\(assessmentReportId.urlPercentEncoding())"
    }
}

public struct DeleteAssessmentReportInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the assessment report.
    /// This member is required.
    public var assessmentReportId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        assessmentReportId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentReportId = assessmentReportId
    }
}

struct DeleteAssessmentReportInputBody: Swift.Equatable {
}

extension DeleteAssessmentReportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssessmentReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssessmentReportOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssessmentReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let controlId = controlId else {
            return nil
        }
        return "/controls/\(controlId.urlPercentEncoding())"
    }
}

public struct DeleteControlInput: Swift.Equatable {
    /// The unique identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?

    public init(
        controlId: Swift.String? = nil
    )
    {
        self.controlId = controlId
    }
}

struct DeleteControlInputBody: Swift.Equatable {
}

extension DeleteControlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteControlOutput: Swift.Equatable {

    public init() { }
}

enum DeleteControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes {
    public enum DeleteResources: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [DeleteResources] {
            return [
                .all,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeleteResources(rawValue: rawValue) ?? DeleteResources.sdkUnknown(rawValue)
        }
    }
}

extension DeregisterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/deregisterAccount"
    }
}

public struct DeregisterAccountInput: Swift.Equatable {

    public init() { }
}

struct DeregisterAccountInputBody: Swift.Equatable {
}

extension DeregisterAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeregisterAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeregisterAccountOutput: Swift.Equatable {
    /// The registration status of the account.
    public var status: AuditManagerClientTypes.AccountStatus?

    public init(
        status: AuditManagerClientTypes.AccountStatus? = nil
    )
    {
        self.status = status
    }
}

struct DeregisterAccountOutputBody: Swift.Equatable {
    let status: AuditManagerClientTypes.AccountStatus?
}

extension DeregisterAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AccountStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeregisterAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension DeregisterOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/deregisterOrganizationAdminAccount"
    }
}

public struct DeregisterOrganizationAdminAccountInput: Swift.Equatable {
    /// The identifier for the administrator account.
    public var adminAccountId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DeregisterOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension DeregisterOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension DeregisterOrganizationAdminAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterOrganizationAdminAccountOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.DeregistrationPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteResources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteResources = self.deleteResources {
            try encodeContainer.encode(deleteResources.rawValue, forKey: .deleteResources)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteResourcesDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.DeleteResources.self, forKey: .deleteResources)
        deleteResources = deleteResourcesDecoded
    }
}

extension AuditManagerClientTypes {
    /// The deregistration policy for the data that's stored in Audit Manager. You can use this attribute to determine how your data is handled when you [deregister Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html). By default, Audit Manager retains evidence data for two years from the time of its creation. Other Audit Manager resources (including assessments, custom controls, and custom frameworks) remain in Audit Manager indefinitely, and are available if you [re-register Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html) in the future. For more information about data retention, see [Data Protection](https://docs.aws.amazon.com/audit-manager/latest/userguide/data-protection.html) in the Audit Manager User Guide. If you choose to delete all data, this action permanently deletes all evidence data in your account within seven days. It also deletes all of the Audit Manager resources that you created, including assessments, custom controls, and custom frameworks. Your data will not be available if you re-register Audit Manager in the future.
    public struct DeregistrationPolicy: Swift.Equatable {
        /// Specifies which Audit Manager data will be deleted when you deregister Audit Manager.
        ///
        /// * If you set the value to ALL, all of your data is deleted within seven days of deregistration.
        ///
        /// * If you set the value to DEFAULT, none of your data is deleted at the time of deregistration. However, keep in mind that the Audit Manager data retention policy still applies. As a result, any evidence data will be deleted two years after its creation date. Your other Audit Manager resources will continue to exist indefinitely.
        public var deleteResources: AuditManagerClientTypes.DeleteResources?

        public init(
            deleteResources: AuditManagerClientTypes.DeleteResources? = nil
        )
        {
            self.deleteResources = deleteResources
        }
    }

}

extension DisassociateAssessmentReportEvidenceFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = self.evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
    }
}

extension DisassociateAssessmentReportEvidenceFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/disassociateFromAssessmentReport"
    }
}

public struct DisassociateAssessmentReportEvidenceFolderInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
    }
}

struct DisassociateAssessmentReportEvidenceFolderInputBody: Swift.Equatable {
    let evidenceFolderId: Swift.String?
}

extension DisassociateAssessmentReportEvidenceFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
    }
}

extension DisassociateAssessmentReportEvidenceFolderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateAssessmentReportEvidenceFolderOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateAssessmentReportEvidenceFolderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.Evidence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportSelection
        case attributes
        case awsAccountId
        case awsOrganization
        case complianceCheck
        case dataSource
        case eventName
        case eventSource
        case evidenceAwsAccountId
        case evidenceByType
        case evidenceFolderId
        case iamId
        case id
        case resourcesIncluded
        case time
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentReportSelection = self.assessmentReportSelection {
            try encodeContainer.encode(assessmentReportSelection, forKey: .assessmentReportSelection)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, evidenceAttributes0) in attributes {
                try attributesContainer.encode(evidenceAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsOrganization = self.awsOrganization {
            try encodeContainer.encode(awsOrganization, forKey: .awsOrganization)
        }
        if let complianceCheck = self.complianceCheck {
            try encodeContainer.encode(complianceCheck, forKey: .complianceCheck)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let eventSource = self.eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let evidenceAwsAccountId = self.evidenceAwsAccountId {
            try encodeContainer.encode(evidenceAwsAccountId, forKey: .evidenceAwsAccountId)
        }
        if let evidenceByType = self.evidenceByType {
            try encodeContainer.encode(evidenceByType, forKey: .evidenceByType)
        }
        if let evidenceFolderId = self.evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
        if let iamId = self.iamId {
            try encodeContainer.encode(iamId, forKey: .iamId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resourcesIncluded = resourcesIncluded {
            var resourcesIncludedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourcesIncluded)
            for resource0 in resourcesIncluded {
                try resourcesIncludedContainer.encode(resource0)
            }
        }
        if let time = self.time {
            try encodeContainer.encodeTimestamp(time, format: .epochSeconds, forKey: .time)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let evidenceAwsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceAwsAccountId)
        evidenceAwsAccountId = evidenceAwsAccountIdDecoded
        let timeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .time)
        time = timeDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let evidenceByTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceByType)
        evidenceByType = evidenceByTypeDecoded
        let resourcesIncludedContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Resource?].self, forKey: .resourcesIncluded)
        var resourcesIncludedDecoded0:[AuditManagerClientTypes.Resource]? = nil
        if let resourcesIncludedContainer = resourcesIncludedContainer {
            resourcesIncludedDecoded0 = [AuditManagerClientTypes.Resource]()
            for structure0 in resourcesIncludedContainer {
                if let structure0 = structure0 {
                    resourcesIncludedDecoded0?.append(structure0)
                }
            }
        }
        resourcesIncluded = resourcesIncludedDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, evidenceattributevalue0) in attributesContainer {
                if let evidenceattributevalue0 = evidenceattributevalue0 {
                    attributesDecoded0?[key0] = evidenceattributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let iamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamId)
        iamId = iamIdDecoded
        let complianceCheckDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceCheck)
        complianceCheck = complianceCheckDecoded
        let awsOrganizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsOrganization)
        awsOrganization = awsOrganizationDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let assessmentReportSelectionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentReportSelection)
        assessmentReportSelection = assessmentReportSelectionDecoded
    }
}

extension AuditManagerClientTypes {
    /// A record that contains the information needed to demonstrate compliance with the requirements specified by a control. Examples of evidence include change activity invoked by a user, or a system configuration snapshot.
    public struct Evidence: Swift.Equatable {
        /// Specifies whether the evidence is included in the assessment report.
        public var assessmentReportSelection: Swift.String?
        /// The names and values that are used by the evidence event. This includes an attribute name (such as allowUsersToChangePassword) and value (such as true or false).
        public var attributes: [Swift.String:Swift.String]?
        /// The identifier for the Amazon Web Services account.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services account that the evidence is collected from, and its organization path.
        public var awsOrganization: Swift.String?
        /// The evaluation status for automated evidence that falls under the compliance check category.
        ///
        /// * Audit Manager classes evidence as non-compliant if Security Hub reports a Fail result, or if Config reports a Non-compliant result.
        ///
        /// * Audit Manager classes evidence as compliant if Security Hub reports a Pass result, or if Config reports a Compliant result.
        ///
        /// * If a compliance check isn't available or applicable, then no compliance evaluation can be made for that evidence. This is the case if the evidence uses Config or Security Hub as the underlying data source type, but those services aren't enabled. This is also the case if the evidence uses an underlying data source type that doesn't support compliance checks (such as manual evidence, Amazon Web Services API calls, or CloudTrail).
        public var complianceCheck: Swift.String?
        /// The data source where the evidence was collected from.
        public var dataSource: Swift.String?
        /// The name of the evidence event.
        public var eventName: Swift.String?
        /// The Amazon Web Service that the evidence is collected from.
        public var eventSource: Swift.String?
        /// The identifier for the Amazon Web Services account.
        public var evidenceAwsAccountId: Swift.String?
        /// The type of automated evidence.
        public var evidenceByType: Swift.String?
        /// The identifier for the folder that the evidence is stored in.
        public var evidenceFolderId: Swift.String?
        /// The unique identifier for the user or role that's associated with the evidence.
        public var iamId: Swift.String?
        /// The identifier for the evidence.
        public var id: Swift.String?
        /// The list of resources that are assessed to generate the evidence.
        public var resourcesIncluded: [AuditManagerClientTypes.Resource]?
        /// The timestamp that represents when the evidence was collected.
        public var time: ClientRuntime.Date?

        public init(
            assessmentReportSelection: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            awsAccountId: Swift.String? = nil,
            awsOrganization: Swift.String? = nil,
            complianceCheck: Swift.String? = nil,
            dataSource: Swift.String? = nil,
            eventName: Swift.String? = nil,
            eventSource: Swift.String? = nil,
            evidenceAwsAccountId: Swift.String? = nil,
            evidenceByType: Swift.String? = nil,
            evidenceFolderId: Swift.String? = nil,
            iamId: Swift.String? = nil,
            id: Swift.String? = nil,
            resourcesIncluded: [AuditManagerClientTypes.Resource]? = nil,
            time: ClientRuntime.Date? = nil
        )
        {
            self.assessmentReportSelection = assessmentReportSelection
            self.attributes = attributes
            self.awsAccountId = awsAccountId
            self.awsOrganization = awsOrganization
            self.complianceCheck = complianceCheck
            self.dataSource = dataSource
            self.eventName = eventName
            self.eventSource = eventSource
            self.evidenceAwsAccountId = evidenceAwsAccountId
            self.evidenceByType = evidenceByType
            self.evidenceFolderId = evidenceFolderId
            self.iamId = iamId
            self.id = id
            self.resourcesIncluded = resourcesIncluded
            self.time = time
        }
    }

}

extension AuditManagerClientTypes {
    public enum EvidenceFinderBackfillStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [EvidenceFinderBackfillStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvidenceFinderBackfillStatus(rawValue: rawValue) ?? EvidenceFinderBackfillStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.EvidenceFinderEnablement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backfillStatus
        case enablementStatus
        case error
        case eventDataStoreArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backfillStatus = self.backfillStatus {
            try encodeContainer.encode(backfillStatus.rawValue, forKey: .backfillStatus)
        }
        if let enablementStatus = self.enablementStatus {
            try encodeContainer.encode(enablementStatus.rawValue, forKey: .enablementStatus)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let eventDataStoreArn = self.eventDataStoreArn {
            try encodeContainer.encode(eventDataStoreArn, forKey: .eventDataStoreArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let enablementStatusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceFinderEnablementStatus.self, forKey: .enablementStatus)
        enablementStatus = enablementStatusDecoded
        let backfillStatusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceFinderBackfillStatus.self, forKey: .backfillStatus)
        backfillStatus = backfillStatusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension AuditManagerClientTypes {
    /// The settings object that specifies whether evidence finder is enabled. This object also describes the related event data store, and the backfill status for populating the event data store with evidence data.
    public struct EvidenceFinderEnablement: Swift.Equatable {
        /// The current status of the evidence data backfill process. The backfill starts after you enable evidence finder. During this task, Audit Manager populates an event data store with your past two years worth of evidence data so that your evidence can be queried.
        ///
        /// * NOT_STARTED means that the backfill hasnt started yet.
        ///
        /// * IN_PROGRESS means that the backfill is in progress. This can take up to 7 days to complete, depending on the amount of evidence data.
        ///
        /// * COMPLETED means that the backfill is complete. All of your past evidence is now queryable.
        public var backfillStatus: AuditManagerClientTypes.EvidenceFinderBackfillStatus?
        /// The current status of the evidence finder feature and the related event data store.
        ///
        /// * ENABLE_IN_PROGRESS means that you requested to enable evidence finder. An event data store is currently being created to support evidence finder queries.
        ///
        /// * ENABLED means that an event data store was successfully created and evidence finder is enabled. We recommend that you wait 7 days until the event data store is backfilled with your past two years worth of evidence data. You can use evidence finder in the meantime, but not all data might be available until the backfill is complete.
        ///
        /// * DISABLE_IN_PROGRESS means that you requested to disable evidence finder, and your request is pending the deletion of the event data store.
        ///
        /// * DISABLED means that you have permanently disabled evidence finder and the event data store has been deleted. You can't re-enable evidence finder after this point.
        public var enablementStatus: AuditManagerClientTypes.EvidenceFinderEnablementStatus?
        /// Represents any errors that occurred when enabling or disabling evidence finder.
        public var error: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudTrail Lake event data store thats used by evidence finder. The event data store is the lake of evidence data that evidence finder runs queries against.
        public var eventDataStoreArn: Swift.String?

        public init(
            backfillStatus: AuditManagerClientTypes.EvidenceFinderBackfillStatus? = nil,
            enablementStatus: AuditManagerClientTypes.EvidenceFinderEnablementStatus? = nil,
            error: Swift.String? = nil,
            eventDataStoreArn: Swift.String? = nil
        )
        {
            self.backfillStatus = backfillStatus
            self.enablementStatus = enablementStatus
            self.error = error
            self.eventDataStoreArn = eventDataStoreArn
        }
    }

}

extension AuditManagerClientTypes {
    public enum EvidenceFinderEnablementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disableInProgress
        case enabled
        case enableInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [EvidenceFinderEnablementStatus] {
            return [
                .disabled,
                .disableInProgress,
                .enabled,
                .enableInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case .enableInProgress: return "ENABLE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvidenceFinderEnablementStatus(rawValue: rawValue) ?? EvidenceFinderEnablementStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.EvidenceInsights: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compliantEvidenceCount
        case inconclusiveEvidenceCount
        case noncompliantEvidenceCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compliantEvidenceCount = self.compliantEvidenceCount {
            try encodeContainer.encode(compliantEvidenceCount, forKey: .compliantEvidenceCount)
        }
        if let inconclusiveEvidenceCount = self.inconclusiveEvidenceCount {
            try encodeContainer.encode(inconclusiveEvidenceCount, forKey: .inconclusiveEvidenceCount)
        }
        if let noncompliantEvidenceCount = self.noncompliantEvidenceCount {
            try encodeContainer.encode(noncompliantEvidenceCount, forKey: .noncompliantEvidenceCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncompliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncompliantEvidenceCount)
        noncompliantEvidenceCount = noncompliantEvidenceCountDecoded
        let compliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantEvidenceCount)
        compliantEvidenceCount = compliantEvidenceCountDecoded
        let inconclusiveEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inconclusiveEvidenceCount)
        inconclusiveEvidenceCount = inconclusiveEvidenceCountDecoded
    }
}

extension AuditManagerClientTypes {
    /// A breakdown of the latest compliance check status for the evidence in your Audit Manager assessments.
    public struct EvidenceInsights: Swift.Equatable {
        /// The number of compliance check evidence that Audit Manager classified as compliant. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public var compliantEvidenceCount: Swift.Int?
        /// The number of evidence that a compliance check ruling isn't available for. Evidence is inconclusive when the associated control uses Security Hub or Config as a data source but you didn't enable those services. This is also the case when a control uses a data source that doesnt support compliance checks (for example, manual evidence, API calls, or CloudTrail). If evidence has a compliance check status of not applicable in the console, it's classified as inconclusive in EvidenceInsights data.
        public var inconclusiveEvidenceCount: Swift.Int?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public var noncompliantEvidenceCount: Swift.Int?

        public init(
            compliantEvidenceCount: Swift.Int? = nil,
            inconclusiveEvidenceCount: Swift.Int? = nil,
            noncompliantEvidenceCount: Swift.Int? = nil
        )
        {
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
        }
    }

}

extension AuditManagerClientTypes {
    public enum ExportDestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportDestinationType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportDestinationType(rawValue: rawValue) ?? ExportDestinationType.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.Framework: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case complianceType
        case controlSets
        case controlSources
        case createdAt
        case createdBy
        case description
        case id
        case lastUpdatedAt
        case lastUpdatedBy
        case logo
        case name
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for controlset0 in controlSets {
                try controlSetsContainer.encode(controlset0)
            }
        }
        if let controlSources = self.controlSources {
            try encodeContainer.encode(controlSources, forKey: .controlSources)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = self.lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let logo = self.logo {
            try encodeContainer.encode(logo, forKey: .logo)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.FrameworkType.self, forKey: .type)
        type = typeDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let logoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logo)
        logo = logoDecoded
        let controlSourcesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSources)
        controlSources = controlSourcesDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[AuditManagerClientTypes.ControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [AuditManagerClientTypes.ControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AuditManagerClientTypes.Framework: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Framework(arn: \(Swift.String(describing: arn)), controlSources: \(Swift.String(describing: controlSources)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), logo: \(Swift.String(describing: logo)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), complianceType: \"CONTENT_REDACTED\", controlSets: \"CONTENT_REDACTED\", createdBy: \"CONTENT_REDACTED\", lastUpdatedBy: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The file that's used to structure and automate Audit Manager assessments for a given compliance standard.
    public struct Framework: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the framework.
        public var arn: Swift.String?
        /// The compliance type that the framework supports, such as CIS or HIPAA.
        public var complianceType: Swift.String?
        /// The control sets that are associated with the framework.
        public var controlSets: [AuditManagerClientTypes.ControlSet]?
        /// The control data sources where Audit Manager collects evidence from.
        public var controlSources: Swift.String?
        /// The time when the framework was created.
        public var createdAt: ClientRuntime.Date?
        /// The user or role that created the framework.
        public var createdBy: Swift.String?
        /// The description of the framework.
        public var description: Swift.String?
        /// The unique identifier for the framework.
        public var id: Swift.String?
        /// The time when the framework was most recently updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The user or role that most recently updated the framework.
        public var lastUpdatedBy: Swift.String?
        /// The logo that's associated with the framework.
        public var logo: Swift.String?
        /// The name of the framework.
        public var name: Swift.String?
        /// The tags that are associated with the framework.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies whether the framework is a standard framework or a custom framework.
        public var type: AuditManagerClientTypes.FrameworkType?

        public init(
            arn: Swift.String? = nil,
            complianceType: Swift.String? = nil,
            controlSets: [AuditManagerClientTypes.ControlSet]? = nil,
            controlSources: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            logo: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: AuditManagerClientTypes.FrameworkType? = nil
        )
        {
            self.arn = arn
            self.complianceType = complianceType
            self.controlSets = controlSets
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.logo = logo
            self.name = name
            self.tags = tags
            self.type = type
        }
    }

}

extension AuditManagerClientTypes.FrameworkMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case description
        case logo
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logo = self.logo {
            try encodeContainer.encode(logo, forKey: .logo)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let logoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logo)
        logo = logoDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
    }
}

extension AuditManagerClientTypes.FrameworkMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FrameworkMetadata(description: \(Swift.String(describing: description)), logo: \(Swift.String(describing: logo)), complianceType: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The metadata of a framework, such as the name, ID, or description.
    public struct FrameworkMetadata: Swift.Equatable {
        /// The compliance standard that's associated with the framework. For example, this could be PCI DSS or HIPAA.
        public var complianceType: Swift.String?
        /// The description of the framework.
        public var description: Swift.String?
        /// The logo that's associated with the framework.
        public var logo: Swift.String?
        /// The name of the framework.
        public var name: Swift.String?

        public init(
            complianceType: Swift.String? = nil,
            description: Swift.String? = nil,
            logo: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.complianceType = complianceType
            self.description = description
            self.logo = logo
            self.name = name
        }
    }

}

extension AuditManagerClientTypes {
    public enum FrameworkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [FrameworkType] {
            return [
                .custom,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FrameworkType(rawValue: rawValue) ?? FrameworkType.sdkUnknown(rawValue)
        }
    }
}

extension GetAccountStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/status"
    }
}

public struct GetAccountStatusInput: Swift.Equatable {

    public init() { }
}

struct GetAccountStatusInputBody: Swift.Equatable {
}

extension GetAccountStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct GetAccountStatusOutput: Swift.Equatable {
    /// The status of the Amazon Web Services account.
    public var status: AuditManagerClientTypes.AccountStatus?

    public init(
        status: AuditManagerClientTypes.AccountStatus? = nil
    )
    {
        self.status = status
    }
}

struct GetAccountStatusOutputBody: Swift.Equatable {
    let status: AuditManagerClientTypes.AccountStatus?
}

extension GetAccountStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AccountStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum GetAccountStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssessmentFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkId = frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())"
    }
}

public struct GetAssessmentFrameworkInput: Swift.Equatable {
    /// The identifier for the framework.
    /// This member is required.
    public var frameworkId: Swift.String?

    public init(
        frameworkId: Swift.String? = nil
    )
    {
        self.frameworkId = frameworkId
    }
}

struct GetAssessmentFrameworkInputBody: Swift.Equatable {
}

extension GetAssessmentFrameworkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssessmentFrameworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssessmentFrameworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.framework = output.framework
        } else {
            self.framework = nil
        }
    }
}

public struct GetAssessmentFrameworkOutput: Swift.Equatable {
    /// The framework that the GetAssessmentFramework API returned.
    public var framework: AuditManagerClientTypes.Framework?

    public init(
        framework: AuditManagerClientTypes.Framework? = nil
    )
    {
        self.framework = framework
    }
}

struct GetAssessmentFrameworkOutputBody: Swift.Equatable {
    let framework: AuditManagerClientTypes.Framework?
}

extension GetAssessmentFrameworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case framework
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Framework.self, forKey: .framework)
        framework = frameworkDecoded
    }
}

enum GetAssessmentFrameworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

public struct GetAssessmentInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct GetAssessmentInputBody: Swift.Equatable {
}

extension GetAssessmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
            self.userRole = output.userRole
        } else {
            self.assessment = nil
            self.userRole = nil
        }
    }
}

public struct GetAssessmentOutput: Swift.Equatable {
    /// An entity that defines the scope of audit evidence collected by Audit Manager. An Audit Manager assessment is an implementation of an Audit Manager framework.
    public var assessment: AuditManagerClientTypes.Assessment?
    /// The wrapper that contains the Audit Manager role information of the current user. This includes the role type and IAM Amazon Resource Name (ARN).
    public var userRole: AuditManagerClientTypes.Role?

    public init(
        assessment: AuditManagerClientTypes.Assessment? = nil,
        userRole: AuditManagerClientTypes.Role? = nil
    )
    {
        self.assessment = assessment
        self.userRole = userRole
    }
}

struct GetAssessmentOutputBody: Swift.Equatable {
    let assessment: AuditManagerClientTypes.Assessment?
    let userRole: AuditManagerClientTypes.Role?
}

extension GetAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
        case userRole
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Role.self, forKey: .userRole)
        userRole = userRoleDecoded
    }
}

enum GetAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssessmentReportUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let assessmentReportId = assessmentReportId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/reports/\(assessmentReportId.urlPercentEncoding())/url"
    }
}

public struct GetAssessmentReportUrlInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the assessment report.
    /// This member is required.
    public var assessmentReportId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        assessmentReportId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentReportId = assessmentReportId
    }
}

struct GetAssessmentReportUrlInputBody: Swift.Equatable {
}

extension GetAssessmentReportUrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssessmentReportUrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssessmentReportUrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.preSignedUrl = output.preSignedUrl
        } else {
            self.preSignedUrl = nil
        }
    }
}

public struct GetAssessmentReportUrlOutput: Swift.Equatable {
    /// Short for uniform resource locator. A URL is used as a unique identifier to locate a resource on the internet.
    public var preSignedUrl: AuditManagerClientTypes.URL?

    public init(
        preSignedUrl: AuditManagerClientTypes.URL? = nil
    )
    {
        self.preSignedUrl = preSignedUrl
    }
}

struct GetAssessmentReportUrlOutputBody: Swift.Equatable {
    let preSignedUrl: AuditManagerClientTypes.URL?
}

extension GetAssessmentReportUrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preSignedUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.URL.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
    }
}

enum GetAssessmentReportUrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetChangeLogsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let controlSetId = controlSetId {
                let controlSetIdQueryItem = ClientRuntime.URLQueryItem(name: "controlSetId".urlPercentEncoding(), value: Swift.String(controlSetId).urlPercentEncoding())
                items.append(controlSetIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let controlId = controlId {
                let controlIdQueryItem = ClientRuntime.URLQueryItem(name: "controlId".urlPercentEncoding(), value: Swift.String(controlId).urlPercentEncoding())
                items.append(controlIdQueryItem)
            }
            return items
        }
    }
}

extension GetChangeLogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/changelogs"
    }
}

public struct GetChangeLogsInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control.
    public var controlId: Swift.String?
    /// The unique identifier for the control set.
    public var controlSetId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetChangeLogsInputBody: Swift.Equatable {
}

extension GetChangeLogsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetChangeLogsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetChangeLogsOutputBody = try responseDecoder.decode(responseBody: data)
            self.changeLogs = output.changeLogs
            self.nextToken = output.nextToken
        } else {
            self.changeLogs = nil
            self.nextToken = nil
        }
    }
}

public struct GetChangeLogsOutput: Swift.Equatable {
    /// The list of user activity for the control.
    public var changeLogs: [AuditManagerClientTypes.ChangeLog]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        changeLogs: [AuditManagerClientTypes.ChangeLog]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.changeLogs = changeLogs
        self.nextToken = nextToken
    }
}

struct GetChangeLogsOutputBody: Swift.Equatable {
    let changeLogs: [AuditManagerClientTypes.ChangeLog]?
    let nextToken: Swift.String?
}

extension GetChangeLogsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeLogs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeLogsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ChangeLog?].self, forKey: .changeLogs)
        var changeLogsDecoded0:[AuditManagerClientTypes.ChangeLog]? = nil
        if let changeLogsContainer = changeLogsContainer {
            changeLogsDecoded0 = [AuditManagerClientTypes.ChangeLog]()
            for structure0 in changeLogsContainer {
                if let structure0 = structure0 {
                    changeLogsDecoded0?.append(structure0)
                }
            }
        }
        changeLogs = changeLogsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetChangeLogsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let controlId = controlId else {
            return nil
        }
        return "/controls/\(controlId.urlPercentEncoding())"
    }
}

public struct GetControlInput: Swift.Equatable {
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?

    public init(
        controlId: Swift.String? = nil
    )
    {
        self.controlId = controlId
    }
}

struct GetControlInputBody: Swift.Equatable {
}

extension GetControlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct GetControlOutput: Swift.Equatable {
    /// The details of the control that the GetControl API returned.
    public var control: AuditManagerClientTypes.Control?

    public init(
        control: AuditManagerClientTypes.Control? = nil
    )
    {
        self.control = control
    }
}

struct GetControlOutputBody: Swift.Equatable {
    let control: AuditManagerClientTypes.Control?
}

extension GetControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case control
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Control.self, forKey: .control)
        control = controlDecoded
    }
}

enum GetControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDelegationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetDelegationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delegations"
    }
}

public struct GetDelegationsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDelegationsInputBody: Swift.Equatable {
}

extension GetDelegationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDelegationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDelegationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.delegations = output.delegations
            self.nextToken = output.nextToken
        } else {
            self.delegations = nil
            self.nextToken = nil
        }
    }
}

public struct GetDelegationsOutput: Swift.Equatable {
    /// The list of delegations that the GetDelegations API returned.
    public var delegations: [AuditManagerClientTypes.DelegationMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        delegations: [AuditManagerClientTypes.DelegationMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.delegations = delegations
        self.nextToken = nextToken
    }
}

struct GetDelegationsOutputBody: Swift.Equatable {
    let delegations: [AuditManagerClientTypes.DelegationMetadata]?
    let nextToken: Swift.String?
}

extension GetDelegationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.DelegationMetadata?].self, forKey: .delegations)
        var delegationsDecoded0:[AuditManagerClientTypes.DelegationMetadata]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [AuditManagerClientTypes.DelegationMetadata]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetDelegationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEvidenceByEvidenceFolderInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetEvidenceByEvidenceFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let evidenceFolderId = evidenceFolderId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/evidenceFolders/\(evidenceFolderId.urlPercentEncoding())/evidence"
    }
}

public struct GetEvidenceByEvidenceFolderInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetEvidenceByEvidenceFolderInputBody: Swift.Equatable {
}

extension GetEvidenceByEvidenceFolderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceByEvidenceFolderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEvidenceByEvidenceFolderOutputBody = try responseDecoder.decode(responseBody: data)
            self.evidence = output.evidence
            self.nextToken = output.nextToken
        } else {
            self.evidence = nil
            self.nextToken = nil
        }
    }
}

public struct GetEvidenceByEvidenceFolderOutput: Swift.Equatable {
    /// The list of evidence that the GetEvidenceByEvidenceFolder API returned.
    public var evidence: [AuditManagerClientTypes.Evidence]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        evidence: [AuditManagerClientTypes.Evidence]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evidence = evidence
        self.nextToken = nextToken
    }
}

struct GetEvidenceByEvidenceFolderOutputBody: Swift.Equatable {
    let evidence: [AuditManagerClientTypes.Evidence]?
    let nextToken: Swift.String?
}

extension GetEvidenceByEvidenceFolderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidence
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Evidence?].self, forKey: .evidence)
        var evidenceDecoded0:[AuditManagerClientTypes.Evidence]? = nil
        if let evidenceContainer = evidenceContainer {
            evidenceDecoded0 = [AuditManagerClientTypes.Evidence]()
            for structure0 in evidenceContainer {
                if let structure0 = structure0 {
                    evidenceDecoded0?.append(structure0)
                }
            }
        }
        evidence = evidenceDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetEvidenceByEvidenceFolderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEvidenceFileUploadUrlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEvidenceFileUploadUrlInput(fileName: \"CONTENT_REDACTED\")"}
}

extension GetEvidenceFileUploadUrlInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let fileName = fileName else {
                let message = "Creating a URL Query Item failed. fileName is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let fileNameQueryItem = ClientRuntime.URLQueryItem(name: "fileName".urlPercentEncoding(), value: Swift.String(fileName).urlPercentEncoding())
            items.append(fileNameQueryItem)
            return items
        }
    }
}

extension GetEvidenceFileUploadUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/evidenceFileUploadUrl"
    }
}

public struct GetEvidenceFileUploadUrlInput: Swift.Equatable {
    /// The file that you want to upload. For a list of supported file formats, see [Supported file types for manual evidence](https://docs.aws.amazon.com/audit-manager/latest/userguide/upload-evidence.html#supported-manual-evidence-files) in the Audit Manager User Guide.
    /// This member is required.
    public var fileName: Swift.String?

    public init(
        fileName: Swift.String? = nil
    )
    {
        self.fileName = fileName
    }
}

struct GetEvidenceFileUploadUrlInputBody: Swift.Equatable {
}

extension GetEvidenceFileUploadUrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceFileUploadUrlOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension GetEvidenceFileUploadUrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEvidenceFileUploadUrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.evidenceFileName = output.evidenceFileName
            self.uploadUrl = output.uploadUrl
        } else {
            self.evidenceFileName = nil
            self.uploadUrl = nil
        }
    }
}

public struct GetEvidenceFileUploadUrlOutput: Swift.Equatable {
    /// The name of the uploaded manual evidence file that the presigned URL was generated for.
    public var evidenceFileName: Swift.String?
    /// The presigned URL that was generated.
    public var uploadUrl: Swift.String?

    public init(
        evidenceFileName: Swift.String? = nil,
        uploadUrl: Swift.String? = nil
    )
    {
        self.evidenceFileName = evidenceFileName
        self.uploadUrl = uploadUrl
    }
}

struct GetEvidenceFileUploadUrlOutputBody: Swift.Equatable {
    let evidenceFileName: Swift.String?
    let uploadUrl: Swift.String?
}

extension GetEvidenceFileUploadUrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFileName
        case uploadUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFileName)
        evidenceFileName = evidenceFileNameDecoded
        let uploadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadUrl)
        uploadUrl = uploadUrlDecoded
    }
}

enum GetEvidenceFileUploadUrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEvidenceFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let evidenceFolderId = evidenceFolderId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/evidenceFolders/\(evidenceFolderId.urlPercentEncoding())"
    }
}

public struct GetEvidenceFolderInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
    }
}

struct GetEvidenceFolderInputBody: Swift.Equatable {
}

extension GetEvidenceFolderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceFolderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEvidenceFolderOutputBody = try responseDecoder.decode(responseBody: data)
            self.evidenceFolder = output.evidenceFolder
        } else {
            self.evidenceFolder = nil
        }
    }
}

public struct GetEvidenceFolderOutput: Swift.Equatable {
    /// The folder that the evidence is stored in.
    public var evidenceFolder: AuditManagerClientTypes.AssessmentEvidenceFolder?

    public init(
        evidenceFolder: AuditManagerClientTypes.AssessmentEvidenceFolder? = nil
    )
    {
        self.evidenceFolder = evidenceFolder
    }
}

struct GetEvidenceFolderOutputBody: Swift.Equatable {
    let evidenceFolder: AuditManagerClientTypes.AssessmentEvidenceFolder?
}

extension GetEvidenceFolderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolder
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentEvidenceFolder.self, forKey: .evidenceFolder)
        evidenceFolder = evidenceFolderDecoded
    }
}

enum GetEvidenceFolderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEvidenceFoldersByAssessmentControlInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetEvidenceFoldersByAssessmentControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let controlId = controlId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/evidenceFolders-by-assessment-control/\(controlSetId.urlPercentEncoding())/\(controlId.urlPercentEncoding())"
    }
}

public struct GetEvidenceFoldersByAssessmentControlInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentControlInputBody: Swift.Equatable {
}

extension GetEvidenceFoldersByAssessmentControlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceFoldersByAssessmentControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEvidenceFoldersByAssessmentControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.evidenceFolders = output.evidenceFolders
            self.nextToken = output.nextToken
        } else {
            self.evidenceFolders = nil
            self.nextToken = nil
        }
    }
}

public struct GetEvidenceFoldersByAssessmentControlOutput: Swift.Equatable {
    /// The list of evidence folders that the GetEvidenceFoldersByAssessmentControl API returned.
    public var evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evidenceFolders = evidenceFolders
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentControlOutputBody: Swift.Equatable {
    let evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]?
    let nextToken: Swift.String?
}

extension GetEvidenceFoldersByAssessmentControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolders
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFoldersContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentEvidenceFolder?].self, forKey: .evidenceFolders)
        var evidenceFoldersDecoded0:[AuditManagerClientTypes.AssessmentEvidenceFolder]? = nil
        if let evidenceFoldersContainer = evidenceFoldersContainer {
            evidenceFoldersDecoded0 = [AuditManagerClientTypes.AssessmentEvidenceFolder]()
            for structure0 in evidenceFoldersContainer {
                if let structure0 = structure0 {
                    evidenceFoldersDecoded0?.append(structure0)
                }
            }
        }
        evidenceFolders = evidenceFoldersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetEvidenceFoldersByAssessmentControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEvidenceFoldersByAssessmentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetEvidenceFoldersByAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/evidenceFolders"
    }
}

public struct GetEvidenceFoldersByAssessmentInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentInputBody: Swift.Equatable {
}

extension GetEvidenceFoldersByAssessmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceFoldersByAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEvidenceFoldersByAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.evidenceFolders = output.evidenceFolders
            self.nextToken = output.nextToken
        } else {
            self.evidenceFolders = nil
            self.nextToken = nil
        }
    }
}

public struct GetEvidenceFoldersByAssessmentOutput: Swift.Equatable {
    /// The list of evidence folders that the GetEvidenceFoldersByAssessment API returned.
    public var evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evidenceFolders = evidenceFolders
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentOutputBody: Swift.Equatable {
    let evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]?
    let nextToken: Swift.String?
}

extension GetEvidenceFoldersByAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolders
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFoldersContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentEvidenceFolder?].self, forKey: .evidenceFolders)
        var evidenceFoldersDecoded0:[AuditManagerClientTypes.AssessmentEvidenceFolder]? = nil
        if let evidenceFoldersContainer = evidenceFoldersContainer {
            evidenceFoldersDecoded0 = [AuditManagerClientTypes.AssessmentEvidenceFolder]()
            for structure0 in evidenceFoldersContainer {
                if let structure0 = structure0 {
                    evidenceFoldersDecoded0?.append(structure0)
                }
            }
        }
        evidenceFolders = evidenceFoldersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetEvidenceFoldersByAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEvidenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let evidenceFolderId = evidenceFolderId else {
            return nil
        }
        guard let evidenceId = evidenceId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/evidenceFolders/\(evidenceFolderId.urlPercentEncoding())/evidence/\(evidenceId.urlPercentEncoding())"
    }
}

public struct GetEvidenceInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// The unique identifier for the evidence.
    /// This member is required.
    public var evidenceId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        evidenceId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceId = evidenceId
    }
}

struct GetEvidenceInputBody: Swift.Equatable {
}

extension GetEvidenceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEvidenceOutputBody = try responseDecoder.decode(responseBody: data)
            self.evidence = output.evidence
        } else {
            self.evidence = nil
        }
    }
}

public struct GetEvidenceOutput: Swift.Equatable {
    /// The evidence that the GetEvidence API returned.
    public var evidence: AuditManagerClientTypes.Evidence?

    public init(
        evidence: AuditManagerClientTypes.Evidence? = nil
    )
    {
        self.evidence = evidence
    }
}

struct GetEvidenceOutputBody: Swift.Equatable {
    let evidence: AuditManagerClientTypes.Evidence?
}

extension GetEvidenceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidence
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Evidence.self, forKey: .evidence)
        evidence = evidenceDecoded
    }
}

enum GetEvidenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInsightsByAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/insights/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

public struct GetInsightsByAssessmentInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct GetInsightsByAssessmentInputBody: Swift.Equatable {
}

extension GetInsightsByAssessmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetInsightsByAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInsightsByAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.insights = output.insights
        } else {
            self.insights = nil
        }
    }
}

public struct GetInsightsByAssessmentOutput: Swift.Equatable {
    /// The assessment analytics data that the GetInsightsByAssessment API returned.
    public var insights: AuditManagerClientTypes.InsightsByAssessment?

    public init(
        insights: AuditManagerClientTypes.InsightsByAssessment? = nil
    )
    {
        self.insights = insights
    }
}

struct GetInsightsByAssessmentOutputBody: Swift.Equatable {
    let insights: AuditManagerClientTypes.InsightsByAssessment?
}

extension GetInsightsByAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insights
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.InsightsByAssessment.self, forKey: .insights)
        insights = insightsDecoded
    }
}

enum GetInsightsByAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights"
    }
}

public struct GetInsightsInput: Swift.Equatable {

    public init() { }
}

struct GetInsightsInputBody: Swift.Equatable {
}

extension GetInsightsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetInsightsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInsightsOutputBody = try responseDecoder.decode(responseBody: data)
            self.insights = output.insights
        } else {
            self.insights = nil
        }
    }
}

public struct GetInsightsOutput: Swift.Equatable {
    /// The analytics data that the GetInsights API returned.
    public var insights: AuditManagerClientTypes.Insights?

    public init(
        insights: AuditManagerClientTypes.Insights? = nil
    )
    {
        self.insights = insights
    }
}

struct GetInsightsOutputBody: Swift.Equatable {
    let insights: AuditManagerClientTypes.Insights?
}

extension GetInsightsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insights
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Insights.self, forKey: .insights)
        insights = insightsDecoded
    }
}

enum GetInsightsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/organizationAdminAccount"
    }
}

public struct GetOrganizationAdminAccountInput: Swift.Equatable {

    public init() { }
}

struct GetOrganizationAdminAccountInputBody: Swift.Equatable {
}

extension GetOrganizationAdminAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOrganizationAdminAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOrganizationAdminAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.adminAccountId = output.adminAccountId
            self.organizationId = output.organizationId
        } else {
            self.adminAccountId = nil
            self.organizationId = nil
        }
    }
}

public struct GetOrganizationAdminAccountOutput: Swift.Equatable {
    /// The identifier for the administrator account.
    public var adminAccountId: Swift.String?
    /// The identifier for the organization.
    public var organizationId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.organizationId = organizationId
    }
}

struct GetOrganizationAdminAccountOutputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
    let organizationId: Swift.String?
}

extension GetOrganizationAdminAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
        case organizationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

enum GetOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServicesInScopeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/services"
    }
}

public struct GetServicesInScopeInput: Swift.Equatable {

    public init() { }
}

struct GetServicesInScopeInputBody: Swift.Equatable {
}

extension GetServicesInScopeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServicesInScopeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServicesInScopeOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceMetadata = output.serviceMetadata
        } else {
            self.serviceMetadata = nil
        }
    }
}

public struct GetServicesInScopeOutput: Swift.Equatable {
    /// The metadata that's associated with the Amazon Web Service.
    public var serviceMetadata: [AuditManagerClientTypes.ServiceMetadata]?

    public init(
        serviceMetadata: [AuditManagerClientTypes.ServiceMetadata]? = nil
    )
    {
        self.serviceMetadata = serviceMetadata
    }
}

struct GetServicesInScopeOutputBody: Swift.Equatable {
    let serviceMetadata: [AuditManagerClientTypes.ServiceMetadata]?
}

extension GetServicesInScopeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceMetadata
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceMetadataContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ServiceMetadata?].self, forKey: .serviceMetadata)
        var serviceMetadataDecoded0:[AuditManagerClientTypes.ServiceMetadata]? = nil
        if let serviceMetadataContainer = serviceMetadataContainer {
            serviceMetadataDecoded0 = [AuditManagerClientTypes.ServiceMetadata]()
            for structure0 in serviceMetadataContainer {
                if let structure0 = structure0 {
                    serviceMetadataDecoded0?.append(structure0)
                }
            }
        }
        serviceMetadata = serviceMetadataDecoded0
    }
}

enum GetServicesInScopeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attribute = attribute else {
            return nil
        }
        return "/settings/\(attribute.rawValue.urlPercentEncoding())"
    }
}

public struct GetSettingsInput: Swift.Equatable {
    /// The list of setting attribute enum values.
    /// This member is required.
    public var attribute: AuditManagerClientTypes.SettingAttribute?

    public init(
        attribute: AuditManagerClientTypes.SettingAttribute? = nil
    )
    {
        self.attribute = attribute
    }
}

struct GetSettingsInputBody: Swift.Equatable {
}

extension GetSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.settings = output.settings
        } else {
            self.settings = nil
        }
    }
}

public struct GetSettingsOutput: Swift.Equatable {
    /// The settings object that holds all supported Audit Manager settings.
    public var settings: AuditManagerClientTypes.Settings?

    public init(
        settings: AuditManagerClientTypes.Settings? = nil
    )
    {
        self.settings = settings
    }
}

struct GetSettingsOutputBody: Swift.Equatable {
    let settings: AuditManagerClientTypes.Settings?
}

extension GetSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

enum GetSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.Insights: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeAssessmentsCount
        case assessmentControlsCountByNoncompliantEvidence
        case compliantEvidenceCount
        case inconclusiveEvidenceCount
        case lastUpdated
        case noncompliantEvidenceCount
        case totalAssessmentControlsCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeAssessmentsCount = self.activeAssessmentsCount {
            try encodeContainer.encode(activeAssessmentsCount, forKey: .activeAssessmentsCount)
        }
        if let assessmentControlsCountByNoncompliantEvidence = self.assessmentControlsCountByNoncompliantEvidence {
            try encodeContainer.encode(assessmentControlsCountByNoncompliantEvidence, forKey: .assessmentControlsCountByNoncompliantEvidence)
        }
        if let compliantEvidenceCount = self.compliantEvidenceCount {
            try encodeContainer.encode(compliantEvidenceCount, forKey: .compliantEvidenceCount)
        }
        if let inconclusiveEvidenceCount = self.inconclusiveEvidenceCount {
            try encodeContainer.encode(inconclusiveEvidenceCount, forKey: .inconclusiveEvidenceCount)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let noncompliantEvidenceCount = self.noncompliantEvidenceCount {
            try encodeContainer.encode(noncompliantEvidenceCount, forKey: .noncompliantEvidenceCount)
        }
        if let totalAssessmentControlsCount = self.totalAssessmentControlsCount {
            try encodeContainer.encode(totalAssessmentControlsCount, forKey: .totalAssessmentControlsCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeAssessmentsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeAssessmentsCount)
        activeAssessmentsCount = activeAssessmentsCountDecoded
        let noncompliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncompliantEvidenceCount)
        noncompliantEvidenceCount = noncompliantEvidenceCountDecoded
        let compliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantEvidenceCount)
        compliantEvidenceCount = compliantEvidenceCountDecoded
        let inconclusiveEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inconclusiveEvidenceCount)
        inconclusiveEvidenceCount = inconclusiveEvidenceCountDecoded
        let assessmentControlsCountByNoncompliantEvidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assessmentControlsCountByNoncompliantEvidence)
        assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidenceDecoded
        let totalAssessmentControlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAssessmentControlsCount)
        totalAssessmentControlsCount = totalAssessmentControlsCountDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A summary of the latest analytics data for all your active assessments. This summary is a snapshot of the data that your active assessments collected on the lastUpdated date. Its important to understand that the following totals are daily counts based on this date  they arent a total sum to date. The Insights data is eventually consistent. This means that, when you read data from Insights, the response might not instantly reflect the results of a recently completed write or update operation. If you repeat your read request after a few hours, the response should return the latest data. If you delete an assessment or change its status to inactive, InsightsByAssessment includes data for that assessment as follows.
    ///
    /// * Inactive assessments - If Audit Manager collected evidence for your assessment before you changed it inactive, that evidence is included in the InsightsByAssessment counts for that day.
    ///
    /// * Deleted assessments - If Audit Manager collected evidence for your assessment before you deleted it, that evidence isn't included in the InsightsByAssessment counts for that day.
    public struct Insights: Swift.Equatable {
        /// The number of active assessments in Audit Manager.
        public var activeAssessmentsCount: Swift.Int?
        /// The number of assessment controls that collected non-compliant evidence on the lastUpdated date.
        public var assessmentControlsCountByNoncompliantEvidence: Swift.Int?
        /// The number of compliance check evidence that Audit Manager classified as compliant on the lastUpdated date. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public var compliantEvidenceCount: Swift.Int?
        /// The number of evidence without a compliance check ruling. Evidence is inconclusive when the associated control uses Security Hub or Config as a data source but you didn't enable those services. This is also the case when a control uses a data source that doesnt support compliance checks (for example: manual evidence, API calls, or CloudTrail). If evidence has a compliance check status of not applicable, it's classed as inconclusive in Insights data.
        public var inconclusiveEvidenceCount: Swift.Int?
        /// The time when the cross-assessment insights were last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant on the lastUpdated date. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public var noncompliantEvidenceCount: Swift.Int?
        /// The total number of controls across all active assessments.
        public var totalAssessmentControlsCount: Swift.Int?

        public init(
            activeAssessmentsCount: Swift.Int? = nil,
            assessmentControlsCountByNoncompliantEvidence: Swift.Int? = nil,
            compliantEvidenceCount: Swift.Int? = nil,
            inconclusiveEvidenceCount: Swift.Int? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            noncompliantEvidenceCount: Swift.Int? = nil,
            totalAssessmentControlsCount: Swift.Int? = nil
        )
        {
            self.activeAssessmentsCount = activeAssessmentsCount
            self.assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidence
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.lastUpdated = lastUpdated
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
            self.totalAssessmentControlsCount = totalAssessmentControlsCount
        }
    }

}

extension AuditManagerClientTypes.InsightsByAssessment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentControlsCountByNoncompliantEvidence
        case compliantEvidenceCount
        case inconclusiveEvidenceCount
        case lastUpdated
        case noncompliantEvidenceCount
        case totalAssessmentControlsCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentControlsCountByNoncompliantEvidence = self.assessmentControlsCountByNoncompliantEvidence {
            try encodeContainer.encode(assessmentControlsCountByNoncompliantEvidence, forKey: .assessmentControlsCountByNoncompliantEvidence)
        }
        if let compliantEvidenceCount = self.compliantEvidenceCount {
            try encodeContainer.encode(compliantEvidenceCount, forKey: .compliantEvidenceCount)
        }
        if let inconclusiveEvidenceCount = self.inconclusiveEvidenceCount {
            try encodeContainer.encode(inconclusiveEvidenceCount, forKey: .inconclusiveEvidenceCount)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let noncompliantEvidenceCount = self.noncompliantEvidenceCount {
            try encodeContainer.encode(noncompliantEvidenceCount, forKey: .noncompliantEvidenceCount)
        }
        if let totalAssessmentControlsCount = self.totalAssessmentControlsCount {
            try encodeContainer.encode(totalAssessmentControlsCount, forKey: .totalAssessmentControlsCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncompliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncompliantEvidenceCount)
        noncompliantEvidenceCount = noncompliantEvidenceCountDecoded
        let compliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantEvidenceCount)
        compliantEvidenceCount = compliantEvidenceCountDecoded
        let inconclusiveEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inconclusiveEvidenceCount)
        inconclusiveEvidenceCount = inconclusiveEvidenceCountDecoded
        let assessmentControlsCountByNoncompliantEvidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assessmentControlsCountByNoncompliantEvidence)
        assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidenceDecoded
        let totalAssessmentControlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAssessmentControlsCount)
        totalAssessmentControlsCount = totalAssessmentControlsCountDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A summary of the latest analytics data for a specific active assessment. This summary is a snapshot of the data that was collected on the lastUpdated date. Its important to understand that the totals in InsightsByAssessment are daily counts based on this date  they arent a total sum to date. The InsightsByAssessment data is eventually consistent. This means that when you read data from InsightsByAssessment, the response might not instantly reflect the results of a recently completed write or update operation. If you repeat your read request after a few hours, the response returns the latest data. If you delete an assessment or change its status to inactive, InsightsByAssessment includes data for that assessment as follows.
    ///
    /// * Inactive assessments - If Audit Manager collected evidence for your assessment before you changed it inactive, that evidence is included in the InsightsByAssessment counts for that day.
    ///
    /// * Deleted assessments - If Audit Manager collected evidence for your assessment before you deleted it, that evidence isn't included in the InsightsByAssessment counts for that day.
    public struct InsightsByAssessment: Swift.Equatable {
        /// The number of assessment controls that collected non-compliant evidence on the lastUpdated date.
        public var assessmentControlsCountByNoncompliantEvidence: Swift.Int?
        /// The number of compliance check evidence that Audit Manager classified as compliant. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public var compliantEvidenceCount: Swift.Int?
        /// The amount of evidence without a compliance check ruling. Evidence is inconclusive if the associated control uses Security Hub or Config as a data source and you didn't enable those services. This is also the case if a control uses a data source that doesnt support compliance checks (for example, manual evidence, API calls, or CloudTrail). If evidence has a compliance check status of not applicable, it's classified as inconclusive in InsightsByAssessment data.
        public var inconclusiveEvidenceCount: Swift.Int?
        /// The time when the assessment insights were last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public var noncompliantEvidenceCount: Swift.Int?
        /// The total number of controls in the assessment.
        public var totalAssessmentControlsCount: Swift.Int?

        public init(
            assessmentControlsCountByNoncompliantEvidence: Swift.Int? = nil,
            compliantEvidenceCount: Swift.Int? = nil,
            inconclusiveEvidenceCount: Swift.Int? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            noncompliantEvidenceCount: Swift.Int? = nil,
            totalAssessmentControlsCount: Swift.Int? = nil
        )
        {
            self.assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidence
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.lastUpdated = lastUpdated
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
            self.totalAssessmentControlsCount = totalAssessmentControlsCount
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal service error occurred during the processing of your request. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditManagerClientTypes {
    public enum KeywordInputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inputText
        case selectFromList
        case uploadFile
        case sdkUnknown(Swift.String)

        public static var allCases: [KeywordInputType] {
            return [
                .inputText,
                .selectFromList,
                .uploadFile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inputText: return "INPUT_TEXT"
            case .selectFromList: return "SELECT_FROM_LIST"
            case .uploadFile: return "UPLOAD_FILE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeywordInputType(rawValue: rawValue) ?? KeywordInputType.sdkUnknown(rawValue)
        }
    }
}

extension ListAssessmentControlInsightsByControlDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let controlDomainId = controlDomainId else {
                let message = "Creating a URL Query Item failed. controlDomainId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let controlDomainIdQueryItem = ClientRuntime.URLQueryItem(name: "controlDomainId".urlPercentEncoding(), value: Swift.String(controlDomainId).urlPercentEncoding())
            items.append(controlDomainIdQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let assessmentId = assessmentId else {
                let message = "Creating a URL Query Item failed. assessmentId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let assessmentIdQueryItem = ClientRuntime.URLQueryItem(name: "assessmentId".urlPercentEncoding(), value: Swift.String(assessmentId).urlPercentEncoding())
            items.append(assessmentIdQueryItem)
            return items
        }
    }
}

extension ListAssessmentControlInsightsByControlDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/controls-by-assessment"
    }
}

public struct ListAssessmentControlInsightsByControlDomainInput: Swift.Equatable {
    /// The unique identifier for the active assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control domain.
    /// This member is required.
    public var controlDomainId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        controlDomainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlDomainId = controlDomainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentControlInsightsByControlDomainInputBody: Swift.Equatable {
}

extension ListAssessmentControlInsightsByControlDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssessmentControlInsightsByControlDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssessmentControlInsightsByControlDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.controlInsightsByAssessment = output.controlInsightsByAssessment
            self.nextToken = output.nextToken
        } else {
            self.controlInsightsByAssessment = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentControlInsightsByControlDomainOutput: Swift.Equatable {
    /// The assessment control analytics data that the ListAssessmentControlInsightsByControlDomain API returned.
    public var controlInsightsByAssessment: [AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlInsightsByAssessment: [AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlInsightsByAssessment = controlInsightsByAssessment
        self.nextToken = nextToken
    }
}

struct ListAssessmentControlInsightsByControlDomainOutputBody: Swift.Equatable {
    let controlInsightsByAssessment: [AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]?
    let nextToken: Swift.String?
}

extension ListAssessmentControlInsightsByControlDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlInsightsByAssessment
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlInsightsByAssessmentContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem?].self, forKey: .controlInsightsByAssessment)
        var controlInsightsByAssessmentDecoded0:[AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]? = nil
        if let controlInsightsByAssessmentContainer = controlInsightsByAssessmentContainer {
            controlInsightsByAssessmentDecoded0 = [AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]()
            for structure0 in controlInsightsByAssessmentContainer {
                if let structure0 = structure0 {
                    controlInsightsByAssessmentDecoded0?.append(structure0)
                }
            }
        }
        controlInsightsByAssessment = controlInsightsByAssessmentDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssessmentControlInsightsByControlDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssessmentFrameworkShareRequestsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let requestType = requestType else {
                let message = "Creating a URL Query Item failed. requestType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let requestTypeQueryItem = ClientRuntime.URLQueryItem(name: "requestType".urlPercentEncoding(), value: Swift.String(requestType.rawValue).urlPercentEncoding())
            items.append(requestTypeQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssessmentFrameworkShareRequestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessmentFrameworkShareRequests"
    }
}

public struct ListAssessmentFrameworkShareRequestsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// Specifies whether the share request is a sent request or a received request.
    /// This member is required.
    public var requestType: AuditManagerClientTypes.ShareRequestType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        requestType: AuditManagerClientTypes.ShareRequestType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.requestType = requestType
    }
}

struct ListAssessmentFrameworkShareRequestsInputBody: Swift.Equatable {
}

extension ListAssessmentFrameworkShareRequestsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssessmentFrameworkShareRequestsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssessmentFrameworkShareRequestsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentFrameworkShareRequests = output.assessmentFrameworkShareRequests
            self.nextToken = output.nextToken
        } else {
            self.assessmentFrameworkShareRequests = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentFrameworkShareRequestsOutput: Swift.Equatable {
    /// The list of share requests that the ListAssessmentFrameworkShareRequests API returned.
    public var assessmentFrameworkShareRequests: [AuditManagerClientTypes.AssessmentFrameworkShareRequest]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentFrameworkShareRequests: [AuditManagerClientTypes.AssessmentFrameworkShareRequest]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentFrameworkShareRequests = assessmentFrameworkShareRequests
        self.nextToken = nextToken
    }
}

struct ListAssessmentFrameworkShareRequestsOutputBody: Swift.Equatable {
    let assessmentFrameworkShareRequests: [AuditManagerClientTypes.AssessmentFrameworkShareRequest]?
    let nextToken: Swift.String?
}

extension ListAssessmentFrameworkShareRequestsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentFrameworkShareRequests
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentFrameworkShareRequestsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentFrameworkShareRequest?].self, forKey: .assessmentFrameworkShareRequests)
        var assessmentFrameworkShareRequestsDecoded0:[AuditManagerClientTypes.AssessmentFrameworkShareRequest]? = nil
        if let assessmentFrameworkShareRequestsContainer = assessmentFrameworkShareRequestsContainer {
            assessmentFrameworkShareRequestsDecoded0 = [AuditManagerClientTypes.AssessmentFrameworkShareRequest]()
            for structure0 in assessmentFrameworkShareRequestsContainer {
                if let structure0 = structure0 {
                    assessmentFrameworkShareRequestsDecoded0?.append(structure0)
                }
            }
        }
        assessmentFrameworkShareRequests = assessmentFrameworkShareRequestsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssessmentFrameworkShareRequestsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssessmentFrameworksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let frameworkType = frameworkType else {
                let message = "Creating a URL Query Item failed. frameworkType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let frameworkTypeQueryItem = ClientRuntime.URLQueryItem(name: "frameworkType".urlPercentEncoding(), value: Swift.String(frameworkType.rawValue).urlPercentEncoding())
            items.append(frameworkTypeQueryItem)
            return items
        }
    }
}

extension ListAssessmentFrameworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessmentFrameworks"
    }
}

public struct ListAssessmentFrameworksInput: Swift.Equatable {
    /// The type of framework, such as a standard framework or a custom framework.
    /// This member is required.
    public var frameworkType: AuditManagerClientTypes.FrameworkType?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        frameworkType: AuditManagerClientTypes.FrameworkType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.frameworkType = frameworkType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentFrameworksInputBody: Swift.Equatable {
}

extension ListAssessmentFrameworksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssessmentFrameworksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssessmentFrameworksOutputBody = try responseDecoder.decode(responseBody: data)
            self.frameworkMetadataList = output.frameworkMetadataList
            self.nextToken = output.nextToken
        } else {
            self.frameworkMetadataList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentFrameworksOutput: Swift.Equatable {
    /// A list of metadata that the ListAssessmentFrameworks API returns for each framework.
    public var frameworkMetadataList: [AuditManagerClientTypes.AssessmentFrameworkMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        frameworkMetadataList: [AuditManagerClientTypes.AssessmentFrameworkMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.frameworkMetadataList = frameworkMetadataList
        self.nextToken = nextToken
    }
}

struct ListAssessmentFrameworksOutputBody: Swift.Equatable {
    let frameworkMetadataList: [AuditManagerClientTypes.AssessmentFrameworkMetadata]?
    let nextToken: Swift.String?
}

extension ListAssessmentFrameworksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkMetadataList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkMetadataListContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentFrameworkMetadata?].self, forKey: .frameworkMetadataList)
        var frameworkMetadataListDecoded0:[AuditManagerClientTypes.AssessmentFrameworkMetadata]? = nil
        if let frameworkMetadataListContainer = frameworkMetadataListContainer {
            frameworkMetadataListDecoded0 = [AuditManagerClientTypes.AssessmentFrameworkMetadata]()
            for structure0 in frameworkMetadataListContainer {
                if let structure0 = structure0 {
                    frameworkMetadataListDecoded0?.append(structure0)
                }
            }
        }
        frameworkMetadataList = frameworkMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssessmentFrameworksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssessmentReportsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssessmentReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessmentReports"
    }
}

public struct ListAssessmentReportsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentReportsInputBody: Swift.Equatable {
}

extension ListAssessmentReportsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssessmentReportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssessmentReportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentReports = output.assessmentReports
            self.nextToken = output.nextToken
        } else {
            self.assessmentReports = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentReportsOutput: Swift.Equatable {
    /// The list of assessment reports that the ListAssessmentReports API returned.
    public var assessmentReports: [AuditManagerClientTypes.AssessmentReportMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentReports: [AuditManagerClientTypes.AssessmentReportMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentReports = assessmentReports
        self.nextToken = nextToken
    }
}

struct ListAssessmentReportsOutputBody: Swift.Equatable {
    let assessmentReports: [AuditManagerClientTypes.AssessmentReportMetadata]?
    let nextToken: Swift.String?
}

extension ListAssessmentReportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReports
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentReportsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentReportMetadata?].self, forKey: .assessmentReports)
        var assessmentReportsDecoded0:[AuditManagerClientTypes.AssessmentReportMetadata]? = nil
        if let assessmentReportsContainer = assessmentReportsContainer {
            assessmentReportsDecoded0 = [AuditManagerClientTypes.AssessmentReportMetadata]()
            for structure0 in assessmentReportsContainer {
                if let structure0 = structure0 {
                    assessmentReportsDecoded0?.append(structure0)
                }
            }
        }
        assessmentReports = assessmentReportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssessmentReportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssessmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListAssessmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessments"
    }
}

public struct ListAssessmentsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The current status of the assessment.
    public var status: AuditManagerClientTypes.AssessmentStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: AuditManagerClientTypes.AssessmentStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListAssessmentsInputBody: Swift.Equatable {
}

extension ListAssessmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssessmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssessmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentMetadata = output.assessmentMetadata
            self.nextToken = output.nextToken
        } else {
            self.assessmentMetadata = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentsOutput: Swift.Equatable {
    /// The metadata that the ListAssessments API returns for each assessment.
    public var assessmentMetadata: [AuditManagerClientTypes.AssessmentMetadataItem]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentMetadata: [AuditManagerClientTypes.AssessmentMetadataItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentMetadata = assessmentMetadata
        self.nextToken = nextToken
    }
}

struct ListAssessmentsOutputBody: Swift.Equatable {
    let assessmentMetadata: [AuditManagerClientTypes.AssessmentMetadataItem]?
    let nextToken: Swift.String?
}

extension ListAssessmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentMetadata
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentMetadataContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentMetadataItem?].self, forKey: .assessmentMetadata)
        var assessmentMetadataDecoded0:[AuditManagerClientTypes.AssessmentMetadataItem]? = nil
        if let assessmentMetadataContainer = assessmentMetadataContainer {
            assessmentMetadataDecoded0 = [AuditManagerClientTypes.AssessmentMetadataItem]()
            for structure0 in assessmentMetadataContainer {
                if let structure0 = structure0 {
                    assessmentMetadataDecoded0?.append(structure0)
                }
            }
        }
        assessmentMetadata = assessmentMetadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssessmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListControlDomainInsightsByAssessmentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let assessmentId = assessmentId else {
                let message = "Creating a URL Query Item failed. assessmentId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let assessmentIdQueryItem = ClientRuntime.URLQueryItem(name: "assessmentId".urlPercentEncoding(), value: Swift.String(assessmentId).urlPercentEncoding())
            items.append(assessmentIdQueryItem)
            return items
        }
    }
}

extension ListControlDomainInsightsByAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/control-domains-by-assessment"
    }
}

public struct ListControlDomainInsightsByAssessmentInput: Swift.Equatable {
    /// The unique identifier for the active assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListControlDomainInsightsByAssessmentInputBody: Swift.Equatable {
}

extension ListControlDomainInsightsByAssessmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListControlDomainInsightsByAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListControlDomainInsightsByAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.controlDomainInsights = output.controlDomainInsights
            self.nextToken = output.nextToken
        } else {
            self.controlDomainInsights = nil
            self.nextToken = nil
        }
    }
}

public struct ListControlDomainInsightsByAssessmentOutput: Swift.Equatable {
    /// The control domain analytics data that the ListControlDomainInsightsByAssessment API returned.
    public var controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlDomainInsights = controlDomainInsights
        self.nextToken = nextToken
    }
}

struct ListControlDomainInsightsByAssessmentOutputBody: Swift.Equatable {
    let controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]?
    let nextToken: Swift.String?
}

extension ListControlDomainInsightsByAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlDomainInsights
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDomainInsightsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlDomainInsights?].self, forKey: .controlDomainInsights)
        var controlDomainInsightsDecoded0:[AuditManagerClientTypes.ControlDomainInsights]? = nil
        if let controlDomainInsightsContainer = controlDomainInsightsContainer {
            controlDomainInsightsDecoded0 = [AuditManagerClientTypes.ControlDomainInsights]()
            for structure0 in controlDomainInsightsContainer {
                if let structure0 = structure0 {
                    controlDomainInsightsDecoded0?.append(structure0)
                }
            }
        }
        controlDomainInsights = controlDomainInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListControlDomainInsightsByAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListControlDomainInsightsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListControlDomainInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/control-domains"
    }
}

public struct ListControlDomainInsightsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListControlDomainInsightsInputBody: Swift.Equatable {
}

extension ListControlDomainInsightsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListControlDomainInsightsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListControlDomainInsightsOutputBody = try responseDecoder.decode(responseBody: data)
            self.controlDomainInsights = output.controlDomainInsights
            self.nextToken = output.nextToken
        } else {
            self.controlDomainInsights = nil
            self.nextToken = nil
        }
    }
}

public struct ListControlDomainInsightsOutput: Swift.Equatable {
    /// The control domain analytics data that the ListControlDomainInsights API returned.
    public var controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlDomainInsights = controlDomainInsights
        self.nextToken = nextToken
    }
}

struct ListControlDomainInsightsOutputBody: Swift.Equatable {
    let controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]?
    let nextToken: Swift.String?
}

extension ListControlDomainInsightsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlDomainInsights
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDomainInsightsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlDomainInsights?].self, forKey: .controlDomainInsights)
        var controlDomainInsightsDecoded0:[AuditManagerClientTypes.ControlDomainInsights]? = nil
        if let controlDomainInsightsContainer = controlDomainInsightsContainer {
            controlDomainInsightsDecoded0 = [AuditManagerClientTypes.ControlDomainInsights]()
            for structure0 in controlDomainInsightsContainer {
                if let structure0 = structure0 {
                    controlDomainInsightsDecoded0?.append(structure0)
                }
            }
        }
        controlDomainInsights = controlDomainInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListControlDomainInsightsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListControlInsightsByControlDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let controlDomainId = controlDomainId else {
                let message = "Creating a URL Query Item failed. controlDomainId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let controlDomainIdQueryItem = ClientRuntime.URLQueryItem(name: "controlDomainId".urlPercentEncoding(), value: Swift.String(controlDomainId).urlPercentEncoding())
            items.append(controlDomainIdQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListControlInsightsByControlDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/controls"
    }
}

public struct ListControlInsightsByControlDomainInput: Swift.Equatable {
    /// The unique identifier for the control domain.
    /// This member is required.
    public var controlDomainId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlDomainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlDomainId = controlDomainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListControlInsightsByControlDomainInputBody: Swift.Equatable {
}

extension ListControlInsightsByControlDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListControlInsightsByControlDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListControlInsightsByControlDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.controlInsightsMetadata = output.controlInsightsMetadata
            self.nextToken = output.nextToken
        } else {
            self.controlInsightsMetadata = nil
            self.nextToken = nil
        }
    }
}

public struct ListControlInsightsByControlDomainOutput: Swift.Equatable {
    /// The control analytics data that the ListControlInsightsByControlDomain API returned.
    public var controlInsightsMetadata: [AuditManagerClientTypes.ControlInsightsMetadataItem]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlInsightsMetadata: [AuditManagerClientTypes.ControlInsightsMetadataItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlInsightsMetadata = controlInsightsMetadata
        self.nextToken = nextToken
    }
}

struct ListControlInsightsByControlDomainOutputBody: Swift.Equatable {
    let controlInsightsMetadata: [AuditManagerClientTypes.ControlInsightsMetadataItem]?
    let nextToken: Swift.String?
}

extension ListControlInsightsByControlDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlInsightsMetadata
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlInsightsMetadataContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlInsightsMetadataItem?].self, forKey: .controlInsightsMetadata)
        var controlInsightsMetadataDecoded0:[AuditManagerClientTypes.ControlInsightsMetadataItem]? = nil
        if let controlInsightsMetadataContainer = controlInsightsMetadataContainer {
            controlInsightsMetadataDecoded0 = [AuditManagerClientTypes.ControlInsightsMetadataItem]()
            for structure0 in controlInsightsMetadataContainer {
                if let structure0 = structure0 {
                    controlInsightsMetadataDecoded0?.append(structure0)
                }
            }
        }
        controlInsightsMetadata = controlInsightsMetadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListControlInsightsByControlDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListControlsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let controlType = controlType else {
                let message = "Creating a URL Query Item failed. controlType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let controlTypeQueryItem = ClientRuntime.URLQueryItem(name: "controlType".urlPercentEncoding(), value: Swift.String(controlType.rawValue).urlPercentEncoding())
            items.append(controlTypeQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListControlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/controls"
    }
}

public struct ListControlsInput: Swift.Equatable {
    /// The type of control, such as a standard control or a custom control.
    /// This member is required.
    public var controlType: AuditManagerClientTypes.ControlType?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlType: AuditManagerClientTypes.ControlType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlType = controlType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListControlsInputBody: Swift.Equatable {
}

extension ListControlsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListControlsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListControlsOutputBody = try responseDecoder.decode(responseBody: data)
            self.controlMetadataList = output.controlMetadataList
            self.nextToken = output.nextToken
        } else {
            self.controlMetadataList = nil
            self.nextToken = nil
        }
    }
}

public struct ListControlsOutput: Swift.Equatable {
    /// A list of metadata that the ListControls API returns for each control.
    public var controlMetadataList: [AuditManagerClientTypes.ControlMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlMetadataList: [AuditManagerClientTypes.ControlMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlMetadataList = controlMetadataList
        self.nextToken = nextToken
    }
}

struct ListControlsOutputBody: Swift.Equatable {
    let controlMetadataList: [AuditManagerClientTypes.ControlMetadata]?
    let nextToken: Swift.String?
}

extension ListControlsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlMetadataList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlMetadataListContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlMetadata?].self, forKey: .controlMetadataList)
        var controlMetadataListDecoded0:[AuditManagerClientTypes.ControlMetadata]? = nil
        if let controlMetadataListContainer = controlMetadataListContainer {
            controlMetadataListDecoded0 = [AuditManagerClientTypes.ControlMetadata]()
            for structure0 in controlMetadataListContainer {
                if let structure0 = structure0 {
                    controlMetadataListDecoded0?.append(structure0)
                }
            }
        }
        controlMetadataList = controlMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListControlsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKeywordsForDataSourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let source = source else {
                let message = "Creating a URL Query Item failed. source is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let sourceQueryItem = ClientRuntime.URLQueryItem(name: "source".urlPercentEncoding(), value: Swift.String(source.rawValue).urlPercentEncoding())
            items.append(sourceQueryItem)
            return items
        }
    }
}

extension ListKeywordsForDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dataSourceKeywords"
    }
}

public struct ListKeywordsForDataSourceInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The control mapping data source that the keywords apply to.
    /// This member is required.
    public var source: AuditManagerClientTypes.SourceType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        source: AuditManagerClientTypes.SourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.source = source
    }
}

struct ListKeywordsForDataSourceInputBody: Swift.Equatable {
}

extension ListKeywordsForDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKeywordsForDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKeywordsForDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.keywords = output.keywords
            self.nextToken = output.nextToken
        } else {
            self.keywords = nil
            self.nextToken = nil
        }
    }
}

public struct ListKeywordsForDataSourceOutput: Swift.Equatable {
    /// The list of keywords for the event mapping source.
    public var keywords: [Swift.String]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        keywords: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.nextToken = nextToken
    }
}

struct ListKeywordsForDataSourceOutputBody: Swift.Equatable {
    let keywords: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListKeywordsForDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keywords
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keywordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keywords)
        var keywordsDecoded0:[Swift.String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [Swift.String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKeywordsForDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNotificationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/notifications"
    }
}

public struct ListNotificationsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNotificationsInputBody: Swift.Equatable {
}

extension ListNotificationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListNotificationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNotificationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notifications = output.notifications
        } else {
            self.nextToken = nil
            self.notifications = nil
        }
    }
}

public struct ListNotificationsOutput: Swift.Equatable {
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The returned list of notifications.
    public var notifications: [AuditManagerClientTypes.Notification]?

    public init(
        nextToken: Swift.String? = nil,
        notifications: [AuditManagerClientTypes.Notification]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

struct ListNotificationsOutputBody: Swift.Equatable {
    let notifications: [AuditManagerClientTypes.Notification]?
    let nextToken: Swift.String?
}

extension ListNotificationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case notifications
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Notification?].self, forKey: .notifications)
        var notificationsDecoded0:[AuditManagerClientTypes.Notification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [AuditManagerClientTypes.Notification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNotificationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of tags that the ListTagsForResource API returned.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.ManualEvidence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFileName
        case s3ResourcePath
        case textResponse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFileName = self.evidenceFileName {
            try encodeContainer.encode(evidenceFileName, forKey: .evidenceFileName)
        }
        if let s3ResourcePath = self.s3ResourcePath {
            try encodeContainer.encode(s3ResourcePath, forKey: .s3ResourcePath)
        }
        if let textResponse = self.textResponse {
            try encodeContainer.encode(textResponse, forKey: .textResponse)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ResourcePath)
        s3ResourcePath = s3ResourcePathDecoded
        let textResponseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textResponse)
        textResponse = textResponseDecoded
        let evidenceFileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFileName)
        evidenceFileName = evidenceFileNameDecoded
    }
}

extension AuditManagerClientTypes.ManualEvidence: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ManualEvidence(s3ResourcePath: \(Swift.String(describing: s3ResourcePath)), evidenceFileName: \"CONTENT_REDACTED\", textResponse: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// Evidence that's manually added to a control in Audit Manager. manualEvidence can be one of the following: evidenceFileName, s3ResourcePath, or textResponse.
    public struct ManualEvidence: Swift.Equatable {
        /// The name of the file that's uploaded as manual evidence. This name is populated using the evidenceFileName value from the [GetEvidenceFileUploadUrl](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_GetEvidenceFileUploadUrl.html) API response.
        public var evidenceFileName: Swift.String?
        /// The S3 URL of the object that's imported as manual evidence.
        public var s3ResourcePath: Swift.String?
        /// The plain text response that's entered and saved as manual evidence.
        public var textResponse: Swift.String?

        public init(
            evidenceFileName: Swift.String? = nil,
            s3ResourcePath: Swift.String? = nil,
            textResponse: Swift.String? = nil
        )
        {
            self.evidenceFileName = evidenceFileName
            self.s3ResourcePath = s3ResourcePath
            self.textResponse = textResponse
        }
    }

}

extension AuditManagerClientTypes.Notification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentName
        case controlSetId
        case controlSetName
        case description
        case eventTime
        case id
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let controlSetId = self.controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let controlSetName = self.controlSetName {
            try encodeContainer.encode(controlSetName, forKey: .controlSetName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let controlSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetName)
        controlSetName = controlSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension AuditManagerClientTypes.Notification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Notification(assessmentId: \(Swift.String(describing: assessmentId)), controlSetId: \(Swift.String(describing: controlSetId)), controlSetName: \(Swift.String(describing: controlSetName)), description: \(Swift.String(describing: description)), eventTime: \(Swift.String(describing: eventTime)), id: \(Swift.String(describing: id)), source: \(Swift.String(describing: source)), assessmentName: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The notification that informs a user of an update in Audit Manager. For example, this includes the notification that's sent when a control set is delegated for review.
    public struct Notification: Swift.Equatable {
        /// The identifier for the assessment.
        public var assessmentId: Swift.String?
        /// The name of the related assessment.
        public var assessmentName: Swift.String?
        /// The identifier for the control set.
        public var controlSetId: Swift.String?
        /// Specifies the name of the control set that the notification is about.
        public var controlSetName: Swift.String?
        /// The description of the notification.
        public var description: Swift.String?
        /// The time when the notification was sent.
        public var eventTime: ClientRuntime.Date?
        /// The unique identifier for the notification.
        public var id: Swift.String?
        /// The sender of the notification.
        public var source: Swift.String?

        public init(
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            controlSetName: Swift.String? = nil,
            description: Swift.String? = nil,
            eventTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.controlSetId = controlSetId
            self.controlSetName = controlSetName
            self.description = description
            self.eventTime = eventTime
            self.id = id
            self.source = source
        }
    }

}

extension AuditManagerClientTypes {
    public enum ObjectTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assessment
        case assessmentReport
        case control
        case controlSet
        case delegation
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectTypeEnum] {
            return [
                .assessment,
                .assessmentReport,
                .control,
                .controlSet,
                .delegation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assessment: return "ASSESSMENT"
            case .assessmentReport: return "ASSESSMENT_REPORT"
            case .control: return "CONTROL"
            case .controlSet: return "CONTROL_SET"
            case .delegation: return "DELEGATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectTypeEnum(rawValue: rawValue) ?? ObjectTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension RegisterAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccount
        case kmsKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegatedAdminAccount = self.delegatedAdminAccount {
            try encodeContainer.encode(delegatedAdminAccount, forKey: .delegatedAdminAccount)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }
}

extension RegisterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/registerAccount"
    }
}

public struct RegisterAccountInput: Swift.Equatable {
    /// The delegated administrator account for Audit Manager.
    public var delegatedAdminAccount: Swift.String?
    /// The KMS key details.
    public var kmsKey: Swift.String?

    public init(
        delegatedAdminAccount: Swift.String? = nil,
        kmsKey: Swift.String? = nil
    )
    {
        self.delegatedAdminAccount = delegatedAdminAccount
        self.kmsKey = kmsKey
    }
}

struct RegisterAccountInputBody: Swift.Equatable {
    let kmsKey: Swift.String?
    let delegatedAdminAccount: Swift.String?
}

extension RegisterAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccount
        case kmsKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let delegatedAdminAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccount)
        delegatedAdminAccount = delegatedAdminAccountDecoded
    }
}

extension RegisterAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct RegisterAccountOutput: Swift.Equatable {
    /// The status of the account registration request.
    public var status: AuditManagerClientTypes.AccountStatus?

    public init(
        status: AuditManagerClientTypes.AccountStatus? = nil
    )
    {
        self.status = status
    }
}

struct RegisterAccountOutputBody: Swift.Equatable {
    let status: AuditManagerClientTypes.AccountStatus?
}

extension RegisterAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AccountStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum RegisterAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension RegisterOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/registerOrganizationAdminAccount"
    }
}

public struct RegisterOrganizationAdminAccountInput: Swift.Equatable {
    /// The identifier for the delegated administrator account.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct RegisterOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension RegisterOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension RegisterOrganizationAdminAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterOrganizationAdminAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.adminAccountId = output.adminAccountId
            self.organizationId = output.organizationId
        } else {
            self.adminAccountId = nil
            self.organizationId = nil
        }
    }
}

public struct RegisterOrganizationAdminAccountOutput: Swift.Equatable {
    /// The identifier for the delegated administrator account.
    public var adminAccountId: Swift.String?
    /// The identifier for the organization.
    public var organizationId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.organizationId = organizationId
    }
}

struct RegisterOrganizationAdminAccountOutputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
    let organizationId: Swift.String?
}

extension RegisterOrganizationAdminAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
        case organizationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

enum RegisterOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case complianceCheck
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let complianceCheck = self.complianceCheck {
            try encodeContainer.encode(complianceCheck, forKey: .complianceCheck)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let complianceCheckDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceCheck)
        complianceCheck = complianceCheckDecoded
    }
}

extension AuditManagerClientTypes {
    /// A system asset that's evaluated in an Audit Manager assessment.
    public struct Resource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the resource.
        public var arn: Swift.String?
        /// The evaluation status for a resource that was assessed when collecting compliance check evidence.
        ///
        /// * Audit Manager classes the resource as non-compliant if Security Hub reports a Fail result, or if Config reports a Non-compliant result.
        ///
        /// * Audit Manager classes the resource as compliant if Security Hub reports a Pass result, or if Config reports a Compliant result.
        ///
        /// * If a compliance check isn't available or applicable, then no compliance evaluation can be made for that resource. This is the case if a resource assessment uses Config or Security Hub as the underlying data source type, but those services aren't enabled. This is also the case if the resource assessment uses an underlying data source type that doesn't support compliance checks (such as manual evidence, Amazon Web Services API calls, or CloudTrail).
        public var complianceCheck: Swift.String?
        /// The value of the resource.
        public var value: Swift.String?

        public init(
            arn: Swift.String? = nil,
            complianceCheck: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.arn = arn
            self.complianceCheck = complianceCheck
            self.value = value
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource that's specified in the request can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that's affected by the error.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AuditManagerClientTypes.Role: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case roleType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let roleType = self.roleType {
            try encodeContainer.encode(roleType.rawValue, forKey: .roleType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.RoleType.self, forKey: .roleType)
        roleType = roleTypeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AuditManagerClientTypes {
    /// The wrapper that contains the Audit Manager role information of the current user. This includes the role type and IAM Amazon Resource Name (ARN).
    public struct Role: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM role.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The type of customer persona. In CreateAssessment, roleType can only be PROCESS_OWNER. In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        /// This member is required.
        public var roleType: AuditManagerClientTypes.RoleType?

        public init(
            roleArn: Swift.String? = nil,
            roleType: AuditManagerClientTypes.RoleType? = nil
        )
        {
            self.roleArn = roleArn
            self.roleType = roleType
        }
    }

}

extension AuditManagerClientTypes {
    public enum RoleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case processOwner
        case resourceOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [RoleType] {
            return [
                .processOwner,
                .resourceOwner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .processOwner: return "PROCESS_OWNER"
            case .resourceOwner: return "RESOURCE_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoleType(rawValue: rawValue) ?? RoleType.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.Scope: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccounts
        case awsServices
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccounts = awsAccounts {
            var awsAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccounts)
            for awsaccount0 in awsAccounts {
                try awsAccountsContainer.encode(awsaccount0)
            }
        }
        if let awsServices = awsServices {
            var awsServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsServices)
            for awsservice0 in awsServices {
                try awsServicesContainer.encode(awsservice0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AWSAccount?].self, forKey: .awsAccounts)
        var awsAccountsDecoded0:[AuditManagerClientTypes.AWSAccount]? = nil
        if let awsAccountsContainer = awsAccountsContainer {
            awsAccountsDecoded0 = [AuditManagerClientTypes.AWSAccount]()
            for structure0 in awsAccountsContainer {
                if let structure0 = structure0 {
                    awsAccountsDecoded0?.append(structure0)
                }
            }
        }
        awsAccounts = awsAccountsDecoded0
        let awsServicesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AWSService?].self, forKey: .awsServices)
        var awsServicesDecoded0:[AuditManagerClientTypes.AWSService]? = nil
        if let awsServicesContainer = awsServicesContainer {
            awsServicesDecoded0 = [AuditManagerClientTypes.AWSService]()
            for structure0 in awsServicesContainer {
                if let structure0 = structure0 {
                    awsServicesDecoded0?.append(structure0)
                }
            }
        }
        awsServices = awsServicesDecoded0
    }
}

extension AuditManagerClientTypes.Scope: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AuditManagerClientTypes {
    /// The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment.
    public struct Scope: Swift.Equatable {
        /// The Amazon Web Services accounts that are included in the scope of the assessment.
        public var awsAccounts: [AuditManagerClientTypes.AWSAccount]?
        /// The Amazon Web Services services that are included in the scope of the assessment.
        public var awsServices: [AuditManagerClientTypes.AWSService]?

        public init(
            awsAccounts: [AuditManagerClientTypes.AWSAccount]? = nil,
            awsServices: [AuditManagerClientTypes.AWSService]? = nil
        )
        {
            self.awsAccounts = awsAccounts
            self.awsServices = awsServices
        }
    }

}

extension AuditManagerClientTypes.ServiceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case description
        case displayName
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
    }
}

extension AuditManagerClientTypes {
    /// The metadata that's associated with the Amazon Web Service.
    public struct ServiceMetadata: Swift.Equatable {
        /// The category that the Amazon Web Service belongs to, such as compute, storage, or database.
        public var category: Swift.String?
        /// The description of the Amazon Web Service.
        public var description: Swift.String?
        /// The display name of the Amazon Web Service.
        public var displayName: Swift.String?
        /// The name of the Amazon Web Service.
        public var name: Swift.String?

        public init(
            category: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.category = category
            self.description = description
            self.displayName = displayName
            self.name = name
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've reached your account quota for this resource type. To perform the requested action, delete some existing resources or [request a quota increase](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) from the Service Quotas console. For a list of Audit Manager service quotas, see [Quotas and restrictions for Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/service-quotas.html).
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditManagerClientTypes {
    public enum SettingAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case defaultAssessmentReportsDestination
        case defaultExportDestination
        case defaultProcessOwners
        case deregistrationPolicy
        case evidenceFinderEnablement
        case isAwsOrgEnabled
        case snsTopic
        case sdkUnknown(Swift.String)

        public static var allCases: [SettingAttribute] {
            return [
                .all,
                .defaultAssessmentReportsDestination,
                .defaultExportDestination,
                .defaultProcessOwners,
                .deregistrationPolicy,
                .evidenceFinderEnablement,
                .isAwsOrgEnabled,
                .snsTopic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .defaultAssessmentReportsDestination: return "DEFAULT_ASSESSMENT_REPORTS_DESTINATION"
            case .defaultExportDestination: return "DEFAULT_EXPORT_DESTINATION"
            case .defaultProcessOwners: return "DEFAULT_PROCESS_OWNERS"
            case .deregistrationPolicy: return "DEREGISTRATION_POLICY"
            case .evidenceFinderEnablement: return "EVIDENCE_FINDER_ENABLEMENT"
            case .isAwsOrgEnabled: return "IS_AWS_ORG_ENABLED"
            case .snsTopic: return "SNS_TOPIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SettingAttribute(rawValue: rawValue) ?? SettingAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAssessmentReportsDestination
        case defaultExportDestination
        case defaultProcessOwners
        case deregistrationPolicy
        case evidenceFinderEnablement
        case isAwsOrgEnabled
        case kmsKey
        case snsTopic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAssessmentReportsDestination = self.defaultAssessmentReportsDestination {
            try encodeContainer.encode(defaultAssessmentReportsDestination, forKey: .defaultAssessmentReportsDestination)
        }
        if let defaultExportDestination = self.defaultExportDestination {
            try encodeContainer.encode(defaultExportDestination, forKey: .defaultExportDestination)
        }
        if let defaultProcessOwners = defaultProcessOwners {
            var defaultProcessOwnersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultProcessOwners)
            for role0 in defaultProcessOwners {
                try defaultProcessOwnersContainer.encode(role0)
            }
        }
        if let deregistrationPolicy = self.deregistrationPolicy {
            try encodeContainer.encode(deregistrationPolicy, forKey: .deregistrationPolicy)
        }
        if let evidenceFinderEnablement = self.evidenceFinderEnablement {
            try encodeContainer.encode(evidenceFinderEnablement, forKey: .evidenceFinderEnablement)
        }
        if let isAwsOrgEnabled = self.isAwsOrgEnabled {
            try encodeContainer.encode(isAwsOrgEnabled, forKey: .isAwsOrgEnabled)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let snsTopic = self.snsTopic {
            try encodeContainer.encode(snsTopic, forKey: .snsTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isAwsOrgEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAwsOrgEnabled)
        isAwsOrgEnabled = isAwsOrgEnabledDecoded
        let snsTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopic)
        snsTopic = snsTopicDecoded
        let defaultAssessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportsDestination.self, forKey: .defaultAssessmentReportsDestination)
        defaultAssessmentReportsDestination = defaultAssessmentReportsDestinationDecoded
        let defaultProcessOwnersContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .defaultProcessOwners)
        var defaultProcessOwnersDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let defaultProcessOwnersContainer = defaultProcessOwnersContainer {
            defaultProcessOwnersDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in defaultProcessOwnersContainer {
                if let structure0 = structure0 {
                    defaultProcessOwnersDecoded0?.append(structure0)
                }
            }
        }
        defaultProcessOwners = defaultProcessOwnersDecoded0
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let evidenceFinderEnablementDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceFinderEnablement.self, forKey: .evidenceFinderEnablement)
        evidenceFinderEnablement = evidenceFinderEnablementDecoded
        let deregistrationPolicyDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.DeregistrationPolicy.self, forKey: .deregistrationPolicy)
        deregistrationPolicy = deregistrationPolicyDecoded
        let defaultExportDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.DefaultExportDestination.self, forKey: .defaultExportDestination)
        defaultExportDestination = defaultExportDestinationDecoded
    }
}

extension AuditManagerClientTypes.Settings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Settings(defaultExportDestination: \(Swift.String(describing: defaultExportDestination)), deregistrationPolicy: \(Swift.String(describing: deregistrationPolicy)), evidenceFinderEnablement: \(Swift.String(describing: evidenceFinderEnablement)), isAwsOrgEnabled: \(Swift.String(describing: isAwsOrgEnabled)), kmsKey: \(Swift.String(describing: kmsKey)), defaultAssessmentReportsDestination: \"CONTENT_REDACTED\", defaultProcessOwners: \"CONTENT_REDACTED\", snsTopic: \"CONTENT_REDACTED\")"}
}

extension AuditManagerClientTypes {
    /// The settings object that holds all supported Audit Manager settings.
    public struct Settings: Swift.Equatable {
        /// The default S3 destination bucket for storing assessment reports.
        public var defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
        /// The default S3 destination bucket for storing evidence finder exports.
        public var defaultExportDestination: AuditManagerClientTypes.DefaultExportDestination?
        /// The designated default audit owners.
        public var defaultProcessOwners: [AuditManagerClientTypes.Role]?
        /// The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.
        public var deregistrationPolicy: AuditManagerClientTypes.DeregistrationPolicy?
        /// The current evidence finder status and event data store details.
        public var evidenceFinderEnablement: AuditManagerClientTypes.EvidenceFinderEnablement?
        /// Specifies whether Organizations is enabled.
        public var isAwsOrgEnabled: Swift.Bool?
        /// The KMS key details.
        public var kmsKey: Swift.String?
        /// The designated Amazon Simple Notification Service (Amazon SNS) topic.
        public var snsTopic: Swift.String?

        public init(
            defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
            defaultExportDestination: AuditManagerClientTypes.DefaultExportDestination? = nil,
            defaultProcessOwners: [AuditManagerClientTypes.Role]? = nil,
            deregistrationPolicy: AuditManagerClientTypes.DeregistrationPolicy? = nil,
            evidenceFinderEnablement: AuditManagerClientTypes.EvidenceFinderEnablement? = nil,
            isAwsOrgEnabled: Swift.Bool? = nil,
            kmsKey: Swift.String? = nil,
            snsTopic: Swift.String? = nil
        )
        {
            self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
            self.defaultExportDestination = defaultExportDestination
            self.defaultProcessOwners = defaultProcessOwners
            self.deregistrationPolicy = deregistrationPolicy
            self.evidenceFinderEnablement = evidenceFinderEnablement
            self.isAwsOrgEnabled = isAwsOrgEnabled
            self.kmsKey = kmsKey
            self.snsTopic = snsTopic
        }
    }

}

extension AuditManagerClientTypes {
    public enum ShareRequestAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accept
        case decline
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareRequestAction] {
            return [
                .accept,
                .decline,
                .revoke,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .decline: return "DECLINE"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareRequestAction(rawValue: rawValue) ?? ShareRequestAction.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum ShareRequestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case declined
        case expired
        case expiring
        case failed
        case replicating
        case revoked
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareRequestStatus] {
            return [
                .active,
                .declined,
                .expired,
                .expiring,
                .failed,
                .replicating,
                .revoked,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .declined: return "DECLINED"
            case .expired: return "EXPIRED"
            case .expiring: return "EXPIRING"
            case .failed: return "FAILED"
            case .replicating: return "REPLICATING"
            case .revoked: return "REVOKED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareRequestStatus(rawValue: rawValue) ?? ShareRequestStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum ShareRequestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case received
        case sent
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareRequestType] {
            return [
                .received,
                .sent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .received: return "RECEIVED"
            case .sent: return "SENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareRequestType(rawValue: rawValue) ?? ShareRequestType.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum SourceFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceFrequency] {
            return [
                .daily,
                .monthly,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceFrequency(rawValue: rawValue) ?? SourceFrequency.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.SourceKeyword: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keywordInputType
        case keywordValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keywordInputType = self.keywordInputType {
            try encodeContainer.encode(keywordInputType.rawValue, forKey: .keywordInputType)
        }
        if let keywordValue = self.keywordValue {
            try encodeContainer.encode(keywordValue, forKey: .keywordValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keywordInputTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.KeywordInputType.self, forKey: .keywordInputType)
        keywordInputType = keywordInputTypeDecoded
        let keywordValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywordValue)
        keywordValue = keywordValueDecoded
    }
}

extension AuditManagerClientTypes {
    /// A keyword that relates to the control data source. For manual evidence, this keyword indicates if the manual evidence is a file or text. For automated evidence, this keyword identifies a specific CloudTrail event, Config rule, Security Hub control, or Amazon Web Services API name. To learn more about the supported keywords that you can use when mapping a control data source, see the following pages in the Audit Manager User Guide:
    ///
    /// * [Config rules supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html)
    ///
    /// * [Security Hub controls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html)
    ///
    /// * [API calls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html)
    ///
    /// * [CloudTrail event names supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-cloudtrail.html)
    public struct SourceKeyword: Swift.Equatable {
        /// The input method for the keyword.
        ///
        /// * SELECT_FROM_LIST is used when mapping a data source for automated evidence.
        ///
        /// * When keywordInputType is SELECT_FROM_LIST, a keyword must be selected to collect automated evidence. For example, this keyword can be a CloudTrail event name, a rule name for Config, a Security Hub control, or the name of an Amazon Web Services API call.
        ///
        ///
        ///
        ///
        /// * UPLOAD_FILE and INPUT_TEXT are only used when mapping a data source for manual evidence.
        ///
        /// * When keywordInputType is UPLOAD_FILE, a file must be uploaded as manual evidence.
        ///
        /// * When keywordInputType is INPUT_TEXT, text must be entered as manual evidence.
        public var keywordInputType: AuditManagerClientTypes.KeywordInputType?
        /// The value of the keyword that's used when mapping a control data source. For example, this can be a CloudTrail event name, a rule name for Config, a Security Hub control, or the name of an Amazon Web Services API call. If youre mapping a data source to a rule in Config, the keywordValue that you specify depends on the type of rule:
        ///
        /// * For [managed rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html), you can use the rule identifier as the keywordValue. You can find the rule identifier from the [list of Config managed rules](https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html). For some rules, the rule identifier is different from the rule name. For example, the rule name restricted-ssh has the following rule identifier: INCOMING_SSH_DISABLED. Make sure to use the rule identifier, not the rule name. Keyword example for managed rules:
        ///
        /// * Managed rule name: [s3-bucket-acl-prohibited](https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-acl-prohibited.html)keywordValue: S3_BUCKET_ACL_PROHIBITED
        ///
        ///
        ///
        ///
        /// * For [custom rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html), you form the keywordValue by adding the Custom_ prefix to the rule name. This prefix distinguishes the custom rule from a managed rule. Keyword example for custom rules:
        ///
        /// * Custom rule name: my-custom-config-rule keywordValue: Custom_my-custom-config-rule
        ///
        ///
        ///
        ///
        /// * For [service-linked rules](https://docs.aws.amazon.com/config/latest/developerguide/service-linked-awsconfig-rules.html), you form the keywordValue by adding the Custom_ prefix to the rule name. In addition, you remove the suffix ID that appears at the end of the rule name. Keyword examples for service-linked rules:
        ///
        /// * Service-linked rule name: CustomRuleForAccount-conformance-pack-szsm1uv0w keywordValue: Custom_CustomRuleForAccount-conformance-pack
        ///
        /// * Service-linked rule name: OrgConfigRule-s3-bucket-versioning-enabled-dbgzf8ba keywordValue: Custom_OrgConfigRule-s3-bucket-versioning-enabled
        ///
        ///
        ///
        ///
        ///
        /// The keywordValue is case sensitive. If you enter a value incorrectly, Audit Manager might not recognize the data source mapping. As a result, you might not successfully collect evidence from that data source as intended. Keep in mind the following requirements, depending on the data source type that you're using.
        ///
        /// * For Config:
        ///
        /// * For managed rules, make sure that the keywordValue is the rule identifier in ALL_CAPS_WITH_UNDERSCORES. For example, CLOUDWATCH_LOG_GROUP_ENCRYPTED. For accuracy, we recommend that you reference the list of [supported Config managed rules](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html).
        ///
        /// * For custom rules, make sure that the keywordValue has the Custom_ prefix followed by the custom rule name. The format of the custom rule name itself may vary. For accuracy, we recommend that you visit the [Config console](https://console.aws.amazon.com/config/) to verify your custom rule name.
        ///
        ///
        ///
        ///
        /// * For Security Hub: The format varies for Security Hub control names. For accuracy, we recommend that you reference the list of [supported Security Hub controls](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html).
        ///
        /// * For Amazon Web Services API calls: Make sure that the keywordValue is written as serviceprefix_ActionName. For example, iam_ListGroups. For accuracy, we recommend that you reference the list of [supported API calls](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html).
        ///
        /// * For CloudTrail: Make sure that the keywordValue is written as serviceprefix_ActionName. For example, cloudtrail_StartLogging. For accuracy, we recommend that you review the Amazon Web Service prefix and action names in the [Service Authorization Reference](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html).
        public var keywordValue: Swift.String?

        public init(
            keywordInputType: AuditManagerClientTypes.KeywordInputType? = nil,
            keywordValue: Swift.String? = nil
        )
        {
            self.keywordInputType = keywordInputType
            self.keywordValue = keywordValue
        }
    }

}

extension AuditManagerClientTypes {
    public enum SourceSetUpOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case proceduralControlsMapping
        case systemControlsMapping
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceSetUpOption] {
            return [
                .proceduralControlsMapping,
                .systemControlsMapping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .proceduralControlsMapping: return "Procedural_Controls_Mapping"
            case .systemControlsMapping: return "System_Controls_Mapping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceSetUpOption(rawValue: rawValue) ?? SourceSetUpOption.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsApiCall
        case awsCloudtrail
        case awsConfig
        case awsSecurityHub
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .awsApiCall,
                .awsCloudtrail,
                .awsConfig,
                .awsSecurityHub,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsApiCall: return "AWS_API_Call"
            case .awsCloudtrail: return "AWS_Cloudtrail"
            case .awsConfig: return "AWS_Config"
            case .awsSecurityHub: return "AWS_Security_Hub"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension StartAssessmentFrameworkShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case destinationAccount
        case destinationRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let destinationAccount = self.destinationAccount {
            try encodeContainer.encode(destinationAccount, forKey: .destinationAccount)
        }
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
    }
}

extension StartAssessmentFrameworkShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkId = frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())/shareRequests"
    }
}

public struct StartAssessmentFrameworkShareInput: Swift.Equatable {
    /// An optional comment from the sender about the share request.
    public var comment: Swift.String?
    /// The Amazon Web Services account of the recipient.
    /// This member is required.
    public var destinationAccount: Swift.String?
    /// The Amazon Web Services Region of the recipient.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// The unique identifier for the custom framework to be shared.
    /// This member is required.
    public var frameworkId: Swift.String?

    public init(
        comment: Swift.String? = nil,
        destinationAccount: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        frameworkId: Swift.String? = nil
    )
    {
        self.comment = comment
        self.destinationAccount = destinationAccount
        self.destinationRegion = destinationRegion
        self.frameworkId = frameworkId
    }
}

struct StartAssessmentFrameworkShareInputBody: Swift.Equatable {
    let destinationAccount: Swift.String?
    let destinationRegion: Swift.String?
    let comment: Swift.String?
}

extension StartAssessmentFrameworkShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case destinationAccount
        case destinationRegion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationAccount)
        destinationAccount = destinationAccountDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension StartAssessmentFrameworkShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartAssessmentFrameworkShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentFrameworkShareRequest = output.assessmentFrameworkShareRequest
        } else {
            self.assessmentFrameworkShareRequest = nil
        }
    }
}

public struct StartAssessmentFrameworkShareOutput: Swift.Equatable {
    /// The share request that's created by the StartAssessmentFrameworkShare API.
    public var assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest?

    public init(
        assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest? = nil
    )
    {
        self.assessmentFrameworkShareRequest = assessmentFrameworkShareRequest
    }
}

struct StartAssessmentFrameworkShareOutputBody: Swift.Equatable {
    let assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest?
}

extension StartAssessmentFrameworkShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentFrameworkShareRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentFrameworkShareRequestDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentFrameworkShareRequest.self, forKey: .assessmentFrameworkShareRequest)
        assessmentFrameworkShareRequest = assessmentFrameworkShareRequestDecoded
    }
}

enum StartAssessmentFrameworkShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags that are associated with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditManagerClientTypes.URL: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hyperlinkName
        case link
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hyperlinkName = self.hyperlinkName {
            try encodeContainer.encode(hyperlinkName, forKey: .hyperlinkName)
        }
        if let link = self.link {
            try encodeContainer.encode(link, forKey: .link)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hyperlinkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hyperlinkName)
        hyperlinkName = hyperlinkNameDecoded
        let linkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .link)
        link = linkDecoded
    }
}

extension AuditManagerClientTypes {
    /// Short for uniform resource locator. A URL is used as a unique identifier to locate a resource on the internet.
    public struct URL: Swift.Equatable {
        /// The name or word that's used as a hyperlink to the URL.
        public var hyperlinkName: Swift.String?
        /// The unique identifier for the internet resource.
        public var link: Swift.String?

        public init(
            hyperlinkName: Swift.String? = nil,
            link: Swift.String? = nil
        )
        {
            self.hyperlinkName = hyperlinkName
            self.link = link
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the specified resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name or key of the tag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAssessmentControlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssessmentControlInput(assessmentId: \(Swift.String(describing: assessmentId)), controlId: \(Swift.String(describing: controlId)), controlSetId: \(Swift.String(describing: controlSetId)), controlStatus: \(Swift.String(describing: controlStatus)), commentBody: \"CONTENT_REDACTED\")"}
}

extension UpdateAssessmentControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentBody
        case controlStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentBody = self.commentBody {
            try encodeContainer.encode(commentBody, forKey: .commentBody)
        }
        if let controlStatus = self.controlStatus {
            try encodeContainer.encode(controlStatus.rawValue, forKey: .controlStatus)
        }
    }
}

extension UpdateAssessmentControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let controlId = controlId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/controls/\(controlId.urlPercentEncoding())"
    }
}

public struct UpdateAssessmentControlInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The comment body text for the control.
    public var commentBody: Swift.String?
    /// The unique identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The status of the control.
    public var controlStatus: AuditManagerClientTypes.ControlStatus?

    public init(
        assessmentId: Swift.String? = nil,
        commentBody: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        controlStatus: AuditManagerClientTypes.ControlStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.commentBody = commentBody
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.controlStatus = controlStatus
    }
}

struct UpdateAssessmentControlInputBody: Swift.Equatable {
    let controlStatus: AuditManagerClientTypes.ControlStatus?
    let commentBody: Swift.String?
}

extension UpdateAssessmentControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentBody
        case controlStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlStatusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlStatus.self, forKey: .controlStatus)
        controlStatus = controlStatusDecoded
        let commentBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentBody)
        commentBody = commentBodyDecoded
    }
}

extension UpdateAssessmentControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAssessmentControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct UpdateAssessmentControlOutput: Swift.Equatable {
    /// The name of the updated control set that the UpdateAssessmentControl API returned.
    public var control: AuditManagerClientTypes.AssessmentControl?

    public init(
        control: AuditManagerClientTypes.AssessmentControl? = nil
    )
    {
        self.control = control
    }
}

struct UpdateAssessmentControlOutputBody: Swift.Equatable {
    let control: AuditManagerClientTypes.AssessmentControl?
}

extension UpdateAssessmentControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case control
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentControl.self, forKey: .control)
        control = controlDecoded
    }
}

enum UpdateAssessmentControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAssessmentControlSetStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssessmentControlSetStatusInput(assessmentId: \(Swift.String(describing: assessmentId)), controlSetId: \(Swift.String(describing: controlSetId)), status: \(Swift.String(describing: status)), comment: \"CONTENT_REDACTED\")"}
}

extension UpdateAssessmentControlSetStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateAssessmentControlSetStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/status"
    }
}

public struct UpdateAssessmentControlSetStatusInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The comment that's related to the status update.
    /// This member is required.
    public var comment: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The status of the control set that's being updated.
    /// This member is required.
    public var status: AuditManagerClientTypes.ControlSetStatus?

    public init(
        assessmentId: Swift.String? = nil,
        comment: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        status: AuditManagerClientTypes.ControlSetStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.comment = comment
        self.controlSetId = controlSetId
        self.status = status
    }
}

struct UpdateAssessmentControlSetStatusInputBody: Swift.Equatable {
    let status: AuditManagerClientTypes.ControlSetStatus?
    let comment: Swift.String?
}

extension UpdateAssessmentControlSetStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlSetStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension UpdateAssessmentControlSetStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAssessmentControlSetStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.controlSet = output.controlSet
        } else {
            self.controlSet = nil
        }
    }
}

public struct UpdateAssessmentControlSetStatusOutput: Swift.Equatable {
    /// The name of the updated control set that the UpdateAssessmentControlSetStatus API returned.
    public var controlSet: AuditManagerClientTypes.AssessmentControlSet?

    public init(
        controlSet: AuditManagerClientTypes.AssessmentControlSet? = nil
    )
    {
        self.controlSet = controlSet
    }
}

struct UpdateAssessmentControlSetStatusOutputBody: Swift.Equatable {
    let controlSet: AuditManagerClientTypes.AssessmentControlSet?
}

extension UpdateAssessmentControlSetStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlSet
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlSetDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentControlSet.self, forKey: .controlSet)
        controlSet = controlSetDecoded
    }
}

enum UpdateAssessmentControlSetStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controls
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for createassessmentframeworkcontrol0 in controls {
                try controlsContainer.encode(createassessmentframeworkcontrol0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let controlsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.CreateAssessmentFrameworkControl?].self, forKey: .controls)
        var controlsDecoded0:[AuditManagerClientTypes.CreateAssessmentFrameworkControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [AuditManagerClientTypes.CreateAssessmentFrameworkControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension AuditManagerClientTypes {
    /// A controlSet entity that represents a collection of controls in Audit Manager. This doesn't contain the control set ID.
    public struct UpdateAssessmentFrameworkControlSet: Swift.Equatable {
        /// The list of controls that are contained within the control set.
        /// This member is required.
        public var controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]?
        /// The unique identifier for the control set.
        public var id: Swift.String?
        /// The name of the control set.
        /// This member is required.
        public var name: Swift.String?

        public init(
            controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.controls = controls
            self.id = id
            self.name = name
        }
    }

}

extension UpdateAssessmentFrameworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssessmentFrameworkInput(controlSets: \(Swift.String(describing: controlSets)), description: \(Swift.String(describing: description)), frameworkId: \(Swift.String(describing: frameworkId)), name: \(Swift.String(describing: name)), complianceType: \"CONTENT_REDACTED\")"}
}

extension UpdateAssessmentFrameworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case controlSets
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for updateassessmentframeworkcontrolset0 in controlSets {
                try controlSetsContainer.encode(updateassessmentframeworkcontrolset0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAssessmentFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkId = frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())"
    }
}

public struct UpdateAssessmentFrameworkInput: Swift.Equatable {
    /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
    public var complianceType: Swift.String?
    /// The control sets that are associated with the framework.
    /// This member is required.
    public var controlSets: [AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]?
    /// The description of the updated framework.
    public var description: Swift.String?
    /// The unique identifier for the framework.
    /// This member is required.
    public var frameworkId: Swift.String?
    /// The name of the framework to be updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        complianceType: Swift.String? = nil,
        controlSets: [AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]? = nil,
        description: Swift.String? = nil,
        frameworkId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.complianceType = complianceType
        self.controlSets = controlSets
        self.description = description
        self.frameworkId = frameworkId
        self.name = name
    }
}

struct UpdateAssessmentFrameworkInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let complianceType: Swift.String?
    let controlSets: [AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]?
}

extension UpdateAssessmentFrameworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case controlSets
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
    }
}

extension UpdateAssessmentFrameworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAssessmentFrameworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.framework = output.framework
        } else {
            self.framework = nil
        }
    }
}

public struct UpdateAssessmentFrameworkOutput: Swift.Equatable {
    /// The name of the framework.
    public var framework: AuditManagerClientTypes.Framework?

    public init(
        framework: AuditManagerClientTypes.Framework? = nil
    )
    {
        self.framework = framework
    }
}

struct UpdateAssessmentFrameworkOutputBody: Swift.Equatable {
    let framework: AuditManagerClientTypes.Framework?
}

extension UpdateAssessmentFrameworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case framework
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Framework.self, forKey: .framework)
        framework = frameworkDecoded
    }
}

enum UpdateAssessmentFrameworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAssessmentFrameworkShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case requestType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let requestType = self.requestType {
            try encodeContainer.encode(requestType.rawValue, forKey: .requestType)
        }
    }
}

extension UpdateAssessmentFrameworkShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let requestId = requestId else {
            return nil
        }
        return "/assessmentFrameworkShareRequests/\(requestId.urlPercentEncoding())"
    }
}

public struct UpdateAssessmentFrameworkShareInput: Swift.Equatable {
    /// Specifies the update action for the share request.
    /// This member is required.
    public var action: AuditManagerClientTypes.ShareRequestAction?
    /// The unique identifier for the share request.
    /// This member is required.
    public var requestId: Swift.String?
    /// Specifies whether the share request is a sent request or a received request.
    /// This member is required.
    public var requestType: AuditManagerClientTypes.ShareRequestType?

    public init(
        action: AuditManagerClientTypes.ShareRequestAction? = nil,
        requestId: Swift.String? = nil,
        requestType: AuditManagerClientTypes.ShareRequestType? = nil
    )
    {
        self.action = action
        self.requestId = requestId
        self.requestType = requestType
    }
}

struct UpdateAssessmentFrameworkShareInputBody: Swift.Equatable {
    let requestType: AuditManagerClientTypes.ShareRequestType?
    let action: AuditManagerClientTypes.ShareRequestAction?
}

extension UpdateAssessmentFrameworkShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case requestType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ShareRequestType.self, forKey: .requestType)
        requestType = requestTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ShareRequestAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateAssessmentFrameworkShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAssessmentFrameworkShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentFrameworkShareRequest = output.assessmentFrameworkShareRequest
        } else {
            self.assessmentFrameworkShareRequest = nil
        }
    }
}

public struct UpdateAssessmentFrameworkShareOutput: Swift.Equatable {
    /// The updated share request that's returned by the UpdateAssessmentFrameworkShare operation.
    public var assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest?

    public init(
        assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest? = nil
    )
    {
        self.assessmentFrameworkShareRequest = assessmentFrameworkShareRequest
    }
}

struct UpdateAssessmentFrameworkShareOutputBody: Swift.Equatable {
    let assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest?
}

extension UpdateAssessmentFrameworkShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentFrameworkShareRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentFrameworkShareRequestDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentFrameworkShareRequest.self, forKey: .assessmentFrameworkShareRequest)
        assessmentFrameworkShareRequest = assessmentFrameworkShareRequestDecoded
    }
}

enum UpdateAssessmentFrameworkShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssessmentInput(assessmentId: \(Swift.String(describing: assessmentId)), assessmentDescription: \"CONTENT_REDACTED\", assessmentName: \"CONTENT_REDACTED\", assessmentReportsDestination: \"CONTENT_REDACTED\", roles: \"CONTENT_REDACTED\", scope: \"CONTENT_REDACTED\")"}
}

extension UpdateAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentDescription
        case assessmentName
        case assessmentReportsDestination
        case roles
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentDescription = self.assessmentDescription {
            try encodeContainer.encode(assessmentDescription, forKey: .assessmentDescription)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let assessmentReportsDestination = self.assessmentReportsDestination {
            try encodeContainer.encode(assessmentReportsDestination, forKey: .assessmentReportsDestination)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
    }
}

extension UpdateAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

public struct UpdateAssessmentInput: Swift.Equatable {
    /// The description of the assessment.
    public var assessmentDescription: Swift.String?
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The name of the assessment to be updated.
    public var assessmentName: Swift.String?
    /// The assessment report storage destination for the assessment that's being updated.
    public var assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    /// The list of roles for the assessment.
    public var roles: [AuditManagerClientTypes.Role]?
    /// The scope of the assessment.
    /// This member is required.
    public var scope: AuditManagerClientTypes.Scope?

    public init(
        assessmentDescription: Swift.String? = nil,
        assessmentId: Swift.String? = nil,
        assessmentName: Swift.String? = nil,
        assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
        roles: [AuditManagerClientTypes.Role]? = nil,
        scope: AuditManagerClientTypes.Scope? = nil
    )
    {
        self.assessmentDescription = assessmentDescription
        self.assessmentId = assessmentId
        self.assessmentName = assessmentName
        self.assessmentReportsDestination = assessmentReportsDestination
        self.roles = roles
        self.scope = scope
    }
}

struct UpdateAssessmentInputBody: Swift.Equatable {
    let assessmentName: Swift.String?
    let assessmentDescription: Swift.String?
    let scope: AuditManagerClientTypes.Scope?
    let assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    let roles: [AuditManagerClientTypes.Role]?
}

extension UpdateAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentDescription
        case assessmentName
        case assessmentReportsDestination
        case roles
        case scope
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentDescription)
        assessmentDescription = assessmentDescriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let assessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportsDestination.self, forKey: .assessmentReportsDestination)
        assessmentReportsDestination = assessmentReportsDestinationDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .roles)
        var rolesDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
    }
}

extension UpdateAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct UpdateAssessmentOutput: Swift.Equatable {
    /// The response object for the UpdateAssessment API. This is the name of the updated assessment.
    public var assessment: AuditManagerClientTypes.Assessment?

    public init(
        assessment: AuditManagerClientTypes.Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct UpdateAssessmentOutputBody: Swift.Equatable {
    let assessment: AuditManagerClientTypes.Assessment?
}

extension UpdateAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

enum UpdateAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAssessmentStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateAssessmentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/status"
    }
}

public struct UpdateAssessmentStatusInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The current status of the assessment.
    /// This member is required.
    public var status: AuditManagerClientTypes.AssessmentStatus?

    public init(
        assessmentId: Swift.String? = nil,
        status: AuditManagerClientTypes.AssessmentStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.status = status
    }
}

struct UpdateAssessmentStatusInputBody: Swift.Equatable {
    let status: AuditManagerClientTypes.AssessmentStatus?
}

extension UpdateAssessmentStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateAssessmentStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAssessmentStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct UpdateAssessmentStatusOutput: Swift.Equatable {
    /// The name of the updated assessment that the UpdateAssessmentStatus API returned.
    public var assessment: AuditManagerClientTypes.Assessment?

    public init(
        assessment: AuditManagerClientTypes.Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct UpdateAssessmentStatusOutputBody: Swift.Equatable {
    let assessment: AuditManagerClientTypes.Assessment?
}

extension UpdateAssessmentStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

enum UpdateAssessmentStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateControlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateControlInput(controlId: \(Swift.String(describing: controlId)), controlMappingSources: \(Swift.String(describing: controlMappingSources)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), actionPlanInstructions: \"CONTENT_REDACTED\", actionPlanTitle: \"CONTENT_REDACTED\", testingInformation: \"CONTENT_REDACTED\")"}
}

extension UpdateControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case testingInformation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionPlanInstructions = self.actionPlanInstructions {
            try encodeContainer.encode(actionPlanInstructions, forKey: .actionPlanInstructions)
        }
        if let actionPlanTitle = self.actionPlanTitle {
            try encodeContainer.encode(actionPlanTitle, forKey: .actionPlanTitle)
        }
        if let controlMappingSources = controlMappingSources {
            var controlMappingSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlMappingSources)
            for controlmappingsource0 in controlMappingSources {
                try controlMappingSourcesContainer.encode(controlmappingsource0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let testingInformation = self.testingInformation {
            try encodeContainer.encode(testingInformation, forKey: .testingInformation)
        }
    }
}

extension UpdateControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let controlId = controlId else {
            return nil
        }
        return "/controls/\(controlId.urlPercentEncoding())"
    }
}

public struct UpdateControlInput: Swift.Equatable {
    /// The recommended actions to carry out if the control isn't fulfilled.
    public var actionPlanInstructions: Swift.String?
    /// The title of the action plan for remediating the control.
    public var actionPlanTitle: Swift.String?
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The data mapping sources for the control.
    /// This member is required.
    public var controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]?
    /// The optional description of the control.
    public var description: Swift.String?
    /// The name of the updated control.
    /// This member is required.
    public var name: Swift.String?
    /// The steps that you should follow to determine if the control is met.
    public var testingInformation: Swift.String?

    public init(
        actionPlanInstructions: Swift.String? = nil,
        actionPlanTitle: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        testingInformation: Swift.String? = nil
    )
    {
        self.actionPlanInstructions = actionPlanInstructions
        self.actionPlanTitle = actionPlanTitle
        self.controlId = controlId
        self.controlMappingSources = controlMappingSources
        self.description = description
        self.name = name
        self.testingInformation = testingInformation
    }
}

struct UpdateControlInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let testingInformation: Swift.String?
    let actionPlanTitle: Swift.String?
    let actionPlanInstructions: Swift.String?
    let controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]?
}

extension UpdateControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case testingInformation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let testingInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testingInformation)
        testingInformation = testingInformationDecoded
        let actionPlanTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanTitle)
        actionPlanTitle = actionPlanTitleDecoded
        let actionPlanInstructionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanInstructions)
        actionPlanInstructions = actionPlanInstructionsDecoded
        let controlMappingSourcesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlMappingSource?].self, forKey: .controlMappingSources)
        var controlMappingSourcesDecoded0:[AuditManagerClientTypes.ControlMappingSource]? = nil
        if let controlMappingSourcesContainer = controlMappingSourcesContainer {
            controlMappingSourcesDecoded0 = [AuditManagerClientTypes.ControlMappingSource]()
            for structure0 in controlMappingSourcesContainer {
                if let structure0 = structure0 {
                    controlMappingSourcesDecoded0?.append(structure0)
                }
            }
        }
        controlMappingSources = controlMappingSourcesDecoded0
    }
}

extension UpdateControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateControlOutputBody = try responseDecoder.decode(responseBody: data)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct UpdateControlOutput: Swift.Equatable {
    /// The name of the updated control set that the UpdateControl API returned.
    public var control: AuditManagerClientTypes.Control?

    public init(
        control: AuditManagerClientTypes.Control? = nil
    )
    {
        self.control = control
    }
}

struct UpdateControlOutputBody: Swift.Equatable {
    let control: AuditManagerClientTypes.Control?
}

extension UpdateControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case control
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Control.self, forKey: .control)
        control = controlDecoded
    }
}

enum UpdateControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSettingsInput(defaultExportDestination: \(Swift.String(describing: defaultExportDestination)), deregistrationPolicy: \(Swift.String(describing: deregistrationPolicy)), evidenceFinderEnabled: \(Swift.String(describing: evidenceFinderEnabled)), kmsKey: \(Swift.String(describing: kmsKey)), snsTopic: \(Swift.String(describing: snsTopic)), defaultAssessmentReportsDestination: \"CONTENT_REDACTED\", defaultProcessOwners: \"CONTENT_REDACTED\")"}
}

extension UpdateSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAssessmentReportsDestination
        case defaultExportDestination
        case defaultProcessOwners
        case deregistrationPolicy
        case evidenceFinderEnabled
        case kmsKey
        case snsTopic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAssessmentReportsDestination = self.defaultAssessmentReportsDestination {
            try encodeContainer.encode(defaultAssessmentReportsDestination, forKey: .defaultAssessmentReportsDestination)
        }
        if let defaultExportDestination = self.defaultExportDestination {
            try encodeContainer.encode(defaultExportDestination, forKey: .defaultExportDestination)
        }
        if let defaultProcessOwners = defaultProcessOwners {
            var defaultProcessOwnersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultProcessOwners)
            for role0 in defaultProcessOwners {
                try defaultProcessOwnersContainer.encode(role0)
            }
        }
        if let deregistrationPolicy = self.deregistrationPolicy {
            try encodeContainer.encode(deregistrationPolicy, forKey: .deregistrationPolicy)
        }
        if let evidenceFinderEnabled = self.evidenceFinderEnabled {
            try encodeContainer.encode(evidenceFinderEnabled, forKey: .evidenceFinderEnabled)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let snsTopic = self.snsTopic {
            try encodeContainer.encode(snsTopic, forKey: .snsTopic)
        }
    }
}

extension UpdateSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings"
    }
}

public struct UpdateSettingsInput: Swift.Equatable {
    /// The default S3 destination bucket for storing assessment reports.
    public var defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    /// The default S3 destination bucket for storing evidence finder exports.
    public var defaultExportDestination: AuditManagerClientTypes.DefaultExportDestination?
    /// A list of the default audit owners.
    public var defaultProcessOwners: [AuditManagerClientTypes.Role]?
    /// The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.
    public var deregistrationPolicy: AuditManagerClientTypes.DeregistrationPolicy?
    /// Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder. When you use this attribute to disable evidence finder, Audit Manager deletes the event data store thats used to query your evidence data. As a result, you cant re-enable evidence finder and use the feature again. Your only alternative is to [deregister](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html) and then [re-register](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html) Audit Manager.
    public var evidenceFinderEnabled: Swift.Bool?
    /// The KMS key details.
    public var kmsKey: Swift.String?
    /// The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to.
    public var snsTopic: Swift.String?

    public init(
        defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
        defaultExportDestination: AuditManagerClientTypes.DefaultExportDestination? = nil,
        defaultProcessOwners: [AuditManagerClientTypes.Role]? = nil,
        deregistrationPolicy: AuditManagerClientTypes.DeregistrationPolicy? = nil,
        evidenceFinderEnabled: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        snsTopic: Swift.String? = nil
    )
    {
        self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
        self.defaultExportDestination = defaultExportDestination
        self.defaultProcessOwners = defaultProcessOwners
        self.deregistrationPolicy = deregistrationPolicy
        self.evidenceFinderEnabled = evidenceFinderEnabled
        self.kmsKey = kmsKey
        self.snsTopic = snsTopic
    }
}

struct UpdateSettingsInputBody: Swift.Equatable {
    let snsTopic: Swift.String?
    let defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    let defaultProcessOwners: [AuditManagerClientTypes.Role]?
    let kmsKey: Swift.String?
    let evidenceFinderEnabled: Swift.Bool?
    let deregistrationPolicy: AuditManagerClientTypes.DeregistrationPolicy?
    let defaultExportDestination: AuditManagerClientTypes.DefaultExportDestination?
}

extension UpdateSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAssessmentReportsDestination
        case defaultExportDestination
        case defaultProcessOwners
        case deregistrationPolicy
        case evidenceFinderEnabled
        case kmsKey
        case snsTopic
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopic)
        snsTopic = snsTopicDecoded
        let defaultAssessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportsDestination.self, forKey: .defaultAssessmentReportsDestination)
        defaultAssessmentReportsDestination = defaultAssessmentReportsDestinationDecoded
        let defaultProcessOwnersContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .defaultProcessOwners)
        var defaultProcessOwnersDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let defaultProcessOwnersContainer = defaultProcessOwnersContainer {
            defaultProcessOwnersDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in defaultProcessOwnersContainer {
                if let structure0 = structure0 {
                    defaultProcessOwnersDecoded0?.append(structure0)
                }
            }
        }
        defaultProcessOwners = defaultProcessOwnersDecoded0
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let evidenceFinderEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .evidenceFinderEnabled)
        evidenceFinderEnabled = evidenceFinderEnabledDecoded
        let deregistrationPolicyDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.DeregistrationPolicy.self, forKey: .deregistrationPolicy)
        deregistrationPolicy = deregistrationPolicyDecoded
        let defaultExportDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.DefaultExportDestination.self, forKey: .defaultExportDestination)
        defaultExportDestination = defaultExportDestinationDecoded
    }
}

extension UpdateSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.settings = output.settings
        } else {
            self.settings = nil
        }
    }
}

public struct UpdateSettingsOutput: Swift.Equatable {
    /// The current list of settings.
    public var settings: AuditManagerClientTypes.Settings?

    public init(
        settings: AuditManagerClientTypes.Settings? = nil
    )
    {
        self.settings = settings
    }
}

struct UpdateSettingsOutputBody: Swift.Equatable {
    let settings: AuditManagerClientTypes.Settings?
}

extension UpdateSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

enum UpdateSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidateAssessmentReportIntegrityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3RelativePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3RelativePath = self.s3RelativePath {
            try encodeContainer.encode(s3RelativePath, forKey: .s3RelativePath)
        }
    }
}

extension ValidateAssessmentReportIntegrityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessmentReports/integrity"
    }
}

public struct ValidateAssessmentReportIntegrityInput: Swift.Equatable {
    /// The relative path of the Amazon S3 bucket that the assessment report is stored in.
    /// This member is required.
    public var s3RelativePath: Swift.String?

    public init(
        s3RelativePath: Swift.String? = nil
    )
    {
        self.s3RelativePath = s3RelativePath
    }
}

struct ValidateAssessmentReportIntegrityInputBody: Swift.Equatable {
    let s3RelativePath: Swift.String?
}

extension ValidateAssessmentReportIntegrityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3RelativePath
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3RelativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3RelativePath)
        s3RelativePath = s3RelativePathDecoded
    }
}

extension ValidateAssessmentReportIntegrityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidateAssessmentReportIntegrityOutputBody = try responseDecoder.decode(responseBody: data)
            self.signatureAlgorithm = output.signatureAlgorithm
            self.signatureDateTime = output.signatureDateTime
            self.signatureKeyId = output.signatureKeyId
            self.signatureValid = output.signatureValid
            self.validationErrors = output.validationErrors
        } else {
            self.signatureAlgorithm = nil
            self.signatureDateTime = nil
            self.signatureKeyId = nil
            self.signatureValid = nil
            self.validationErrors = nil
        }
    }
}

public struct ValidateAssessmentReportIntegrityOutput: Swift.Equatable {
    /// The signature algorithm that's used to code sign the assessment report file.
    public var signatureAlgorithm: Swift.String?
    /// The date and time signature that specifies when the assessment report was created.
    public var signatureDateTime: Swift.String?
    /// The unique identifier for the validation signature key.
    public var signatureKeyId: Swift.String?
    /// Specifies whether the signature key is valid.
    public var signatureValid: Swift.Bool?
    /// Represents any errors that occurred when validating the assessment report.
    public var validationErrors: [Swift.String]?

    public init(
        signatureAlgorithm: Swift.String? = nil,
        signatureDateTime: Swift.String? = nil,
        signatureKeyId: Swift.String? = nil,
        signatureValid: Swift.Bool? = nil,
        validationErrors: [Swift.String]? = nil
    )
    {
        self.signatureAlgorithm = signatureAlgorithm
        self.signatureDateTime = signatureDateTime
        self.signatureKeyId = signatureKeyId
        self.signatureValid = signatureValid
        self.validationErrors = validationErrors
    }
}

struct ValidateAssessmentReportIntegrityOutputBody: Swift.Equatable {
    let signatureValid: Swift.Bool?
    let signatureAlgorithm: Swift.String?
    let signatureDateTime: Swift.String?
    let signatureKeyId: Swift.String?
    let validationErrors: [Swift.String]?
}

extension ValidateAssessmentReportIntegrityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signatureAlgorithm
        case signatureDateTime
        case signatureKeyId
        case signatureValid
        case validationErrors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signatureValidDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .signatureValid)
        signatureValid = signatureValidDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
        let signatureDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signatureDateTime)
        signatureDateTime = signatureDateTimeDecoded
        let signatureKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signatureKeyId)
        signatureKeyId = signatureKeyIdDecoded
        let validationErrorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[Swift.String]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [Swift.String]()
            for string0 in validationErrorsContainer {
                if let string0 = string0 {
                    validationErrorsDecoded0?.append(string0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
    }
}

enum ValidateAssessmentReportIntegrityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that caused the error, if applicable.
        public internal(set) var fields: [AuditManagerClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the request failed validation.
        public internal(set) var reason: AuditManagerClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [AuditManagerClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AuditManagerClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AuditManagerClientTypes.ValidationExceptionReason?
    let fields: [AuditManagerClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[AuditManagerClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [AuditManagerClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension AuditManagerClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditManagerClientTypes {
    /// Indicates that the request has invalid or missing parameters for the field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The body of the error message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation error.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension AuditManagerClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
