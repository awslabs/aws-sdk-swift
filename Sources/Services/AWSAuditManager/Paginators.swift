// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetChangeLogsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetChangeLogsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetChangeLogsOutputResponse`
extension AuditManagerClient {
    public func getChangeLogsPaginated(input: GetChangeLogsInput) -> ClientRuntime.PaginatorSequence<GetChangeLogsInput, GetChangeLogsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetChangeLogsInput, GetChangeLogsOutputResponse>(input: input, inputKey: \GetChangeLogsInput.nextToken, outputKey: \GetChangeLogsOutputResponse.nextToken, paginationFunction: self.getChangeLogs(input:))
    }
}

extension GetChangeLogsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetChangeLogsInput {
        return GetChangeLogsInput(
            assessmentId: self.assessmentId,
            controlId: self.controlId,
            controlSetId: self.controlSetId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetDelegationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetDelegationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetDelegationsOutputResponse`
extension AuditManagerClient {
    public func getDelegationsPaginated(input: GetDelegationsInput) -> ClientRuntime.PaginatorSequence<GetDelegationsInput, GetDelegationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetDelegationsInput, GetDelegationsOutputResponse>(input: input, inputKey: \GetDelegationsInput.nextToken, outputKey: \GetDelegationsOutputResponse.nextToken, paginationFunction: self.getDelegations(input:))
    }
}

extension GetDelegationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDelegationsInput {
        return GetDelegationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetEvidenceByEvidenceFolderOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetEvidenceByEvidenceFolderInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetEvidenceByEvidenceFolderOutputResponse`
extension AuditManagerClient {
    public func getEvidenceByEvidenceFolderPaginated(input: GetEvidenceByEvidenceFolderInput) -> ClientRuntime.PaginatorSequence<GetEvidenceByEvidenceFolderInput, GetEvidenceByEvidenceFolderOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetEvidenceByEvidenceFolderInput, GetEvidenceByEvidenceFolderOutputResponse>(input: input, inputKey: \GetEvidenceByEvidenceFolderInput.nextToken, outputKey: \GetEvidenceByEvidenceFolderOutputResponse.nextToken, paginationFunction: self.getEvidenceByEvidenceFolder(input:))
    }
}

extension GetEvidenceByEvidenceFolderInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetEvidenceByEvidenceFolderInput {
        return GetEvidenceByEvidenceFolderInput(
            assessmentId: self.assessmentId,
            controlSetId: self.controlSetId,
            evidenceFolderId: self.evidenceFolderId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetEvidenceFoldersByAssessmentOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetEvidenceFoldersByAssessmentInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetEvidenceFoldersByAssessmentOutputResponse`
extension AuditManagerClient {
    public func getEvidenceFoldersByAssessmentPaginated(input: GetEvidenceFoldersByAssessmentInput) -> ClientRuntime.PaginatorSequence<GetEvidenceFoldersByAssessmentInput, GetEvidenceFoldersByAssessmentOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetEvidenceFoldersByAssessmentInput, GetEvidenceFoldersByAssessmentOutputResponse>(input: input, inputKey: \GetEvidenceFoldersByAssessmentInput.nextToken, outputKey: \GetEvidenceFoldersByAssessmentOutputResponse.nextToken, paginationFunction: self.getEvidenceFoldersByAssessment(input:))
    }
}

extension GetEvidenceFoldersByAssessmentInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetEvidenceFoldersByAssessmentInput {
        return GetEvidenceFoldersByAssessmentInput(
            assessmentId: self.assessmentId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetEvidenceFoldersByAssessmentControlOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetEvidenceFoldersByAssessmentControlInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetEvidenceFoldersByAssessmentControlOutputResponse`
extension AuditManagerClient {
    public func getEvidenceFoldersByAssessmentControlPaginated(input: GetEvidenceFoldersByAssessmentControlInput) -> ClientRuntime.PaginatorSequence<GetEvidenceFoldersByAssessmentControlInput, GetEvidenceFoldersByAssessmentControlOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetEvidenceFoldersByAssessmentControlInput, GetEvidenceFoldersByAssessmentControlOutputResponse>(input: input, inputKey: \GetEvidenceFoldersByAssessmentControlInput.nextToken, outputKey: \GetEvidenceFoldersByAssessmentControlOutputResponse.nextToken, paginationFunction: self.getEvidenceFoldersByAssessmentControl(input:))
    }
}

extension GetEvidenceFoldersByAssessmentControlInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetEvidenceFoldersByAssessmentControlInput {
        return GetEvidenceFoldersByAssessmentControlInput(
            assessmentId: self.assessmentId,
            controlId: self.controlId,
            controlSetId: self.controlSetId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListAssessmentControlInsightsByControlDomainOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAssessmentControlInsightsByControlDomainInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAssessmentControlInsightsByControlDomainOutputResponse`
extension AuditManagerClient {
    public func listAssessmentControlInsightsByControlDomainPaginated(input: ListAssessmentControlInsightsByControlDomainInput) -> ClientRuntime.PaginatorSequence<ListAssessmentControlInsightsByControlDomainInput, ListAssessmentControlInsightsByControlDomainOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssessmentControlInsightsByControlDomainInput, ListAssessmentControlInsightsByControlDomainOutputResponse>(input: input, inputKey: \ListAssessmentControlInsightsByControlDomainInput.nextToken, outputKey: \ListAssessmentControlInsightsByControlDomainOutputResponse.nextToken, paginationFunction: self.listAssessmentControlInsightsByControlDomain(input:))
    }
}

extension ListAssessmentControlInsightsByControlDomainInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssessmentControlInsightsByControlDomainInput {
        return ListAssessmentControlInsightsByControlDomainInput(
            assessmentId: self.assessmentId,
            controlDomainId: self.controlDomainId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListAssessmentFrameworksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAssessmentFrameworksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAssessmentFrameworksOutputResponse`
extension AuditManagerClient {
    public func listAssessmentFrameworksPaginated(input: ListAssessmentFrameworksInput) -> ClientRuntime.PaginatorSequence<ListAssessmentFrameworksInput, ListAssessmentFrameworksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssessmentFrameworksInput, ListAssessmentFrameworksOutputResponse>(input: input, inputKey: \ListAssessmentFrameworksInput.nextToken, outputKey: \ListAssessmentFrameworksOutputResponse.nextToken, paginationFunction: self.listAssessmentFrameworks(input:))
    }
}

extension ListAssessmentFrameworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssessmentFrameworksInput {
        return ListAssessmentFrameworksInput(
            frameworkType: self.frameworkType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListAssessmentFrameworkShareRequestsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAssessmentFrameworkShareRequestsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAssessmentFrameworkShareRequestsOutputResponse`
extension AuditManagerClient {
    public func listAssessmentFrameworkShareRequestsPaginated(input: ListAssessmentFrameworkShareRequestsInput) -> ClientRuntime.PaginatorSequence<ListAssessmentFrameworkShareRequestsInput, ListAssessmentFrameworkShareRequestsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssessmentFrameworkShareRequestsInput, ListAssessmentFrameworkShareRequestsOutputResponse>(input: input, inputKey: \ListAssessmentFrameworkShareRequestsInput.nextToken, outputKey: \ListAssessmentFrameworkShareRequestsOutputResponse.nextToken, paginationFunction: self.listAssessmentFrameworkShareRequests(input:))
    }
}

extension ListAssessmentFrameworkShareRequestsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssessmentFrameworkShareRequestsInput {
        return ListAssessmentFrameworkShareRequestsInput(
            maxResults: self.maxResults,
            nextToken: token,
            requestType: self.requestType
        )}
}

/// Paginate over `[ListAssessmentReportsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAssessmentReportsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAssessmentReportsOutputResponse`
extension AuditManagerClient {
    public func listAssessmentReportsPaginated(input: ListAssessmentReportsInput) -> ClientRuntime.PaginatorSequence<ListAssessmentReportsInput, ListAssessmentReportsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssessmentReportsInput, ListAssessmentReportsOutputResponse>(input: input, inputKey: \ListAssessmentReportsInput.nextToken, outputKey: \ListAssessmentReportsOutputResponse.nextToken, paginationFunction: self.listAssessmentReports(input:))
    }
}

extension ListAssessmentReportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssessmentReportsInput {
        return ListAssessmentReportsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListAssessmentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAssessmentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAssessmentsOutputResponse`
extension AuditManagerClient {
    public func listAssessmentsPaginated(input: ListAssessmentsInput) -> ClientRuntime.PaginatorSequence<ListAssessmentsInput, ListAssessmentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssessmentsInput, ListAssessmentsOutputResponse>(input: input, inputKey: \ListAssessmentsInput.nextToken, outputKey: \ListAssessmentsOutputResponse.nextToken, paginationFunction: self.listAssessments(input:))
    }
}

extension ListAssessmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssessmentsInput {
        return ListAssessmentsInput(
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}

/// Paginate over `[ListControlDomainInsightsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListControlDomainInsightsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListControlDomainInsightsOutputResponse`
extension AuditManagerClient {
    public func listControlDomainInsightsPaginated(input: ListControlDomainInsightsInput) -> ClientRuntime.PaginatorSequence<ListControlDomainInsightsInput, ListControlDomainInsightsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListControlDomainInsightsInput, ListControlDomainInsightsOutputResponse>(input: input, inputKey: \ListControlDomainInsightsInput.nextToken, outputKey: \ListControlDomainInsightsOutputResponse.nextToken, paginationFunction: self.listControlDomainInsights(input:))
    }
}

extension ListControlDomainInsightsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListControlDomainInsightsInput {
        return ListControlDomainInsightsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListControlDomainInsightsByAssessmentOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListControlDomainInsightsByAssessmentInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListControlDomainInsightsByAssessmentOutputResponse`
extension AuditManagerClient {
    public func listControlDomainInsightsByAssessmentPaginated(input: ListControlDomainInsightsByAssessmentInput) -> ClientRuntime.PaginatorSequence<ListControlDomainInsightsByAssessmentInput, ListControlDomainInsightsByAssessmentOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListControlDomainInsightsByAssessmentInput, ListControlDomainInsightsByAssessmentOutputResponse>(input: input, inputKey: \ListControlDomainInsightsByAssessmentInput.nextToken, outputKey: \ListControlDomainInsightsByAssessmentOutputResponse.nextToken, paginationFunction: self.listControlDomainInsightsByAssessment(input:))
    }
}

extension ListControlDomainInsightsByAssessmentInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListControlDomainInsightsByAssessmentInput {
        return ListControlDomainInsightsByAssessmentInput(
            assessmentId: self.assessmentId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListControlInsightsByControlDomainOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListControlInsightsByControlDomainInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListControlInsightsByControlDomainOutputResponse`
extension AuditManagerClient {
    public func listControlInsightsByControlDomainPaginated(input: ListControlInsightsByControlDomainInput) -> ClientRuntime.PaginatorSequence<ListControlInsightsByControlDomainInput, ListControlInsightsByControlDomainOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListControlInsightsByControlDomainInput, ListControlInsightsByControlDomainOutputResponse>(input: input, inputKey: \ListControlInsightsByControlDomainInput.nextToken, outputKey: \ListControlInsightsByControlDomainOutputResponse.nextToken, paginationFunction: self.listControlInsightsByControlDomain(input:))
    }
}

extension ListControlInsightsByControlDomainInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListControlInsightsByControlDomainInput {
        return ListControlInsightsByControlDomainInput(
            controlDomainId: self.controlDomainId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListControlsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListControlsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListControlsOutputResponse`
extension AuditManagerClient {
    public func listControlsPaginated(input: ListControlsInput) -> ClientRuntime.PaginatorSequence<ListControlsInput, ListControlsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListControlsInput, ListControlsOutputResponse>(input: input, inputKey: \ListControlsInput.nextToken, outputKey: \ListControlsOutputResponse.nextToken, paginationFunction: self.listControls(input:))
    }
}

extension ListControlsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListControlsInput {
        return ListControlsInput(
            controlType: self.controlType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListKeywordsForDataSourceOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListKeywordsForDataSourceInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListKeywordsForDataSourceOutputResponse`
extension AuditManagerClient {
    public func listKeywordsForDataSourcePaginated(input: ListKeywordsForDataSourceInput) -> ClientRuntime.PaginatorSequence<ListKeywordsForDataSourceInput, ListKeywordsForDataSourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListKeywordsForDataSourceInput, ListKeywordsForDataSourceOutputResponse>(input: input, inputKey: \ListKeywordsForDataSourceInput.nextToken, outputKey: \ListKeywordsForDataSourceOutputResponse.nextToken, paginationFunction: self.listKeywordsForDataSource(input:))
    }
}

extension ListKeywordsForDataSourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListKeywordsForDataSourceInput {
        return ListKeywordsForDataSourceInput(
            maxResults: self.maxResults,
            nextToken: token,
            source: self.source
        )}
}

/// Paginate over `[ListNotificationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListNotificationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListNotificationsOutputResponse`
extension AuditManagerClient {
    public func listNotificationsPaginated(input: ListNotificationsInput) -> ClientRuntime.PaginatorSequence<ListNotificationsInput, ListNotificationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListNotificationsInput, ListNotificationsOutputResponse>(input: input, inputKey: \ListNotificationsInput.nextToken, outputKey: \ListNotificationsOutputResponse.nextToken, paginationFunction: self.listNotifications(input:))
    }
}

extension ListNotificationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNotificationsInput {
        return ListNotificationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
